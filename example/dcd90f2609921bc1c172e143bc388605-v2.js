"use strict";
(self.webpackChunktestdemo2024 = self.webpackChunktestdemo2024 || []).push([
    [9453], {
        XkCy: (e, t, i) => {
            i.d(t, {
                Z: () => g
            });
            var n = i("aqzA"),
                r = n.Z.osg,
                a = function () {
                    r.ComputeBoundsVisitor.call(this), this._minBox = new r.BoundingBox, this._visitedBuffers = {}
                };
            r.createPrototypeObject(a, r.objectInherit(r.ComputeBoundsVisitor.prototype, {
                getPreciseBox: function () {
                    return this._minBox
                },
                apply: function (e) {
                    if (e instanceof r.Transform) this.applyTransform(e);
                    else {
                        if (e instanceof r.Geometry) {
                            var t = this._matrixStack.getLength() > 0 ? this._matrixStack.back() : r.mat4.IDENTITY,
                                i = e.getVertexAttributeList().Vertex,
                                n = this._visitedBuffers[i.getInstanceID()];
                            if (n && r.mat4.exactEquals(n.matrix, t)) return;
                            var a = e.computeTransformedVertices ? e.computeTransformedVertices() : i.getElements();
                            this._visitedBuffers[i.getInstanceID()] = {
                                buffer: a,
                                matrix: r.mat4.copy(r.mat4.create(), t)
                            };
                            for (var o = t[0], s = t[1], l = t[2], u = t[3], c = t[4], h = t[5], d = t[6], g = t[7], f = t[8], m = t[9], p = t[10], v = t[11], _ = t[12], S = t[13], x = t[14], C = t[15], T = this._minBox.getMin(), M = this._minBox.getMax(), b = T[0], y = T[1], A = T[2], R = M[0], w = M[1], E = M[2], P = 0, N = a.length; P < N; P += 3) {
                                var O = a[P],
                                    D = a[P + 1],
                                    I = a[P + 2],
                                    F = u * O + g * D + v * I + C || 1,
                                    L = (o * O + c * D + f * I + _) / F,
                                    V = (s * O + h * D + m * I + S) / F,
                                    B = (l * O + d * D + p * I + x) / F;
                                L < b && (b = L), V < y && (y = V), B < A && (A = B), L > R && (R = L), V > w && (w = V), B > E && (E = B)
                            }
                            return T[0] = b, T[1] = y, T[2] = A, M[0] = R, M[1] = w, void (M[2] = E)
                        }
                        this.traverse(e)
                    }
                }
            }));
            const o = a;
            var s, l, u = i("QG/p"),
                c = n.Z.osg,
                h = 0,
                d = new u.Z;
            const g = {
                BIAS_MIN: .9,
                BIAS_MAX: 1.1,
                getBoxReady: function () {
                    return d.promise
                },
                updateMaxWorldDisplacement: function (e) {
                    e <= h || (h = e, this._updateModelBoxes())
                },
                getModelBoxWithDisplacement: function () {
                    return s
                },
                getModelBoxWithoutDisplacement: function () {
                    return l
                },
                _updateModelBoxes: function () {
                    if (s && 0 !== h) {
                        var e = s.getMin(),
                            t = s.getMax(),
                            i = c.vec3.fromValues(h, h, h);
                        c.vec3.add(t, t, i), c.vec3.sub(e, e, i)
                    }
                },
                computePreciseBox: function (e) {
                    var t = new o;
                    e.accept(t), l = t.getPreciseBox(), (s = new c.BoundingBox).copy(l), this._updateModelBoxes(), d.resolve()
                },
                getMaxDistanceFromOrigin: function () {
                    var e = c.vec3.length(l.getMin()),
                        t = c.vec3.length(l.getMax());
                    return Math.max(e, t)
                }
            }
        },
        "QR/4": (e, t, i) => {
            i.d(t, {
                Z: () => s
            });
            var n = i("X9mO"),
                r = i("lqp/"),
                a = i("aqzA").Z.osg,
                o = function (e) {
                    this._model = void 0 !== e ? e.model : void 0, this._viewer = void 0 !== e ? e.viewer : void 0, this._scene = void 0 !== e ? e.scene : void 0, this._widgetAPI = void 0 !== e ? e.widgetAPI : void 0, this._features = {}
                };
            o.prototype = {
                getModel: function () {
                    return this._model
                },
                getFeatures: function () {
                    return this._features
                },
                getViewer: function () {
                    return this._viewer
                },
                getScene: function () {
                    return this._scene
                },
                getWidgetAPI: function () {
                    return this._widgetAPI
                },
                addFeature: function (e) {
                    if (e) {
                        var t = e.getName();
                        this._features[t] ? a.error("Feature already added" + t) : this._features[t] = e
                    }
                    return this._features
                },
                getModelByName: function (e) {
                    if (e) {
                        var t = (0, n.Z)(this._features, (function (t) {
                            var i = t.getModel();
                            return !(!i || !i.getName) && i.getName() === e
                        }));
                        return t ? t.getModel() : void 0
                    }
                },
                getViewsByName: function (e) {
                    if (e) {
                        var t = [];
                        return (0, r.Z)(this._features, (function (i) {
                            if (i) {
                                var n = i._views.filter((function (t) {
                                    return !!t.getName && t.getName() === e
                                }));
                                Array.prototype.push.apply(t, n)
                            }
                        })), t
                    }
                }
            };
            const s = o
        },
        GhWR: (e, t, i) => {
            i.d(t, {
                Z: () => h
            });
            var n = i("aqzA"),
                r = i("gvzH"),
                a = i("ZmEo"),
                o = i("XkCy"),
                s = i("MQQR"),
                l = n.Z.osg,
                u = function () {
                    l.CullVisitor.call(this), this._separateVR = !1, this._isEnv = !1, this._isRootModel = !1
                },
                c = u.vrConfig = {
                    doVR: !1,
                    framebufferWidth: 0,
                    framebufferHeight: 0,
                    leftRenderWidth: 0,
                    rightRenderWidth: 0,
                    leftRenderHeight: 0,
                    rightRenderHeight: 0,
                    rightProjection: l.mat4.create(),
                    leftProjection: l.mat4.create(),
                    leftOffsetView: l.mat4.create(),
                    rightOffsetView: l.mat4.create()
                };
            u.cameraMain = void 0, u.cameraEnvironment = void 0, u.nodePostProcessOut = void 0, u.nodeRootModel = void 0, l.createPrototypeObject(u, l.objectInherit(l.CullVisitor.prototype, {
                popCameraModelViewProjectionMatrix: function (e) {
                    this.popModelViewMatrix(), this.popProjectionMatrix(e)
                },
                reset: function () {
                    l.CullVisitor.prototype.reset.call(this), this._minNear = this._computedNear, this._maxFar = this._computedFar
                },
                updateNearFar: function () {
                    this._minNear = Math.min(this._minNear, this._computedNear), this._maxFar = Math.max(this._maxFar, this._computedFar)
                },
                _handleMainCamera: function (e) {
                    var t = this.getCurrentProjectionMatrix(),
                        i = this._computedNear,
                        n = this._computedFar,
                        r = this._nearFarRatio,
                        o = this._projectionMatrixStack.getArray()[0];
                    l.mat4.copy(o, t), this.clampProjectionMatrix(o, this._minNear, this._maxFar, 1e-5), c.doVR && (this.clampProjectionMatrix(c.leftProjection, i, n, r), this.clampProjectionMatrix(c.rightProjection, i, n, r));
                    var s = a.Z.uNearFar.getInternalArray(),
                        u = a.Z.uPreviousNearFar.getInternalArray();
                    u[0] = s[0], u[1] = s[1], this.clampProjectionMatrix(t, i, n, r, s), e.clampedProjectionMatrix ? l.mat4.copy(e.clampedProjectionMatrix, t) : e.clampedProjectionMatrix = l.mat4.clone(t)
                },
                popProjectionMatrix: function (e) {
                    if (!0 === this._computeNearFar && this._computedFar >= this._computedNear) {
                        var t = e === u.cameraMain;
                        (t || e.getReferenceFrame() === l.Transform.RELATIVE_RF && !e.isRenderToTextureCamera()) && this.updateNearFar(), t ? this._handleMainCamera(e) : this.clampProjectionMatrix(this.getCurrentProjectionMatrix(), this._computedNear, this._computedFar, this._nearFarRatio)
                    }
                    l.CullStack.prototype.popProjectionMatrix.call(this)
                },
                handleCullCallbacksAndTraverse: function (e) {
                    e === u.nodePostProcessOut ? this._separateVR = c.doVR : e === u.cameraEnvironment ? this._isEnv = !0 : e === u.nodeRootModel && (this._isRootModel = !0);
                    var t = e.getCullCallback();
                    t && !t.cull(e, this) || this.traverse(e), e === u.nodePostProcessOut ? this._separateVR = !1 : e === u.cameraEnvironment ? this._isEnv = !1 : e === u.nodeRootModel && (this._isRootModel = !1)
                },
                pushLeaf: function (e, t) {
                    var i = this._currentStateGraph._leafs;
                    0 === i.getLength() && this._currentRenderBin.addStateGraph(this._currentStateGraph);
                    var n = this._separateVR && this.traversalMask !== r.Z.SHADOW,
                        a = this.createOrReuseRenderLeaf();
                    if (a.isVR = n, n) {
                        var o = this._isEnv,
                            s = this.getCurrentModelViewMatrix(),
                            u = this.getCurrentViewMatrix();
                        a.leftProjection = c.leftProjection, a.rightProjection = c.rightProjection;
                        var h = a.leftModelView || l.mat4.create(),
                            d = a.rightModelView || l.mat4.create();
                        a.leftModelView = o ? l.mat4.copy(h, s) : l.mat4.multiply(h, c.leftOffsetView, s), a.rightModelView = o ? l.mat4.copy(d, s) : l.mat4.multiply(d, c.rightOffsetView, s);
                        var g = a.leftView || l.mat4.create(),
                            f = a.rightView || l.mat4.create();
                        a.leftView = o ? l.mat4.copy(g, u) : l.mat4.multiply(g, c.leftOffsetView, u), a.rightView = o ? l.mat4.copy(f, u) : l.mat4.multiply(f, c.rightOffsetView, u)
                    }
                    a.init(this._currentStateGraph, e, this.getCurrentProjectionMatrix(), this.getCurrentViewMatrix(), this.getCurrentModelViewMatrix(), this.getCurrentModelMatrix(), t), i.push(a)
                },
                updateCalculatedNearFar: function (e, t) {
                    var i = o.Z.getModelBoxWithoutDisplacement();
                    if (i && this._isRootModel) {
                        var n = (0, s.Z)().scaleEpsilon * i.radius() / t.getBound().radius();
                        n *= n;
                        var r = e[0],
                            a = e[4],
                            u = e[8];
                        if (r * r + a * a + u * u < n && (r = e[1]) * r + (a = e[5]) * a + (u = e[9]) * u < n && (r = e[2]) * r + (a = e[6]) * a + (u = e[10]) * u < n) return !1
                    }
                    return l.CullVisitor.prototype.updateCalculatedNearFar.call(this, e, t)
                }
            }), "osgtestdemo2024", "CullVisitor");
            const h = u
        },
        tEGF: (e, t, i) => {
            i.d(t, {
                Z: () => a
            });
            var n = i("k46e"),
                r = function (e) {
                    this._views = [], e && (this._name = e.FeatureName, this._modelName = e.ModelName, this._modelType = e.ModelType, this._viewListType = e.ViewListType.slice(0))
                };
            r.prototype = {
                getName: function () {
                    return this._name
                },
                getModel: function () {
                    return this._model
                },
                addView: function (e) {
                    e && this._views.push(e)
                },
                init: function (e) {
                    if (this._model || (this._model = e.getModelByName(this._modelName)), !this._model) {
                        var t = this._modelType;
                        this._model = new t, this._model.init && this._model.init(e)
                    }
                    var i = function (t) {
                        var i = new t({
                            model: this._model,
                            context: e
                        });
                        this.addView(i)
                    };
                    this._viewListType.forEach((function (e) {
                        i.call(this, e)
                    }), this), e.addFeature(this)
                },
                prepareForScreenShot: function () {
                    var e = this.getWidgetNode();
                    return !(!e || !e.getNodeMask()) && (this._oldMaskEditorWidget = e.getNodeMask(), e.setNodeMask(0), !0)
                },
                resetAfterScreenShot: function () {
                    var e = this.getWidgetNode();
                    e && e.setNodeMask(this._oldMaskEditorWidget)
                },
                getWidgetNode: function () { }
            }, r.create = function (e) {
                var t = function () {
                    r.call(this, t)
                };
                return t.prototype = (0, n.Z)({}, r.prototype), (0, n.Z)(t, e), t.getName = function () {
                    return e.FeatureName
                }, t
            };
            const a = r
        },
        bWy4: (e, t, i) => {
            i.d(t, {
                Z: () => f
            });
            var n = i("R4My"),
                r = i.n(n),
                a = i("aqzA"),
                o = i("ppEn"),
                s = i("h4+f"),
                l = i.n(s),
                u = i("QX1t"),
                c = i("FqYX"),
                h = a.Z.osg,
                d = (0, u.Z)(a.Z.osg.CullFace),
                g = r().Model;
            const f = g.extend({
                initialize: function () {
                    if (g.prototype.initialize.apply(this, arguments), this._featureSchema = this.getSubSchema(this.getModelOptionPath()), this._featureSchema) {
                        this._typeMap = {}, this._buildTypeMap(this._featureSchema, this._typeMap);
                        var e = this.getInstance();
                        this.initDefaults(e)
                    }
                },
                getModelOptionPath: function () {
                    return ""
                },
                getSubSchema: function (e, t) {
                    for (void 0 === t && (t = !0), e = e ? 0 === e.indexOf("#") ? e.substring(2).replace(/\//g, ".") : "properties." + e.replace(/\./g, ".properties.") : "properties"; e.indexOf(":") > 0;) {
                        var i = e.split(":"),
                            n = this._getAttribute(o, i[0]);
                        if (n.patternProperties) {
                            var r = i[1].indexOf(".");
                            r < 0 && (r = i[1].length);
                            var a = i[1].substring(0, r),
                                s = Object.keys(n.patternProperties)[a];
                            e = e.replace(":" + a, ".patternProperties." + s)
                        }
                    }
                    var l = this._getAttribute(o, e);
                    if (l && t)
                        if (0 === e.indexOf("definition")) {
                            l.definitions = (0, c.Z)({}, o.definitions);
                            var u = e.split(".");
                            u = u[u.length - 1], delete l.definitions[u]
                        } else l.definitions = o.definitions;
                    return l
                },
                _getAttribute: function (e, t) {
                    for (var i = t.split("."); i.length && (e = e[i.shift()]););
                    return e
                },
                getInstance: function (e) {
                    return e || (e = this._featureSchema), this._instantiateFromSchema(e)
                },
                _getRequiredFields: function (e) {
                    var t = e.required ? e.required.slice() : void 0;
                    return e.oneOf && e.oneOf.length && e.oneOf[0].required && e.oneOf[0].required.length && t.push(e.oneOf[0].required[0]), t
                },
                _instantiateFromSchema: function (e) {
                    if ("object" === e.type) {
                        var t = {},
                            i = this._getRequiredFields(e);
                        for (var n in e = e.properties ? e.properties : e)
                            if (!(i && i.indexOf(n) < 0)) {
                                var r = e[n];
                                t[n] = this._instantiateAttribute(r)
                            }
                        return t
                    }
                    return this._instantiateAttribute(e)
                },
                _instantiateAttribute: function (e) {
                    var t = e.default;
                    if (e.$ref) {
                        var i = e.$ref,
                            n = this.getSubSchema(i, !1),
                            r = this._instantiateFromSchema(n);
                        return t && ("object" == typeof t ? (0, c.Z)(r, t) : r = t), r
                    }
                    if (e.type) {
                        if (t && "array" !== e.type) return t;
                        switch (e.type) {
                            case "object":
                                return this._instantiateFromSchema(e);
                            case "array":
                                var a;
                                if (a = e.minItems ? new Array(e.minItems) : [], e.items)
                                    for (var o = e.items, s = 0; s < a.length; s++) Array.isArray(e.items) && (o = e.items[Object.keys(e.items)[s]]), a[s] = this._instantiateFromSchema(o);
                                return a;
                            case "number":
                            case "integer":
                                return 0;
                            case "boolean":
                                return !1;
                            case "string":
                                return e.enum ? e.enum[0] : ""
                        }
                    }
                },
                validate: function (e, t) {
                    var i = this._validator,
                        n = t && t.schema || this._featureSchema;
                    i || (i = new (l())({
                        allErrors: !0,
                        removeAdditional: !0
                    }).compile(n), this._validator = i);
                    var r, a = [];
                    if (i(e)) return a;
                    for (var o = 0; o < i.errors.length; o++) {
                        var s, u = i.errors[o],
                            c = u.instancePath.substring(1);
                        if (c.indexOf("]") >= 0 && (c = c.replace(/]/g, "")), "type" === u.keyword) {
                            if (null == (s = this._getAttribute(e, c))) continue;
                            if (r = s, Array.isArray(r) || r instanceof Int8Array || r instanceof Uint8Array || r instanceof Uint8ClampedArray || r instanceof Int16Array || r instanceof Uint16Array || r instanceof Int32Array || r instanceof Uint32Array || r instanceof Float32Array || r instanceof Float64Array) continue
                        }
                        "pattern" === u.keyword && (s = this._getAttribute(e, c), -1 !== c.indexOf("texture.uid") && -1 !== s.indexOf("tmp_")) || "required" !== u.keyword && a.push(this._formatErrorMessage(u, c, t))
                    }
                    return a
                },
                _formatErrorMessage: function (e, t, i) {
                    var n;
                    i && i.context && (n = i.context);
                    var r = n ? n + ": " : "";
                    if (r += t.length ? '"' + t + '" ' : "", r += e.message, "enum" === e.keyword) {
                        r += ": ";
                        for (var a = 0; a < e.params.allowedValues.length; a++) {
                            r += e.params.allowedValues[a] + ", "
                        }
                    } else "additionalProperties" === e.keyword && (r += " (" + e.params.additionalProperty + ")");
                    return r
                },
                setJSON: function (e, t) {
                    if (!this._featureSchema) return ["Json Schema not initialized"];
                    this._adaptJSON && this._adaptJSON(e);
                    var i, n = t || {};
                    if (n.schema ? (i = {}, this._buildTypeMap(n.schema, i)) : (n.schema = this._featureSchema, i = this._typeMap), n.validate) {
                        var r = this.validate(e, n);
                        if (r.length) {
                            if (!n.warnOnError) return console.error("Failed to validate json", e, r), r.join("\n");
                            console.warn("Failed to validate json", e), console.warn(r.join("\n"))
                        }
                    }
                    var a = this._flattenObject(e, i, n);
                    return this.set(a), []
                },
                _buildTypeMap: function (e, t) {
                    if (e.properties) {
                        var i = e.properties;
                        for (var n in i) {
                            var r = i[n];
                            "object" === r.type ? (t[n] = {}, this._buildTypeMap(r, t[n])) : r.type ? t[n] = r.type : r.$ref && (t[n] = r.$ref)
                        }
                    } else e.$ref && this._buildTypeMap(this.getSubSchema(e.$ref, !1), t)
                },
                initDefaults: function (e) {
                    if (e) {
                        var t = this._flattenObject(e, this._typeMap);
                        this.set(t)
                    }
                },
                getJSON: function (e) {
                    if (!this._featureSchema) return ["Json Schema not initialized"];
                    var t = this.getInstance();
                    if (e && e.ignore)
                        for (var i = 0; i < e.ignore.length; i++) {
                            delete t[e.ignore[i]]
                        }
                    return this._populate(t, this._typeMap, "", e), t
                },
                _flattenObject: function (e, t, i) {
                    var n = {},
                        r = i && i.ignore ? i.ignore : void 0;
                    for (var a in t)
                        if (Object.prototype.hasOwnProperty.call(e, a) && !(r && r.indexOf(a) >= 0))
                            if ("object" == typeof t[a]) {
                                var o = this._flattenObject(e[a], t[a], i);
                                for (var s in o) Object.prototype.hasOwnProperty.call(o, s) && (n[a + s.charAt(0).toUpperCase() + s.slice(1)] = o[s])
                            } else void 0 !== e[a] && (n[a] = this._toModelType(e[a], t[a]));
                    return n
                },
                _toModelType: function (e, t) {
                    return void 0 === e ? e : t.indexOf("vec2") > 0 || t.indexOf("unitVec2") > 0 ? h.vec2.clone(e) : t.indexOf("vec3") > 0 || t.indexOf("unitVec3") > 0 ? h.vec3.clone(e) : t.indexOf("vec4") > 0 || t.indexOf("unitVec4") > 0 ? h.vec4.clone(e) : t.indexOf("quaternion") > 0 ? h.quat.clone(e) : t.indexOf("matrix") > 0 ? h.mat4.clone(e) : t.indexOf("cullFace") > 0 ? h.CullFace[e] : e
                },
                _toJsonType: function (e, t) {
                    return t.indexOf("vec2") > 0 || t.indexOf("unitVec2") > 0 || t.indexOf("vec3") > 0 || t.indexOf("unitVec3") > 0 || t.indexOf("vec4") > 0 || t.indexOf("unitVec4") > 0 || t.indexOf("quaternion") > 0 || t.indexOf("matrix") > 0 ? Array.prototype.slice.call(e) : t.indexOf("cullFace") > 0 ? d[e] : e
                },
                _populate: function (e, t, i, n) {
                    for (var r in t)
                        if (!(n && n.ignore && n.ignore.indexOf(r) >= 0)) {
                            var a = i ? i + r.charAt(0).toUpperCase() + r.slice(1) : r;
                            if ("object" == typeof t[r]) this._populate(e[r], t[r], a);
                            else {
                                var o = this.get(a);
                                void 0 !== o && (e[r] = this._toJsonType(o, t[r]))
                            }
                        }
                }
            })
        },
        "4EEe": (e, t, i) => {
            i.d(t, {
                Z: () => c
            });
            var n = i("aqzA"),
                r = i("WGQk"),
                a = i("MQQR"),
                o = i("8SXq"),
                s = i.n(o);
            const l = {
                initGestures: function (e) {
                    var t = e.getInputSource("TouchScreen");
                    if (t) {
                        var i = t.getHammer();
                        i.get("pan").set({
                            enable: !1
                        });
                        var n = new (s().Pinch)({
                            enable: !0,
                            threshold: .1
                        }),
                            r = new (s().Pan)({
                                event: "panh",
                                direction: s().DIRECTION_HORIZONTAL
                            }),
                            a = new (s().Pan)({
                                event: "panv",
                                direction: s().DIRECTION_VERTICAL
                            });
                        a.requireFailure(r), r.requireFailure(n), i.add(r), i.add(a), i.add(n)
                    }
                }
            };
            var u = n.Z.InputGroups;
            u.GLOBAL_ACTIONS = u.SCENE + ".globalactions", u.GLOBAL_FOCUS = "focuscanvas", u.SCENE_VIEWERAPI = u.SCENE + ".viewerapi", u.SCENE_VIEWERAPI_1_4 = u.SCENE + ".viewerapi_1_4", u.FOCUS_INSPECTOR = "focus.inspector", u.SCENE_INSPECTOR = u.SCENE + ".inspector", u.UI_INSPECTOR = u.UI + ".inspector", u.SCENE_INSPECTOR_ZOOM = u.SCENE_INSPECTOR + ".zoom", u.UI_INSPECTOR_ZOOM = u.UI_INSPECTOR + ".zoom", u.ENVIRONMENT = u.SCENE + ".environment", u.DEBUG = "debug", u.DEBUG_TRIPICK = "debug.tripick", u.DEBUG_GEOMPICK = "debug.geompick", u.AUTOSPIN = u.SCENE + ".autospin", u.HOTSPOT = u.SCENE + ".hotspot", u.HOTSPOT_VIEWER = u.HOTSPOT + ".viewer", u.HOTSPOT_EDITOR = u.HOTSPOT + ".editor", u.CAMERA = u.SCENE + ".camera", u.CAMERA_GIZMO = u.CAMERA + ".gizmo", u.SOUND = u.SCENE + ".sound", u.SOUND_GIZMO = u.SOUND + ".gizmo", u.WEBVR = u.SCENE + ".webvr", u.WEBVREDITOR = u.SCENE + "webvreditor", u.WEBVR_NAVIGATION = u.WEBVR + ".navigation", u.WEBVR_DISPLAY = u.WEBVR + ".display", u.AR = "ar", u.AR_DEBUG = u.AR + ".debug", u.DECALS_DEBUG = "decals.debug";
            const c = {
                init: function (e) {
                    this._manager = e
                },
                initGlobalClickEvents: function (e, t) {
                    var i = 0,
                        n = 0,
                        r = 0;
                    this._manager.group(u.GLOBAL_ACTIONS).addMappings({
                        onDoubleClick: ["doubletap", "doubletap2fingers", "dblclick"],
                        onSingleClick: "singletap"
                    }, e), this._manager.group(u.GLOBAL_ACTIONS).addMappings({
                        preventclick: "mousedown"
                    }, (function (e) {
                        r = 0, i = e.clientX, n = e.clientY
                    })), this._manager.group(u.GLOBAL_ACTIONS).addMappings({
                        preventmousemove: "mousemove"
                    }, (function (e) {
                        var t = Math.abs(i - e.clientX) + Math.abs(n - e.clientY);
                        r = Math.max(r, t)
                    })), this._manager.group(u.GLOBAL_ACTIONS).addMappings({
                        fallbacksingleclick: "mouseup"
                    }, (function (t) {
                        r < 2 && e.onSingleClick(t)
                    })), this._manager.group("focuscanvas").addMappings({
                        focus: "mousedown"
                    }, (function () {
                        t.focus({
                            preventScroll: !0
                        })
                    })), this._manager.setPriority("focuscanvas", 0)
                },
                initViewerAPI: function (e) {
                    this._manager.group(u.SCENE_VIEWERAPI).addMappings({
                        onMouseMove: "mousemove",
                        onCursorUp: ["mouseup", "singletap"]
                    }, e)
                },
                initViewerAPI_1_4: function (e) {
                    this._manager.group(u.SCENE_VIEWERAPI_1_4).addMappings({
                        onMouseMove: "mousemove",
                        onCursorUp: ["mouseup", "singletap"],
                        onCursorDown: ["mousedown"]
                    }, e)
                },
                initInspector: function (e) {
                    this._manager.group(u.FOCUS_INSPECTOR).addMappings({
                        focusCheck: ["mousedown", "touchstart", "wheel", "mousemove", "touchend", "mouseup"],
                        onCursorDown: ["mousedown", "touchstart"],
                        onCursorUp: ["touchend", "touchcancel", "mouseout", "mouseup"]
                    }, e), this._manager.group(u.SCENE_INSPECTOR).addMappings({
                        onMouseMove: "mousemove"
                    }, e), this._manager.group(u.SCENE_INSPECTOR_ZOOM).addMappings({
                        onMouseWheel: "wheel"
                    }, e), this._manager.setPriority(u.FOCUS_INSPECTOR, this._manager.getHigherPriority(u.SCENE_INSPECTOR)), this._manager.setPriority(u.FOCUS_INSPECTOR + ":onCursorUp", this._manager.getHigherPriority(u.FOCUS_INSPECTOR))
                },
                initInspectorCamera2D: function (e) {
                    this._manager.group(u.UI_INSPECTOR).addMappings({
                        onEventStart: ["pinchstart", "panstart", "mousedown"],
                        onEventEnd: ["pinchend", "panend", "mouseup", "mouseout"],
                        onEventUpdate: ["pinch", "pan", "mousemove"]
                    }, e), this._manager.group(u.UI_INSPECTOR_ZOOM).addMappings({
                        onMouseWheel: "wheel"
                    }, e), this._manager.setPriority(u.UI_INSPECTOR + ":onEventEnd", this._manager.getHigherPriority(u.FOCUS_INSPECTOR))
                },
                setInspectorInputsEnable: function (e) {
                    this._manager.setEnable(u.SCENE_INSPECTOR, e), this._manager.setEnable(u.SCENE_INSPECTOR_ZOOM, e)
                },
                initEnvironment: function (e) {
                    this._manager.group(u.ENVIRONMENT).addMappings({
                        startRotate: ["mousedown alt", "touchstart 3"],
                        rotateLight: ["mousemove alt ctrl !shift"],
                        rotateEnv: ["mousemove alt shift !ctrl"],
                        rotateEnvAndLight: ["mousemove alt !shift !ctrl", "panmove 3"],
                        endRotate: ["mouseup", "mouseout", "touchend", "touchcancel"]
                    }, e), this._manager.setPriority(u.ENVIRONMENT, this._manager.getHigherPriority(u.MANIPULATORS))
                },
                initDebug3D: function (e) {
                    this._manager.group(u.DEBUG_TRIPICK).addMappings({
                        onTrianglePick: "dblclick"
                    }, e), this._manager.group(u.DEBUG_GEOMPICK).addMappings({
                        onPickSelect: "dblclick"
                    }, e), this._manager.setPriority(u.DEBUG, 1)
                },
                initAutospin: function (e, t) {
                    this._manager.group(u.AUTOSPIN).addMappings({
                        pause: ["mousedown", "touchstart"],
                        resume: ["mouseup", "mouseout", "touchend", "touchcancel"]
                    }, e), this._manager.setPriority(u.AUTOSPIN, this._manager.getHigherPriority(u.MANIPULATORS)), this._manager.setEnable(u.AUTOSPIN, t)
                },
                initHotspot: function (e) {
                    this._manager.group(u.HOTSPOT).addMappings({
                        hoverHotspot: "mousemove"
                    }, e), (0, r.Z)() ? (this._manager.group(u.HOTSPOT_EDITOR).addMappings({
                        createHotspot: "dblclick",
                        startDrag: ["mousedown", "touchstart"],
                        dragHotspot: ["mousemove", "touchmove"],
                        stopDrag: ["touchend", "mouseup"],
                        cancelDrag: ["touchcancel", "mouseout"]
                    }, e), this._manager.setPriority(u.HOTSPOT, this._manager.getHigherPriority(u.MANIPULATORS))) : this._manager.group(u.HOTSPOT_VIEWER).addMappings({
                        selectHotspot: ["mousedown", "singletap"]
                    }, e)
                },
                initCamera: function (e) {
                    this._manager.group(u.CAMERA_GIZMO).addMappings({
                        motion: "mousemove",
                        startDrag: "mousedown",
                        endDrag: ["mouseleave", "mouseup"]
                    }, e), this._manager.setPriority(u.CAMERA_GIZMO, this._manager.getHigherPriority(u.MANIPULATORS))
                },
                initSound: function (e) {
                    this._manager.group(u.SOUND_GIZMO).addMappings({
                        onDragMove: "mousemove",
                        onDragStart: "mousedown",
                        onDragEnd: ["mouseleave", "mouseup"],
                        onDoubleClick: "dblclick"
                    }, e), this._manager.setEnable(u.SOUND_GIZMO, !1), this._manager.setPriority(u.SOUND_GIZMO, this._manager.getHigherPriority(u.MANIPULATORS))
                },
                initWebVR: function (e) {
                    this._manager.group(u.WEBVR).addMappings({
                        scaleUp: "keydown o",
                        scaleDown: "keydown p"
                    }, e), this._manager.group(u.WEBVR_DISPLAY).addMappings({
                        onPoseChange: ["vrdisplayposechanged"]
                    }, e), this._manager.setEnable(u.WEBVR, !1), (0, r.Z)() && this._manager.group(u.WEBVREDITOR).addMappings({
                        savePosition: "mousemove"
                    }, e)
                },
                initWebVRNavigation: function (e) {
                    this._manager.group(u.WEBVR_NAVIGATION).addMappings({
                        onPointerDown: "touchstart 1",
                        onPointerUp: ["touchend 1", "mouseup 0", "mouseup 1"],
                        displayMenu: ["mouseup 2"],
                        onMouseDown: "mousedown"
                    }, e), this._manager.setEnable(u.WEBVR_NAVIGATION, !1)
                },
                initAR: function (e) {
                    (0, a.Z)().arkitDebug && (this._manager.group(u.AR_DEBUG).addMappings({
                        startMotion: ["mousedown 1", "mousedown 2"],
                        startRotate: "mousedown 1 !ctrl",
                        startElevate: "mousedown ctrl 1",
                        startScale: "mousedown 2",
                        motion: "mousemove",
                        endMotion: ["mouseup", "mouseout"]
                    }, e), this._manager.setPriority(u.AR_DEBUG, this._manager.getHigherPriority(u.MANIPULATORS))), l.initGestures(this._manager), this._manager.group(u.AR).addMappings({
                        startScale: "pinchstart",
                        endScale: "pinchend",
                        scale: "pinch",
                        endRotate: "panhend",
                        endElevate: "panvend",
                        rotate: "panh",
                        elevate: "panv"
                    }, e)
                },
                initDecals: function (e) {
                    this._manager.group(u.DECALS_DEBUG).addMappings({
                        onClick: ["mousedown 1"]
                    }, e), this._manager.setPriority(u.DECALS_DEBUG, this._manager.getHigherPriority(u.MANIPULATORS))
                }
            }
        },
        JbUU: (e, t, i) => {
            i.d(t, {
                Z: () => T
            });
            var n, r, a, o, s, l, u, c, h = i("aqzA"),
                d = i("gvzH"),
                g = i("XkCy"),
                f = i("FGWR"),
                m = i("8WLf"),
                p = i("ZmEo"),
                v = i("qk4i"),
                _ = i("MQQR"),
                S = h.Z.osg,
                x = h.Z.osgUtil,
                C = function () {
                    S.NodeVisitor.call(this), this.setNodeMaskOverride(-1)
                };
            C.prototype = S.objectInherit(S.NodeVisitor.prototype, {
                apply: function (e) {
                    e.setShape && e.setShape(null), this.traverse(e)
                }
            });
            const T = {
                init: function (e, t) {
                    this._context = e, this._viewer = e.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._features = this._context.getFeatures(), this._rootModel = t, S.time("compute KdTree"), this.computeKdTree(t), S.timeEnd("compute KdTree"), this._initialized = !0
                },
                isInitialized: function () {
                    return this._initialized
                },
                getViewport3d: function () {
                    return this._features.postProcess.getCamera().getViewport()
                },
                getMaterialFromHit: function (e) {
                    return this._features.material.getModel().findFirstMaterial(e._nodePath)
                },
                decodeDepth: function (e) {
                    if (255 === e[0]) return 1;
                    var t = e[0] + e[1] / 255;
                    return 3 & e && (t += e[2] / 65025), t / 255
                },
                pickDepth: (c = new Uint8Array(4), function (e, t, i) {
                    return e.readPixels(t, i, 1, 1, e.RGBA, e.UNSIGNED_BYTE, c), this.decodeDepth(c)
                }),
                getWorldPositionFromDepthXY: (l = S.vec4.create(), u = S.mat4.create(), function (e, t, i, n) {
                    var r = this._viewerOSGJS.getCamera(),
                        a = this._viewer.getFeaturesManager().getViewport3d(),
                        o = p.Z.uNearFar.getInternalArray(),
                        s = o[0] + (o[1] - o[0]) * e;
                    return l[0] = (t / a.width() * 2 - 1) * s, l[1] = (i / a.height() * 2 - 1) * s, l[2] = 1, l[3] = s, S.mat4.invert(u, r.getProjectionMatrix()), S.vec4.transformMat4(l, l, u), S.mat4.invert(u, r.getViewMatrix()), S.vec3.transformMat4(n || S.vec3.create(), l, u)
                }),
                getPixelDepth: function (e, t, i) {
                    v.Z.draw();
                    var n = this._features.quality.getModel(),
                        r = n.get("dynamicResolutionScaling")[0],
                        a = (0, _.Z)().stats && this._viewerOSGJS.getViewerStats();
                    m.Z.setCallbackDepth(function (o) {
                        m.Z.setCallbackDepth(void 0), a && a.getCounter("readpixels").start();
                        var s = o.getGraphicContext();
                        if (s.checkFramebufferStatus(s.FRAMEBUFFER) !== s.FRAMEBUFFER_COMPLETE) return i(-1);
                        s.flush(), s.finish();
                        var l = n.get("dynamicResolutionScaling")[0];
                        r !== l && (e = e * l / r, t = t * l / r);
                        var u = this.pickDepth(s, e, t, i);
                        a && a.getCounter("readpixels").end(), i(u, e, t, s)
                    }.bind(this))
                },
                _computeIntersections3D: (o = new x.IntersectionVisitor, s = new x.LineSegmentIntersector, function (e, t, i, n) {
                    n || (n = this._features.webVR.getNode()), void 0 === i && (i = d.Z.PICK_GEOMETRY_SLOW), o.reset(), s.reset();
                    var r = this._features.shadingStyle,
                        a = r && r.getModel().get("hasLines"),
                        l = r && r.getModel().get("hasPoints"),
                        u = .005 * g.Z.getModelBoxWithoutDisplacement().radius(),
                        c = l || a ? u : 0;
                    return o.setTraversalMask(i), o.setIntersector(s), s.set(e, t, c), n.accept(o), s.getIntersections()
                }),
                computeNearestIntersection3D: function (e, t, i, n) {
                    var r = this._computeIntersections3D(e, t, i, n);
                    return this._sortIntersections(r)
                },
                computeNearestIntersection3DHotspotFirst: function (e, t, i, n) {
                    var r = this._computeIntersections3D(e, t, i, n);
                    if (0 !== r.length) {
                        r.sort((function (e, t) {
                            return e._ratio - t._ratio
                        }));
                        var a = 0,
                            o = r.length,
                            s = this._features.hotspot.getWidgetNode();
                        for (a = 0; a < o; ++a)
                            if (-1 !== r[a]._nodePath.indexOf(s)) return r[a];
                        return this._getFirstVisibleHit(r)
                    }
                },
                pickNearestSurface: function (e) {
                    return this.computeNearestIntersection2D(e.canvasX, e.canvasY, d.Z.PICK_GEOMETRY_SLOW, this._rootModel)
                },
                _computeIntersections2D: (n = S.vec3.create(), r = S.vec3.create(), a = S.mat4.create(), function (e, t, i, o) {
                    return o || (o = this._features.webVR.getNode()), f.Z.canvasCoordToGL(e, t, n), f.Z.canvasCoordToGL(e, t, r), n[2] = 0, r[2] = 1, this.getWorldPositionFromScreenPoint(n, n), this.getWorldPositionFromScreenPoint(r, r), o.getWorldMatrix(void 0, a), S.mat4.invert(a, a), S.vec3.transformMat4(n, n, a), S.vec3.transformMat4(r, r, a), this._computeIntersections3D(n, r, i, o)
                }),
                computeNearestIntersection2D: function (e, t, i, n) {
                    var r = this._computeIntersections2D(e, t, i, n);
                    return this._sortIntersections(r)
                },
                _sortIntersections: function (e) {
                    if (0 !== e.length) return e.sort((function (e, t) {
                        return e._ratio - t._ratio
                    })), this._getFirstVisibleHit(e)
                },
                _getFirstVisibleHit: function (e) {
                    for (var t = 0, i = e.length; t < i; ++t) {
                        var n = e[t];
                        if (!n._backface) return n;
                        for (var r = n._nodePath, a = r.length - 1; a >= 0; --a) {
                            var o = r[a].getStateSet(),
                                s = o && o.getAttribute("CullFace");
                            if (void 0 !== s) {
                                if (s.getMode() === S.CullFace.DISABLE) return n;
                                break
                            }
                        }
                    }
                },
                getRelativePositionFromHit: function () {
                    var e = S.mat4.create(),
                        t = S.mat3.create();
                    return function (i, n, r, a) {
                        for (var o = i._nodePath, s = !1, l = 0, u = o.length; l < u; ++l)
                            if (o[l] === a) {
                                o = o.slice(l), s = !0;
                                break
                            }
                        return S.mat4.identity(e), !1 === s && o[0].getWorldMatrix(a, e), S.computeLocalToWorld(o, !0, e), S.vec3.transformMat4(n, i._localIntersectionPoint, e), r && (S.mat3.normalFromMat4(t, e), S.vec3.transformMat3(r, i._localIntersectionNormal, t), S.vec3.normalize(r, r)), n
                    }
                }(),
                getWorldPositionFromHit: function (e, t, i) {
                    return this.getRelativePositionFromHit(e, t, i, this._viewerOSGJS.getSceneData())
                },
                getScenePositionFromHit: function (e, t, i) {
                    return this.getRelativePositionFromHit(e, t, i, this._rootModel)
                },
                getWorldPositionFromScenePoint: function (e, t) {
                    var i = t || S.vec3.create(),
                        n = this._features.orientation,
                        r = this._features.autospin;
                    return n && S.vec3.transformMat4(i, e, n.getNode().getMatrix()), r && S.vec3.transformMat4(i, i, r.getNode().getMatrix()), i
                },
                getScenePositionFromWorldPoint: function () {
                    var e = S.mat4.create();
                    return function (t, i) {
                        var n = i || S.vec3.create(),
                            r = this._features.orientation,
                            a = this._features.autospin;
                        return S.mat4.identity(e), r && S.mat4.multiply(e, e, r.getNode().getMatrix()), a && S.mat4.multiply(e, e, a.getNode().getMatrix()), S.mat4.invert(e, e), S.vec3.transformMat4(n, t, e)
                    }
                }(),
                getScreenPositionFromScenePoint: function (e, t) {
                    var i = this.getWorldPositionFromScenePoint(e, t);
                    return this.getScreenPositionFromWorldPoint(i, i)
                },
                getScreenPositionFromWorldPoint: function () {
                    var e = S.mat4.create();
                    return function (t, i) {
                        if (this._viewerOSGJS) {
                            var n = this._viewerOSGJS.getCamera();
                            S.mat4.identity(e), this.getViewport3d().computeWindowMatrix(e), S.mat4.multiply(e, e, n.getProjectionMatrix()), S.mat4.multiply(e, e, n.getViewMatrix());
                            var r = i || S.vec3.create();
                            return S.vec3.transformMat4(r, t, e)
                        }
                    }
                }(),
                getWorldPositionFromScreenPoint: function () {
                    var e = S.mat4.create();
                    return function (t, i) {
                        var n = this._viewerOSGJS.getCamera();
                        S.mat4.identity(e), this.getViewport3d().computeWindowMatrix(e), S.mat4.multiply(e, e, n.getProjectionMatrix()), S.mat4.multiply(e, e, n.getViewMatrix()), S.mat4.invert(e, e);
                        var r = i || S.vec3.create();
                        return S.vec3.transformMat4(r, t, e)
                    }
                }(),
                getScenePositionFromScreenPoint: function (e, t) {
                    var i = this.getWorldPositionFromScreenPoint(e, t);
                    return this.getScenePositionFromWorldPoint(i, i)
                },
                computeKdTree: function (e) {
                    for (var t = this._context.getScene().getWireframeNodes(), i = new C, n = t.length, r = 0; r < n; ++r) t[r].accept(i);
                    new S.KdTreeBuilder({
                        _numVerticesProcessed: 0,
                        _targetNumTrianglesPerLeaf: 50,
                        _maxNumLevels: 50
                    }).apply(e)
                }
            }
        },
        CUcOv: (e, t, i) => {
            i.d(t, {
                Z: () => Q
            });
            var n = i("lZH+"),
                r = i.n(n),
                a = i("aqzA"),
                o = i("k46e"),
                s = i("X9mO"),
                l = i("QG/p"),
                u = i("qk4i"),
                c = i("kbo/"),
                h = function (e, t, i) {
                    this._url = e, this._defer = new l.Z, this._responseType = t, this._options = i
                };
            h.prototype = {
                getPromise: function () {
                    return this._defer
                },
                getURL: function () {
                    return this._url
                },
                start: function () {
                    this._xhr = new XMLHttpRequest, this._xhr.addEventListener("error", this.error.bind(this), !1), this._xhr.addEventListener("abort", this.abort.bind(this), !1), this._xhr.addEventListener("progress", this.progress.bind(this), !1), this._xhr.responseType = this._options && this._options.diter && this._options.diter.b ? "arraybuffer" : this._responseType, this._xhr.addEventListener("load", function (e) {
                        var t = function () {
                            this._xhr.response || (this._xhr.response = this._xhr.responseText), this.load.call(this), u.Z.draw()
                        }.bind(this);
                        if (200 !== this._xhr.status) return console.log("Error not loaded " + this._url), void this.error(e);
                        this._options && this._options.diter ? (0, c.Z)(this._xhr.response, this._options.diter.b, this._options.diter.v, this._options.diter.d, function (e) {
                            var i = e.buffer;
                            if ("text" === this._responseType) {
                                i = "";
                                for (var n = new Uint8Array(e), r = 0; r < e.length; r += 65535) i += String.fromCharCode.apply(null, n.slice(r, r + 65535))
                            }
                            this._xhr = {
                                response: i,
                                responseText: i
                            }, t()
                        }.bind(this)) : t()
                    }.bind(this), !1), this._xhr.open("GET", this._url, !0), this._xhr.send(null)
                },
                error: function () {
                    console.error("Error when downloading url : " + this._url), this._defer.reject(new Error("Error when downloading url : " + this._url))
                },
                abort: function () {
                    this._defer.cancel("Cancelling download of url : " + this._url)
                },
                progress: function (e) {
                    var t = this._options;
                    if (t && t.progress && t.size) {
                        var i = e.loaded / t.size;
                        t.progress(i, t.secondary, t.progressKey)
                    }
                },
                load: function () {
                    this._defer.resolve(this)
                },
                getXHR: function () {
                    return this._xhr
                }
            };
            const d = h;
            var g = function () {
                d.apply(this, arguments)
            };
            g.prototype = (0, o.Z)({}, d.prototype, {
                load: function () {
                    this._model = this._xhr.response, this._defer.resolve(this._model)
                },
                getModel: function () {
                    return this._model
                }
            });
            const f = g;
            var m = i("9O9B"),
                p = i("MQQR"),
                v = i("ZXTF");
            var _ = a.Z.osg,
                S = {},
                x = {},
                C = parseInt((/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [0, 0])[1], 10),
                T = (0, p.Z)().asyncImage;
            T && (T = window.Worker && window.fetch && window.createImageBitmap && C >= 52);
            var M = [];
            window.closeBitmaps = function () {
                M.forEach((function (e) {
                    e.close()
                }))
            };
            var b = function (e) {
                var t = 0,
                    i = Math.max(2, Math.min(4, navigator.hardwareConcurrency || 2)),
                    n = [],
                    r = URL.createObjectURL(new Blob([e], {
                        type: "text/javascript"
                    }));
                return function () {
                    var e = n[t];
                    return e || ((e = n[t] = new Worker(r)).onmessage = function (e) {
                        var t = e.data,
                            i = t.uid,
                            n = x[i];
                        t.bitmap ? (n.setImage(t.bitmap), M.push(t.bitmap)) : (n.setImage(t.img), n.setWidth(t.width), n.setHeight(t.height)), S[i]()
                    }), t = (t + 1) % i, e
                }
            },
                y = b(v),
                A = b("/*jshint worker: true */\n\nself.onmessage = function (event) {\n    var data = event.data;\n\n    var opt = {\n        imageOrientation: 'flipY',\n        premultiplyAlpha: 'none',\n        colorSpaceConversion: 'none',\n    };\n\n    self.fetch(data.url).then(function (response) {\n        response.blob().then(function (blob) {\n            self.createImageBitmap(blob, opt).then(function (bitmap) {\n                postMessage(\n                    {\n                        bitmap: bitmap,\n                        url: data.url,\n                        uid: data.uid,\n                    },\n                    [bitmap]\n                );\n            });\n        });\n    });\n};\n\n/*jshint worker: false */\n"),
                R = function (e, t) {
                    d.call(this, e, "blob", t), this._responseType = "arraybuffer"
                };
            R.prototype = (0, o.Z)({}, d.prototype, {
                isVideo: function (e) {
                    return m.Z.isVideoURL(e)
                },
                createVideo: function () {
                    var e = document.createElement("video");
                    return document.body.appendChild(e), e.style.display = "none", e
                },
                start: function () {
                    var e = this.getURL();
                    if (this.isVideo(e)) {
                        var t = this.createVideo();
                        return this._osgjsImage = new _.ImageStream(t), window.video = this._osgjsImage, t.preload = "auto", t.crossOrigin = "anonymous", (this._options.mute || this._options.muted) && (t.muted = !0), this._options.loop && (t.loop = this._options.loop), t.src = e, void this._osgjsImage.whenReady().then(function (e) {
                            e.play(), this._defer.resolve(this._osgjsImage)
                        }.bind(this))
                    }
                    this._osgjsImage = new _.Image;
                    var i = this._options;
                    if (!(i.panoramaLUV || i.integrateBRDFLUV || i.cubemapLUV)) return u.Z.draw(), this._url.endsWith(".astc.gz") ? (i.astc = !0, void d.prototype.start.call(this)) : this._url.endsWith(".svg") ? (i.svg = !0, void this.loadImage()) : void (i.decodeAsync && T ? this.loadImageAsync() : this.loadImage());
                    d.prototype.start.call(this)
                },
                load: function () {
                    var e = this._options;
                    e.panoramaLUV || e.integrateBRDFLUV ? this.loadLUV() : e.cubemapLUV ? this.loadCubemapLUV() : e.astc && this.loadAstc()
                },
                loadImageAsync: function () {
                    S[this._url] = this._defer.resolve.bind(this._defer, this._osgjsImage), x[this._url] = this._osgjsImage, A().postMessage({
                        uid: this._url,
                        url: this._url
                    })
                },
                loadAstc: function () {
                    var e = this._xhr.response;
                    S[this._url] = this._defer.resolve.bind(this._defer, this._osgjsImage), x[this._url] = this._osgjsImage, y().postMessage({
                        uid: this._url,
                        buffer: e,
                        swizzle: !0,
                        nbComponents: 3
                    }, [e])
                },
                svgToCanvas: function () {
                    var e = document.createElement("canvas"),
                        t = (0, p.Z)().svgSize;
                    e.width = t, e.height = t;
                    var i = e.getContext("2d");
                    this._htmlImage.width = t, this._htmlImage.height = t, i.drawImage(this._htmlImage, 0, 0, t, t), this._osgjsImage.setImage(e)
                },
                loadImage: function () {
                    this._htmlImage = new Image, this._options.crossOrigin && (this._htmlImage.crossOrigin = this._options.crossOrigin), this._htmlImage.addEventListener("load", function () {
                        this._options.svg && this.svgToCanvas(), this._defer.resolve(this._osgjsImage)
                    }.bind(this)), this._htmlImage.onerror = function () {
                        this._htmlImage._aborted ? this._defer.cancel(this._osgjsImage) : this._defer.reject(this._osgjsImage)
                    }.bind(this), this._htmlImage.src = this._url, this._osgjsImage.setImage(this._htmlImage)
                },
                abort: function () {
                    this._htmlImage ? (this._htmlImage.src = "", this._htmlImage._aborted = !0) : d.prototype.abort.call(this)
                },
                loadLUV: function () {
                    var e, t = this._xhr.response,
                        i = Math.sqrt(t.byteLength / 4);
                    e = this._options.integrateBRDFLUV ? new Uint8Array(t) : this.deinterleaveImage4(i, new Uint8Array(t), new Uint8Array(t.byteLength));
                    var n = this._osgjsImage;
                    n.setImage(e), n.setWidth(i), n.setHeight(i), this._defer.resolve(this._osgjsImage)
                },
                loadCubemapLUV: function () {
                    for (var e = this._xhr.response, t = Math.log(this._options.size) / Math.LN2, i = 0, n = {}, r = 0; r <= t && !(i >= e.byteLength); r++)
                        for (var a = Math.pow(2, t - r), o = 0; o < 6; o++) {
                            n[_.Texture.TEXTURE_CUBE_MAP_POSITIVE_X + o] || (n[_.Texture.TEXTURE_CUBE_MAP_POSITIVE_X + o] = []);
                            var s = a * a * 4,
                                l = new Uint8Array(s);
                            this.deinterleaveImage4(a, new Uint8Array(e, i, s), l);
                            var u = new _.Image;
                            u.setImage(l), u.setWidth(a), u.setHeight(a), n[_.Texture.TEXTURE_CUBE_MAP_POSITIVE_X + o].push(u), i += s
                        }
                    this._defer.resolve(n)
                },
                deinterleaveImage4: function (e, t, i) {
                    for (var n = e * e, r = 2 * e * e, a = 3 * e * e, o = 0, s = 0; s < n; s++) i[o++] = t[s], i[o++] = t[s + n], i[o++] = t[s + r], i[o++] = t[s + a];
                    return i
                },
                getImage: function () {
                    return this._osgjsImage
                }
            });
            const w = R;
            var E = function (e, t) {
                d.call(this, e, "arraybuffer", t)
            };
            E.prototype = (0, o.Z)({}, d.prototype, {
                load: function () {
                    var e = this.getXHR().response;
                    this._defer.resolve(e)
                }
            });
            const P = E;
            var N = a.Z.osg,
                O = function (e, t, i) {
                    i ? N.error("ResourceLoader: " + e + " failed " + t + " error " + i) : N.error("ResourceLoader: " + e + " failed " + t)
                },
                D = function () {
                    this._nbThreads = 5, this._processing = [], this._queue = [], this._finished = [], this._running = !1
                };
            D.prototype = {
                checkResource: function (e) {
                    var t;
                    return [this._processing, this._queue, this._finished].forEach((function (i) {
                        t || (t = (0, s.Z)(i, (function (t) {
                            return t._url === e
                        })))
                    })), t
                },
                run: function () {
                    this._running = !0, this.runPendingProcess()
                },
                runPendingProcess: function () {
                    for (; this._processing.length < this._nbThreads && this._queue.length > 0;) {
                        var e = this._queue.shift();
                        this._processing.push(e), e.start()
                    }
                },
                queue: function (e) {
                    e.start || (console.log(e.url), e = new d(e.url, e.response)), this._queue.push(e);
                    var t = e.getPromise();
                    return t.finally(function () {
                        t.isFulfilled() && this._finished.push(e), this._processing.splice(this._processing.indexOf(e), 1), this.runPendingProcess()
                    }.bind(this)), this._running && this.runPendingProcess(), e
                },
                getModel: function (e, t) {
                    var i = this.checkResource(e);
                    return i || ((i = this.queue(new f(e, "text", t))).getPromise().catch((function (t) {
                        O(e, "model", t)
                    })), i)
                },
                getImage: function (e, t) {
                    var i = this.checkResource(e);
                    if (i) return i;
                    var n = t || {};
                    return "data:image" === e.substr(0, "data:image".length) || (n.crossOrigin = "anonymous"), (i = this.queue(new w(e, n))).getPromise().catch((function () {
                        O(e, "image")
                    })), i
                },
                getBinaryArray: function (e, t) {
                    var i = this.checkResource(e);
                    return i || ((i = this.queue(new P(e, t))).getPromise().catch((function (t) {
                        O(e, "binary array", t)
                    })), i)
                }
            };
            const I = D;
            var F = i("kRpH"),
                L = i("CalZ"),
                V = i("fb2z"),
                B = i("Sgtb"),
                U = i("r5qc"),
                k = i("E6+r"),
                Z = i("/TID"),
                H = i("l1dI"),
                G = i("avzw"),
                z = i("Qf9l"),
                W = i("fx+f"),
                j = a.Z.osg,
                X = function (e) {
                    e = this.computeURL(e);
                    var t = new j.Image;
                    return t.setURL(e), r().resolve(t)
                },
                Y = [],
                J = {},
                q = function (e, t) {
                    this.resource = e, this.promise = t
                },
                K = function (e) {
                    if (!e) {
                        if (K.instance) return K.instance;
                        K.instance = this
                    }
                    return this._optPrefetch = {
                        modelUid: void 0,
                        checkPrefetch: !0
                    }, this._maps = {}, this._collections = {}, this._resourceLoader = new I, this
                };
            K.Entry = q, K.prototype = {
                setModelUid: function (e) {
                    this._optPrefetch.modelUid = e
                },
                setStateContextOSG: function (e) {
                    this._state = e
                },
                getInstance: function () {
                    return K.instance
                },
                register: function (e, t) {
                    this._maps[e] = t
                },
                exist: function (e) {
                    return this._maps[e]
                },
                hashTextureOptions: function (e) {
                    for (var t = "", i = F.Z.getValidOptions(), n = i.length, r = 0; r < n; ++r) t += e[i[r]];
                    return t
                },
                _getCollection: function (e, t) {
                    var i = this._collections[t];
                    return i || (this._collections[t] = new e([], this._optPrefetch), window.RunningTests || this._collections[t].fetch(), this._collections[t])
                },
                getEnvironmentCollection: function () {
                    return this._getCollection(L.Z, "environment")
                },
                getBackgroundCollection: function () {
                    return this._getCollection(V.Z, "background")
                },
                getSoundCollection: function () {
                    return this._getCollection(H.Z, "sound")
                },
                getHotspotCollection: function () {
                    return this._getCollection(k.Z, "hotspot")
                },
                getMatcapCollection: function () {
                    return this._getCollection(U.Z, "matcap")
                },
                getAnimationCollection: function () {
                    return this._getCollection(Z.Z, "animation")
                },
                getTextureCollection: function () {
                    if (this._collections.texture) return this._collections.texture;
                    var e = this._getCollection(B.Z, "texture");
                    return e.forEach((function (t) {
                        0 === t.getImages().length && e.remove(t)
                    })), e.isValid(), e
                },
                getOrCreateMultiresTexture: function (e, t) {
                    var i = [e, this.hashTextureOptions(t)].join(""),
                        n = this.exist(i);
                    if (n) return n;
                    var a = this.getTextureCollection().get(e) || this.getMatcapCollection().get(e);
                    if (a) {
                        var o = new G.Z;
                        return F.Z.setOptions(t, o), o.setImageModel(a), n = new q(o, r().resolve(o)), this.register(i, n), n
                    }
                },
                getOrCreateImage: function (e, t) {
                    var i = "image" + e;
                    t && t.widget && (i += "widget");
                    var n = this.exist(i);
                    if (n) return n;
                    var r = this._resourceLoader.getImage(e, t).getPromise();
                    return (n = new q).promise = r.then((function (e) {
                        return t && t.pk && (e.pk = t.pk), n.image = e, n.resource = e, e
                    })), this.register(i, n), n
                },
                getOrCreateTexture: function (e, t) {
                    var i = function (e) {
                        !this._state || e._textureObject && !e.isDirty() || this._state.applyTextureAttribute(0, e)
                    }.bind(this),
                        n = F.Z.createValidOptions(t),
                        r = [e, this.hashTextureOptions(n)].join(""),
                        a = this.exist(r),
                        o = !!(t && t.transferToGPU && this._state);
                    if (a) return o && (a.promise.isFulfilled() ? i(a.texture) : a._bindToGPU = !0), a;
                    n.cubemap = t && t.cubemap;
                    var s = n.cubemap ? new z.Z : new G.Z;
                    s.setTextureSize(1, 1), F.Z.setOptions(n, s), t && void 0 !== t.convertNPOT && (s._convertNPOT = t.convertNPOT);
                    var l = this._resourceLoader.getImage(e, t).getPromise();
                    (a = new q(s)).texture = s, a._bindToGPU = o;
                    var u = this;
                    return a.promise = l.then((function (e) {
                        if (n.cubemap)
                            for (var t = 0; t < 6; t++) {
                                var r = j.Texture.TEXTURE_CUBE_MAP_POSITIVE_X + t;
                                s.setImage(r, e[r], "RGBA")
                            } else s.setImage(e);
                        return s.dirty(), a._bindToGPU && i(s), s
                    })).finally((function () {
                        return l.isFulfilled() || u.register(r, void 0), s
                    })), this.register(r, a), a
                },
                getOrCreateModel: function (e, t) {
                    var i = e,
                        n = this.exist(i);
                    if (n) return n;
                    var a, s = t && t.node ? t.node : new j.Node,
                        l = {};
                    l.readImageURL = X, l.readBinaryArrayURL = (a = this._resourceLoader, function (e, t) {
                        return e = t.currentAnimationUID ? t.currentAnimationUID : this.computeURL(e), a.getBinaryArray(e, t).getPromise()
                    }), l.bufferMap = J, l.readBufferArray = function () {
                        var e = this.getJSON(),
                            t = e.UniqueID,
                            i = new j.BufferArray(j.BufferArray[e.Type]);
                        i.setItemSize(e.ItemSize), i.setElements(Y);
                        var n = i.getInstanceID();
                        if (J[n] = {}, e.Array) {
                            var a = Object.keys(e.Array)[0],
                                o = e.Array[a];
                            o.Elements ? J[n].inlined = o.Elements : (J[n].vb = o, J[n].type = a)
                        } else J[n].inlined = e.Elements;
                        var s = r().resolve(i);
                        return void 0 !== t && (this._identifierMap[t] = s), s
                    };
                    var u = (0, o.Z)({}, l, t),
                        c = this._resourceLoader.getModel(e, u),
                        h = e.split("/");
                    h.length = h.length - 1, h.length <= 0 && j.error("getOrCreateModel: can't find prefix to load subdata");
                    var d = h.join("/") + "/";
                    u.prefixURL = d;
                    var g = (0, W.Z)(c.getPromise(), e, u, s, this._resourceLoader);
                    return (n = new q(s, g)).node = s, this.register(i, n), n
                },
                run: function () {
                    this._resourceLoader.run()
                }
            }, new K;
            const Q = K
        },
        wAYD: (e, t, i) => {
            i.d(t, {
                Z: () => c
            });
            var n = i("aqzA"),
                r = i("MQQR"),
                a = n.Z.osg,
                o = n.Z.osgShader.shaderProcessor,
                s = {
                    "utils/common.glsl": i("eq5r"),
                    "utils/functions.glsl": i("GDcI"),
                    "shadowing/shadowReceive.glsl": i("OLDE"),
                    "shadowing/shadowLinearSoft.glsl": i("U0i3"),
                    "shadowing/tapPCF.glsl": i("ZNov"),
                    "utils/lightCommon.glsl": i("fvmo"),
                    "utils/lights.glsl": i("U/h/"),
                    "utils/lightsPBR.glsl": i("uMel"),
                    "utils/lightsSSS.glsl": i("rSdO"),
                    "utils/skinning.glsl": i("LG61"),
                    "utils/morphing.glsl": i("lyG1"),
                    "utils/environment.glsl": i("Lebq"),
                    "utils/panoramaLod.glsl": i("JBxq"),
                    "utils/cubemapLod.glsl": i("RSGS"),
                    "utils/cubemap.glsl": i("D4k4"),
                    "utils/rand.glsl": i("58et"),
                    "utils/curvature.glsl": i("dd27"),
                    "utils/refraction.glsl": i("49g6"),
                    "utils/clearCoat.glsl": i("lLHi"),
                    "utils/ssr.glsl": i("I19b"),
                    "utils/material.glsl": i("HUu/"),
                    "utils/normalBump.glsl": i("IK/+"),
                    "utils/checkerboard.glsl": i("8g60"),
                    "utils/decodeDepth.glsl": i("RC5z"),
                    "utils/encodeDepth.glsl": i("Z5UG"),
                    "utils/encodeDecode.glsl": i("NfER"),
                    "utils/getLuminance.glsl": i("hWsA"),
                    "base.vert": i("WkX6"),
                    "earlyz.vert": i("urqr"),
                    "earlyz.frag": i("1BmB"),
                    "pbr.vert": i("m6+n"),
                    "pbr.frag": i("8M0R"),
                    "outline.vert": i("sIqN"),
                    "outline.frag": i("3rnw"),
                    "matcap.vert": i("FAG/"),
                    "matcap.frag": i("8Ftk"),
                    "shadeless.vert": i("mU6Y"),
                    "shadeless.frag": i("HCcy"),
                    "wireframe.vert": i("qgTy"),
                    "wireframe.frag": i("z26O"),
                    "inspector/inspector.vert": i("rz9/"),
                    "inspector/inspector.frag": i("G+Dx"),
                    "shadowing/shadowCast.vert": i("k2zI"),
                    "shadowing/shadowCast.frag": i("s4hY"),
                    "ARKit/shadowAr.vert": i("aV2Y"),
                    "ARKit/shadowAr.frag": i("s4wW"),
                    "webVR/controller.vert": i("cMLc"),
                    "webVR/controller.frag": i("26Cb"),
                    "debug/boneBox.vert": i("0Vir"),
                    "debug/boneBox.frag": i("Aakz"),
                    "debug/normal.vert": i("M9k7"),
                    "debug/normal.frag": i("AYWJ"),
                    "debug/tangent.vert": i("5oZM"),
                    "debug/tangent.frag": i("Lzt+"),
                    "debug/skinning.vert": i("PQ9b"),
                    "debug/skinning.frag": i("YpwI"),
                    "debug/geometry.vert": i("t7Q4"),
                    "debug/geometry.frag": i("mROa"),
                    "ground/ground.vert": i("Rh6r"),
                    "ground/ground.frag": i("zG+0"),
                    "ground/bakeShadowMap.vert": i("WHiR"),
                    "ground/bakeShadowMap.frag": i("xERb")
                };
            if (o.addShaders(s), !(0, r.Z)().rgbm) {
                var l = o.getShaderTextPure("utils/functions.glsl");
                l = (l = l.replace(/encodeRGBM.*\{/, "$&\nreturn vec4(color, 1.0);")).replace(/decodeRGBM.*\{/, "$&\nreturn color.rgb;"), o.addShaders({
                    "utils/functions.glsl": l
                })
            }
            var u = function () {
                this._shaderCache = {}
            };
            u.prototype = {
                getOrCreateShader: function (e, t, i, n, r) {
                    var a = "";
                    r && (a = r.toString());
                    var o = i + a,
                        s = this._shaderCache[o];
                    return s || (s = this._createShader(e, t, i, n, r), this._shaderCache[o] = s), s
                },
                _createShader: function (e, t, i, n, r) {
                    var s = "#define SHADER_NAME " + n + "\n";
                    if (r)
                        if (Array.isArray(r))
                            for (var l = 0; l < r.length; l++) s += "#define " + r[l] + "\n";
                        else s += "#define " + r + "\n";
                    var u = {};
                    return u[i + "-vert"] = s + e, u[i + "-frag"] = s + t, o.addShaders(u), new a.Program(new a.Shader(a.Shader.VERTEX_SHADER, o.getShader(i + "-vert")), new a.Shader(a.Shader.FRAGMENT_SHADER, o.getShader(i + "-frag")))
                }
            };
            const c = new u
        },
        KXnA: (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = new (i("/K0U").Z);
            n.PBR_LIT = 1, n.CLASSIC_LIT = 2, n.PBR_SHADELESS = 4, n.CLASSIC_SHADELESS = 8, n.MATCAP = 16, n.INSPECTOR = 32, n.nameMatch = {
                "shadeless-pbr": n.PBR_SHADELESS,
                "shadeless-classic": n.CLASSIC_SHADELESS,
                "lit-pbr": n.PBR_LIT,
                "lit-classic": n.CLASSIC_LIT,
                "shading-ar": n.PBR_LIT,
                "shading-vr": n.PBR_LIT,
                ground: n.INSPECTOR,
                inspector: n.INSPECTOR
            }, n.LIT = n.PBR_LIT | n.CLASSIC_LIT, n.SHADELESS = n.PBR_SHADELESS | n.CLASSIC_SHADELESS, n.PBR = n.PBR_LIT | n.PBR_SHADELESS, n.CLASSIC = n.CLASSIC_LIT | n.CLASSIC_SHADELESS, n.set("mask", n.PBR_LIT), n.set("hasSsr", !1), n.on("change:mask", (function () {
                var e = n.get("mask");
                switch (e) {
                    case n.PBR_LIT:
                    case n.CLASSIC_LIT:
                    case n.PBR_SHADELESS:
                    case n.CLASSIC_SHADELESS:
                    case n.INSPECTOR:
                    case n.MATCAP:
                        break;
                    default:
                        console.error("Invalid ShadingGlobal mask value !" + e)
                }
            }));
            const r = n
        },
        "5Mmo": (e, t, i) => {
            i.d(t, {
                Z: () => h
            });
            var n = i("QX1t"),
                r = i("aqzA"),
                a = i("/K0U"),
                o = i("kRpH"),
                s = i("CUcOv"),
                l = r.Z.osg,
                u = (0, n.Z)(l.Texture),
                c = ["magFilter", "minFilter", "wrapS", "wrapT", "textureTarget", "internalFormat"];
            const h = a.Z.extend({
                initialize: function () {
                    if (a.Z.prototype.initialize.apply(this, arguments), this.attributes.image) {
                        var e = o.Z.createValidOptionsForMaterial(this.attributes);
                        this.set(e), this.setMultiresTextureFromValidOptions(e), void 0 === this.get("texCoordUnit") && this.set("texCoordUnit", 0), this.bind("change:image", this.updateMultiresTexture, this)
                    } else l.error("no image found in attributes, TextureModel invalid")
                },
                getImageModel: function () {
                    return this.get("image")
                },
                setImageModel: function (e) {
                    this.set("image", e)
                },
                getResourceManager: function () {
                    return this._resourceManager || s.Z.instance
                },
                getMultiresTexture: function () {
                    return this.get("multiresTexture")
                },
                getURL: function () {
                    console.trace("dont call TextureModel.getURL")
                },
                setMultiresTextureFromValidOptions: function (e) {
                    var t = this.get("image").getUID(),
                        i = this.getResourceManager().getOrCreateMultiresTexture(t, e);
                    i && this.set("multiresTexture", i.resource)
                },
                updateMultiresTexture: function () {
                    this.setMultiresTextureFromValidOptions(o.Z.createValidOptionsForMaterial(this.attributes))
                },
                isLuminance: function () {
                    return this.get("internalFormat") === l.Texture.LUMINANCE
                },
                isAlpha: function () {
                    return this.get("internalFormat") === l.Texture.ALPHA
                },
                getUID: function () {
                    return this.getImageModel().getUID()
                },
                getJSON: function () {
                    for (var e = {}, t = 0, i = c.length; t < i; ++t) {
                        var n = c[t];
                        e[n] = u[this.get(n)]
                    }
                    return e.texCoordUnit = this.get("texCoordUnit"), e.uid = this.getUID(), e
                }
            })
        },
        PpZu: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = i("aqzA"),
                r = i("qk4i"),
                a = function (e) {
                    this._duration = void 0 === e ? 1 : e, this.reset()
                };
            n.Z.osg.createPrototypeObject(a, {
                getDuration: function () {
                    return this._duration
                },
                setDuration: function (e) {
                    this._duration = e
                },
                reset: function () {
                    this._startTime = -1, this._finished = !1, this._ratio = 0, r.Z.draw()
                },
                finished: function () { },
                interpolate: function (e, t, i) {
                    if (this._finished) return 1;
                    this._startTime < 0 && (this._startTime = e);
                    var n = Math.min(this._duration, e - this._startTime),
                        r = 0 === this._duration ? 1 : n / this._duration;
                    return this._ratio = r, (r >= 1 || 0 === this._duration) && (this._finished = !0, this.finished(t, i)), r
                },
                update: function (e, t) {
                    return this.interpolate(t.getFrameStamp().getSimulationTime(), e, t), !0
                }
            });
            const o = a
        },
        "+cmV": (e, t, i) => {
            i.d(t, {
                Z: () => l
            });
            var n = i("aqzA"),
                r = n.Z.osg,
                a = n.Z.osgAnimation,
                o = {
                    wireframe: !0,
                    epsilon: !0,
                    nphi: !0,
                    attributes: !0,
                    vertex_mode: !0,
                    triangle_mode: !0,
                    rigIndex: !0,
                    framerate: !0,
                    bx: !0,
                    by: !0,
                    bz: !0,
                    hx: !0,
                    hy: !0,
                    hz: !0,
                    ox: !0,
                    oy: !0,
                    oz: !0,
                    ow: !0,
                    ot: !0,
                    channel_mode: !0
                },
                s = function () {
                    r.NodeVisitor.call(this)
                };
            s.convertUserDataToObject = function (e, t) {
                var i = t || {};
                if (!e) return i;
                for (var n = 0, r = e.length; n < r; ++n) {
                    var a = e[n],
                        s = a.Name;
                    o[s] || -1 !== s.indexOf("_bbl_") || -1 !== s.indexOf("_h_") || -1 !== s.indexOf("_mode") ? i[s] = JSON.parse(a.Value) : i[s] = a.Value
                }
                return i
            }, s.instanceIDGeometryMap = {}, s.uidGeometryMap = {}, s.hasPoints = !1, s.hasTriangles = !1, s.hasLines = !1, s.hasVertexNormals = !1, s.hasBones = !1, s.hasMorphs = !1, s.hasRigsOrMorphs = !1, r.createPrototypeObject(s, r.objectInherit(r.NodeVisitor.prototype, {
                apply: function (e) {
                    var t = e instanceof r.Geometry;
                    if (t) {
                        void 0 !== e._uniqueID && (s.uidGeometryMap[e._uniqueID] = e), s.instanceIDGeometryMap[e.getInstanceID()] = e;
                        var i = s.hasMorphs || e instanceof a.MorphGeometry;
                        if (s.hasMorphs = i, !s.hasRigsOrMorphs) {
                            var n = e instanceof a.RigGeometry;
                            s.hasRigsOrMorphs = n || i
                        }
                    }
                    var o = e instanceof a.Bone;
                    if (s.hasBones = s.hasBones || o, t || o) {
                        e.userDataMap = s.convertUserDataToObject(e.getUserData());
                        var l = e;
                        if (e.getSourceGeometry && (l = e.getSourceGeometry(), s.convertUserDataToObject(l.getUserData(), e.userDataMap)), l instanceof a.MorphGeometry) {
                            s.hasMorphs = !0;
                            for (var u = l.getMorphTargets(), c = 0, h = u.length; c < h; ++c) {
                                var d = e.userDataMap["morph_" + c] = {};
                                s.convertUserDataToObject(u[c].getUserData(), d)
                            }
                        }
                    }
                    return this.traverse(e)
                }
            }));
            const l = s
        },
        aMVL: (e, t, i) => {
            i.d(t, {
                Z: () => l
            });
            var n = i("lZH+"),
                r = i.n(n),
                a = i("MQQR"),
                o = {
                    OSG_VERSION: -1
                },
                s = function (e) {
                    var t = {},
                        i = new (r())((function (e, i) {
                            t.resolve = e, t.reject = i
                        }));
                    i.resolve = t.resolve, i.reject = t.reject, o["get" + e] = function () {
                        return i
                    }, o["resolve" + e] = function () {
                        !1 === i.isFulfilled() && i.resolve.apply(i, arguments)
                    }
                };
            o.getInitialTextureBoundPromise = function () {
                return (0, a.Z)().preload ? o.getHighResBound() : o.getLowResBound()
            }, s("Polygon"), s("Wireframe"), s("WireframeOptimized"), s("WireframeOptimizedSplit"), s("WireframeOptimizedSplitCompressed"), s("ModelDisplayed"), s("FirstAnimation"), s("AllAnimations"), s("HasAnimation"), s("FirstCameraAnimation"), s("Material"), s("HasSound"), s("SoundsCanPlayTrough"), s("VrDisplayReady"), s("LowResLoaded"), s("HighResLoaded"), s("LowResBound"), s("HighResBound"), s("AsyncShaderCompilation"), s("DataSizeOSGJS"), s("DataSizePolygon"), s("DataSizeTextures"), s("DataSizeSound"), s("DataSizeEnvironment"), s("DataSizeWireframe"), s("DataSizeAllModel"), r().all([o.getDataSizeOSGJS(), o.getDataSizePolygon(), o.getDataSizeSound(), o.getDataSizeTextures(), o.getDataSizeEnvironment(), o.getDataSizeWireframe()]).then((function (e) {
                for (var t = 0, i = 0, n = e.length; i < n; i++) t += e[i];
                o.resolveDataSizeAllModel(t)
            })), o.allLoadingDone = window.testdemo2024ViewerLoaded = r().all([o.getHighResBound(), o.getAllAnimations(), o.getWireframeOptimizedSplitCompressed()]), document.createEvent && window.dispatchEvent && window.testdemo2024ViewerLoaded.then((function () {
                var e = document.createEvent("Event");
                e.initEvent("testdemo2024allloadingdone", !0, !0), window.dispatchEvent(e)
            }));
            const l = o
        },
        uKuv: (e, t, i) => {
            i.d(t, {
                Z: () => fi
            });
            var n = i("QKpV"),
                r = i("lZH+"),
                a = i.n(r),
                o = i("ypNz"),
                s = i("5Eyw"),
                l = i.n(s),
                u = i("aqzA"),
                c = i("BvLe"),
                h = i("mSEu"),
                d = i("nv4P"),
                g = i("WGQk"),
                f = !1;
            window && window.navigator && (f = -1 !== window.navigator.userAgent.indexOf("Edge"));
            const m = function () {
                return f
            };
            var p = i("X2SH"),
                v = i("hySD"),
                _ = i("GhWR"),
                S = i("MQQR"),
                x = i("qk4i"),
                C = i("ZmEo"),
                T = u.Z.osg,
                M = [
                    [.263385, -.0252475],
                    [-.38545, .054485],
                    [-.139795, -.5379925],
                    [-.2793775, .6875475],
                    [.7139025, .4710925],
                    [.90044, -.16422],
                    [.4481775, -.82799],
                    [-.9253375, -.2910625],
                    [.3468025, 1.02292],
                    [-1.13742, .33522],
                    [-.7676225, -.9123175],
                    [-.2005775, -1.1774125],
                    [-.926525, .96876],
                    [1.12909, -.7500325],
                    [.9603, 1.14625]
                ],
                b = function (e) {
                    return b.instance ? b.instance : (this._canBeEnabled = (0, S.Z)().supersample, this._viewer = e, this._sampleCount = 15, this._isFakeSupersampling = !1, this._isSupersampling = !1, this._frameNum = 1, this._frameNumTaa = 0, this._switch = !0, this._jitter = C.Z.uHalton.getInternalArray(), this._jitter[2] = 1, b.instance = this, this)
                };
            T.createPrototypeObject(b, {
                getSampleCount: function () {
                    return this._sampleCount
                },
                canBeEnabled: function () {
                    return this._canBeEnabled
                },
                getSortedJitterTable: function () {
                    return M
                },
                getBackgroundModel: function () {
                    return this._viewer.getFeatures().background.getModel()
                },
                getAnimationModel: function () {
                    return this._viewer.getFeatures().animation.getModel()
                },
                getWireframeAttenuation: function () {
                    var e = this._viewer.getOrCreateScene().getWireframeNodes();
                    if (!e.length || 0 === e[0].getNodeMask()) return 1;
                    var t = e[0].getStateSet().getUniform("uColor").getInternalArray()[3];
                    return 1 - t + .05 * t
                },
                updateUniforms: function (e, t) {
                    var i = e % this._sampleCount,
                        n = this.getSortedJitterTable()[i],
                        r = t ? .05 : this.getWireframeAttenuation();
                    this._jitter[0] = n[0] * r, this._jitter[1] = n[1] * r, this._jitter[3] = i
                },
                setSwitch: function (e) {
                    this._switch = e
                },
                isTaaJitter: function () {
                    var e = this._postProcess.getModel(),
                        t = e.get("taaEnable"),
                        i = "none" !== this.getBackgroundModel().get("enable"),
                        n = void 0 !== (0, S.Z)().taaJitter ? (0, S.Z)().taaJitter : i,
                        r = e.get("webVR"),
                        a = this.getAnimationModel().canActivateTAA(),
                        o = 0 === (0, S.Z)().autospin || (0, S.Z)().taaAnimation;
                    return a && t && n && !r && o
                },
                updateFrame: function () {
                    if (this._jitter[2] = -this._jitter[2], this._postProcess.getModel().trigger("pingPongTexture0", this._jitter[2] > 0), !this._isSupersampling) return this._jitter[2] = Math.sign(this._jitter[2]), x.Z._doJitter && this.isTaaJitter() ? (this.updateUniforms(this._frameNumTaa, !0), this._frameNumTaa++) : (this._jitter[0] = 0, this._jitter[1] = 0, this._frameNum = 1, this._frameNumTaa = 0), x.Z._doJitter = !0, !1;
                    x.Z._doJitter = !0;
                    var e = this._frameNum % this._sampleCount;
                    return this.updateUniforms(e), this._frameNum++, this.isSupersampled() && (this._isSupersampling = !1), this._isFakeSupersampling = !1, this._isSupersampling
                },
                getFrameNumber: function () {
                    return this._frameNum % this._sampleCount
                },
                update: function (e, t) {
                    if (!this._switch) return !0;
                    var i = t.getFrameStamp().getFrameNumber();
                    return this._lastUpdateFrame === i || (this._lastUpdateFrame = i, !this._postProcess && (this._postProcess = this._viewer.getFeatures().postProcess, !this._postProcess) || (this.updateFrame() && x.Z.drawSameFrame(), !0))
                },
                isSupersampled: function () {
                    return this._frameNum >= this._sampleCount
                },
                isEnabled: function () {
                    return this._isSupersampling
                },
                isFakeEnabled: function () {
                    return this._isFakeSupersampling
                },
                forceEnable: function () {
                    this._isSupersampling = !0, this._jitter[0] = 0, this._jitter[1] = 0, this._jitter[2] = 2 * Math.sign(this._jitter[2]), this._jitter[3] = 0, this._frameNum = 1, x.Z.drawSameFrame()
                },
                enable: function () {
                    if (!this.canBeEnabled()) return this._isFakeSupersampling || x.Z.drawSameFrame(), void (this._isFakeSupersampling = !0);
                    1 === this._frameNum && this.forceEnable()
                },
                reset: function () {
                    this._jitter[2] = Math.sign(this._jitter[2]), this._frameNum = 1, this._isSupersampling = !1, this._isFakeSupersampling = !1
                },
                setRoot: function (e) {
                    var t = new T.Node;
                    e.addChild(t), t.addUpdateCallback(b.instance)
                }
            });
            const y = b;
            var A = i("CUcOv"),
                R = i("QR/4"),
                w = i("QX1t"),
                E = i("Rdny"),
                P = u.Z.osg,
                N = (0, w.Z)(P.Texture),
                O = ["magFilter", "minFilter", "wrapS", "wrapT", "textureTarget", "internalFormat"],
                D = ["NormalMap", "SubsurfaceScattering", "Opacity", "Displacement", "BumpMap", "AOPBR", "CavityPBR", "MetalnessPBR", "GlossinessPBR", "RoughnessPBR", "SpecularF0", "SpecularHardness"],
                I = function (e) {
                    return Math.max(0, Math.min(1, e))
                },
                F = function (e, t, i) {
                    if (void 0 !== e.factor) {
                        var n = 0,
                            r = 1;
                        i <= 2 && ("Opacity" === t ? "alphaMask" === e.type ? n = .01 : "alphaBlend" === e.type && e.factor >= .99 && (e.factor = 1) : e.factor < .01 && (e.factor = 0)), "BumpMap" === t || "EmitColor" === t ? r = 10 : "SpecularHardness" === t ? r = 1e4 : "Displacement" !== t && "SubsurfaceScattering" !== t || (r = 1e15), e.factor = Math.max(n, Math.min(r, e.factor))
                    }
                    if (e.color)
                        if (D.indexOf(t) >= 0) delete e.color;
                        else {
                            var a = e.color;
                            e.color = P.vec3.fromValues(I(a[0]), I(a[1]), I(a[2]))
                        }
                    void 0 === e.enable && (e.enable = !0);
                    var o = e.texture;
                    if (o) {
                        ! function (e) {
                            e.image && (e.url = e.image, delete e.image);
                            for (var t = 0, i = O.length; t < i; ++t) {
                                var n = O[t];
                                "number" == typeof e[n] && (e[n] = N[e[n]])
                            }
                            void 0 === e.texCoordUnit ? e.texCoordUnit = 0 : "string" == typeof e.texCoordUnit && (e.texCoordUnit = parseInt(e.texCoordUnit, 10)), e.format && delete e.format
                        }(o);
                        var s = E.Z.getPossibleFormat(t);
                        o.internalFormat && 1 !== Object.keys(s).length ? s[o.internalFormat] || (s.ALPHA ? o.internalFormat = "ALPHA" : s.RGB ? o.internalFormat = "RGB" : o.internalFormat = "LUMINANCE") : o.internalFormat = E.Z.getDefaultFormatString(t)
                    }
                };
            const L = function (e) {
                var t = e.channels;
                t.Geometry && (t.NormalMap = t.Geometry, delete t.Geometry), t.Reflection && (void 0 === e.reflection && (e.reflection = t.Reflection.factor), delete t.Reflection), e.cullFace || e.cullFaceMode && (e.cullFace = e.cullFaceMode, delete e.cullFaceMode), e.depthCheckMode && (t.Opacity && !t.Opacity.type && (t.Opacity.type = "alphaBlend"), delete e.depthCheckMode);
                var i = e.version || 0;
                if (t)
                    for (var n in t) F(t[n], n, i)
            };
            var V = i("/c5M"),
                B = u.Z.osg,
                U = function (e, t, i) {
                    return Math.max(t, Math.min(i, e))
                },
                k = function (e, t) {
                    if ("object" == typeof e) {
                        for (var i in t.textLog += " { ", e) {
                            t.textLog += i + ": ";
                            var n = e[i];
                            void 0 !== n ? (k(n, t), t.textLog += ", ") : t.textError += "\n " + i + "=> " + t.textLog.substring(Math.max(0, t.textLog.length - 125), t.textLog.length) + " <= err"
                        }
                        t.textLog += " } "
                    } else t.textLog += JSON.stringify(e)
                },
                Z = function (e, t) {
                    return function (e) {
                        if (e.animation) {
                            var t = e.animation.autoplay;
                            void 0 !== e.animation.autoplay && (e.animation.initializeWithRestPose = !t, delete e.animation.autoplay)
                        }
                    }(e),
                        function (e) {
                            var t = e.camera,
                                i = e.scene;
                            t && i && (i.fov && (t.fov = i.fov, delete i.fov), i.nearFarRatio && (t.nearFarRatio = i.nearFarRatio, delete i.nearFarRatio))
                        }(e),
                        function (e) {
                            if (e.orientation.axis) {
                                var t = e.orientation.axis;
                                t = B.vec3.fromValues(U(t[0], 0, 3), U(t[1], 0, 3), U(t[2], 0, 3)), delete e.orientation.axis, t[0] = (4 - t[0]) % 4, t[1] = (4 - t[1]) % 4, t[2] = (4 - t[2]) % 4, e.orientation.matrix = B.mat4.fromRotation(B.mat4.create(), .5 * Math.PI * (t[0] + t[1] + t[2]), t)
                            }
                        }(e),
                        function (e) {
                            switch (e.shading.type) {
                                case "lit":
                                case "matcap":
                                case "shadeless":
                                    break;
                                case "blending":
                                case "default":
                                case "default-shading":
                                case "predefined-shading":
                                case "shading":
                                case void 0:
                                    e.shading.type = "lit";
                                    break;
                                default:
                                    e.shading.type = "shadeless"
                            }
                            e.shading.vertexColor || "pbr" !== e.shading.renderer || (e.shading.vertexColor = {
                                enable: !1,
                                colorSpace: "linear"
                            })
                        }(e),
                        function (e) {
                            var t = e.environment;
                            void 0 !== t.exposure && (t.exposure *= void 0 !== t.light && t.light > 0 ? t.light : 1);
                            var i = t.backgroundEnable;
                            void 0 !== i && !0 === t.enable ? e.background.enable = !0 === i ? "environment" : !0 === e.background.enable ? "fixed" : "none" : void 0 !== e.background.enable && (!0 === e.background.enable ? e.background.enable = "fixed" : !1 === e.background.enable && (e.background.enable = "none"))
                        }(e),
                        function (e) {
                            var t = e.materials;
                            for (var i in t) {
                                var n = t[i];
                                "object" == typeof n ? void 0 === n.stateSetID ? delete t[n.id] : L(n) : delete t[i]
                            }
                        }(e),
                        function (e) {
                            if (e.lighting.lights)
                                for (var t = e.lighting.lights, i = e.version, n = 0, r = t.length; n < r; ++n) {
                                    var a = t[n];
                                    a.hardness = Math.max(Math.min(a.hardness, 1), 0), (void 0 === a.castShadows || i < 1 && a.attachedToCamera) && (a.castShadows = !1)
                                } else e.lighting = {}
                        }(e),
                        function (e) {
                            var t = e.scene && e.scene.postProcess;
                            if (t) {
                                var i = t.ssao;
                                2 === e.version && t.enable && i && i.enable && 0 === i.bias && 0 === i.radius && (i.ssaoBias = -1, i.ssaoRadius = -1, e.vr.scale = -1);
                                var n = t.vignette;
                                if (n && n.lens) {
                                    var r = n.lens;
                                    n.amount = 1 - .5 * (r[0] + r[1]), n.hardness = 1 - .5 * (r[0] - r[1]), delete n.lens
                                }
                            }
                        }(e),
                        function (e) {
                            var t = e.vr;
                            t && t.scale && (t.worldFactor = t.scale)
                        }(e), t ? e : (0, o.Z)(e, (function (t) {
                            return void 0 === t ? (k(e, i = {
                                textLog: "",
                                textError: ""
                            }), 0 !== i.textError.length && V.Z.client.captureMessage("Invalid CloneDeepWith: " + i.textError), []) : t.byteLength ? Array.prototype.slice.call(t) : void 0;
                            var i
                        }))
                },
                H = function (e) {
                    var t = e.toJSON();
                    return void 0 === e.get("vertexCount") && e.set("vertexCount", t.nbVertexes), void 0 === e.get("faceCount") && e.set("faceCount", t.nbTriangles), void 0 === t.options && (t.options = {}), e.set("options", Z(t.options, !0)), e.set("files", t.files), e
                };
            H.readOptions = Z;
            const G = H;
            var z = i("kghU"),
                W = i("wgEG"),
                j = i("rEmB"),
                X = i("aMVL"),
                Y = i("jXe1"),
                J = u.Z.osg,
                q = u.Z.osgUtil.NodeGizmo,
                K = function () {
                    q.apply(this, arguments), this._forcePicking = !1
                };
            J.createPrototypeNode(K, J.objectInherit(q.prototype, {
                setForcePicking: function (e) {
                    this._forcePicking = e
                },
                onMouseUp: function (e) {
                    this.isEditing() && x.Z.draw();
                    var t = this._attachedNode;
                    q.prototype.onMouseUp.call(this, e), t !== this._attachedNode && x.Z.draw(), this._forcePicking && !this._attachedNode && (this._attachedNode = t)
                },
                onMouseMove: function (e) {
                    var t = this._hoverNode;
                    q.prototype.onMouseMove.call(this, e), this.isEditing() && x.Z.redrawShadow(), (this.isEditing() || t !== this._hoverNode) && x.Z.draw()
                }
            }), "osgtestdemo2024", "NodeGizmo");
            const Q = K;
            var $ = i("Hjnd"),
                ee = i.n($),
                te = i("4rHk"),
                ie = i("G1IL"),
                ne = i("JbUU"),
                re = i("JBIs"),
                ae = i("4EEe"),
                oe = i("Lz+S"),
                se = u.Z.osg,
                le = u.Z.osgAnimation,
                ue = u.Z.osgUtil,
                ce = function () {
                    se.NodeVisitor.call(this, se.NodeVisitor.TRAVERSE_PARENTS), this._paths = [], this._halt = void 0
                };
            se.createPrototypeObject(ce, se.objectInherit(se.NodeVisitor.prototype, {
                reset: function () {
                    se.NodeVisitor.prototype.reset.call(this), this._paths.length = 0
                },
                setHalt: function (e) {
                    this._halt = e
                },
                apply: function (e) {
                    e === this._halt && this._paths.push(this.nodePath.slice(1)), this.traverse(e)
                }
            }));
            var he = function (e) {
                se.NodeVisitor.call(this), this._cullCallback = e ? void 0 : ie.Z.hideCullCallback
            };
            se.createPrototypeObject(he, se.objectInherit(se.NodeVisitor.prototype, {
                apply: function (e) {
                    e instanceof se.Geometry && e._isBoneBox && e.setCullCallback(this._cullCallback), this.traverse(e)
                }
            }));
            var de = function (e, t) {
                var i, n;
                this._fManager = e, this._viewerWebGL = e.getViewerWebGL(), this._rootModel = this._viewerWebGL.getRootModel(), this._rootFeature = t, this._debugNormal = !1, this._debugTangent = !1, this._debugScale = .5, this._baseScale = .07 * this._rootModel.getMinimumBound().radius(), this._normalVisitor = new ue.DisplayNormalVisitor, this._normalVisitor.setScale(this._baseScale * this._debugScale), this._geoColorVisitor = new ue.DisplayGeometryVisitor, this._geoColorVisitor._stCenter.setRenderBinDetails(te.Z.DEBUG_2, "RenderBin"), this._geoColorVisitor._stCenter.setAttribute(new re.Z(!0)), this._debugGeometry = !1, this._debugShadow = !1, this._useGizmo = !1, this._useSync = !1, this._protoUpdateWeights = le.UpdateMorph.prototype.updateWeights, this._protoComputeChannels = le.UpdateMatrixTransform.prototype.computeChannels, this._enableRig = !0, this._collectPathVisitor = new ce, this._collectPathVisitor.setHalt(this._fManager.getWorldNode()), this._showBoneBoxes = !1, this._graphVisitor = ue.DisplayGraph.instance(), i = this._graphVisitor, n = (0, w.Z)(te.Z), i._graphRender.generateRenderBin = function (e, t) {
                    var i = t.className() + " ( " + t.getInstanceID() + " )";
                    t.getName() && (i += "\n" + t.getName());
                    var r = t.getBinNumber();
                    i += "\n" + n[r] || 0, this._selectables.set(t.getInstanceID().toString(), t), e.addNode(t.getInstanceID(), {
                        label: i,
                        description: "",
                        style: "fill: " + this.getColorFromClassName(t.className()) + ";stroke-width: 0px;"
                    })
                }, this._debugGraphNode = "Model", this._debugGraphRenderer = !1, this._displayGraph = !1;
                var r = this._fManager.getFeatures().camera.getModel();
                this._enabledConstraints = r.get("enableCameraConstraints"), this._showConstraintsWidget = !1, ae.Z.initDebug3D(this)
            };
            de.prototype = {
                _getSaveAElement: function () {
                    return this._aSave || (this._aSave = document.createElement("a"), document.body.appendChild(this._aSave), this._aSave.style.display = "none"), this._aSave
                },
                _download: function (e, t) {
                    var i = this._fManager._context.getModel("uid").get("uid") + "_";
                    i += (new Date).toString().split(" ").splice(1, 4).join("_").replace(/:/g, "_"), i += ".";
                    var n = this._getSaveAElement();
                    n.href = e, n.download = i + t, n.click()
                },
                _getCameraModel: function () {
                    return this._fManager.getFeatures().camera.getModel()
                },
                onTakeScreenShot: function () {
                    (0, v.Z)(2048, 2048, this._viewerWebGL).toBlob(function (e) {
                        this._download(URL.createObjectURL(e), "png")
                    }.bind(this), "png", 1)
                },
                onStartMovieRecord: function () {
                    var e = document.getElementsByClassName("canvas")[0].captureStream(25);
                    this._recorder = new window.MediaRecorder(e, {
                        mimeType: "video/webm; codecs=vp9"
                    });
                    var t = [],
                        i = function (e) {
                            var t = window.URL.createObjectURL(e);
                            this._download(t, "webm")
                        }.bind(this);
                    this._recorder.ondataavailable = function (e) {
                        e.data && e.data.size > 0 && t.push(e.data)
                    }, this._recorder.onstop = function () {
                        i(new Blob(t, {
                            type: "video/webm"
                        }))
                    }.bind(this), this._recorder.start()
                },
                onEndMovieRecord: function () {
                    this._recorder && this._recorder.stop()
                },
                onTrianglePick: function (e) {
                    if (!this._displayGraph) {
                        var t = ne.Z.computeNearestIntersection2D(e.canvasX, e.canvasY);
                        if (t) {
                            window.hit = t;
                            var i = t._nodePath[t._nodePath.length - 1];
                            console.log("Active hit : window.hit"), console.log("Name geometry : " + i.getName()), console.log("Vertex indices : " + t._i1 + ", " + t._i2 + ", " + t._i3), console.log("Unique id : " + i._uniqueID);
                            var n = {};
                            n[t._i1] = {}, n[t._i2] = {}, n[t._i3] = {};
                            var r = i.getVertexAttributeList();
                            for (var a in n) {
                                var o = n[a];
                                for (var s in a = parseInt(a), r)
                                    for (var l = r[s], u = l.getItemSize(), c = l.getElements(), h = o[s] = [], d = 0; d < u; ++d) h[d] = c[a * u + d]
                            }
                            t.verts = n, console.log("\n")
                        }
                    }
                },
                onDebugScale: function (e) {
                    this._normalVisitor.setScale(this._baseScale * e), x.Z.draw()
                },
                onDebugNormal: function (e) {
                    this._normalVisitor.setNormalVisibility(e, this._rootModel), x.Z.draw()
                },
                onDebugTangent: function (e) {
                    this._normalVisitor.setTangentVisibility(e, this._rootModel), x.Z.draw()
                },
                onDebugGeometry: function () {
                    this._debugGeometry ? this._geoColorVisitor.setGeometryDebug(this._rootModel) : this._geoColorVisitor.disableDebug(this._rootModel), x.Z.draw()
                },
                onEnableCamConstraints: function () {
                    var e = this._getCameraModel();
                    e.set("enableCameraConstraints", !e.get("enableCameraConstraints"))
                },
                onShowConstraintsWidget: function () {
                    var e = this._getCameraModel();
                    e.set("displayGizmo", !e.get("displayGizmo")), e.trigger("refreshConstraints"), x.Z.draw()
                },
                resetGraph: function () {
                    this._viewerWebGL.getInputManager().setEnable(oe.Z.DEBUG_GEOMPICK, !1), this._graphVisitor.reset()
                },
                onDisplayGraph: function () {
                    this.resetGraph(), this._displayGraph && (this._viewerWebGL.getInputManager().setEnable(oe.Z.DEBUG_GEOMPICK, !0), X.Z.getModelDisplayed().then(this.createDebugGraph.bind(this)))
                },
                createDebugGraph: function () {
                    var e;
                    "Model" === this._debugGraphNode ? e = this._rootModel : "Feature" === this._debugGraphNode && (e = this._rootFeature), this._graphVisitor.setDisplayGraphRenderer(this._debugGraphRenderer), this._graphVisitor.createGraph(e), this._graphVisitor.setCallbackSelect(this.onNodeSelect.bind(this)), x.Z.draw()
                },
                onDebugShadow: function (e) {
                    var t = this._fManager.getFeatures().lighting;
                    if (t) {
                        t.getModel().set("forceShadowRedraw", e);
                        for (var i = t.getModel().get("lights"), n = 0, r = i.length; n < r; ++n) {
                            var a = i[n];
                            a.getShadowMap() && (a.getShadowMap().setDebug(e), a.dirty())
                        }
                        x.Z.draw()
                    }
                },
                onPickSelect: function (e) {
                    var t = this._fManager.getWorldNode(),
                        i = ne.Z.computeNearestIntersection2D(e.glX, e.glY, void 0, t);
                    i && (this._graphVisitor.selectNode(i._nodePath[i._nodePath.length - 1]), this._graphVisitor.focusOnGraph())
                },
                onNodeSelect: function (e) {
                    if (e instanceof se.StateSet) {
                        var t = this._fManager.getFeatures().outline.getModel();
                        return t.set("durationOutline", 5), t.set("durationHighlight", 2.5), void t.trigger("displayOutlineFocus", e, 5, 2.5)
                    }
                    for (var i = e.getBoundingBox(), n = e.getWorldMatrices(this._fManager.getWorldNode()), r = new se.BoundingBox, a = 0; a < n.length; ++a) {
                        var o = new se.BoundingBox;
                        i.transformMat4(o, n[a]), r.expandByBoundingBox(o)
                    }
                    this._fManager.focusOnBound(r, 1), this._collectPathVisitor.reset(), e.accept(this._collectPathVisitor);
                    var s = this._collectPathVisitor._paths,
                        l = this._fManager.getFeatures().outline.getNode();
                    l.clearOutlineScene(), l.addPaths(s), l.showOutline()
                },
                _getCameraUrl: function () {
                    var e = se.vec3.create(),
                        t = se.vec3.create();
                    this._fManager.getCameraWithoutAutospin(e, t);
                    var i = window.location.href;
                    return i += "&camera_eye=" + e.join(",") + "&camera_target=" + t.join(",")
                },
                cameraClipboard: function () {
                    var e = this._getCameraUrl(),
                        t = document.createTextNode(e);
                    document.body.appendChild(t);
                    var i = document.createRange();
                    i.selectNode(t), window.getSelection().removeAllRanges(), window.getSelection().addRange(i), document.execCommand("copy"), document.body.removeChild(t)
                },
                cameraOpen: function () {
                    window.open(this._getCameraUrl())
                },
                onEnableRig: function (e) {
                    le.UpdateMatrixTransform.prototype.computeChannels = e ? this._protoComputeChannels : function () {
                        this._dirty = !0;
                        var e = this._matrix;
                        se.mat4.identity(e);
                        for (var t = this._stackedTransforms, i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.resetToDefaultValue(), r.applyToMatrix(e)
                        }
                    }, x.Z.draw()
                },
                onShowBoneBoxes: function (e) {
                    this._rootModel.accept(new he(e)), x.Z.draw()
                },
                onUseGizmo: function (e) {
                    this._gizmo || (this._gizmo = new Q(this._fManager.getViewerOSGJS()), this._rootFeature.addChild(this._gizmo)), this._gizmo.attachToNode(null), this._gizmo.setAutoMatrixTransformInsertion(e), this._gizmo.setCorrectPivotOnAutoInsert(e), this._gizmo.setTraversalMask(e ? 1 : 0), x.Z.draw()
                }
            };
            var ge = function (e, t, i) {
                var n, r = e.addFolder("Animation");
                return i._useRig = r.add(t, "_enableRig").name("Use rig"), i._useRig.onChange(t.onEnableRig.bind(t)), n = le.UpdateMorph.prototype.updateWeights, le.UpdateMorph.prototype.updateWeights = function () {
                    if (void 0 !== this._debugActiveTarget) {
                        var e = parseInt(this._debugActiveTarget, 0);
                        if (-2 === e) {
                            var t = this._weights;
                            return void (t[0] = t[1] = t[2] = t[3] = 0)
                        }
                        if (-1 !== e)
                            for (var i = this._targets, r = 0, a = i.length; r < a; ++r) i[r].value = r === e ? 1 : 0
                    }
                    return n.call(this)
                },
                    function (e, t) {
                        var i = function () {
                            se.NodeVisitor.call(this, se.NodeVisitor.TRAVERSE_ALL_CHILDREN)
                        };
                        se.createPrototypeObject(i, se.objectInherit(se.NodeVisitor.prototype, {
                            apply: function (t) {
                                for (var i = t.getUpdateCallbackList(), n = 0, r = i.length; n < r; ++n) {
                                    var a = i[n];
                                    if (a instanceof le.UpdateMorph) {
                                        for (var o = {
                                            ___DEFAULT: -1,
                                            "___NO MORPH": -2
                                        }, s = a._targetNames, l = 0, u = s.length; l < u; ++l) o[s[l]] = l;
                                        a._debugActiveTarget = -1, e.add(a, "_debugActiveTarget", o).name("Name " + a.getName()).onChange(x.Z.draw)
                                    }
                                }
                                this.traverse(t)
                            }
                        }));
                        var n = new i;
                        t._rootModel.accept(n)
                    }(r, t), i._showBoxes = r.add(t, "_showBoneBoxes").name("Show boxes"), i._showBoxes.onChange(t.onShowBoneBoxes.bind(t)), r.open(), r
            },
                fe = function (e) {
                    var t = new window.dat.GUI;
                    t.domElement.style.paddingTop = "50px";
                    var i = new de(this, e),
                        n = {};
                    ! function (e, t, i) {
                        var n = e.addFolder("Debug graph");
                        i._graphNode = n.add(t, "_debugGraphNode", {
                            Model: "Model",
                            Feature: "Feature",
                            None: "None"
                        }).name("Root"), i._graphNode.onChange(t.onDisplayGraph.bind(t)), i._graphRenderer = n.add(t, "_debugGraphRenderer").name("Renderer"), i._graphRenderer.onChange(t.onDisplayGraph.bind(t)), i._displayGraph = n.add(t, "_displayGraph").name("Display graph"), i._displayGraph.onChange(t.onDisplayGraph.bind(t)), n.open()
                    }(t, i, n),
                        function (e, t, i) {
                            var n = e.addFolder("Display vectors");
                            i._showNormal = n.add(t, "_debugNormal").name("Display normal"), i._showNormal.onChange(t.onDebugNormal.bind(t)), i._showTangent = n.add(t, "_debugTangent").name("Display tangent"), i._showTangent.onChange(t.onDebugTangent.bind(t)), i._vectorScale = n.add(t, "_debugScale").min(0).max(2).name("Scale vectors"), i._vectorScale.onChange(t.onDebugScale.bind(t)), n.open()
                        }(t, i, n), ge(t, i, n),
                        function (e, t, i) {
                            var n = e.addFolder("Camera");
                            i._enableConstraints = n.add(t, "_enabledConstraints").name("Constraints"), i._enableConstraints.onChange(t.onEnableCamConstraints.bind(t)), i._showConstraintsWidget = n.add(t, "_showConstraintsWidget").name("Show widget"), i._showConstraintsWidget.onChange(t.onShowConstraintsWidget.bind(t)), i._cameraClipboard = n.add(t, "cameraClipboard").name("Copy clipboard"), i._cameraOpen = n.add(t, "cameraOpen").name("Open new tab"), n.open()
                        }(t, i, n),
                        function (e, t, i) {
                            var n = e.addFolder("Misc");
                            i._showGeometry = n.add(t, "_debugGeometry").name("Display geometry"), i._showGeometry.onChange(t.onDebugGeometry.bind(t)), i._gizmo = n.add(t, "_useGizmo").name("Use gizmo"), i._gizmo.onChange(t.onUseGizmo.bind(t)), n.add(t, "_debugShadow").name("Debug Shadow").onChange(t.onDebugShadow.bind(t)), n.add({
                                ScreenShot: t.onTakeScreenShot.bind(t)
                            }, "ScreenShot"), n.add({
                                StartRec: t.onStartMovieRecord.bind(t)
                            }, "StartRec"), n.add({
                                StopRec: t.onEndMovieRecord.bind(t)
                            }, "StopRec"), n.open()
                        }(t, i, n)
                };
            const me = function (e, t) {
                var i = fe.bind(e, t);
                ee().getScript("https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js").done(i)
            };
            var pe, ve, _e, Se, xe, Ce, Te, Me = i("gvzH"),
                be = i("ng3c"),
                ye = i("z1JG"),
                Ae = i("o2b8"),
                Re = i("pXO4"),
                we = i("FGWR"),
                Ee = i("YBVK"),
                Pe = i("XkCy"),
                Ne = i("vcih"),
                Oe = i("uyWM"),
                De = i("Ygw6"),
                Ie = u.Z.osg,
                Fe = function (e, t) {
                    this._viewerWebGL = e, this._viewerOSGJS = e.getViewerOSGJS(), this._urlOptions = e.options, this._features = e.getFeatures(), this._context = t, this._canvas = e.getCanvas(), this._nodeGizmo = null, (0, Oe.gN)(this)
                };
            Fe.prototype = {
                getFeatures: function () {
                    return this._features
                },
                getCanvas: function () {
                    return this._canvas
                },
                getViewerWebGL: function () {
                    return this._viewerWebGL
                },
                getViewerOSGJS: function () {
                    return this._viewerOSGJS
                },
                getRootModel: function () {
                    return this._viewerWebGL.getRootModel()
                },
                getWorldNode: function () {
                    return this._features.autospin.getNode()
                },
                getTextureDepth: function () {
                    return this._features.postProcess.getCamera()._textureDepth
                },
                getViewport3d: function () {
                    return this._features.postProcess.getCamera().getViewport()
                },
                getIconScaleFov: function (e) {
                    e || (e = this._viewerOSGJS.getCamera().getProjectionMatrix());
                    var t = Math.sqrt(e[0] * e[0] + e[4] * e[4] + e[8] * e[8]);
                    return .02 * this.getViewport3d().width() * t / we.Z.getPixelRatio()[0]
                },
                getResourceManager: function () {
                    return this._resourceManager || A.Z.instance
                },
                getCurrentTabName: function () {
                    if (this._urlOptions.widgetAPI) return this._urlOptions.widgetAPI.getTabbedWidget().get()
                },
                getTargetAndEyeFocusFromBound: function (e, t, i) {
                    if (!e.valid()) return !1;
                    var n = this._viewerOSGJS.getManipulator(),
                        r = n.getCurrentManipulator().getHomeBoundingSphere();
                    r.volume() < e.volume() && (e = r), Ie.vec3.copy(t, e.center(t));
                    var a = n.getHomeDistance(e);
                    return n.getEyePosition(i), Ie.vec3.sub(i, t, i), i[2] = 0, Ie.vec3.normalize(i, i), Ie.vec3.scale(i, i, a), Ie.vec3.sub(i, t, i), !0
                },
                focusOnBound: (Ce = Ie.vec3.create(), Te = Ie.vec3.create(), function (e, t, i) {
                    return !!this.getTargetAndEyeFocusFromBound(e, Ce, Te) && this.focusOnTargetAndEye(Ce, Te, t, i)
                }),
                focusOnTargetAndEye: (xe = Ie.vec3.create(), function (e, t, i, n) {
                    var r = this._features.camera;
                    if (!r) return !1;
                    var a = this._viewerOSGJS.getManipulator();
                    if (!i || i < 0) return a.setTargetAndEye(e, t), !0;
                    var o = r.getModel();
                    return e || (e = a.getTarget(xe)), t || (t = a.getEyePosition(xe)), o.setTargetAndEye(e, t, n), o.set("animationDuration", i), !0
                }),
                focusOnHomePosition: function (e) {
                    var t = this._features.camera;
                    if (t && t.getModel()) {
                        var i = t.getManipulator().getCurrentManipulator(),
                            n = i.getHomeBoundingSphere(),
                            r = n.center(),
                            a = i.getEyePosition(Ie.vec3.create());
                        Ie.vec3.sub(a, r, a), Ie.vec3.normalize(a, a), Ie.vec3.scale(a, a, i.getHomeDistance(n)), Ie.vec3.sub(a, r, a), this.focusOnTargetAndEye(r, a, e)
                    }
                },
                focusOnSavedCamera: function (e) {
                    var t = this._context.getModel().get("options"),
                        i = (0, S.Z)(),
                        n = this._viewerOSGJS.getManipulator(),
                        r = i.cameraTarget || t.camera.target,
                        a = i.cameraEye || t.camera.position,
                        o = a && null !== a[0];
                    return o ? o && !this._features.camera.getModel().validateEyeTarget(a, r) ? n.computeHomePosition() : void this.focusOnTargetAndEye(r, a, e) : n.computeHomePosition()
                },
                updateFocusOnAutoHit: function () {
                    if (!this._autoHit.get("focus")) return !0;
                    var e = (0, Oe.kR)(this._autoHit),
                        t = this._features.camera.getManipulator().getCurrentManipulator(),
                        i = t.getEyePosition(Ie.vec3.create()),
                        n = t.getTarget(Ie.vec3.create()),
                        r = Ie.vec3.create(),
                        a = Ie.vec3.create();
                    return 1 === (0, S.Z)().cameraFollowBones ? (Ie.vec3.sub(a, e, n), Ie.vec3.add(r, i, a), Ie.vec3.copy(a, e)) : (Ie.vec3.sub(r, e, i), Ie.vec3.normalize(r, r), Ie.vec3.scale(r, r, Ie.vec3.dist(i, n)), Ie.vec3.sub(r, e, r), Ie.vec3.copy(a, e)), Ie.vec3.lerp(a, n, a, .25), Ie.vec3.lerp(r, i, r, .25), this.focusOnTargetAndEye(a, r, 0), !0
                },
                setInitialAnimation: function () {
                    if (this._features.camera.getModel().shouldPlayFirstCameraAnimation()) {
                        var e = Ie.vec3.create(),
                            t = Ie.vec3.create(),
                            i = this._viewerOSGJS.getManipulator();
                        i.getEyePosition(t), i.getTarget(e);
                        var n = [e[0] - t[0], e[1] - t[1], 0],
                            r = n[0] > n[1] ? 0 : 1,
                            a = 0 === r ? 1 : 0,
                            o = Ie.vec3.create();
                        o[a] = 1;
                        var s = n[r] < 0 ? -1 : 1;
                        o[2] = .2 * s;
                        var l = 1.5 * Pe.Z.getModelBoxWithDisplacement().radius();
                        Ie.vec3.scale(o, o, 10 * l * s);
                        var u = Ie.vec3.add(Ie.vec3.create(), t, o);
                        i.setEyePosition(u), this.focusOnTargetAndEye(e, t, 2.5);
                        var c = this._features.autospin.getModel();
                        c.set("speed", -c.get("speed") * s)
                    } else X.Z.resolveFirstCameraAnimation()
                },
                focusOnHit: function (e, t, i) {
                    var n = Ie.vec3.create();
                    ne.Z.getWorldPositionFromHit(e, n);
                    var r = this._features.camera.getManipulator().getCurrentManipulator(),
                        a = r.getEyePosition(Ie.vec3.create()),
                        o = i * r.getHomeDistance(r.getHomeBoundingSphere());
                    Ie.vec3.dist(n, a) > o && (Ie.vec3.sub(a, n, a), Ie.vec3.normalize(a, a), Ie.vec3.scale(a, a, o), Ie.vec3.sub(a, n, a)), this.focusOnTargetAndEye(n, a, t, !0)
                },
                _focusDof: function (e, t) {
                    var i = this._features.postProcess.getModel();
                    ne.Z.getPixelDepth(e, t, (function (e, t, n) {
                        if (!(e < 0 || e >= 1)) {
                            var r = i.get("dofFocusPoint");
                            ne.Z.getWorldPositionFromDepthXY(e, t, n, r), i.trigger("change:dofFocusPoint", r)
                        }
                    }))
                },
                onSingleClick: (ve = Ie.vec3.create(), _e = Ie.vec3.create(), Se = Ie.vec2.create(), function (e) {
                    var t = e.canvasX,
                        i = e.canvasY,
                        n = this._features.postProcess.getModel();
                    n.get("enable") && n.get("dofEnable") && this._focusDof(e.glX, e.glY);
                    var r = "materials" === this.getCurrentTabName(),
                        a = "split" === this._features.inspector.getModel().get("splitType") || r,
                        o = this._viewerWebGL.getViewerAPI(),
                        s = o && o.intersectPoint || a,
                        l = this._features.ARKit.getModel();
                    if (l.get("enable") && l.trigger("pick", Ie.vec2.fromValues(t, i)), s) {
                        var u = ne.Z.computeNearestIntersection2D(t, i);
                        if (a && this._singleClickOnInspector(u), u) {
                            var c = _e,
                                h = o && o.intersectPoint ? ve : void 0;
                            ne.Z.getWorldPositionFromHit(u, c, h), o && o.intersectPoint && (Se[0] = t, Se[1] = i, o.intersectPoint(u, c, Se, h))
                        }
                    }
                }),
                _singleClickOnInspector: function (e) {
                    var t = e && ne.Z.getMaterialFromHit(e);
                    if (t) {
                        var i = this._features.inspector.getModel(),
                            n = t.get("id");
                        i.get("material") === n ? i.trigger("change:material", i, n) : i.set("material", n)
                    } else this._features.outline.getModel().trigger("hideOutline")
                },
                onDoubleClick: function (e) {
                    if ((0, S.Z)().doubleClick) {
                        var t = this._features.camera;
                        if (!t.getModel().get("webVR") && t.canMoveTarget())
                            if (this._autoHit && this._autoHit.get("focus") && this._autoHit.set("focus", !1), e.pointers && e.pointers.length > 1) this.focusOnHomePosition(1);
                            else {
                                var i = ne.Z.computeNearestIntersection2D(e.canvasX, e.canvasY);
                                if (i) {
                                    var n = this.getCurrentTabName();
                                    "virtual reality and augmented reality" !== n ? "annotations" !== n && "sound" !== n && ((0, S.Z)().cameraFollowBones && (0, Y.Z)(i._nodePath) ? ((0, Oe.hP)(this._autoHit, i), this._autoHit.set("focus", !0)) : (this._features.outline.getModel().trigger("clearFocusTimeout"), this.focusOnHit(i, 1, .2))) : this._features.webVR.getModel().trigger("doubleTap", i)
                                } else this.focusOnHomePosition(1)
                            }
                    }
                },
                preloadMaxBackground: function () {
                    var e = this._features.background;
                    if (e) {
                        var t = e.getModel();
                        if (t && "fixed" === t.get("enable")) {
                            var i = t.getBackground();
                            if (i) {
                                var n = i.findImageNearestUpToResolution(window.screen.width, window.screen.height);
                                n && this.getResourceManager().getOrCreateTexture(n.url, {
                                    minFilter: Ie.Texture.LINEAR,
                                    magFilter: Ie.Texture.LINEAR,
                                    transferToGPU: !1,
                                    convertNPOT: !1,
                                    internalFormat: Ie.Texture.RGB
                                })
                            }
                        }
                    }
                },
                applyAutospinToCamera: function (e, t) {
                    var i = this._features.autospin;
                    if (i) {
                        var n = i.getNode().getMatrix();
                        Ie.vec3.transformMat4(e, e, n), Ie.vec3.transformMat4(t, t, n)
                    }
                },
                getCameraWithoutAutospin: (pe = Ie.mat4.create(), function (e, t) {
                    var i = this._features.autospin;
                    if (i) {
                        var n = this._viewerOSGJS.getManipulator();
                        n.getEyePosition(e), n.getTarget(t), Ie.mat4.invert(pe, i.getNode().getMatrix()), Ie.vec3.transformMat4(e, e, pe), Ie.vec3.transformMat4(t, t, pe)
                    }
                }),
                createGizmoNode: function () {
                    var e = new Ie.Camera;
                    e.getOrCreateStateSet().setRenderBinDetails(te.Z.EDITOR_GIZMO, "RenderBin");
                    var t = this._nodeGizmo = new Q(this._viewerOSGJS);
                    t.setTraversalMask(Me.Z.PICK_GIZMO_LIGHT), e.addChild(t);
                    var i = this._urlOptions.widgetAPI;
                    if (i) {
                        var n = this._features.orientation;
                        i.getTabbedWidget().model.on("change:value", (function () {
                            t.attachToNode(null), n && n.getModel().set("showGizmo", !1)
                        }))
                    }
                    return e
                },
                setManipulatorNode: function (e) {
                    this._features.camera ? this._features.camera.getModel().set("node", e) : this._viewerOSGJS.getManipulator().setNode(e)
                },
                getNodeGizmo: function () {
                    return this._nodeGizmo
                },
                initializePreciseBoundManager: function () {
                    var e = this._features.orientation.getNode();
                    Pe.Z.computePreciseBox(e);
                    var t = Pe.Z.getModelBoxWithDisplacement();
                    e.getBoundingBox().copy(t);
                    var i = e.getBoundingSphere();
                    i.set(t.center(i.center()), t.radius()), ne.Z.init(this._context, this.getRootModel())
                },
                initGraph: function (e) {
                    var t = this._features,
                        i = new Ie.Node;
                    i.getOrCreateStateSet().setAttributeAndModes(De.Z.CULL_DISABLE), i.setName("FeatureManager - Root"), i.addChild(Re.Z), Re.Z.initReadyForHighResBound();
                    var n = t.orientation,
                        r = t.autospin,
                        a = t.outline,
                        o = t.ground,
                        s = t.environment,
                        l = t.lighting,
                        u = t.camera,
                        c = t.sound,
                        h = t.hotspot,
                        d = t.postProcess,
                        g = t.webVR,
                        f = t.ARKit,
                        m = t.inspector,
                        p = l.getNodeShadow(),
                        v = i;
                    d && (i.addChild(d.getNodeIn()), v = d.getNodeOut()), v.addChild(this.createGizmoNode(v)), v.addChild(p), v = p;
                    for (var _ = [u, s, l, c, g, h, m, a, r, f, o, n], S = 0, x = _.length; S < x; ++S) {
                        var C = _[S];
                        if (C) {
                            var T = C.getNodeIn ? C.getNodeIn() : C.getNode(),
                                M = C.getNodeOut ? C.getNodeOut() : C.getNode();
                            v.addChild(T), v = M
                        }
                    }
                    return v.addChild(e), i
                },
                addGlobalUniforms: function () {
                    var e = this._features.postProcess.getNodeIn().getOrCreateStateSet();
                    for (var t in C.Z) e.addUniform(C.Z[t])
                },
                finished: function (e) {
                    var t = this._features,
                        i = this.getRootModel();
                    i.setNodeMask(Me.Z.PICK_GEOMETRY_SHADOW), i.setName("Scene - RootModel"), _.Z.nodeRootModel = i;
                    var n = this._viewerOSGJS.getCamera();
                    Ne.Z.setCamera(n), i.addUpdateCallback(Ne.Z);
                    var r = this.initGraph(i);
                    e.addChild(r), this.setManipulatorNode(this._features.orientation.getNode()), this.preloadMaxBackground();
                    var a = t.lighting;
                    a && a.getModel().initLights(t.material.getSceneLights());
                    var o = t.environment;
                    o && o.getNode().init(n, a.getNodeShadow());
                    if (window.testdemo2024ViewerStats.shadows > 1 && Ie.WebGLCaps.instance().getWebGLParameter("MAX_FRAGMENT_UNIFORM_VECTORS") < 65)
                        for (var s = a.getModel().get("lights"), l = window.testdemo2024ViewerStats.shadows - 1, u = 0; u < 3 && 0 !== l; u++) {
                            var c = s[u];
                            c.get("enable") && c.isCastingShadows() && (c._enableShadow = !1, l--)
                        }
                    return we.Z.init(this._canvas, this._features.quality.getModel(), this._viewerOSGJS.getCanvasPixelRatio()), this.focusOnSavedCamera(), this._features.camera && this._features.camera.getModel().saveCameraPosition(), ae.Z.initGlobalClickEvents(this, this._canvas), this._viewerOSGJS.getInputManager().setEnable("global_click_events", !0), i.getOrCreateStateSet().setAttribute(new re.Z), (0, S.Z)().zz ? (i.accept(new Ae.Z), X.Z.getWireframeOptimizedSplit().then((function () {
                        i.accept(new Ae.Z), X.Z.resolveWireframeOptimizedSplitCompressed()
                    }))) : X.Z.getWireframeOptimizedSplit().then(X.Z.resolveWireframeOptimizedSplitCompressed), this.addGlobalUniforms(), Ie.time("drawFirstFrame"), this._viewerWebGL.drawFrame(), Ie.timeEnd("drawFirstFrame"), this.initializePreciseBoundManager(), t.webVR && t.webVR.getModel().initAfterFirstFrame(), t.postProcess && t.postProcess.getModel().initAfterFirstFrame(), t.camera && t.camera.getModel().initAfterFirstFrame(), t.lighting && t.lighting.getModel().set("forceShadowRedraw", !0), Ie.time("drawSecondFrame"), this._viewerWebGL.drawFrame(), Ie.timeEnd("drawSecondFrame"), t.lighting && t.lighting.getModel().set("forceShadowRedraw", !1), (0, g.Z)() && (X.Z.getFirstAnimation().then(function () {
                        this.registerOptionsJSON(this._viewerWebGL.getOptionsJSON())
                    }.bind(this)), window.addEventListener("beforeunload", this.onBeforeUnload.bind(this), !1)), !(0, ye.Z)() && "onhashchange" in window && window.addEventListener("hashchange", this._hashChanged.bind(this), !1), (0, S.Z)().debug3D && me(this, r), (0, S.Z)().cameraFollowBones && (this._autoHit = new Ee.Z, r.addUpdateCallback({
                        update: this.updateFocusOnAutoHit.bind(this)
                    })), r
                },
                _registerCollection: function (e) {
                    e.each((function (e) {
                        e.registerOptions()
                    }))
                },
                registerOptionsJSON: function (e) {
                    this._lastOptions = (0, z.Z)(e);
                    var t = this._features;
                    this._registerCollection(t.animation.getModel().get("animations")), this._registerCollection(t.hotspot.getModel().get("hotspots"))
                },
                getUnsavedChanges: function () {
                    var e = this._viewerWebGL.getOptionsJSON();
                    return (0, W.Z)(this._lastOptions, (function (t, i, n) {
                        return (0, j.Z)(i, e[n]) ? t : t.concat(n)
                    }), [])
                },
                getUnsavedMessage: function () {
                    var e = this.getUnsavedChanges();
                    if (0 !== e.length) {
                        var t = "You have unsaved changes:\n";
                        return t += "- " + e.join("\n- "), t += "\n\nYou might want to save your changes before leaving."
                    }
                },
                onBeforeUnload: function (e) {
                    var t = this.getUnsavedMessage();
                    return t && (e.returnValue = t), t
                },
                _hashChanged: function () {
                    var e = {};
                    e = (0, be.Z)(e), this._features.material.getModel().overrideMaterialChannels(e);
                    var t = (0, S.Z)();
                    !t.debug3D && Boolean(e.debug3D) && (t.debug3D = !0, me(this, this.getRootModel())), !t.stats && Boolean(e.stats) && (t.continuousRender = !0, t.stats = !0, this._viewerOSGJS.initStats({
                        getBoolean: function (e) {
                            return "stats" === e
                        }
                    })), this._features.inspector.getModel().set("uiVisible", Boolean(e.inspector))
                },
                getShadowForcedUpdate: function () {
                    return !!(0, S.Z)().shadow && (!!x.Z.getShadowForcedUpdate() || (!!this._viewerWebGL.getSuperSample().isEnabled() || (!!this._features.lighting.getModel().get("forceShadowRedraw") || (!!this._features.autospin.getModel().get("enable") || !!this._features.animation.getModel().isPlaying()))))
                }
            };
            const Le = Fe;
            var Ve = i("WvFz"),
                Be = i("WoEt"),
                Ue = i("KXnA"),
                ke = i("R2Pi"),
                Ze = u.Z.osg,
                He = u.Z.osgShader.shaderProcessor,
                Ge = Math.random(),
                ze = function (e, t) {
                    this._vertDefines = [], this._fragDefines = [], this._vertAssignUV = [], this._envBrdf, this._envSpecular, this._compression, this._material, this._skinning, this._morphing, this._pointSize, this._lights = [], this._shadows = [], this._shadowsTextures = [], this._targetByUnit = [], this.initAttributes(e), this.initTextureAttributes(t);
                    var i = this._material ? this._material.getMaterialModel() : void 0;
                    // this._channels = i ? i.getChannels() : void 0, ke.default.apple.device ? (this._vertDefines.push("#define IS_IOS"), this._vertDefines.push("#define NEED_INVARIANT")) : (navigator ? .userAgentData ? .platform || navigator ? .platform || "").toUpperCase().indexOf("MAC") >= 0 && this._vertDefines.push("#define NEED_INVARIANT"), this.defineShaderName(), this.initDefines()
                    // Initialize _channels based on the condition
                    this._channels = i ? i.getChannels() : undefined;

                    // Check if the device is Apple and adjust shader definitions accordingly
                    if (ke.default.apple.device) {
                        this._vertDefines.push("#define IS_IOS");
                        this._vertDefines.push("#define NEED_INVARIANT");
                    } else {
                        // Check for platform and userAgentData
                        const userAgentData = navigator?.userAgentData?.platform || navigator?.platform || "";
                        if (userAgentData.toUpperCase().indexOf("MAC") >= 0) {
                            this._vertDefines.push("#define NEED_INVARIANT");
                        }
                    }

                    // Define shader name and initialize defines
                    this.defineShaderName();
                    this.initDefines();
                };
            Ze.setStateAttributeConfig(ze, {
                attribute: ["VertexCompression", "testdemo2024Light0", "testdemo2024Light1", "testdemo2024Light2", "testdemo2024Light3", "ShadowReceive0", "ShadowReceive1", "ShadowReceive2", "ShadowReceive3", "testdemo2024Material", "Morph", "Skinning", "PointSize", "Decals"],
                textureAttribute: ["Texture"]
            }), Ze.createPrototypeObject(ze, {
                getCompilerName: function () {
                    return "PBR"
                },
                getFragmentMain: function () {
                    return "pbr.frag"
                },
                getVertexMain: function () {
                    return "pbr.vert"
                },
                initAttributes: function (e) {
                    for (var t = this._lights, i = this._shadows, n = 0, r = e.length; n < r; n++) {
                        var a = e[n].className();
                        "Light" === a ? t.push(e[n]) : "Material" === a ? this._material = e[n] : "ShadowReceiveAttribute" === a ? i.push(e[n]) : "SkinningAttribute" === a ? this._skinning = e[n] : "MorphAttribute" === a ? this._morphing = e[n] : "PointSizeAttribute" === a ? this._pointSize = e[n] : "VertexCompression" === a ? this._compression = e[n] : "DecalsAttribute" === a && (this._decals = e[n])
                    }
                },
                initTextureAttributes: function (e) {
                    for (var t = e.length, i = 0; i < t; i++) {
                        var n = e[i];
                        if (n)
                            for (var r = 0, a = n.length; r < a; r++) {
                                var o = n[r];
                                this._targetByUnit[i] = o;
                                var s = o.className();
                                if ("TextureEnvironment" === s) {
                                    var l = o.getChannel();
                                    "SpecularPBR" === l || "Specular" === l ? this._envSpecular = o : "IntegrateBRDF" === l && (this._envBrdf = o)
                                }
                                "ShadowTexture" !== s && "ShadowTextureAtlas" !== s || this._shadowsTextures.push(o)
                            }
                    }
                },
                defineShaderName: function () {
                    this._vertDefines.push("#define SHADER_NAME " + this.getVertexShaderName()), this._fragDefines.push("#define SHADER_NAME " + this.getFragmentShaderName());
                    var e = (1 - (0, S.Z)().epsilonAlpha).toExponential();
                    this._fragDefines.push("#define EPSILON_ALPHA " + e)
                },
                getFragmentShaderName: function () {
                    var e = this.getCompilerName(),
                        t = this._material && this._material.getName();
                    t && (e += "(" + (t = t.replace(/[^a-zA-Z0-9]+/g, "_").slice(0, 20)) + ")");
                    var i, n = this._channels && this._channels.Opacity,
                        r = n && n.isEffective() && n.get("type");
                    if (i = "alphaBlend" === r || "additive" === r ? "Blend" : "refraction" === r ? "Refract" : "dithering" === r ? "Dither" : "Opaque", this._channels && this._channels.AlphaMask && this._channels.AlphaMask.isEffective() && (i = "AlphaMask" + i), i) {
                        var a = this.getCompilerName();
                        e = e.replace(a, a + "_" + i)
                    }
                    return e
                },
                getVertexShaderName: function () {
                    return this.getFragmentShaderName()
                },
                getDebugIdentifier: function () {
                    var e = this.getVertexShaderName(),
                        t = this.getFragmentShaderName();
                    return e === t ? t : e + "|" + t
                },
                createShader: function (e) {
                    var t = e ? this.getFragmentMain() : this.getVertexMain(),
                        i = e ? this._fragDefines : this._vertDefines;
                    e || i.push("#define ASSIGN_UV " + this._vertAssignUV.join(" ")), i = He.getSortedUnique(i);
                    for (var n = "", r = 0; r < i.length; ++r) i[r] && (n += i[r] + "\n");
                    return n = (n = "#define SHADER_NAME " + this.getFragmentShaderName() + "\n" + n) + '#pragma include "' + t + '"', He.processShader(n)
                },
                createFragmentShader: function () {
                    return this.createShader(!0)
                },
                createVertexShader: function () {
                    return this.createShader(!1)
                },
                declareAndAssignTexCoord: function (e, t) {
                    var i = "TexCoord" + e;
                    if (this._vertDefines.push("attribute vec2 " + i + ";"), t && !this._compression) return i;
                    var n = "vTexCoord" + e,
                        r = "varying vec2 " + n + ";",
                        a = "vec2 " + n + ";";
                    if (t) - 1 === this._vertDefines.indexOf(r) && this._vertDefines.push("vec2 " + n + ";");
                    else {
                        this._fragDefines.push(r), this._vertDefines.push(r);
                        var o = this._vertDefines.indexOf(a); - 1 !== o && this._vertDefines.splice(o, 1)
                    }
                    var s = n + " = ";
                    if (this._compression) {
                        var l = "uQUV" + e;
                        this._vertDefines.push("uniform vec4 " + l + ";"), s += i + ".xy * " + l + ".zw + " + l + ".xy;"
                    } else s += i + ";";
                    return -1 === this._vertAssignUV.indexOf(s) && this._vertAssignUV.push(s), n
                },
                _getTexCoordTransforms: function (e, t) {
                    var i = "u" + t;
                    return e = "vec2( mat2(" + i + "UVTransforms) * " + e, e += " + " + i + "UVOffset)"
                },
                getChannelUV: function (e) {
                    var t = e.getName();
                    if (!e.getTextureModel()) {
                        var i = E.Z.getColorPacking(t);
                        return 0 === i ? "vec2(0.125, 0.5)" : 1 === i ? "vec2(0.375, 0.5)" : 2 === i ? "vec2(0.625, 0.5)" : "vec2(0.875, 0.5)"
                    }
                    var n = "Displacement" === e.get("name"),
                        r = this.declareAndAssignTexCoord(e.getTexCoordUnit(), n);
                    return e.getNonIdentityUvTransform() && (r = this._getTexCoordTransforms(r, e.get("name"))), r
                },
                defineOpacity: function (e) {
                    var t = e.get("type");
                    "alphaBlend" !== t && "additive" !== t ? "dithering" !== t ? (this._fragDefines.push("#define HAS_OPACITY_REFRACTION"), e.get("useNormalOffset") && this._fragDefines.push("#define HAS_REFRACTION_NORMAL_OFFSET"), e.get("useAlbedoTint") && this._fragDefines.push("#define HAS_REFRACTION_ALBEDO_TINT"), e.get("useMicrosurfaceTexture") && this._fragDefines.push("#define HAS_REFRACTION_MICROSURFACE"), (0, S.Z)().depthMipmap && this._fragDefines.push("#define DEPTH_MIPMAP")) : this._fragDefines.push("#define HAS_OPACITY_DITHER") : this._fragDefines.push("#define HAS_OPACITY_BLEND_OR_ADDITIVE")
                },
                defineChannel: function (e) {
                    var t = e.getName();
                    if (e.isEnableEffectiveHardware(this._material)) {
                        var i = "Displacement" === t ? this._vertDefines : this._fragDefines,
                            n = t.toUpperCase();
                        if (i.push("#define HAS_" + n), "NormalMap" !== t && "Inspector" !== t || this._vertDefines.push("#define HAS_" + n), e.isEffective()) {
                            "NormalMap" !== t && "BumpMap" !== t && "ClearCoatNormalMap" !== t && "Anisotropy" !== t || (this._decals && this._decals.isComputeFragmentTangents() ? this._fragDefines.push("#define COMPUTE_FRAGMENT_TANGENTS") : (this._fragDefines.push("#define HAS_VIEW_TANGENT"), this._vertDefines.push("#define HAS_VIEW_TANGENT"))), "Opacity" === t && this.defineOpacity(e), "Displacement" === t && ((0, S.Z)().substanceDisplacement ? i.push("#define HAS_SUBSTANCE_DISPLACEMENT") : i.push("#define HAS_testdemo2024_DISPLACEMENT")), "AlbedoPBR" === t && !e.getTextureModel() && this._decals && this._decals.isDiscardOutOfTextureBoundPixels() && this.declareAndAssignTexCoord(0, !1);
                            var r = E.Z.getColorPacking(t);
                            if (e.getTextureModel() || !(r < 0)) {
                                var a = this._material.getChannelMapping(t);
                                if (!(void 0 === a || a < 0)) {
                                    var o = this._targetByUnit[a],
                                        s = o.getName(),
                                        l = o.getChannelPacking(t),
                                        u = e.getSRGB() ? "sRGBToLinear" : "",
                                        c = t.toUpperCase(),
                                        h = this.getChannelUV(e);
                                    i.push("uniform sampler2D " + s + ";"), i.push("uniform vec4 u" + t + "UVTransforms;"), i.push("uniform vec2 u" + t + "UVOffset;"), i.push("#define SAMPLER_" + c + " " + s), i.push("#define PACK_" + c + " " + l), i.push("#define UV_" + c + " " + h), i.push("#define COLOR_CONVERT_" + c + " " + u)
                                }
                            }
                        }
                    }
                },
                defineVertexColorAndAlpha: function () {
                    if (this._material && this._material.getVertexColorEnable()) {
                        this._fragDefines.push("#define HAS_VERTEX_COLOR"), this._vertDefines.push("#define HAS_VERTEX_COLOR");
                        var e = "srgb" === this._material.getVertexColorColorSpace() ? "sRGBToLinear" : "";
                        this._fragDefines.push("#define COLOR_CONVERT_VERTEX_COLOR " + e), this._material.getVertexAlphaEnable() && (this._fragDefines.push("#define HAS_VERTEX_ALPHA"), this._vertDefines.push("#define HAS_VERTEX_ALPHA"))
                    }
                },
                defineLights: function () {
                    var e = this._lights;
                    if (e.length) {
                        for (var t = 0; t < e.length; ++t) {
                            var i = e[t],
                                n = i.getLightNumber(),
                                r = "LIGHT_" + i.getLightType();
                            this._fragDefines.push("#define LIGHT_TYPE_" + n + " " + r)
                        }
                        this._fragDefines.push("#define HAS_LIGHT")
                    }
                },
                defineShadows: function () {
                    var e = this._shadows;
                    if (e.length) {
                        for (var t = 0; t < e.length; ++t) {
                            var i = e[t];
                            this._fragDefines.push("#define HAS_SHADOW_" + i.getLightNumber()), this._fragDefines.push.apply(this._fragDefines, i.getDefines())
                        }
                        this._fragDefines.push("#define HAS_SHADOW"), this._vertDefines.push("#define HAS_MODEL_VERTEX"), this._vertDefines.push("#define HAS_MODEL_NORMAL")
                    }
                },
                defineEnvironment: function () {
                    this._envSpecular && (this._fragDefines.push("#define HAS_ENVIRONMENT"), this._envSpecular.getIsCubemap() ? this._fragDefines.push("#define ENV_CUBEMAP") : this._fragDefines.push("#define ENV_PANORAMA")), this._envBrdf && this._fragDefines.push("#define HAS_ENVIRONMENT_BRDF")
                },
                defineSsr: function () {
                    Ue.Z.get("hasSsr") && (this._fragDefines.push("#define HAS_SSR"), (0, S.Z)().ssrTransparent && this._fragDefines.push("#define HAS_SSR_TRANSPARENT"), (0, S.Z)().depthMipmap && -1 === this._fragDefines.indexOf("#define DEPTH_MIPMAP") && this._fragDefines.push("#define DEPTH_MIPMAP"))
                },
                defineSkinning: function () {
                    this._skinning && (this._vertDefines.push("#define HAS_SKINNING"), this._vertDefines.push("#define NUM_BONES " + this._skinning.getBoneUniformSize()))
                },
                defineMorphing: function () {
                    this._morphing && this._morphing.hasTarget("Vertex") && (this._vertDefines.push("#define HAS_MORPHING"), this._vertDefines.push("#define NUM_TARGETS " + this._morphing.getNumTargets()), this._morphing.hasTarget("Normal") && this._vertDefines.push("#define HAS_MORPHING_NORMAL"), this._morphing.hasTarget("Tangent") && this._vertDefines.push("#define HAS_MORPHING_TANGENT"))
                },
                defineChannels: function () {
                    var e = this._channels;
                    for (var t in e) this.defineChannel(e[t])
                },
                _randHardcodedScale: function () {
                    var e, t = Ze.BufferArray.randa,
                        i = t[0],
                        n = t[1],
                        r = t[2];
                    Ge > .5 ? e = "* " : (e = "/ ", i = 1 / i, n = 1 / n, r = 1 / r), i = i.toExponential(), n = n.toExponential(), r = r.toExponential();
                    var a = Math.random();
                    return a < .33 ? e + "vec3(" + r + "," + i + "," + n + ").yzx" : a < .66 ? e + "vec3(" + n + "," + r + "," + i + ").zxy" : e + "vec3(" + r + "," + i + "," + n + ").yzx"
                },
                defineCompression: function () {
                    this._compression && (0, S.Z)().zz && (this._vertDefines.push("#define RAND_SCALE " + this._randHardcodedScale()), this._vertDefines.push("#define HAS_COMPRESSION"), (0, S.Z)().zoct && this._vertDefines.push("#define HAS_OCT_COMPRESSION"), (0, S.Z)().zw && this._vertDefines.push("#define HAS_ZW_COMPRESSION"))
                },
                definePointSize: function () {
                    this._pointSize && (this._vertDefines.push("#define HAS_POINT_SIZE"), this._pointSize.isCircleShape() && this._fragDefines.push("#define HAS_POINT_CIRCLE"))
                },
                defineDecals: function () {
                    this._decals && (this._decals.isDiscardOutOfTextureBoundPixels() && this._fragDefines.push("#define HAS_DISCARD_OOTB_PIXELS"), this._decals.hasPolygonOffset() && this._vertDefines.push("#define HAS_POLYGON_OFFSET"))
                },
                initDefines: function () {
                    this.defineChannels(), this.defineVertexColorAndAlpha(), this.defineLights(), this.defineShadows(), this.defineEnvironment(), this.defineSsr(), this.defineMorphing(), this.defineSkinning(), this.defineCompression(), this.definePointSize(), this.defineDecals(), Ue.Z.get("mask") & Ue.Z.CLASSIC && (this._fragDefines.push("#define HAS_LEGACY_CLASSIC"), "PBR" === this.getCompilerName() && (this._fragDefines.push('#pragma include "utils/cubemap.glsl"'), this._fragDefines.push('#pragma include "utils/lights.glsl"')))
                }
            }, "osgtestdemo2024", "Compiler");
            const We = ze;
            var je = u.Z.osg,
                Xe = function () {
                    We.apply(this, arguments)
                };
            je.setStateAttributeConfig(Xe, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "PointSize"],
                textureAttribute: ["Texture"]
            }), je.createPrototypeObject(Xe, je.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Shadeless"
                },
                getFragmentMain: function () {
                    return "shadeless.frag"
                },
                getVertexMain: function () {
                    return "shadeless.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    this.defineChannel(e.AlbedoPBR), this.defineChannel(e.DiffusePBR), this.defineChannel(e.AlphaMask), this.defineChannel(e.Opacity), this.defineChannel(e.Displacement), this.defineChannel(e.EmitColor), this.defineChannel(e.CavityPBR), this.defineChannel(e.AOPBR), this.defineChannel(e.DiffuseColor), this.defineChannel(e.DiffuseIntensity), -1 !== this._fragDefines.indexOf("#define HAS_OPACITY_REFRACTION") && (this._vertDefines.push("#define HAS_VIEW_NORMAL"), this._vertDefines.push("#define HAS_VIEW_VERTEX"))
                }
            }));
            const Ye = Xe;
            var Je = u.Z.osg,
                qe = function () {
                    We.apply(this, arguments)
                };
            Je.setStateAttributeConfig(qe, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "PointSize"],
                textureAttribute: ["Texture"]
            }), Je.createPrototypeObject(qe, Je.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Matcap"
                },
                getFragmentMain: function () {
                    return "matcap.frag"
                },
                getVertexMain: function () {
                    return "matcap.vert"
                },
                getChannelUV: function (e) {
                    return "Matcap" === e.getName() ? "" : We.prototype.getChannelUV.call(this, e)
                },
                defineChannels: function () {
                    var e = this._channels;
                    this.defineChannel(e.AlphaMask), this.defineChannel(e.Opacity), this.defineChannel(e.Displacement), this.defineChannel(e.NormalMap), this.defineChannel(e.BumpMap), this.defineChannel(e.Matcap)
                }
            }));
            const Ke = qe;
            var Qe = u.Z.osg,
                $e = function () {
                    We.apply(this, arguments)
                };
            Qe.setStateAttributeConfig($e, {
                attribute: ["testdemo2024Light0", "testdemo2024Light1", "testdemo2024Light2", "testdemo2024Light3", "ShadowReceive0", "ShadowReceive1", "ShadowReceive2", "ShadowReceive3", "GroundStateAttribute"],
                textureAttribute: ["Texture"]
            }), Qe.createPrototypeObject($e, Qe.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Ground"
                },
                getFragmentMain: function () {
                    return "ground/ground.frag"
                },
                getVertexMain: function () {
                    return "ground/ground.vert"
                },
                initAttributes: function (e) {
                    for (var t = this._lights, i = this._shadows, n = 0, r = e.length; n < r; n++) {
                        var a = e[n].className();
                        "Light" === a ? t.push(e[n]) : "ShadowReceiveAttribute" === a ? i.push(e[n]) : "GroundStateAttribute" === a && (this._groundState = e[n])
                    }
                },
                initDefines: function () {
                    var e = this._groundState.isUseBakedAo(),
                        t = this._groundState.isDisplayPlane();
                    e ? this._fragDefines.push("#define BAKED_AO") : (this.defineLights(), this.defineShadows(), this._shadows.length && this._lights.length ? this._fragDefines.push("#define SHADOW_CATCHER") : this._fragDefines.push("#define PASS_THROUGH")), t && this._fragDefines.push("#define DISPLAY_PLANE"), this._vertDefines.push("attribute vec2 TexCoord0;"), this._vertDefines.push("varying vec2 vTexCoord0;"), this._vertAssignUV.push("vTexCoord0 = TexCoord0;")
                }
            }));
            const et = $e;
            var tt = u.Z.osg,
                it = function () {
                    We.apply(this, arguments)
                };
            tt.setStateAttributeConfig(it, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "PointSize", "Decals"],
                textureAttribute: ["Texture"]
            }), tt.createPrototypeObject(it, tt.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "EarlyZ"
                },
                getFragmentMain: function () {
                    return "earlyz.frag"
                },
                getVertexMain: function () {
                    return "earlyz.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    e && (this.defineChannel(e.AlphaMask), this._decals && this._decals.isDiscardOutOfTextureBoundPixels() && this.declareAndAssignTexCoord(0, !1), this.defineChannel(e.Opacity), this.defineChannel(e.Displacement), this.defineChannel(e.SubsurfaceScattering))
                }
            }));
            const nt = it;
            var rt = u.Z.osg,
                at = function () {
                    nt.apply(this, arguments)
                };
            rt.setStateAttributeConfig(at, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "ShadowCast"],
                textureAttribute: ["Texture"]
            }), rt.createPrototypeObject(at, rt.objectInherit(nt.prototype, {
                getCompilerName: function () {
                    return "ShadowBakeAo"
                },
                getFragmentMain: function () {
                    return "ground/bakeShadowMap.frag"
                },
                getVertexMain: function () {
                    return "ground/bakeShadowMap.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    e && (this.defineChannel(e.AlphaMask), this.defineChannel(e.Opacity), this.defineChannel(e.Displacement))
                }
            }));
            const ot = at;
            var st = u.Z.osg,
                lt = function () {
                    nt.apply(this, arguments)
                };
            st.setStateAttributeConfig(lt, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "ShadowCast"],
                textureAttribute: ["Texture"]
            }), st.createPrototypeObject(lt, st.objectInherit(nt.prototype, {
                getCompilerName: function () {
                    return "ShadowCastSkfb"
                },
                getFragmentMain: function () {
                    return "shadowing/shadowCast.frag"
                },
                getVertexMain: function () {
                    return "shadowing/shadowCast.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    e && (this.defineChannel(e.AlphaMask), this.defineChannel(e.Opacity), this.defineChannel(e.Displacement))
                }
            }));
            const ut = lt;
            var ct = u.Z.osg,
                ht = function () {
                    We.apply(this, arguments)
                };
            ct.setStateAttributeConfig(ht, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "PointSize"],
                textureAttribute: ["Texture"]
            }), ct.createPrototypeObject(ht, ct.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Outline"
                },
                getFragmentMain: function () {
                    return "outline.frag"
                },
                getVertexMain: function () {
                    return "outline.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    e && this.defineChannel(e.Displacement)
                }
            }));
            const dt = ht;
            var gt = u.Z.osg,
                ft = function () {
                    We.apply(this, arguments)
                };
            gt.setStateAttributeConfig(ft, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning"],
                textureAttribute: ["Texture"]
            }), gt.createPrototypeObject(ft, gt.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Wireframe"
                },
                getFragmentMain: function () {
                    return "wireframe.frag"
                },
                getVertexMain: function () {
                    return "wireframe.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    e && this.defineChannel(e.Displacement)
                }
            }));
            const mt = ft;
            var pt = u.Z.osg,
                vt = function () {
                    We.apply(this, arguments)
                };
            pt.setStateAttributeConfig(vt, {
                attribute: ["ShadowReceive0"],
                textureAttribute: ["Texture"]
            }), pt.createPrototypeObject(vt, pt.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "ShadowAr"
                },
                getFragmentMain: function () {
                    return "ARKit/shadowAr.frag"
                },
                getVertexMain: function () {
                    return "ARKit/shadowAr.vert"
                },
                initDefines: function () {
                    this.defineShadows()
                }
            }));
            const _t = vt;
            var St = i("eKF4"),
                xt = u.Z.osg,
                Ct = function () {
                    We.apply(this, arguments)
                };
            xt.setStateAttributeConfig(Ct, {
                attribute: ["VertexCompression", "testdemo2024Material", "Morph", "Skinning", "PointSize"],
                textureAttribute: ["Texture"]
            }), xt.createPrototypeObject(Ct, xt.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Inspector"
                },
                getFragmentMain: function () {
                    return "inspector/inspector.frag"
                },
                getVertexMain: function () {
                    return "inspector/inspector.vert"
                },
                defineChannels: function () {
                    var e = this._channels;
                    this.defineChannel(e.Opacity), this.defineChannel(e.Displacement), this.defineChannel(e.Inspector);
                    var t = e.Inspector;
                    if (t.getTextureModel() && (this._fragDefines.push("#define HAS_INSPECTOR_TEXTURE"), this._vertDefines.push("#define HAS_INSPECTOR_TEXTURE"), e.Inspector.getSRGB() || this._fragDefines.push("#define CONVERT_INSPECTOR_TO_LINEAR")), t.isEnableEffectiveHardware(this._material))
                        if (t.getTextureModel()) this._fragDefines.push("#define FEEDBACK_UV UV_INSPECTOR");
                        else {
                            var i = t.get("selectUV");
                            this.declareAndAssignTexCoord(i), this._fragDefines.push("#define FEEDBACK_UV vTexCoord" + i)
                        }
                    St.Z.me().get("features").includes("ff_display_inspector_watermarking") && this._fragDefines.push("#define DISPLAY_WATERMARK 1")
                }
            }));
            const Tt = Ct;
            var Mt = u.Z.osg,
                bt = function () {
                    We.apply(this, arguments)
                };
            Mt.setStateAttributeConfig(bt, {
                attribute: [],
                textureAttribute: []
            }), Mt.createPrototypeObject(bt, Mt.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "Controller"
                },
                getFragmentMain: function () {
                    return "webVR/controller.frag"
                },
                getVertexMain: function () {
                    return "webVR/controller.vert"
                },
                initDefines: function () { }
            }));
            const yt = bt;
            var At = u.Z.osg,
                Rt = function () {
                    We.apply(this, arguments)
                };
            At.setStateAttributeConfig(Rt, {
                attribute: ["Morph", "Skinning", "PointSize"],
                textureAttribute: []
            }), At.createPrototypeObject(Rt, At.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "DebugNormal"
                },
                getFragmentMain: function () {
                    return "debug/normal.frag"
                },
                getVertexMain: function () {
                    return "debug/normal.vert"
                }
            }));
            const wt = Rt;
            var Et = u.Z.osg,
                Pt = function () {
                    We.apply(this, arguments)
                };
            Et.setStateAttributeConfig(Pt, {
                attribute: ["Morph", "Skinning", "PointSize"],
                textureAttribute: []
            }), Et.createPrototypeObject(Pt, Et.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "DebugTangent"
                },
                getFragmentMain: function () {
                    return "debug/tangent.frag"
                },
                getVertexMain: function () {
                    return "debug/tangent.vert"
                }
            }));
            const Nt = Pt;
            var Ot = u.Z.osg,
                Dt = function () {
                    We.apply(this, arguments)
                };
            Ot.setStateAttributeConfig(Dt, {
                attribute: ["VertexCompression", "Morph", "Skinning", "PointSize"],
                textureAttribute: []
            }), Ot.createPrototypeObject(Dt, Ot.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "DebugGeometry"
                },
                getFragmentMain: function () {
                    return "debug/geometry.frag"
                },
                getVertexMain: function () {
                    return "debug/geometry.vert"
                }
            }));
            const It = Dt;
            var Ft = u.Z.osg,
                Lt = function () {
                    We.apply(this, arguments)
                };
            Ft.setStateAttributeConfig(Lt, {
                attribute: ["VertexCompression", "Morph", "Skinning", "PointSize"],
                textureAttribute: []
            }), Ft.createPrototypeObject(Lt, Ft.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "DebugSkinning"
                },
                getFragmentMain: function () {
                    return "debug/skinning.frag"
                },
                getVertexMain: function () {
                    return "debug/skinning.vert"
                }
            }));
            const Vt = Lt;
            var Bt = u.Z.osg,
                Ut = function () {
                    We.apply(this, arguments)
                };
            Bt.setStateAttributeConfig(Ut, {
                attribute: ["VertexCompression"],
                textureAttribute: []
            }), Bt.createPrototypeObject(Ut, Bt.objectInherit(We.prototype, {
                getCompilerName: function () {
                    return "DebugBoneBox"
                },
                getFragmentMain: function () {
                    return "debug/boneBox.frag"
                },
                getVertexMain: function () {
                    return "debug/boneBox.vert"
                }
            }));
            const kt = Ut;
            var Zt = -1,
                Ht = u.Z.osg,
                Gt = u.Z.osgShader.ShaderGenerator,
                zt = function (e, t) {
                    Gt.call(this), this.setShaderCompiler(e), this._materialHashCompiler = t || Be.Z.SHADING_COMPILER
                };
            Ht.createPrototypeObject(zt, Ht.objectInherit(Gt.prototype, {
                getOrCreateProgram: function (e) {
                    return Be.Z.CURRENT_COMPILER = this._materialHashCompiler, Gt.prototype.getOrCreateProgram.call(this, e)
                },
                _getProgram: function (e, t, i, n) {
                    var r = this._cache[e];
                    return r && -1 === r.getAsyncCompiling() ? r : r ? r.getAsyncLinkingStatus() ? (r.getLinkResult(t.getGraphicContext()), Zt -= 1, i.length = 0, n.length = 0, this.getActiveAttributeList(t, i), this.getActiveTextureAttributeList(t, n), r.setActiveUniforms(this.getActiveUniforms(t, i, n)), r) : (x.Z.draw(), r._placeHolder) : void 0
                },
                _createProgram: function (e, t, i, n) {
                    var r = Gt.prototype._createProgram.call(this, e, t, i, n);
                    return -1 !== r.getAsyncCompiling() ? (this._waitingProgram || (this._waitingProgram = this._createWaitingProgram(t, i, n), this._waitingProgram._name = "placeHolder"), r.enableAsyncCompilation(this._waitingProgram, t._frameStamp._frame), Zt += 1, this._waitingProgram) : r
                }
            }));
            var Wt = function (e, t, i, n) {
                e.addShaderGenerator(t, new zt(i, n))
            },
                jt = {},
                Xt = !1;
            jt.register = function (e) {
                Xt || (Xt = !0, Wt(e, "lit-classic", We), Wt(e, "lit-pbr", We), Wt(e, "shadeless-classic", Ye), Wt(e, "shadeless-pbr", Ye), Wt(e, "matcap", Ke), Wt(e, "ground", et), Wt(e, "shadow-ao-bake", ot), Wt(e, "earlyz", nt, Be.Z.EARLYZ_COMPILER), Wt(e, "shadowcast", ut, Be.Z.SHADOWCAST_COMPILER), Wt(e, "outline", dt, Be.Z.SHADOWCAST_COMPILER), Wt(e, "wireframe", mt, Be.Z.WIREFRAME_COMPILER), Wt(e, "shadow-ar", _t), Wt(e, "inspector", Tt), Wt(e, "controller", yt), Wt(e, "debugNormal", wt), Wt(e, "debugTangent", Nt), Wt(e, "debugGeometry", It), Wt(e, "debugSkinning", Vt), Wt(e, "debugBoneBox", kt))
            };
            const Yt = jt;
            var Jt = i("8WLf"),
                qt = i("QG/p"),
                Kt = i("N8nW"),
                Qt = i("YxXF"),
                $t = function (e, t) {
                    this._key = e, this._progress = 0, this._weight = 0, this._active = !1, this._progressUpdate = t, this._promises, this._nbPromisesDone = 0, this._lastSetPromiseId = 0, this._cbFakeUpdate, this._refTime, this._totalBytes = 0
                };
            $t.prototype = {
                setPromises: function (e) {
                    this._progress = 0, this._promises = e, this._nbPromisesDone = 0, this._totalBytes = 0, this._lastSetPromiseId++, this._cbFakeUpdate = this._onPromiseAutoUpdate.bind(this, this._lastSetPromiseId);
                    for (var t = 0; t < this._promises.length; ++t) {
                        var i = this._promises[t];
                        i.finally(this._onPromiseDone.bind(this, this._lastSetPromiseId, i.size || 0)), this._totalBytes += this._promises[t].progressSize || 0
                    }
                    window.setTimeout(this._cbFakeUpdate, 100), this._updateRefTime()
                },
                _updateRefTime: function () {
                    this._refTime = (new Date).getTime()
                },
                _onPromiseDone: function (e, t) {
                    this._lastSetPromiseId === e && (this._totalBytes -= t, this._updateRefTime(), this._nbPromisesDone++, this._progress = this._nbPromisesDone / this._promises.length, this._progressUpdate(this))
                },
                _onPromiseAutoUpdate: function (e) {
                    if (this._lastSetPromiseId === e) {
                        var t = this._promises.length;
                        if (this._nbPromisesDone !== t) {
                            var i = 2e-4 * ((new Date).getTime() - this._refTime),
                                n = this._nbPromisesDone / t,
                                r = (this._nbPromisesDone + 1) / t;
                            this._progress = r - (r - n) / (i * i + 1), this._progressUpdate(this), window.setTimeout(this._cbFakeUpdate, 100)
                        }
                    }
                }
            };
            var ei = function (e) {
                this._triggerProgress = e, this._primaryChannels = [], this._secondaryChannels = [], this._init()
            };
            ei.prototype = {
                _init: function () {
                    var e = this._updateChannelProgress.bind(this, !1),
                        t = this._primaryChannels;
                    t.push(new $t("texture", e)), t.push(new $t("polygon", e)), t.push(new $t("osgjs", e)), t.push(new $t("wireframe", e));
                    var i = this._updateChannelProgress.bind(this, !0),
                        n = this._secondaryChannels;
                    n.push(new $t("texture", i)), n.push(new $t("environment", i)), n.push(new $t("background", i)), n.push(new $t("wireframe", i))
                },
                initPrimaryProgress: function (e, t, i) {
                    var n = this._getProgressChannel("texture", !1),
                        r = this._getProgressChannel("polygon", !1),
                        a = this._getProgressChannel("osgjs", !1),
                        o = this._getProgressChannel("wireframe", !1);
                    n._totalBytes = this._estimateTexturesSize(), r._totalBytes = t, a._totalBytes = e, o._totalBytes = i, n._active = !0, r._active = !0, a._active = !0, o._active = i > 0, this._autoComputeWeights()
                },
                _estimateTexturesSize: function () {
                    var e, t = A.Z.instance.getTextureCollection().models,
                        i = t.length;
                    if (!i) return 0;
                    if (!(0, S.Z)().preload) return 5e3 * i;
                    var n = 0,
                        r = 0,
                        a = (0, Kt.Z)();
                    for (e = 0; e < i; ++e) {
                        var o = t[e].findImageNearestPowerOfTwoUpToResolution(a, a);
                        r += o.width * o.height, n = Math.max(n, o.width, o.height)
                    }
                    var s = (0, S.Z)().pixelBudget;
                    void 0 === s && (s = ke.default.any ? 6144 : 12288), s *= s;
                    var l = Math.min(a, Math.sqrt(s / i));
                    l = Qt.Z.snapToPowerOf2(l, .75), (n <= a || r <= l * l) && (l = a);
                    var u = 0;
                    for (e = 0; e < i; ++e) u += t[e].findImageNearestPowerOfTwoUpToResolution(l, l).size;
                    return u
                },
                _getProgressChannel: function (e, t) {
                    for (var i = t ? this._secondaryChannels : this._primaryChannels, n = 0; n < i.length; ++n)
                        if (i[n]._key === e) return i[n]
                },
                _autoComputeWeights: function (e) {
                    var t = e ? this._secondaryChannels : this._primaryChannels,
                        i = 0,
                        n = 0,
                        r = 0,
                        a = 0;
                    for (n = 0; n < t.length; ++n) t[n]._active && (i++, r += t[n]._totalBytes, t[n]._totalBytes || a++);
                    var o = 1 / i,
                        s = 1 - o * a;
                    for (n = 0; n < t.length; ++n)
                        if (t[n]._active) {
                            var l = t[n]._totalBytes;
                            t[n]._weight = l ? s * l / r : o
                        } else t[n]._weight = 0
                },
                _updateChannelProgress: function (e, t) {
                    var i = e ? this._secondaryChannels : this._primaryChannels;
                    e && !t._active && (t._active = !0, this._autoComputeWeights(!0));
                    var n = 0,
                        r = 0;
                    for (r = 0; r < i.length; ++r) n += i[r]._progress * i[r]._weight;
                    var a = e ? "secondary-progress" : "primary-progress";
                    if (this._triggerProgress(a, {
                        progress: n
                    }), 1 === n)
                        for (r = 0; r < i.length; ++r) i[r]._active = !1
                },
                updateProgress: function (e, t, i) {
                    var n = this._getProgressChannel(i, t);
                    n._progress = e, this._updateChannelProgress(t, n)
                },
                setFakeProgress: function (e, t, i) {
                    var n = this._getProgressChannel(i, t);
                    n ? (void 0 === e.length && (e = [e]), n.setPromises(e), t || this._autoComputeWeights()) : console.error("Unexpected progress channel key : " + i)
                }
            };
            const ti = ei;
            var ii = i("HXjs"),
                ni = i("078t"),
                ri = i("3XAv"),
                ai = i("JueD"),
                oi = i("0bhc"),
                si = i("aa6s"),
                li = u.Z.osg,
                ui = u.Z.osgViewer,
                ci = new (l())({
                    device: "VWR"
                }),
                hi = function (e) {
                    if (e.byteLength) return Array.prototype.slice.call(e)
                },
                di = function (e) {
                    return (0, o.Z)(e, hi)
                },
                gi = function (e) {
                    this._dataScene = e, this._modelFile = this.selectModelFile(), this._rootModel = new li.Node, this._rootModel.setName("Scene - Root"), this._polygonNode = new li.Node, this._polygonNode.setName("Scene - PolygonNode"), this._wireframeNodes = [], this._resourcePromises = [], this._cleanLegacyAbsoluteUrl()
                };
            gi.prototype = {
                addResourcePromise: function (e) {
                    this._resourcePromises.push(e)
                },
                getJSON: function () {
                    return this._dataScene
                },
                getPolygonURL: function () {
                    return this._modelFile.osgjsUrl
                },
                getWireframeURL: function () {
                    return this._modelFile.wireframeUrl
                },
                getOsgjsSize: function () {
                    return this._modelFile.osgjsSize
                },
                getPolygonSize: function () {
                    return this._modelFile.modelSize
                },
                getWireframeSize: function () {
                    return this._modelFile.wireframeSize
                },
                getResourceManager: function () {
                    return this._resourceManager || A.Z.instance
                },
                getRootModel: function () {
                    return this._rootModel
                },
                getWireframeNodes: function () {
                    return this._wireframeNodes
                },
                createOptionDownload: function (e, t, i) {
                    return {
                        node: i,
                        progress: t,
                        diter: this._modelFile.p && this._modelFile.p[0] && this._modelFile.p[0],
                        binarySize: "polygon" === e ? this.getPolygonSize() : this.getWireframeSize(),
                        binaryKey: e,
                        osgjsSize: this.getOsgjsSize(),
                        osgjsKey: "osgjs",
                        secondary: !1
                    }
                },
                loadPolygon: function (e, t, i, n) {
                    var r = this.createOptionDownload("polygon", e, this._polygonNode);
                    if (t) {
                        var a = n ? e : void 0;
                        r.wireframeOptions = this.createOptionDownload("wireframe", a), r.wireframeOptions.startPromise = i, r.wireframeOptions.deferDownload = new qt.Z, r.wireframeOptions.nodes = this.getWireframeNodes(), n && this._resourcePromises.push(r.wireframeOptions.deferDownload);
                        var o = li.Timer.instance().tick();
                        r.wireframeOptions.deferDownload.then((function () {
                            X.Z.resolveWireframe({
                                time: li.Timer.instance().tick() - o
                            })
                        }))
                    }
                    var s = this.getResourceManager().getOrCreateModel(this.getPolygonURL(), r);
                    return this.getRootModel().addChild(this._polygonNode), this.getResourceManager().run(), s.promise
                },
                loadWireframeLegacy: function (e) {
                    var t = this.createOptionDownload("wireframe", e, new li.Node);
                    t.node.setStateSet(new ni.Z);
                    var i = this.getResourceManager().getOrCreateModel(this.getWireframeURL(), t);
                    return this.getWireframeNodes().push(t.node), this.getRootModel().addChild(t.node), i.promise
                },
                selectModelFile: function () {
                    var e = (0, g.Z)() || (0, S.Z)().apiVersion || (0, ye.Z)() ? 0 : 1;
                    void 0 !== (0, S.Z)().modelOptimization && (e = (0, S.Z)().modelOptimization ? 1 : 0);
                    for (var t = this._dataScene.files, i = 0; i < t.length; ++i)
                        if (t[i].flag === e) return t[i];
                    return t[0]
                },
                _cleanLegacyAbsoluteUrl: function () {
                    var e = this._dataScene.options && this._dataScene.options.materials;
                    if (e) {
                        var t = this.getPolygonURL(),
                            i = t.substr(0, t.lastIndexOf("/") + 1);
                        for (var n in e) {
                            var r = e[n].channels;
                            for (var a in r) {
                                var o = r[a].texture;
                                o && (o.image && (o.image = i.concat(o.image)), o.url && (o.url = i.concat(o.url)))
                            }
                        }
                    }
                }
            };
            const fi = d.Z.extend({
                initialize: function () {
                    if (d.Z.prototype.initialize.apply(this, arguments), !this.options.model) throw new Error("no model provided to ViewerWebGL");
                    var e = (0, S.Z)();
                    e.preferOriginalNormalMap = this.options.model.get("preferOriginalNormalMap"), V.Z.client.configureScope((function (e) {
                        e.setTag("frontend", "3d")
                    })), this._root = null, this._features = this.options.features, this._widgetAPI = this.options.widgetAPI, this._viewerAPI = this.options.viewerAPI, this._progressManager = new ti(this.trigger.bind(this)), this._widgetAPI && this._widgetAPI.getTabbedWidget().model.on("change", x.Z.draw), A.Z.instance.setModelUid(this.model.get("uid")), this._featuresInstancied = {};
                    var t = this.$(".canvas"),
                        i = t[0];
                    i.oncontextmenu = function () {
                        return !1
                    }, this._initOptions(), li.Geometry.enableVAO = e.useVao, ri.Z && X.Z.resolveAsyncShaderCompilation();
                    var n = this._viewer = new ui.Viewer(i, {
                        powerPreference: e.powerPreference,
                        antialias: !1,
                        depth: !1,
                        stencil: !1,
                        alpha: this._requireAlphaContext(),
                        premultipliedAlpha: !0,
                        fullscreen: !1,
                        overrideDevicePixelRatio: e.pratio,
                        preserveDrawingBuffer: e.preserveDrawingBuffer,
                        enableFrustumCulling: !1,
                        maxDevicePixelRatio: (0, ai.Z)(),
                        InputSources: {
                            Mouse: {
                                scrollwheel: e.scrollwheel
                            },
                            Keyboard: {
                                sourceElement: t[0]
                            },
                            WebVR: {
                                pollInterval: -1
                            },
                            GamePad: {
                                enable: !1
                            }
                        }
                    });
                    ae.Z.init(n.getInputManager()), n.getState().getExcludeUniforms().uDrawOpaque = !0, n.getState().getExcludeUniforms().uQVT = !0, n.getState().getExcludeUniforms().uQVS = !0, n.getState().getExcludeUniforms().uQW = !0, n.getViewerStats() && n.getViewerStats().addConfig(this._createOptionStats());
                    var r = li.TimerGPU.instance();
                    e.webglTimerGpu && (r.setFrameAverageCount(20), r.enable()), Jt.Z.setTimerGPU(r);
                    var a = m();
                    this._contextLostCount = a ? 0 : e.webglRestore, this._restoreContextBinded = this.restoreContext.bind(this), n.setContextRestoreCallback(this.requestRestoreContext.bind(this)), n.setContextLostCallback(function () {
                        return li.warn("Context Lost"), (0, si.I)(!1), this._contextLostCount++, (0, oi.Z)("Embed Lost WebGL Context"), !0
                    }.bind(this)), Yt.register(n.getState().getShaderGeneratorProxy());
                    for (var o = (0, Ve.Z)(), s = n.getState(), l = 0; l < o; l++) s.setGlobalDefaultTextureAttribute(l, li.Texture.textureNull);
                    n.requestContinuousUpdate((0, S.Z)().continuousRender), t[0].setAttribute("tabindex", "0"), n.init();
                    var u = this.getCamera();
                    u.getRenderer().setCullVisitor(new _.Z), n.setupManipulator(), this._rootScene = new li.MatrixTransform, this._rootScene.setName("Root scene"), u.setClearColor(li.vec4.fromValues(.25, .3, .3, 1)), n.setSceneData(this._rootScene), x.Z.setViewer(n), this._superSample = new y(this), x.Z.setSuperSample(this._superSample), this._superSample.setRoot(this._rootScene), n.getManipulator().computeHomePosition(), e.forceMs ? n._requestAnimationFrame = function (e) {
                        window.setTimeout(e, (0, S.Z)().forceMs)
                    } : n._requestAnimationFrame = p.Z.get(), this._setShaderAsyncCompilation(), n.run(), this._currentScene = void 0, V.Z.client.configureScope((function (e) {
                        e.setTag("frontend", "web")
                    }))
                },
                _initOptions: function () {
                    var e = this.options.model;
                    void 0 === e.get("options").version && (e.get("options").version = h.Z.optionsVersion), li.time("processModelJSON"), G(e), li.timeEnd("processModelJSON"), (0, S.Z)().processOptions && e.set("options", {
                        version: h.Z.optionsVersion,
                        sound: {},
                        orientation: {},
                        ground: {},
                        wireframe: {},
                        scene: {},
                        hotspot: {},
                        materials: {},
                        environment: {},
                        vr: {},
                        camera: {},
                        lighting: {},
                        background: {},
                        shading: {},
                        animation: {}
                    })
                },
                updateProgress: function (e, t, i) {
                    this._progressManager.updateProgress(e, t, i), this.trigger("modelLoadProgress", e)
                },
                setFakeSecondaryProgress: function (e, t) {
                    this._progressManager.setFakeProgress(e, !0, t)
                },
                setFakePrimaryProgress: function (e, t) {
                    this._progressManager.setFakeProgress(e, !1, t)
                },
                setFakeProgress: function (e, t, i) {
                    this._progressManager.setFakeProgress(e, t, i)
                },
                requestRestoreContext: function () {
                    this._contextLostCount < 3 ? this.restoreContext() : new (0, i("g6dK").Z)({
                        title: "3D/WebGL context error",
                        text: "Your browser seems to have hit its 3D capability limit. The page needs to be reloaded to fix this. <br/>If the problems persists, you can try to close other tabs with 3D/WebGL or restart your browser entirely.",
                        safe: !0,
                        buttons: {
                            continue: !0,
                            continueLabel: "Reload Current Page",
                            continueClass: "button-error-popup-continue",
                            cancel: !1
                        }
                    }).open().then(function () {
                        window.location.reload()
                    }.bind(this))
                },
                restoreContext: function () {
                    if ((0, ii.BG)()) document.addEventListener((0, ii.X2)(), this._restoreContextBinded);
                    else if (this._featuresManager) {
                        var e = this._featuresManager._features;
                        if (e) {
                            if (e.postProcess) {
                                var t = e.postProcess.getModel();
                                t.set("enable", !1), t.set("enable", !0)
                            }
                            e.quality && e.material && (e.quality.getModel().trigger("updateTexelPolicy"), Re.Z.resetCaches(), Re.Z.packAllMaterialsTextures(e.material.getModel().getMaterials())), x.Z.draw(), document.removeEventListener((0, ii.X2)(), this._restoreContextBinded)
                        }
                    }
                },
                getModelUID: function () {
                    return this.model.get("uid")
                },
                _requireAlphaContext: function () {
                    if ((0, g.Z)() || (0, S.Z)().transparent || (0, S.Z)().arkit) return !0;
                    var e = this.options.model.get("options");
                    return "none" === (e && e.background && e.background.enable)
                },
                _getLower: function (e, t) {
                    for (var i = [], n = 0, r = e.length; n < r; ++n) i.push(e[n]), t[i[n]] = {
                        caption: e[n],
                        average: !0
                    };
                    return i
                },
                _createOptionStats: function () {
                    var e = ["Total GL", "Shading", "PostProcess", "ShadowMap"],
                        t = {};
                    return {
                        values: t,
                        groups: [{
                            name: e[0],
                            caption: "GL Total (ms)",
                            values: this._getLower(e, t)
                        }, {
                            name: e[1],
                            caption: "GL Shading (ms)",
                            values: this._getLower(["EarlyOpaque", "EarlyTransparency", "ShadingOpaque", "ShadingTransparency", "ShadingRefraction", "Extra"], t)
                        }, {
                            name: e[2],
                            caption: "GL PostProcess (ms)",
                            values: []
                        }, {
                            name: e[3],
                            caption: "GL ShadowMap (ms)",
                            values: this._getLower(["ShadowMap0", "ShadowMap1", "ShadowMap2", "ShadowMap3"], t)
                        }]
                    }
                },
                setOptionStatsPostProcess: function (e) {
                    var t = {},
                        i = [{
                            name: "PostProcess",
                            caption: "GL PostProcess (ms)",
                            values: this._getLower(e, t)
                        }],
                        n = this._viewer.getViewerStats();
                    n.addConfig({
                        values: t,
                        groups: i
                    }), n.update()
                },
                getRootUserData: function () {
                    return this._currentScene && this.getRootModel().userDataMap || {}
                },
                getRootScene: function () {
                    return this._rootScene
                },
                getRootModel: function () {
                    return this._currentScene.getRootModel()
                },
                getWidth: function () {
                    return this._viewer.getCanvasWidth()
                },
                getHeight: function () {
                    return this._viewer.getCanvasHeight()
                },
                getOptions: function () {
                    return this.options
                },
                isViewerReady: function () {
                    return X.Z.getModelDisplayed()
                },
                getViewerAPI: function () {
                    return this._viewerAPI
                },
                createContext: function (e) {
                    return new R.Z({
                        model: e.model,
                        viewer: this,
                        scene: e.scene,
                        widgetAPI: this._widgetAPI
                    })
                },
                loadWireframeLegacy: function (e, t) {
                    var i = e.loadWireframeLegacy(t),
                        n = li.Timer.instance().tick();
                    return i.then((function () {
                        X.Z.resolveWireframe({
                            time: li.Timer.instance().tick() - n
                        })
                    })), i
                },
                _dataSizePromisesResolve: function (e) {
                    X.Z.resolveDataSizeOSGJS(e.getOsgjsSize()), X.Z.resolveDataSizePolygon(e.getPolygonSize()), X.Z.getHasSound().then(function (e) {
                        var t = 0;
                        e && this.getFeatures().sound.getModel("soundtracks").get("soundtracks").each((function (e) {
                            var i = e.get("size");
                            i && (t += i)
                        }));
                        X.Z.resolveDataSizeSound(t)
                    }.bind(this))
                },
                hasIntegratedWireframe: function () {
                    var e = this._currentScene;
                    return !e._modelFile.wireframeUrl || !e._modelFile.wireframeSize
                },
                run: function () {
                    var e = (0, S.Z)(),
                        t = this.options.model,
                        n = this,
                        r = this.getOrCreateScene(t.toJSON()),
                        o = t.get("options"),
                        s = r.getJSON().animationCount > 0 || (0, g.Z)() && o.animation && o.animation.order && t.get("options").animation.order.length > 0;
                    X.Z.resolveHasAnimation(s), this._dataSizePromisesResolve(r);
                    var l = this.createContext({
                        model: t,
                        scene: r
                    }),
                        u = r._resourcePromises,
                        c = e.preload,
                        h = r._modelFile,
                        d = (0, S.Z)().wireframePreload || !(0, ri.Z)() && (e.uiInspector || !0 === o.wireframe.enable) && void 0 !== h.wireframeSize && h.wireframeSize > 0,
                        f = d && !0 === c,
                        m = d && this.hasIntegratedWireframe();
                    X.Z.resolveDataSizeWireframe(d ? h.wireframeSize : 0);
                    var p = d && !f,
                        v = p && !m,
                        _ = p ? X.Z.getHighResLoaded() : a().resolve(),
                        C = r.loadPolygon(this.updateProgress.bind(this), m, _, f);
                    u.push(C);
                    var T, M = li.Timer.instance().tick();
                    C.then((function () {
                        X.Z.resolvePolygon({
                            time: li.Timer.instance().tick() - M
                        })
                    })), !m && f && u.push(this.loadWireframeLegacy(r, this.updateProgress.bind(this))), e.cleanShader && u.push(i.e(4741).then(i.t.bind(i, "8Qi+", 23)).then((function (e) {
                        window.glslesPreprocessor = e
                    }))), li.time("createAndInitFeatures"), n._features.forEach((function (e) {
                        n.addFeature(e, l)
                    })), li.timeEnd("createAndInitFeatures"), this._progressManager.initPrimaryProgress(r.getOsgjsSize(), r.getPolygonSize(), f ? r.getWireframeSize() : 0), (0, ii.BG)() && (T = setInterval((function () {
                        x.Z.draw()
                    }), 200), X.Z.getInitialTextureBoundPromise().then((function () {
                        clearInterval(T)
                    }))), a().all(u).then(this._launchViewer.bind(this, l, v, M)), this._featuresInstancied = l.getFeatures();
                    var b = this._featuresInstancied.material.getModel().getMaterials();
                    return Re.Z.setMaterials(b), X.Z.getModelDisplayed()
                },
                _disableShaderAsyncCompilation: function () {
                    c.Z.instance().getWebGLExtensions().KHR_parallel_shader_compile = void 0
                },
                _setShaderAsyncCompilation: function () {
                    (0, S.Z)().asyncShader ? X.Z.getMaterial().then(function () {
                        var e = this._viewer.getCamera();
                        e.setFinalDrawCallback(function () {
                            0 !== Zt && this._viewer.requestRedraw(), e.setFinalDrawCallback(void 0), X.Z.resolveAsyncShaderCompilation()
                        }.bind(this))
                    }.bind(this)) : this._disableShaderAsyncCompilation()
                },
                _launchViewer: function (e, t, i) {
                    li.time("featureFinished"), this.featureFinished(e, this._rootScene), li.timeEnd("featureFinished"), t && X.Z.getHighResLoaded().then(this.loadWireframeLegacy.bind(this, this._currentScene, void 0)), li.time("wait async"), (X.Z.getAsyncShaderCompilation().isFulfilled() ? X.Z.getInitialTextureBoundPromise() : a().all([X.Z.getAsyncShaderCompilation(), X.Z.getInitialTextureBoundPromise()])).then(function () {
                        this.trigger("primary-progress", {
                            progress: 1
                        }), li.timeEnd("wait async"), n.Z.logBound(Pe.Z.getModelBoxWithoutDisplacement()), n.Z.showMessage(), this._onViewerLaunched(i), X.Z.getModelDisplayed().then(function () {
                            ((0, g.Z)() || (0, S.Z)().apiVersion) && this._disableShaderAsyncCompilation()
                        }.bind(this))
                    }.bind(this))
                },
                _startAnimation: function () {
                    this._featuresInstancied.animation.getModel().trigger("afterFirstVisibleFrame")
                },
                _afterTabVisible: function () {
                    var e, t = (0, ii.X2)();
                    e = function () {
                        this._featuresManager.setInitialAnimation(), this._startAnimation(), document.removeEventListener(t, e)
                    }.bind(this), document.addEventListener(t, e)
                },
                _hasFocusTab: function () {
                    var e = (0, ii.X2)();
                    return !(0, ii.BG)() || !e
                },
                _onViewerLaunched: function (e) {
                    var t = this._hasFocusTab();
                    (t && this._featuresManager.setInitialAnimation(), this.drawFrame(), t ? this._startAnimation() : this._afterTabVisible(), X.Z.resolveModelDisplayed({
                        time: li.Timer.instance().tick() - e
                    }), this.trigger("success"), this.trigger("viewerready"), (0, S.Z)().messaging) && ci.createMessage({
                        data: "ready"
                    }).appendToHash()
                },
                onFail: function (e, t) {
                    li.error(t.stack), e.reject(t), this.trigger("failure")
                },
                addFeature: function (e, t) {
                    if (!e) return console.warn("Feature undefined!"), !0;
                    var i = new e;
                    if (i.init(t), (0, g.Z)()) {
                        var n = i.getModel(),
                            r = i.getName();
                        n.editorSetJSON && !window.editorModels[r] && (window.editorModels[r] = {
                            setJSON: this._makeCallbackSetJSON(n),
                            getJSON: this._makeCallbackGetJSON(n)
                        })
                    }
                },
                _makeCallbackSetJSON: function (e) {
                    return function (t) {
                        var i = e.editorSetJSON(di(t));
                        return i && i.then ? i : i ? a().reject(i) : a().resolve()
                    }
                },
                _makeCallbackGetJSON: function (e) {
                    return function () {
                        var t = e.editorGetJSON();
                        return a().resolve(di(t))
                    }
                },
                drawFrame: function () {
                    this._viewer.requestRedraw(), this._viewer.frame()
                },
                getCanvas: function () {
                    return this._viewer.getGraphicContext().canvas
                },
                getInputManager: function () {
                    return this._viewer.getInputManager()
                },
                setTimeline: function (e) {
                    this._timeline = e
                },
                getTimeline: function () {
                    return this._timeline
                },
                getScreenShot: function (e, t, i) {
                    return (0, v.Z)(e, t, this, i)
                },
                getCamera: function () {
                    return this._viewer.getCamera()
                },
                getFeatures: function () {
                    return this._featuresInstancied
                },
                getSuperSample: function () {
                    return this._superSample
                },
                getFeaturesManager: function () {
                    return this._featuresManager
                },
                getViewerOSGJS: function () {
                    return this._viewer
                },
                getOrCreateScene: function (e) {
                    if (this._currentScene) return this._currentScene;
                    var t = new gi(e);
                    return t.getResourceManager().setStateContextOSG(this._viewer.getState()), this._currentScene = t, t
                },
                featureFinished: function (e, t) {
                    return this._featuresManager = new Le(this, e), this._featuresManager.finished(t)
                },
                getOptionsJSON: function () {
                    var e = this.getFeatures(),
                        t = {};
                    t.version = h.Z.optionsVersion, t.background = e.background.getModel().getJSON(), t.environment = e.environment.getModel().getJSON(), t.lighting = e.lighting.getModel().getJSON(), t.materials = e.material.getModel().getJSON(), t.orientation = e.orientation.getModel().getJSON(), t.camera = e.camera.getModel().getJSON(), t.animation = e.animation.getModel().getJSON(), t.hotspot = e.hotspot.getModel().getJSON(), t.vr = e.webVR.getModel().getJSON(), t.scene = t.scene || {}, t.scene.postProcess = e.postProcess.getModel().getJSON(), t.scene.sssProfiles = e.postProcess.getModel().getProfilesJSON(), t.sound = e.sound.getModel().getJSON(), t.ground = e.ground.getModel().getJSON();
                    var i = e.shadingStyle.getModel().getJSON();
                    return t.shading = i.shading, t.wireframe = i.wireframe, G.readOptions(t)
                }
            })
        },
        G1IL: (e, t, i) => {
            i.d(t, {
                Z: () => _
            });
            var n = i("aqzA"),
                r = i("aMVL"),
                a = i("gvzH"),
                o = i("MQQR"),
                s = n.Z.osg,
                l = n.Z.osgUtil,
                u = n.Z.osgAnimation,
                c = a.Z.SHADOW | a.Z.PICK_GEOMETRY_ANIMATED;
            u.MorphGeometry.MAX_MORPH_GPU = Math.min(4, (0, o.Z)().morphGpu);
            var h = l.IntersectionVisitor.prototype.enter;
            l.IntersectionVisitor.prototype.enter = function (e) {
                return !!e._forceEnterIntersection || h.call(this, e)
            };
            var d = function () { };
            s.createPrototypeObject(d, {
                cull: function () {
                    return !1
                }
            }, "osgtestdemo2024", "HideCullCallback");
            var g = new d,
                f = s.vec3.create(),
                m = s.vec3.create(),
                p = function (e, t) {
                    s.NodeVisitor.call(this), this._wirePromise = r.Z.getWireframeOptimized(), this._wireNodes = t.getOrCreateScene().getWireframeNodes(), this.nodeMaskOverride = -1, this._visitedNodes = {}, this._rigIndexed = [], this._boneGeomIndexed = [], this._skls = e;
                    var i = t.getFeatures().material.getModel(),
                        n = s.WebGLCaps.instance();
                    this._maxVA = n.getWebGLParameter("MAX_VERTEX_ATTRIBS");
                    var a = 0;
                    a += 1, a += 1, a += 1, a += 3, a += 3, a += 4, a += 4, a += 4, a += 4, a += 1, a += 1, a += 1, a += 1, a += 1, a += 1, a += 1, a += 1, a += 1, a += 1, a += 1 * i.getMaxUvCount(), a = Math.ceil(a);
                    var l = n.getWebGLParameter("MAX_VERTEX_UNIFORM_VECTORS");
                    l = Math.min(l, (0, o.Z)().maxVertexUniforms), this._maxBones = Math.floor((l - a) / 3), u.SkinningAttribute.maxBoneUniformAllowed = 3 * this._maxBones, this._minUniformsRequired = a + 39
                };
            s.createPrototypeObject(p, s.objectInherit(s.NodeVisitor.prototype, {
                createSplitRigGeometry: function (e) {
                    var t = new u.RigGeometry;
                    t.setName("Split (" + e.getInstanceID() + ")"), t.setStateSet(e.getStateSet()), t.setUserData(e.getUserData()), t.userDataMap = e.userDataMap, t.setSourceGeometry(e.getSourceGeometry()), t._forceEnterIntersection = !0, t.setNodeMask(e.getNodeMask());
                    var i = e.getVertexAttributeList(),
                        n = t.getVertexAttributeList();
                    for (var r in i) n[r] = i[r];
                    var a = i.Bones.getElements(),
                        o = new a.constructor(a.length);
                    n.Bones = new s.BufferArray(s.BufferArray.ARRAY_BUFFER, o, i.Bones.getItemSize(), !0), t.userDataMap.wireframe && this._wireNodes.push(t);
                    var l = t.userDataMap.rigIndex;
                    return void 0 !== l && (this._rigIndexed[l] = t), t._boundingSphereComputed = !0, t._boundingBoxComputed = !0, t
                },
                checkVertex: function (e, t) {
                    var i = t.baseBones,
                        n = t.baseWeights,
                        r = t.mappedUsedBones,
                        a = 0;
                    return n[e] && !r[i[e]] && a++, n[e + 1] && !r[i[e + 1]] && a++, n[e + 2] && !r[i[e + 2]] && a++, n[e + 3] && !r[i[e + 3]] && a++, a
                },
                tagBoneVertex: function (e, t) {
                    var i = t.baseBones,
                        n = t.baseWeights,
                        r = t.mappedUsedBones,
                        a = t.boneNameID,
                        o = t.boneToName,
                        s = i[e];
                    n[e] && !r[s] && (a[o[s]] = t.nbUsedBones, r[s] = ++t.nbUsedBones), t.newBones[e] = r[s] - 1, s = i[e + 1], n[e + 1] && !r[s] && (a[o[s]] = t.nbUsedBones, r[s] = ++t.nbUsedBones), t.newBones[e + 1] = r[s] - 1, s = i[e + 2], n[e + 2] && !r[s] && (a[o[s]] = t.nbUsedBones, r[s] = ++t.nbUsedBones), t.newBones[e + 2] = r[s] - 1, s = i[e + 3], n[e + 3] && !r[s] && (a[o[s]] = t.nbUsedBones, r[s] = ++t.nbUsedBones), t.newBones[e + 3] = r[s] - 1
                },
                splitTriangle: function (e, t, i, n) {
                    if (n.currentIdPrimitive++, e === t || e === i || t === i || n.processedPrimitive[n.currentIdPrimitive - 1]) return !0;
                    var r = n.nbUsedBones,
                        a = this.checkVertex(4 * e, n);
                    if (r + a < this._maxBones && (a += this.checkVertex(4 * t, n)), r + a < this._maxBones && (a += this.checkVertex(4 * i, n)), r + a >= this._maxBones) n.finished = !1;
                    else {
                        this.tagBoneVertex(4 * e, n), this.tagBoneVertex(4 * t, n), this.tagBoneVertex(4 * i, n);
                        var o = n.first + n.countIdPrimitive;
                        n.countIdPrimitive += 3, n.newIndexesElements[o] = e, n.newIndexesElements[o + 1] = t, n.newIndexesElements[o + 2] = i, n.processedPrimitive[n.currentIdPrimitive - 1] = 1
                    }
                },
                splitLine: function (e, t, i) {
                    if (i.currentIdPrimitive++, e === t || i.processedPrimitive[i.currentIdPrimitive - 1]) return !0;
                    var n = i.nbUsedBones,
                        r = this.checkVertex(4 * e, i);
                    if (n + r < this._maxBones && (r += this.checkVertex(4 * t, i)), n + r >= this._maxBones) i.finished = !1;
                    else {
                        this.tagBoneVertex(4 * e, i), this.tagBoneVertex(4 * t, i);
                        var a = i.first + i.countIdPrimitive;
                        i.countIdPrimitive += 2, i.newIndexesElements[a] = e, i.newIndexesElements[a + 1] = t, i.processedPrimitive[i.currentIdPrimitive - 1] = 1
                    }
                },
                callbackDrawElementsTriangles: function (e, t, i) {
                    for (var n = 0; n < e; n += 3) this.splitTriangle(t[n], t[n + 1], t[n + 2], i)
                },
                callbackDrawElementsTriangleStrip: function (e, t, i) {
                    for (var n = 2, r = 0; n < e; ++n, ++r) n % 2 ? this.splitTriangle(t[r], t[r + 2], t[r + 1], i) : this.splitTriangle(t[r], t[r + 1], t[r + 2], i)
                },
                callbackDrawElementsLines: function (e, t, i) {
                    for (var n = 0; n < e; n += 2) this.splitLine(t[n], t[n + 1], i)
                },
                splitPrimitive: function (e, t) {
                    e.finished = !0;
                    var i = e.baseRig,
                        n = e.primitive,
                        r = this.createSplitRigGeometry(i);
                    e.boneNameID = r._boneNameID, e.newBones = r.getVertexAttributeList().Bones.getElements(), e.mappedUsedBones = new Uint32Array(t), e.nbUsedBones = 0, e.currentIdPrimitive = 0, e.countIdPrimitive = 0;
                    var a = n.getIndices().getElements(),
                        o = n.getCount(),
                        l = n.getMode();
                    if (l === s.primitiveSet.TRIANGLE_STRIP ? this.callbackDrawElementsTriangleStrip(o, a, e) : l === s.primitiveSet.TRIANGLES ? this.callbackDrawElementsTriangles(o, a, e) : this.callbackDrawElementsLines(o, a, e), 0 === e.countIdPrimitive) {
                        var u = "Only " + this._maxBones + " bones supported per draw call (min is 13)";
                        return u += "\nMinium uniforms count should be " + this._minUniformsRequired, console.warn(u), !1
                    }
                    var c = new s.DrawElements(l === s.primitiveSet.LINES ? s.primitiveSet.LINES : s.primitiveSet.TRIANGLES, e.newIndexesBuffer);
                    c.setFirst(e.first * e.newIndexesElements.BYTES_PER_ELEMENT), c.setCount(e.countIdPrimitive), e.first += e.countIdPrimitive, r.getPrimitives().push(c);
                    for (var h = i.getParents(), d = h.length, g = 0; g < d; ++g) h[g].addChild(r);
                    return !e.finished
                },
                getBoneToNames: function (e, t) {
                    for (var i = t.length, n = new Array(i), r = 0; r < i; ++r) {
                        var a = t[r];
                        n[e[a]] = a
                    }
                    return n
                },
                splitRigGeometry: function (e) {
                    for (var t = e._boneNameID, i = Object.keys(t), n = i.length, r = e.getPrimitives(), a = r.length, o = {
                        baseRig: e,
                        baseWeights: e.getVertexAttributeList().Weights.getElements(),
                        baseBones: e.getVertexAttributeList().Bones.getElements(),
                        boneToName: this.getBoneToNames(e._boneNameID, i)
                    }, l = 0; l < a; ++l) {
                        var u = r[l],
                            c = u.getMode();
                        if (0 !== u.getCount())
                            if (u instanceof s.DrawElements != !1)
                                if (c === s.primitiveSet.TRIANGLE_STRIP || c === s.primitiveSet.TRIANGLES || c === s.primitiveSet.LINES) {
                                    var h = u.getIndices(),
                                        d = h.getElements(),
                                        g = c === s.primitiveSet.TRIANGLE_STRIP ? 3 : 1;
                                    for (o.newIndexesElements = new d.constructor(u.getCount() * g), o.newIndexesBuffer = new s.BufferArray(s.BufferArray.ELEMENT_ARRAY_BUFFER, o.newIndexesElements, h.getItemSize(), !0), o.first = u.getFirst(), o.processedPrimitive = new Uint8Array(u.getCount()), o.primitive = u; this.splitPrimitive(o, n););
                                    o.newIndexesBuffer.setElements(o.newIndexesElements.subarray(0, o.first))
                                } else s.error("Split rigged primitives mode not yet handled : ", c);
                            else s.error("Split rigged primitives type not yet handled", u)
                    }
                },
                handleRigGeometry: function (e) {
                    var t = e._boneNameID,
                        i = e.userDataMap.wireframe,
                        n = e.userDataMap.rigIndex;
                    void 0 !== n && (this._rigIndexed[n] = e), this._maxBones < Object.keys(t).length && (i ? (e._boundingBoxComputed = !0, e._boundingSphereComputed = !0, this._wirePromise.then(this.splitRigGeometry.bind(this, e))) : this.splitRigGeometry(e), e.setCullCallback(g)), this.tagForceIntersection()
                },
                tagForceIntersection: function () {
                    for (var e = this._skls[this._skls.length - 1], t = 1 + this.nodePath.indexOf(e); t < this.nodePath.length; ++t) this.nodePath[t]._forceEnterIntersection = !0
                },
                popTargetAttribute: function (e, t, i) {
                    for (var n = t.getMorphTargets(), r = n.length, a = e.getVertexAttributeList(), o = t.getVertexAttributeList(), s = 0; s < r; ++s) {
                        delete n[s].getVertexAttributeList()[i];
                        var l = i + "_" + s;
                        delete a[l], a !== o && delete o[l]
                    }
                },
                computeUsedVA: function (e, t, i, n) {
                    var r = Object.keys(e).length - Object.keys(t).length * (i.length - Math.min(n, i.length));
                    return e.Color || r++, r
                },
                handleMorphGeometry: function (e, t) {
                    var i = t.getMaximumPossibleMorphGPU(),
                        n = t.getMorphTargets(),
                        r = n[0].getVertexAttributeList(),
                        a = e.getVertexAttributeList(),
                        o = this.computeUsedVA(a, r, n, i),
                        s = this._maxVA;
                    if (!(o <= s || a.Tangent_1 && (this.popTargetAttribute(e, t, "Tangent"), (o = this.computeUsedVA(a, r, n, i)) <= s) || a.Normal_1 && (this.popTargetAttribute(e, t, "Normal"), (o = this.computeUsedVA(a, r, n, i)) <= s))) {
                        for (; i > 0;)
                            if (i--, t.setMaximumPossibleMorphGPU(i), (o = this.computeUsedVA(a, r, n, i)) <= s) return;
                        console.warn("Too much vertex attributes!")
                    }
                },
                apply: function (e) {
                    var t = e.getInstanceID();
                    if (!this._visitedNodes[t]) {
                        this._visitedNodes[t] = !0;
                        var i, n, r, o = e instanceof u.RigGeometry,
                            l = o ? e.getSourceGeometry() : e,
                            h = l instanceof u.MorphGeometry;
                        if (o && e.separateStaticBoxInGeometry(g, a.Z.PICK_GEOMETRY_RIG_BOX | a.Z.SHADOW_BOUNDS), !h && !o || e.userDataMap.wireframe || e.setNodeMask(c), h && this.handleMorphGeometry(e, l), o) this.handleRigGeometry(e);
                        else if (e instanceof u.Bone) {
                            var d = e.getBoneBoundingBox();
                            if (d.valid()) {
                                d.center(f), s.vec3.sub(m, d.getMax(), d.getMin());
                                var p = (i = f, n = m, (r = s.createTexturedBoxGeometry(i[0], i[1], i[2], n[0], n[1], n[2])).setName("BoneBox"), r.getOrCreateStateSet().setShaderGeneratorName("debugBoneBox"), r.setCullCallback(g), r._isBoneBox = !0, r.setNodeMask(a.Z.PICK_GEOMETRY_RIG_BOX | a.Z.SHADOW_BOUNDS), r);
                                e.addChild(p), e.userDataMap.apexes = function (e, t) {
                                    return [
                                        [e[0] + .5 * t[0], e[1], e[2]],
                                        [e[0] - .5 * t[0], e[1], e[2]],
                                        [e[0], e[1] + .5 * t[1], e[2]],
                                        [e[0], e[1] - .5 * t[1], e[2]],
                                        [e[0], e[1], e[2] + .5 * t[2]],
                                        [e[0], e[1], e[2] - .5 * t[2]]
                                    ]
                                }(f, m), void 0 !== e.userDataMap.rigIndex && this._boneGeomIndexed.push(p)
                            }
                        } else e instanceof u.Skeleton && this._skls.push(e);
                        this.traverse(e)
                    }
                }
            }), "osgtestdemo2024", "InitVisitor");
            var v = {};
            v.hideCullCallback = g, v.init = function (e, t) {
                var i = new p(e, t),
                    n = t.getRootModel();
                s.time("InitGraphAnimation"), n.accept(i), s.timeEnd("InitGraphAnimation");
                for (var r = i._boneGeomIndexed, a = i._rigIndexed, o = r.length, l = 0; l < o; ++l) {
                    var u = r[l];
                    u._mostInfluencedRig = a[u.getParents()[0].userDataMap.rigIndex]
                }
            };
            const _ = v
        },
        jXe1: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = i("aqzA"),
                r = n.Z.osg,
                a = n.Z.osgAnimation;
            const o = function (e) {
                for (var t = 0, i = e.length; t < i; ++t) {
                    var n, o = e[t];
                    if (o instanceof a.Bone) n = a.UpdateBone;
                    else {
                        if (!(o instanceof r.MatrixTransform)) continue;
                        n = a.UpdateMatrixTransform
                    }
                    for (var s = o.getUpdateCallbackList(), l = 0, u = s.length; l < u; ++l)
                        if (s[l] instanceof n) return !0
                }
                return !1
            }
        },
        UpLw: (e, t, i) => {
            i.d(t, {
                Z: () => h
            });
            var n = i("aqzA"),
                r = i("+cmV"),
                a = i("WoEt"),
                o = n.Z.osg,
                s = [o.primitiveSet.TRIANGLES, o.primitiveSet.TRIANGLE_STRIP, o.primitiveSet.TRIANGLE_FAN],
                l = [o.primitiveSet.LINES, o.primitiveSet.LINE_LOOP, o.primitiveSet.LINE_STRIP],
                u = function (e, t) {
                    var i = t.getItemSize(),
                        n = t.getElements(),
                        r = 1;
                    1 === n.BYTES_PER_ELEMENT ? r = 255 : 2 === n.BYTES_PER_ELEMENT && (r = 65535);
                    var o = !1,
                        s = n.length,
                        l = 0;
                    if (4 === i) {
                        var u = !0,
                            c = !0;
                        for (l = 3; l < s; l += 4) {
                            var h = n[l];
                            if (0 !== h && (u = !1), h !== r && (c = !1), !u && !c) break
                        }
                        if (u && 4 === i)
                            for (l = 3; l < s; l += 4) n[l] = r;
                        o = !u && !c
                    }
                    var d = !0;
                    if (!o) {
                        var g = !0;
                        for (l = 0; l < s && (n[l] !== r && (g = !1), n[l + 1] !== r && (g = !1), n[l + 2] !== r && (g = !1), g); l += i);
                        g && delete e.getVertexAttributeList().Color, d = !g
                    }
                    o && (a.Z.hasVertexAlpha = e.userDataMap.hasVertexAlpha = !0), d && (a.Z.hasVertexColor = !0)
                },
                c = function (e) {
                    for (var t = e.getPrimitiveSetList(), i = t.length, n = !1, a = !1, u = !1, c = void 0 !== e.getVertexAttributeList().Normal, h = 0; h < i; ++h) {
                        var d = t[h].getMode();
                        0 !== t[h].getCount() && (n || (n = d === o.primitiveSet.POINTS), u || (u = -1 !== s.indexOf(d)), a || (a = -1 !== l.indexOf(d)))
                    }
                    r.Z.hasPoints || (r.Z.hasPoints = n), r.Z.hasTriangles || (r.Z.hasTriangles = u), r.Z.hasLines || (r.Z.hasLines = a), r.Z.hasVertexNormals || (r.Z.hasVertexNormals = c), e.userDataMap.hasPoints = n, e.userDataMap.hasTriangles = u, e.userDataMap.hasLines = a
                };
            const h = function () {
                for (var e in r.Z.instanceIDGeometryMap) {
                    var t = r.Z.instanceIDGeometryMap[e];
                    if (!t.userDataMap.wireframe) {
                        var i = t.getVertexAttributeList().Color;
                        i && u(t, i), c(t)
                    }
                }
                r.Z.instanceIDGeometryMap = {}
            }
        },
        U6YP: (e, t, i) => {
            i.d(t, {
                Z: () => Eg
            });
            var n = i("tEGF"),
                r = i("QX1t"),
                a = i("bWy4"),
                o = i("WGQk"),
                s = i("CUcOv"),
                l = i("MQQR"),
                u = a.Z.extend({
                    getModelOptionPath: function () {
                        return "animation"
                    },
                    defaults: function () {
                        var e = this.getResourceManager().getAnimationCollection(),
                            t = [];
                        return (0, o.Z)() || (t = e.remove(e.where({
                            isEnabled: !1
                        }))), {
                            animations: e,
                            disabledAnimations: t,
                            currentUID: "-1",
                            playing: !0,
                            fps: -1,
                            progress: 0
                        }
                    },
                    getName: function () {
                        return "Animation"
                    },
                    getResourceManager: function () {
                        return this._resourceManager || s.Z.instance
                    },
                    getAnimationByUID: function (e) {
                        return this.get("animations").find((function (t) {
                            return t.get("uid") === e
                        }))
                    },
                    getCurrentAnimation: function () {
                        return this.getAnimationByUID(this.get("currentUID"))
                    },
                    canActivateTAA: function () {
                        return !this.isPlaying() || (0, l.Z)().taaAnimation
                    },
                    isPlaying: function () {
                        return !!this.get("animations").length && (!!this.get("playing") && "-1" !== this.get("currentUID"))
                    },
                    getEnabledAnimationsCount: function () {
                        return this.get("animations").where({
                            isEnabled: !0
                        }).length
                    },
                    getFirstEnabledAnimation: function () {
                        for (var e = this.get("animations"), t = e.length, i = 0; i < t; ++i) {
                            var n = e.at(i);
                            if (n && n.get("isEnabled")) return n
                        }
                    },
                    init: function (e) {
                        this._viewer = e.getViewer();
                        var t = e.getModel().get("options").animation;
                        t && t.order && (this.setJSON(t), this.set("playing", (0, l.Z)().animationAutoplay))
                    },
                    setJSON: function (e, t) {
                        var i = t || {};
                        i.ignore = ["order"], a.Z.prototype.setJSON.call(this, e, i);
                        var n = this.get("animations"),
                            o = (0, r.Z)(e.order);
                        n.forEach((function (e) {
                            e.set("order", parseInt(o[e.get("uid")], 10))
                        })), n.sort()
                    },
                    getJSON: function () {
                        for (var e = a.Z.prototype.getJSON.call(this), t = this.get("animations").pluck("uid"), i = this.get("disabledAnimations"), n = 0; n < i.length; ++n) t.push(i[n].get("uid"));
                        return e.order = t, e
                    }
                });
            const c = u;
            var h = i("lZH+"),
                d = i.n(h),
                g = i("aqzA"),
                f = i("+cmV");
            const m = function (e, t, i) {
                for (var n = e.length / i, r = 0; r < n; ++r)
                    for (var a = r * i, o = 0; o < i; ++o) t[a + o] = e[r + n * o];
                return t
            };
            const p = function (e, t) {
                for (var i = t || 1, n = 1, r = e.length / i; n < r; ++n)
                    for (var a = (n - 1) * i, o = n * i, s = 0; s < i; ++s) e[o + s] += e[a + s];
                return e
            };
            const v = function (e) {
                for (var t = 1, i = e.length / 4; t < i; ++t) {
                    var n = 4 * (t - 1),
                        r = 4 * t,
                        a = e[n],
                        o = e[n + 1],
                        s = e[n + 2],
                        l = e[n + 3],
                        u = e[r],
                        c = e[r + 1],
                        h = e[r + 2],
                        d = e[r + 3];
                    e[r] = a * d + o * h - s * c + l * u, e[r + 1] = -a * h + o * d + s * u + l * c, e[r + 2] = a * c - o * u + s * d + l * h, e[r + 3] = -a * u - o * c - s * h + l * d
                }
                return e
            };
            var _ = i("H+3W"),
                S = i("vNR5"),
                x = i("IuDx"),
                C = g.Z.osg,
                T = g.Z.osgDB,
                M = g.Z.osgAnimation,
                b = g.Z.osgWrappers.osgAnimation,
                y = M.Channel,
                A = function () { },
                R = T.registry();
            R.registerObject("osgAnimation.Vec3LerpChannelCompressedPacked", A), R.registerObject("osgAnimation.Vec3LerpChannelCompressed", A), R.registerObject("osgAnimation.Vec3LerpChannelPacked", A), R.registerObject("osgAnimation.QuatSlerpChannelCompressedPacked", A), R.registerObject("osgAnimation.QuatSlerpChannelCompressed", A), R.registerObject("osgAnimation.QuatSlerpChannelPacked", A), R.registerObject("osgAnimation.FloatLerpChannelCompressedPacked", A), R.registerObject("osgAnimation.FloatLerpChannelCompressed", A), R.registerObject("osgAnimation.FloatLerpChannelPacked", A);
            var w = {},
                E = (new s.Z)._resourceLoader,
                P = 1,
                N = 4,
                O = 8,
                D = 16,
                I = function (e, t, i, n, r, a) {
                    var o, s = t.ItemSize,
                        l = Object.keys(t.Array)[0],
                        u = t.Array[l],
                        c = u.Offset ? u.Offset : 0,
                        h = u.Size,
                        d = i.channel_mode || 0,
                        g = !!(1 === a ? d & D : d & N),
                        f = new ArrayBuffer(4 * (g ? h + 2 : h + 1) * a),
                        T = new Float32Array(f, g ? 4 * a : 0, h * a);
                    return o = u.Encoding && "varint" === u.Encoding ? (0, _.Z)(new Uint8Array(e, c), s * h, l) : new C[l](e, c, s * h), 4 === a && d & O ? (r && (o = m(o, new Float32Array(o.length), s)), (0, x.Z)(o, T, a, i.epsilon, i.nphi, !0), g && ((T = new Float32Array(f, 0, (h + 1) * a))[0] = i.ox, T[1] = i.oy, T[2] = i.oz, T[3] = i.ow, v(T)), T) : (r && 1 !== a ? m(o, T, s) : T.set(o), n ? (3 === a && d & P && (0, S.Z)(T, T, [i.bx, i.by, i.bz], [i.hx, i.hy, i.hz], a), g && (T = new Float32Array(f, 0, (h + 1) * a), 3 === a ? (T[0] = i.ox, T[1] = i.oy, T[2] = i.oz) : T[0] = i.ot, p(T, s)), T) : T)
                },
                F = function (e, t, i, n, r, a) {
                    var o = e.getJSON();
                    if (!(void 0 !== o.TargetName && o.KeyFrames && o.Name && o.KeyFrames.Time && o.KeyFrames.Key)) return d().reject(new Error);
                    var s = o.UserDataContainer,
                        l = s ? f.Z.convertUserDataToObject(e.setJSON(s).readUserDataContainer()) : w;
                    return E.getBinaryArray(e.getOptions().currentAnimationUID).getPromise().then((function (e) {
                        var s = I(e, o.KeyFrames.Time, l, n, !1, 1),
                            u = I(e, o.KeyFrames.Key, l, n, r, a);
                        return i(u, s, o.TargetName, o.Name, t), t
                    }))
                };
            b.Vec3LerpChannel = function (e, t) {
                return F(e, t, y.createVec3Channel, !1, !1, 3)
            }, b.Vec3LerpChannelCompressedPacked = function (e, t) {
                return F(e, t, y.createVec3Channel, !0, !0, 3)
            }, b.Vec3LerpChannelCompressed = function (e, t) {
                return F(e, t, y.createVec3Channel, !0, !1, 3)
            }, b.Vec3LerpChannelPacked = function (e, t) {
                return F(e, t, y.createVec3Channel, !1, !0, 3)
            }, b.QuatSlerpChannel = function (e, t) {
                return F(e, t, y.createQuatChannel, !1, !1, 4)
            }, b.QuatSlerpChannelCompressedPacked = function (e, t) {
                return F(e, t, y.createQuatChannel, !0, !0, 4)
            }, b.QuatSlerpChannelCompressed = function (e, t) {
                return F(e, t, y.createQuatChannel, !0, !1, 4)
            }, b.QuatSlerpChannelPacked = function (e, t) {
                return F(e, t, y.createQuatChannel, !1, !0, 4)
            }, b.FloatLerpChannel = function (e, t) {
                return F(e, t, y.createFloatChannel, !1, !1, 1)
            }, b.FloatLerpChannelCompressedPacked = function (e, t) {
                return F(e, t, y.createFloatChannel, !0, !0, 1)
            }, b.FloatLerpChannelCompressed = function (e, t) {
                return F(e, t, y.createFloatChannel, !0, !1, 1)
            }, b.FloatLerpChannelPacked = function (e, t) {
                return F(e, t, y.createFloatChannel, !1, !0, 1)
            };
            var L = i("aMVL"),
                V = i("nv4P"),
                B = i("G1IL"),
                U = i("qk4i"),
                k = g.Z.osg,
                Z = g.Z.osgAnimation,
                H = g.Z.osgWrappers,
                G = H.osg,
                z = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.model;
                        e.bind("change:playing", this.onPlayingChanged, this), e.bind("change:speed", this.onSpeedChanged, this), e.bind("change:currentUID", this.onCurrentAnimationChanged, this), e.bind("afterFirstVisibleFrame", this.onAfterFirstVisibleFrame, this), e.bind("seek", this.onSeek, this), this._manager = null, this._idLoop = 0, this._loopEnded = !1, this._skeletons = [], this._viewer = this.options.context.getViewer(), this._firstAnimationPlayed = !1, this._animationPromises = [], this._hookBasicAnimationManager(L.Z.getPolygon()), L.Z.getMaterial().then(this._initAnimation.bind(this)), L.Z.getModelDisplayed().then(this._resolveAllAnimations.bind(this))
                    },
                    onAfterFirstVisibleFrame: function () {
                        this._manager && (this.model.set("playing", (0, l.Z)().animationAutoplay), this.onCurrentAnimationChanged())
                    },
                    _resolveAllAnimations: function () {
                        0 === this._animationPromises.length ? (L.Z.resolveFirstAnimation(), L.Z.resolveAllAnimations()) : d().all(this._animationPromises).then(L.Z.resolveAllAnimations.bind(L.Z))
                    },
                    _initAnimation: function () {
                        if (this._manager) this.onSpeedChanged(), B.Z.init(this._skeletons, this._viewer), L.Z.getWireframeOptimized().then(L.Z.resolveWireframeOptimizedSplit.bind(L.Z));
                        else {
                            if (f.Z.hasRigsOrMorphs) {
                                if (f.Z.hasMorphs) {
                                    var e = this.model.get("animations");
                                    if (!e || !e.length) f.Z.hasMorphs && console.warn("Morph without UpdateMorphs tracks! No MorphAttributes in stateset")
                                }
                                B.Z.init(this._skeletons, this._viewer)
                            }
                            L.Z.getWireframeOptimized().then(L.Z.resolveWireframeOptimizedSplit.bind(L.Z))
                        }
                    },
                    _getHookUpdateManager: function () {
                        var e = this,
                            t = Z.BasicAnimationManager.prototype.updateManager;
                        return function (i) {
                            var n = e.getCurrentInstanceAnimation();
                            return !(n && !e._loopEnded) || (-1 === this._seekTime && this._pause || U.Z.draw(), i = e._detectAnimationEnd(i, n), i = e._snapTimeOnFrame(i, n), t.call(this, i))
                        }
                    },
                    _snapTimeOnFrame: function (e, t) {
                        var i = this.model.get("fps");
                        if (i <= 0) return e;
                        var n = 1 / i,
                            r = (e - t.start) % n;
                        return Math.abs(r) > .5 * n ? e + (n - r) : e - r
                    },
                    _detectAnimationEnd: function (e, t) {
                        var i, n, r, a = e < 0 ? -1 : 1;
                        if (1 === a) {
                            if (i = e - t.start, n = (i = Math.max(0, i)) % t.duration * 100 / t.duration, (r = Math.floor(i / t.duration)) <= this._idLoop) return this._idLoop = r, this.model.set("progress", n), e
                        } else if (i = t.start + t.duration + e, i = Math.min(t.start + t.duration - .01, i), n = 100 - (n = 100 * Math.abs(i % t.duration) / t.duration), (r = Math.abs(Math.round(Math.abs((i + .02) / t.duration)))) <= this._idLoop) return this._idLoop = r, this.model.set("progress", n), e;
                        return t = this.getCurrentInstanceAnimation(), this._viewer.trigger("animationEnded", t.name), this._onAnimationEnd(), this._loopEnded ? (e = 1 === a ? t.duration - .01 : 0, this.model.set("progress", 100)) : (this._idLoop = r, (t = this.getCurrentInstanceAnimation()) && (this._viewer.trigger("animationBegan", t.name), e = 1 === a ? t.start : t.start + t.duration - .01), this.model.set("progress", 0)), e
                    },
                    _onAnimationEnd: function () {
                        var e = this.model.get("cycleMode");
                        if ("oneAndStop" === e) return this.model.set("playing", !1), void (this._loopEnded = !0);
                        if ("one" !== e) {
                            for (var t, i = this.model.get("animations"), n = "-1", r = i.indexOf(this.getCurrentAnimation()) + 1, a = i.length; r < a; ++r)
                                if ((t = i.at(r)) && t.get("isEnabled")) {
                                    n = t.get("uid");
                                    break
                                }
                            if ("-1" === n && "all" === e) {
                                var o = this.model.getFirstEnabledAnimation();
                                n = o ? o.get("uid") : "-1"
                            }
                            "-1" !== n ? this.model.set("currentUID", n) : (this.model.set("playing", !1), this._loopEnded = !0)
                        } else this.model.trigger("cycleMode")
                    },
                    _debugSnapKeyFrameHook: function () {
                        (0, l.Z)().snapKeyframe && (Z.BasicAnimationManager.prototype._updateChannelsType = function (e, t, i) {
                            for (var n = 0, r = t.length; n < r; n++) {
                                var a = t[n],
                                    o = a.instanceAnimation,
                                    s = o.loop,
                                    l = e - a.t;
                                s && o.duration > 0 && (l %= o.duration), l += o.firstKeyTime;
                                var u = a.channel;
                                if (l > u.start && l < u.end) {
                                    var c = u.times,
                                        h = a.key;
                                    if (l > c[h])
                                        for (; c[h + 1] < l;) h++;
                                    else if (l < c[h])
                                        for (; c[h] > l;) h--;
                                    var d = c[h],
                                        g = c[h + 1];
                                    l = Math.abs(l - d) < Math.abs(l - g) ? d : g
                                }
                                i(l, a)
                            }
                        })
                    },
                    _hookBasicAnimationManager: function (e) {
                        var t = this,
                            i = this._animationPromises,
                            n = this._getHookUpdateManager();
                        this._debugSnapKeyFrameHook(), H.osgAnimation.BasicAnimationManager = function (r, a) {
                            var o = r.getJSON();
                            return o.Animations ? (G.Object(r, a), L.Z.OSG_VERSION < 8 ? d().resolve(a) : t._manager ? (k.error("More than one basicAnimationManager !"), d().resolve(a)) : (t._manager = a, t.model.get("playing") || a.togglePause(), a.updateManager = n, e.then((function () {
                                var e = r.getOptions();
                                e.progress = void 0;
                                for (var n = o.Animations.length, a = 0; a < n; ++a) {
                                    var s = o.Animations[a],
                                        l = r.setJSON(s["osgAnimation.Animation"].UserDataContainer).readUserDataContainer(),
                                        u = f.Z.convertUserDataToObject(l),
                                        c = t.model.getAnimationByUID(u.AnimationUID);
                                    if (c) {
                                        e.currentAnimationUID = c.get("url");
                                        var h = r.setJSON(s).readObject();
                                        h.isRejected() ? k.Notify.warn("An Animation failed on the parsing!") : (h.then(t.onAddAnimation.bind(t, a, u)), i.push(h))
                                    }
                                }
                            })), d().resolve(a))) : d().reject(new Error)
                        }
                    },
                    onAddAnimation: function (e, t, i) {
                        var n = t.AnimationUID;
                        i.name = n, i.duration || (i.duration = 2.5, i.still = !0), this._manager.addAnimations([i]), 0 === i.duration && (this._manager.getAnimations()[n].duration = 2.5);
                        var r = this.model;
                        r.trigger("change:animations");
                        var a = r.getAnimationByUID(n);
                        a.on("change:isLoop", this.onAnimationChangeLoop.bind(this)), a.get("isLoop") && this.onAnimationChangeLoop(a), this.model.get("currentUID") === n && this.onCurrentAnimationChanged(), this._firstAnimationPlayed || (this._playFirstAnimation(n) && (this._firstAnimationPlayed = !0, this.model.set("currentUID", n)), L.Z.getModelDisplayed().then(L.Z.resolveFirstAnimation.bind(L.Z)))
                    },
                    _playFirstAnimation: function (e) {
                        if (this.model.get("initializeWithRestPose")) return !1;
                        var t = this.model.getFirstEnabledAnimation();
                        return t && e === t.get("uid")
                    },
                    onAnimationChangeLoop: function (e) {
                        var t = this._manager.getAnimations()[e.get("uid")];
                        this._manager.setAnimationLerpEndStart(t, e.get("isLoop") ? 1 / 30 : 0)
                    },
                    onCurrentAnimationChanged: function () {
                        this._loopEnded = !1, this._idLoop = 0;
                        var e = this._manager;
                        if (e.stopAllAnimation(), e.resetUpdateCallbacks(), this.getCurrentAnimation()) {
                            var t = this.getCurrentInstanceAnimation();
                            t && (e.playAnimation(t), e.setSeekTime(t.start))
                        }
                        var i = this.getCurrentAnimation();
                        i ? (this._viewer.trigger("animationChange", i.get("uid")), (0, o.Z)() && this.model.set("initializeWithRestPose", !1)) : (0, o.Z)() && this.model.set("initializeWithRestPose", !0), U.Z.draw()
                    },
                    getCurrentAnimation: function () {
                        return this.model.getCurrentAnimation()
                    },
                    getCurrentInstanceAnimation: function () {
                        var e = this.getCurrentAnimation();
                        return e ? this._manager.getAnimations()[e.get("uid")] : void 0
                    },
                    onPlayingChanged: function () {
                        if (this._manager) {
                            if (this._loopEnded) {
                                this._loopEnded = !1;
                                var e = this.model.getFirstEnabledAnimation().get("uid") || "-1";
                                e === this.getCurrentAnimation().get("uid") ? this.model.trigger("seek", 0) : this.model.set("currentUID", e)
                            }
                            this._viewer.trigger(this.model.get("playing") ? "animationPlay" : "animationStop"), this._manager.togglePause(), U.Z.draw()
                        }
                    },
                    onSeek: function (e) {
                        var t = this.getCurrentInstanceAnimation();
                        if (t) {
                            this._loopEnded = !1;
                            var i = Math.min(t.duration - .01, t.duration * e / 100);
                            this._manager.setSeekTime(t.start + i / this._manager.getTimeFactor()), U.Z.draw(), U.Z.redrawShadow()
                        }
                    },
                    onSpeedChanged: function () {
                        this._manager.setTimeFactor(this.model.get("speed"))
                    }
                });
            var W = {
                FeatureName: "animation",
                ModelType: c,
                ViewListType: [z]
            },
                j = !1;
            L.Z.getHasAnimation().then((function (e) {
                e && (j = e)
            }));
            var X = n.Z.create(W);
            X.prototype.prepareForScreenShot = function () {
                return !!j && (this._oldPlayingAnimation = this.getModel().get("playing"), this.getModel().set("playing", !1), !0)
            }, X.prototype.resetAfterScreenShot = function () {
                this._oldPlayingAnimation && this.getModel().set("playing", !0)
            };
            const Y = X;
            var J = i("XkCy"),
                q = i("FqYX"),
                K = g.Z.osg,
                Q = Math.PI / 2,
                $ = a.Z.extend({
                    getModelOptionPath: function () {
                        return "camera"
                    },
                    defaults: {
                        webVR: !1,
                        indexManipulator: "fps" === (0, l.Z)().navigation ? 1 : 0,
                        node: void 0,
                        minSpeed: .1,
                        displayGizmo: !1,
                        animationEye: K.vec3.create(),
                        animationTarget: K.vec3.create(),
                        animationDuration: 1,
                        enableCameraConstraints: !0,
                        offset: 0,
                        angle: 2 * Math.PI
                    },
                    getName: function () {
                        return "Camera"
                    },
                    setTargetAndEye: function (e, t, i) {
                        return this.set("animationTarget", e), this.set("animationEye", t), this.trigger("setTargetAndEye", i)
                    },
                    init: function (e) {
                        this._viewer = e.getViewer();
                        var t = e.getModel().get("options").camera;
                        this.set("enableCameraConstraints", (0, l.Z)().cameraConstraints);
                        var i = this._getUrlOptions(),
                            n = (0, q.Z)(t, i);
                        this.setJSON(n), this.yawLeftRightToAngleOffset(), this.on("change:zoomIn", this.checkOverLap.bind(this, "zoomOut", "zoomIn", "zoomOut")), this.on("change:zoomOut", this.checkOverLap.bind(this, "zoomOut", "zoomIn", "zoomIn")), this.on("change:up", this.checkOverLap.bind(this, "up", "down", "down")), this.on("change:down", this.checkOverLap.bind(this, "up", "down", "up")), this.on("change:offset", this.yawAngleOffsetToLeftRight.bind(this)), this.on("change:angle", this.yawAngleOffsetToLeftRight.bind(this))
                    },
                    shouldPlayFirstCameraAnimation: function () {
                        return !0 === (0, l.Z)().camera && !this.get("useCameraConstraints")
                    },
                    initAfterFirstFrame: function () {
                        var e = J.Z.getModelBoxWithoutDisplacement().radius() * (180 - this.get("fov")); - 1 === this.get("zoomOut") && this.set("zoomOut", e), -1 === this.get("zoomIn") && this.set("zoomIn", e), this.set("maxZoom", e), this.trigger("uiReady")
                    },
                    _getUrlOptions: function () {
                        var e = {
                            usePanConstraints: (0, l.Z)().orbitConstraintPan,
                            zoomIn: (0, l.Z)().orbitConstraintZoomIn,
                            zoomOut: (0, l.Z)().orbitConstraintZoomOut,
                            left: (0, l.Z)().orbitConstraintYawLeft,
                            right: (0, l.Z)().orbitConstraintYawRight,
                            up: (0, l.Z)().orbitConstraintPitchUp,
                            down: (0, l.Z)().orbitConstraintPitchDown
                        };
                        return e.useZoomConstraints = void 0 !== e.zoomOut || void 0 !== e.zoomIn || void 0, e.useYawConstraints = void 0 !== e.left || void 0 !== e.right || void 0, e.usePitchConstraints = void 0 !== e.up || void 0 !== e.down || void 0, e.useCameraConstraints = e.useZoomConstraints || e.useYawConstraints || e.usePitchConstraints || e.usePanConstraints, e
                    },
                    getCameraPosition: function (e, t) {
                        var i = this._viewer.getFeaturesManager();
                        if (i && (i.getCameraWithoutAutospin(e, t), 0 !== this.get("indexManipulator") && this.get("node"))) {
                            var n = this.get("node").getMinimumBound(),
                                r = K.vec3.dist(e, n.center()),
                                a = Math.max(.1 * n.radius(), r);
                            K.vec3.sub(t, t, e), K.vec3.normalize(t, t), K.vec3.scale(t, t, a), K.vec3.add(t, e, t)
                        }
                    },
                    saveCameraPosition: function () {
                        !this.get("useCameraConstraints") || this.get("enableCameraConstraints") ? this.getCameraPosition(this.get("position"), this.get("target")) : this.getCameraPosition(this.get("position"), K.vec3.create())
                    },
                    validateEyeTarget: function (e, t) {
                        var i = K.vec3.dist(e, t);
                        if (i <= 1e-8) return !1;
                        var n = this.get("node").getMinimumBound().radius();
                        return i <= .001 * n && (K.vec3.sub(t, t, e), K.vec3.scale(t, t, .01 * n / i), K.vec3.add(t, e, t)), !0
                    },
                    editorGetJSON: function () {
                        return this.getJSON()
                    },
                    editorSetJSON: function (e) {
                        var t = this.setJSON(e, {
                            validate: !0
                        });
                        return t || d().resolve(!0)
                    },
                    range: function (e) {
                        return "[" + e.min + ", " + e.max + "]"
                    },
                    limits: function () {
                        return {
                            zoomIn: {
                                min: 0,
                                max: this.get("maxZoom")
                            },
                            zoomOut: {
                                min: 0,
                                max: this.get("maxZoom")
                            },
                            offset: {
                                min: 0,
                                max: 2 * Math.PI
                            },
                            angle: {
                                min: 0,
                                max: 2 * Math.PI
                            },
                            up: {
                                min: -Q,
                                max: Q
                            },
                            down: {
                                min: -Q,
                                max: Q
                            },
                            fov: {
                                min: 1,
                                max: 179
                            },
                            nearFarRatio: {
                                min: 1e-4,
                                max: .005
                            }
                        }
                    },
                    yawAngleOffsetToLeftRight: function () {
                        var e = this.get("offset"),
                            t = this.get("angle"),
                            i = e - t / 2,
                            n = 0;
                        t === 2 * Math.PI && (n = -.001);
                        var r = e + t / 2 + n;
                        i >= Math.PI && (i -= 2 * Math.PI), r >= Math.PI && (r -= 2 * Math.PI), this.set("left", i), this.set("right", r)
                    },
                    yawLeftRightToAngleOffset: function () {
                        var e = this._getYawValue(this.get("left")),
                            t = this._getYawValue(this.get("right")),
                            i = this.computeAngleOffset(e, t);
                        this.set("angle", i[0]), this.set("offset", i[1])
                    },
                    _getYawValue: function (e) {
                        return e <= -3.14 ? -Math.PI : e >= 3.14 ? Math.PI : e
                    },
                    computeAngleOffset: function (e, t) {
                        var i = t - e;
                        i < 0 && (i += 2 * Math.PI);
                        var n = e + i / 2;
                        return n < 0 && (n += 2 * Math.PI), [i, n]
                    },
                    checkOverLap: function (e, t, i) {
                        var n = this.get(e),
                            r = this.get(t);
                        r > n && this.set(i, i === e ? r : n)
                    }
                });
            const ee = $;
            var te, ie, ne, re, ae = g.Z.osg,
                oe = g.Z.osgGA,
                se = function (e) {
                    oe.FirstPersonManipulator.call(this, e);
                    var t = Math.max(0, Math.min(4, (0, l.Z)().fpsSpeed / 25));
                    this._stepFactor = t, this.getControllerList().StandardMouseKeyboard._stepFactor = t, this._postMultRotate = ae.quat.create(), this._resetInitialVR = !1, this._lookPosition._delay = .25
                };
            ae.createPrototypeObject(se, ae.objectInherit(oe.FirstPersonManipulator.prototype, {
                getPostMultRotate: function () {
                    return this._postMultRotate
                },
                setResetInitialRotationVR: function (e) {
                    this._resetInitialVR = e, e || ae.quat.identity(this._postMultRotate)
                },
                setNode: function (e) {
                    oe.FirstPersonManipulator.prototype.setNode.call(this, e);
                    var t = this.getHomeBoundingSphere();
                    t && t.valid() && (this._distance = this.getHomeDistance(t))
                },
                setInitialPoseVR: (ie = ae.quat.create(), ne = ae.mat4.create(), re = ae.vec3.fromValues(0, 0, 1), function (e, t) {
                    ae.mat4.lookAt(ne, e, t, re), ae.mat4.invert(ne, ne), ae.mat4.getRotation(ie, ne), ie[1] = ie[0] = 0, ae.quat.normalize(ie, ie), ae.quat.copy(this._postMultRotate, ie), this.setEyePosition(e), this.setTarget(t), this.setResetInitialRotationVR(!0)
                }),
                setPoseVR: (te = ae.vec3.create(), function (e, t) {
                    this._resetInitialVR && (ae.quat.invert(this._vrRot, e), this._vrRot[0] = this._vrRot[1] = 0, ae.quat.normalize(this._vrRot, this._vrRot), ae.quat.multiply(this._postMultRotate, this._vrRot, this._postMultRotate)), ae.quat.multiply(this._vrRot, this._postMultRotate, e), ae.vec3.transformQuat(te, t, this._postMultRotate), this._resetInitialVR ? (ae.vec3.set(this._vrTrans, 0, 0, 0), this._resetInitialVR = !1) : ae.vec3.sub(this._vrTrans, te, this._vrPos), ae.vec3.copy(this._vrPos, te), this._vrEnable = !0
                })
            }), "osgtestdemo2024", "FirstPersonManipulator");
            const le = se;
            var ue, ce, he, de = .99,
                ge = .5 * Math.PI * .99,
                fe = g.Z.osg,
                me = g.Z.osgGA,
                pe = function (e) {
                    me.OrbitManipulator.call(this, e), this.setLimitPitchUp(ge), this.setLimitPitchDown(-ge), this._enableRecenter = !0, this._zoomEMA = 0, this._pitchEMA = 0, this._yawEMA = 0, this._panVEMA = 0, this._panHEMA = 0, this._constrainPan = !1, this._constrainedTarget = fe.vec3.create()
                };
            fe.createPrototypeObject(pe, fe.objectInherit(me.OrbitManipulator.prototype, {
                setEyePosition: (ue = fe.vec3.create(), ce = fe.vec3.create(), he = fe.vec3.create(), function (e, t) {
                    var i = this._rotation,
                        n = this._target;
                    if (fe.vec3.sub(ue, e, n), fe.vec3.normalize(ue, ue), t) {
                        var r = fe.vec3.dot(ue, this._upz);
                        if (Math.abs(r) > de) {
                            var a = Math.sqrt((1 - .9801) / (ue[0] * ue[0] + ue[1] * ue[1]));
                            ue[0] *= a, ue[1] *= a, ue[2] = de * Math.sign(r)
                        }
                    }
                    fe.vec3.cross(ce, ue, this._upz), fe.vec3.normalize(ce, ce), fe.vec3.cross(he, ce, ue), fe.vec3.normalize(he, he), i[0] = ce[0], i[1] = ue[0], i[2] = he[0], i[3] = 0, i[4] = ce[1], i[5] = ue[1], i[6] = he[1], i[7] = 0, i[8] = ce[2], i[9] = ue[2], i[10] = he[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this._distance = fe.vec3.dist(n, e)
                }),
                enableRecenter: function (e) {
                    this._enableRecenter = e
                },
                computeHomePosition: function (e) {
                    this._enableRecenter && me.OrbitManipulator.prototype.computeHomePosition.call(this, e)
                },
                _computeEMA: function (e, t) {
                    return 0 === t ? e : .2 * e + .8 * t
                },
                _getLimitReached: function (e, t, i) {
                    return Math.abs(e - i) < .001 ? i : Math.abs(e - t) < .001 ? t : void 0
                },
                computeZoom: function (e) {
                    if (me.OrbitManipulator.prototype.computeZoom.call(this, e), this._constrainZoom) {
                        var t = 1;
                        (e -= 1) < 0 && (e = -e, t = -1);
                        var i = this.getSpeedFactor() * e,
                            n = this._getLimitReached(this.getDistance(), this._limitZoomIn, this._limitZoomOut);
                        void 0 !== n && (void 0 === this._prevDistance && (this._prevDistance = n), i = i / (1 + i) * (.1 * this.getDistance()), this._zoomEMA = this._computeEMA(i, this._zoomEMA), t < 0 && this._prevDistance > n || t > 0 && this._prevDistance < n ? this._distance = this._prevDistance + this.getSpeedFactor() * e * t : this._distance = n + this._zoomEMA * t), this._prevDistance = this._distance
                    }
                },
                _computePitch: function (e, t) {
                    var i;
                    if (e = void 0 !== this._previousPitch ? this._previousPitch : e, i = me.OrbitManipulator.prototype._computePitch.call(this, e, t), !this._constrainPitch || 0 === t) return this._previousPitch = void 0, i;
                    this._previousPitch = i;
                    var n = t / 10;
                    n = n / (1 + n) * .5;
                    var r = this._getLimitReached(i, this._limitPitchUp, this._limitPitchDown);
                    return void 0 !== r && (this._pitchEMA = this._computeEMA(n, this._pitchEMA), i = r + this._pitchEMA), Math.max(Math.min(i, ge), -ge)
                },
                _computeYaw: function (e, t) {
                    var i;
                    if (e = void 0 !== this._previousYaw ? this._previousYaw : e, i = me.OrbitManipulator.prototype._computeYaw.call(this, e, t), !this._constrainYaw || 0 === t) return this._previousYaw = void 0, i;
                    this._previousYaw = i;
                    var n = t / 10;
                    n = n / (1 + n) * 3;
                    var r = this._getLimitReached(i, this._limitYawLeft, this._limitYawRight);
                    return void 0 !== r && (this._yawEMA = this._computeEMA(n, this._yawEMA), i = r + this._yawEMA), i
                },
                computePan: function (e, t) {
                    !this._constrainPan || 0 === e && 0 === t || (this._panVEMA = this._computeEMA(e / (1 + e) * .5, this._panVEMA), this._panHEMA = this._computeEMA(t / (1 + t) * .5, this._panHEMA), e = this._panVEMA, t = this._panHEMA, fe.vec3.copy(this._target, this._constrainedTarget)), me.OrbitManipulator.prototype.computePan.call(this, e, t)
                },
                setConstrainPan: function (e) {
                    this._constrainPan = e
                },
                isConstrainPan: function () {
                    return this._constrainPan
                },
                setPanConstraintTarget: function (e) {
                    fe.vec3.copy(this._constrainedTarget, e)
                }
            }), "osgtestdemo2024", "OrbitManipulator");
            const ve = pe;
            var _e, Se = g.Z.osg,
                xe = g.Z.osgGA,
                Ce = g.Z.osgUtil.DelayInterpolator.prototype,
                Te = Ce.set;
            Ce.set = function () {
                Te.apply(this, arguments), this._epsilon >= 0 && !this.isDone() && _e(!0)
            };
            var Me = Ce.setTarget;
            Ce.setTarget = function () {
                Me.apply(this, arguments), this._epsilon >= 0 && !this.isDone() && _e(!0)
            };
            var be = Ce.addTarget;
            Ce.addTarget = function () {
                be.apply(this, arguments), this._epsilon >= 0 && !this.isDone() && _e(!0)
            }, Ce.isDone = function (e) {
                e = e || 1;
                for (var t = Math.abs(this._epsilon), i = 0, n = this._current.length; i < n; ++i)
                    if (Math.abs(this._target[i] - this._current[i]) > t * e) return !1;
                return !0
            };
            var ye = Ce.update;
            Ce.update = function (e) {
                var t = ye.call(this, e);
                if (this._epsilon >= 0)
                    if (this.isDone())
                        for (var i = 0, n = this._current.length; i < n; ++i) this._current[i] = this._target[i];
                    else _e(), this.isDone(100) ? U.Z.draw() : U.Z.drawNoJitter();
                return t
            };
            var Ae = function () {
                for (var e = Math.abs(this._epsilon), t = 0, i = this._current.length; t < i; ++t)
                    if (1 === Math.abs(this._target[t]) || Math.abs(this._target[t] - this._current[t]) > e) return !1;
                return !0
            },
                Re = function (e) {
                    e.isDone = Ae.bind(e)
                },
                we = function (e, t) {
                    _e = t, xe.SwitchManipulator.call(this), this._boundStrategy = xe.Manipulator.COMPUTE_HOME_USING_SPHERE | xe.Manipulator.COMPUTE_HOME_USING_BBOX, this._inputManager = e, this.init()
                };
            Se.createPrototypeObject(we, Se.objectInherit(xe.SwitchManipulator.prototype, {
                init: function () {
                    xe.SwitchManipulator.prototype.setManipulatorIndex.call(this, 0);
                    var e = new ve({
                        boundStrategy: this._boundStrategy,
                        inputManager: this._inputManager
                    });
                    e.getRotateInterpolator()._epsilon = .1, e.getPanInterpolator()._epsilon = .1, e.getZoomInterpolator()._epsilon = .001, e.setZoomFactor((0, l.Z)().orbitZoomFactor), e.setRotationFactor((0, l.Z)().orbitRotationFactor), e.setPanFactor((0, l.Z)().orbitPanFactor), e.getPanInterpolator()._isOrbitPan = !0;
                    var t = new le({
                        boundStrategy: this._boundStrategy,
                        inputManager: this._inputManager
                    });
                    t.getLookPositionInterpolator()._epsilon = .1, t.getSideInterpolator()._epsilon = .001, Re(t.getSideInterpolator()), t.getForwardInterpolator()._epsilon = .001, Re(t.getForwardInterpolator()), t.getPanInterpolator()._epsilon = .001, Re(t.getPanInterpolator()), t.getZoomInterpolator()._epsilon = .001, Re(t.getZoomInterpolator()), this.addManipulator(e, "ORBIT"), this.addManipulator(t, "FPS"), void 0 !== (0, l.Z)().cameraEasing && this.setDelay(1 - (0, l.Z)().cameraEasing)
                },
                getOrbitManipulator: function () {
                    return this._manipulatorList[we.ORBIT]
                },
                getFirstPersonManipulator: function () {
                    return this._manipulatorList[we.FPS]
                },
                _setManipulatorDelay: function (e, t) {
                    e.setDelay(t);
                    var i = e._controllerList;
                    for (var n in i) {
                        var r = i[n];
                        void 0 !== r._delay && (r._delay = t)
                    }
                },
                setDelay: function (e) {
                    this._setManipulatorDelay(this._manipulatorList[we.ORBIT], e), this._setManipulatorDelay(this._manipulatorList[we.FPS], e)
                },
                addManipulator: function (e, t) {
                    xe.SwitchManipulator.prototype.addManipulator.call(this, e), t && (we[t] = this.getManipulatorList().length - 1)
                },
                setManipulatorIndex: function () {
                    var e = Se.vec3.create(),
                        t = Se.vec3.create();
                    return function (i) {
                        if (i !== this.getCurrentManipulatorIndex()) {
                            var n = this.getCurrentManipulator();
                            xe.SwitchManipulator.prototype.setManipulatorIndex.call(this, i), this.setTargetAndEye(n.getTarget(e), n.getEyePosition(t))
                        }
                    }
                }(),
                setTargetAndEye: function (e, t) {
                    var i = this.getCurrentManipulator();
                    this.getCurrentManipulatorIndex() === we.ORBIT ? (e && i.setTarget(e), t && i.setEyePosition(t)) : (t && i.setEyePosition(t), e && i.setTarget(e)), _e(!0)
                },
                setCameraRoll: function (e) {
                    this.getCurrentManipulator().setRoll(e), _e(!0)
                },
                setEyePosition: function (e, t) {
                    this.getCurrentManipulator().setEyePosition(e, t), _e(!0)
                },
                getEyePosition: function (e) {
                    return this.getCurrentManipulator().getEyePosition(e)
                },
                setTarget: function (e) {
                    this.getCurrentManipulator().setTarget(e), _e(!0)
                },
                getTarget: function (e) {
                    return this.getCurrentManipulator().getTarget(e)
                },
                setDistance: function (e) {
                    this.getCurrentManipulatorIndex() === we.ORBIT && (this.getCurrentManipulator().setDistance(e), _e(!0))
                },
                getDistance: function () {
                    return this.getCurrentManipulator().getDistance()
                },
                computeHomePosition: function (e) {
                    xe.SwitchManipulator.prototype.computeHomePosition.call(this, e), _e(!0)
                }
            }), "osgtestdemo2024", "SwitchManipulator");
            const Ee = we;
            var Pe = i("gvzH"),
                Ne = i("wAYD"),
                Oe = i("4rHk");
            const De = {
                iconCamCenter: i("XjOY"),
                iconZoomHint: i("xbNu"),
                iconsLight: {
                    DIRECTION: i("eaiT"),
                    SPOT: i("R25V"),
                    POINT: i("/R0b"),
                    HEMI: i("gS32")
                },
                iconSound: i("48po"),
                iconHotspot: i("XywL")
            };
            var Ie = i("FGWR"),
                Fe = i("JbUU"),
                Le = i("Ygw6"),
                Ve = i("4EEe");
            const Be = "attribute vec3 Vertex;\n\n#ifdef ICON\n attribute vec2 TexCoord0;\n varying vec2 vTexCoord0;\n#else\n varying vec3 pos;\n#endif\n\n\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  #ifdef ICON\n    vTexCoord0 = TexCoord0;\n  #else\n    pos = Vertex.xyz;\n  #endif\n\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex.xyz, 1.0));\n}\n",
                Ue = "\nuniform float uAlpha;\n\nuniform vec4 uColor;\n\nuniform float uUp;\nuniform float uDown;\n\n#ifdef ICON\n    uniform sampler2D uTextureIcon;\n    varying vec2 vTexCoord0;\n#else\n    varying vec3 pos;\n#endif\n\nvoid main(void) {\n\n    #ifdef ICON\n        gl_FragColor = vec4(uColor.rgb, uAlpha) * texture2D(uTextureIcon, vTexCoord0);\n    #else\n        float alpha = step(pos.x, uUp) * step(uDown, pos.x);\n        gl_FragColor = vec4(uColor.rgb, uAlpha * alpha);\n    #endif\n\n    gl_FragColor.rgb *= gl_FragColor.a;\n}\n";
            var ke, Ze, He, Ge, ze, We, je = g.Z.osg,
                Xe = g.Z.osgUtil,
                Ye = g.Z.InputGroups,
                Je = je.vec4.fromValues(.309375, .8640625, 1, 1),
                qe = je.vec4.fromValues(1, 1, 0, 1),
                Ke = je.vec3.fromValues(-1, 0, 0),
                Qe = .05,
                $e = je.vec3.fromValues(Qe, Qe, Qe),
                et = .02,
                tt = 2 * Math.PI,
                it = Le.Z.BLEND_SUBSTRACTIVE,
                nt = Le.Z.DEPTH_DISABLE,
                rt = je.StateAttribute.ON,
                at = function (e, t) {
                    return (e % t + t) % t
                },
                ot = function (e, t) {
                    je.MatrixTransform.call(this), this.setName("Camera - Constraints Gizmo"), this._manipulator = e, this._model = t, this._defaults = this._model.getInstance();
                    var i = this._model.computeAngleOffset(this._defaults.left, this._defaults.right);
                    this._defaults.angle = i[0], this._defaults.offset = i[1], this._circleGeom = Xe.GizmoGeometry.createCircleGeometry(128, 1, 2.015 * Math.PI), this._arcGeom = Xe.GizmoGeometry.createCircleGeometry(64, 1, 1.015 * Math.PI), this._pivotNode = new je.MatrixTransform, this._arcNode = new je.MatrixTransform, this._circleNode = new je.MatrixTransform, this._circleNode.setName("Camera - Constraints Gizmo - circleNode"), this._pivotNode.addChild(this._arcNode), this._pivotNode.addChild(this._circleNode), this._arcCenter = this._makeArc(this._arcGeom), this._arcLeft = this._makeArc(this._arcGeom, -Math.PI), this._arcRight = this._makeArc(this._arcGeom, Math.PI), this._arcHalfLeft = this._makeArc(this._arcGeom, .5 * -Math.PI), this._arcHalfRight = this._makeArc(this._arcGeom, .5 * Math.PI), this._circleCenter = this._makeCircle(), this._circleUp = this._makeCircle(), this._circleDown = this._makeCircle(), this._pivotNode.editMask = Xe.NodeGizmo.PICK_ARROW | Xe.NodeGizmo.PICK_PLANE, this.addChild(this._pivotNode), this.setGizmoStateset(Je), this._makeCenter(), this._geomHandle = new je.createTexturedBoxGeometry(0, 0, 0, et, et, et), this._handleCenter = this._makeHandle("handleCenter"), this._handleUp = this._makeHandle("handleUp"), this._handleDown = this._makeHandle("handleDown"), this._handleLeft = this._makeHandle("handleLeft"), this._handleRight = this._makeHandle("handleRight"), this._startCoord = je.vec2.create(), Ve.Z.initCamera(this), this.setVisible(!1)
                };
            ot.prototype = je.objectInherit(je.MatrixTransform.prototype, {
                _makeArc: function (e, t) {
                    var i = new je.MatrixTransform,
                        n = new je.MatrixTransform;
                    return n.addChild(e), je.mat4.fromRotation(n.getMatrix(), .5 * -Math.PI, je.vec3.fromValues(0, 1, 0)), t && je.mat4.fromZRotation(i.getMatrix(), t), i.addChild(n), this._arcNode.addChild(i), i
                },
                _makeCircle: function () {
                    var e = new je.MatrixTransform;
                    return this._circleNode.addChild(e), e.addChild(this._circleGeom), e
                },
                _makeCenter: function () {
                    this._centerNode = new je.MatrixTransform, this._pivotNode.addChild(this._centerNode);
                    var e = this._centerNode.getOrCreateStateSet(),
                        t = Ne.Z.getOrCreateShader(Be, Ue, "icon", "CamConstraintsIcon", "ICON");
                    e.setAttributeAndModes(t), this._centerIcon = this._addIcon(this._centerNode, De.iconCamCenter, "center")
                },
                _makeHandle: function (e) {
                    var t = new je.MatrixTransform;
                    t.setName(e), t.setNodeMask(-1), t.addChild(this._geomHandle), je.mat4.fromTranslation(t.getMatrix(), Ke);
                    var i = t.getOrCreateStateSet();
                    return this._setupColorAndAlpha(Je, 1, i), i.addUniform(je.Uniform.createFloat(1, "uUp")), i.addUniform(je.Uniform.createFloat(-1, "uDown")), this._circleNode.addChild(t), t
                },
                _getIconGeom: function () {
                    return this._quadGeom || (this._quadGeom = je.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0), this._quadGeom.setNodeMask(-1), this._quadGeom.setName("iconGeom")), this._quadGeom
                },
                _addIcon: function (e, t, i) {
                    var n = new je.MatrixTransform;
                    n.addChild(this._getIconGeom()), n.setName(i + "Icon"), e.addChild(n);
                    var r = s.Z.instance.getOrCreateTexture(t, {
                        internalFormat: je.Texture.RGBA
                    }),
                        a = n.getOrCreateStateSet();
                    return a.setTextureAttributeAndModes(0, r.texture, rt), a.addUniform(je.Uniform.createInt(0, "uTextureIcon")), this._setupColorAndAlpha(Je, 1, a), n
                },
                _getGizmo: function () {
                    var e = this._model._viewer.getFeaturesManager();
                    return e ? e.getNodeGizmo() : null
                },
                setPivotSelected: function (e) {
                    this._getGizmo().attachToNode(e ? this._centerNode : void 0)
                },
                setGizmoStateset: function (e) {
                    this._circleGeom.getOrCreateStateSet().removeAttribute("Program"), this._arcGeom.getOrCreateStateSet().removeAttribute("Program");
                    var t = this._pivotNode.getOrCreateStateSet();
                    t.setRenderBinDetails(Oe.Z.EDITOR_GIZMO, "RenderBin"), t.setAttributeAndModes(Ne.Z.getOrCreateShader(Be, Ue, "gizmo", "CamConstraintsGizmo"), rt), t.setAttributeAndModes(it, rt), t.setAttributeAndModes(nt, rt), this._setupColorAndAlpha(e, .4, t), this._setupColorAndAlpha(e, 1, this._circleDown.getOrCreateStateSet()), this._setupColorAndAlpha(e, 1, this._circleUp.getOrCreateStateSet()), this._setupColorAndAlpha(e, 1, this._arcLeft.getOrCreateStateSet()), this._setupColorAndAlpha(e, 1, this._arcRight.getOrCreateStateSet());
                    var i = this._arcNode.getOrCreateStateSet();
                    this._uUp = je.Uniform.createFloat(1, "uUp"), i.addUniform(this._uUp), this._uDown = je.Uniform.createFloat(-1, "uDown"), i.addUniform(this._uDown);
                    var n = this._circleNode.getOrCreateStateSet();
                    this._uHUp = je.Uniform.createFloat(1, "uUp"), n.addUniform(this._uHUp), n.addUniform(je.Uniform.createFloat(-1, "uDown"))
                },
                _setupColorAndAlpha: function (e, t, i) {
                    i.addUniform(je.Uniform.createFloat4(e, "uColor")), i.addUniform(je.Uniform.createFloat(t, "uAlpha"))
                },
                setVisible: function (e) {
                    this.setNodeMask(e ? Pe.Z.NO_SHADOW : 0), e ? this._manipulator.getInputManager().setEnable(Ye.CAMERA_GIZMO, !0) : this._manipulator.getInputManager().setEnable(Ye.CAMERA_GIZMO, !1)
                },
                motion: (We = je.vec2.create(), function (e) {
                    if (je.vec2.set(We, e.canvasX, e.canvasY), this._dragging) this._onDrag(We);
                    else if (Fe.Z.isInitialized()) {
                        var t = Fe.Z.computeNearestIntersection2D(We[0], We[1], Pe.Z.PICK, this);
                        if (t) {
                            var i = t._nodePath.length,
                                n = t._nodePath[i - 1];
                            if (n === this._getIconGeom() || n === this._geomHandle) {
                                var r = t._nodePath[i - 2];
                                this._onHover(r)
                            }
                        } else this._onHover()
                    }
                }),
                _onDrag: function () {
                    var e = je.vec3.create(),
                        t = je.vec3.create();
                    return function (i) {
                        var n = this._model._viewer.getCanvas().height,
                            r = this._model.get("usePitchConstraints"),
                            a = this._model.get("useYawConstraints");
                        if (r) {
                            var o = (this._startCoord[1] - i[1]) / n * 2;
                            if (this._dragging === this._handleUp) return void this._model.set("up", Math.asin(je.clamp(this._startModel.up + o, -1, 1)));
                            if (this._dragging === this._handleDown) return void this._model.set("down", Math.asin(je.clamp(this._startModel.down + o, -1, 1)))
                        }
                        if (a) {
                            this._getDragPosition(t, i), je.vec3.sub(e, t, this._model.get("target")), je.vec3.normalize(e, e);
                            var s = this._startModel.a1,
                                l = Math.atan2(e[0], e[1]),
                                u = Math.sign(je.vec3.cross(e, this._startModel.baseDir, e)[2]),
                                c = 0,
                                h = this._model.get("angle");
                            if (this._dragging === this._handleLeft) return c = this._clampAngle(2 * (l - s), -u, h), void this._model.set("angle", c);
                            if (l > 0 && (l -= tt), this._dragging === this._handleRight) return c = this._clampAngle(2 * (s - l), u, h), void this._model.set("angle", c);
                            this._dragging === this._handleCenter && this._model.set("offset", at(this._startModel.offset + (s - l), tt))
                        }
                    }
                }(),
                _getDragPosition: function () {
                    var e = je.vec3.create(),
                        t = je.vec3.create(),
                        i = je.vec3.create(),
                        n = je.vec3.create(),
                        r = je.vec3.create(),
                        a = je.vec3.create();
                    return function (o, s) {
                        Ie.Z.canvasCoordToGL(s[0], s[1], n), n[2] = 0, Fe.Z.getWorldPositionFromScreenPoint(n, e), n[2] = 1, Fe.Z.getWorldPositionFromScreenPoint(n, t), je.vec3.sub(a, t, e), je.vec3.normalize(a, a), je.vec3.set(r, 0, 0, 1);
                        var l = -this._startModel.startPosition[2],
                            u = je.vec3.dot(r, a);
                        if (Math.abs(u) < .05) {
                            var c = this._startModel.startPosition;
                            je.vec3.sub(r, c, this._model.get("target")), r[2] = 0, je.vec3.normalize(r, r), je.vec3.set(i, c[0], c[1], 0), i[2] = 0, l = -je.vec3.dot(r, i), u = je.vec3.dot(r, a)
                        }
                        var h = -(je.vec3.dot(r, e) + l) / u;
                        return je.vec3.scaleAndAdd(o, e, a, h), o
                    }
                }(),
                _clampAngle: function (e, t, i) {
                    return e = at(e, tt), t < 0 ? i < tt - i ? 0 : tt : e
                },
                startDrag: (He = je.vec3.create(), Ge = je.vec3.create(), ze = je.mat4.create(), function (e) {
                    this._hovered && this._hovered !== this._centerNode && (this._dragging = this._hovered, je.vec2.set(this._startCoord, e.canvasX, e.canvasY), this._handleCenter.getWorldMatrix(this, ze), je.mat4.getTranslation(He, ze), je.vec3.sub(Ge, He, this._model.get("target")), je.vec3.normalize(Ge, Ge), this._dragging.getWorldMatrix(this, ze), je.mat4.getTranslation(He, ze), this._startModel = {
                        up: Math.sin(this._model.get("up")),
                        down: Math.sin(this._model.get("down")),
                        offset: this._model.get("offset"),
                        angle: this._model.get("angle"),
                        startPosition: He,
                        baseDir: Ge,
                        a1: Math.atan2(Ge[0], Ge[1])
                    }, this._manipulator.getInputManager().setEnable(Ye.MANIPULATORS, !1), this._savedEnableState = this._model.get("enableCameraConstraints"), this._model.set("enableCameraConstraints", !1))
                }),
                endDrag: function (e) {
                    this._dragging && (this._manipulator.getInputManager().setEnable(Ye.MANIPULATORS, !0), this._dragging = void 0, this.motion(e), this._model.set("enableCameraConstraints", this._savedEnableState))
                },
                _onHover: function (e) {
                    if (e !== this._hovered)
                        if (this._hovered && (this._changeColor(this._hovered.getStateSet(), Je), this._changeColor(this._circleUp.getStateSet(), Je), this._changeColor(this._arcLeft.getStateSet(), Je), this._changeColor(this._arcRight.getStateSet(), Je), this._changeColor(this._circleDown.getStateSet(), Je), U.Z.draw()), e) {
                            switch (this._hovered = e, this._changeColor(e.getStateSet(), qe), e) {
                                case this._handleCenter:
                                    this._changeColor(this._circleDown.getStateSet(), qe), this._changeColor(this._circleUp.getStateSet(), qe), this._changeColor(this._arcLeft.getStateSet(), qe), this._changeColor(this._arcRight.getStateSet(), qe);
                                    break;
                                case this._handleUp:
                                    this._changeColor(this._circleUp.getStateSet(), qe);
                                    break;
                                case this._handleDown:
                                    this._changeColor(this._circleDown.getStateSet(), qe);
                                    break;
                                case this._handleLeft:
                                    this._changeColor(this._arcLeft.getStateSet(), qe);
                                    break;
                                case this._handleRight:
                                    this._changeColor(this._arcRight.getStateSet(), qe)
                            }
                            U.Z.draw()
                        } else this._hovered = void 0
                },
                _changeColor: function (e, t) {
                    var i = e.getUniform("uColor").getInternalArray();
                    je.vec4.copy(i, t)
                },
                update: function () {
                    var e = je.vec4.create(),
                        t = je.vec3.create(),
                        i = je.vec3.create();
                    return function (n) {
                        var r = n.getViewport(),
                            a = r.width() / r.height(),
                            o = je.mat4.getScale(e, n.getProjectionMatrix())[0],
                            s = Math.max(1.2, a * (1.1 + .2 / o) * o);
                        this._manipulator.getEyePosition(t);
                        var l = this._model.get("target"),
                            u = this._getGizmo();
                        u.isEditing() ? (je.mat4.getTranslation(l, u.getMatrix()), this._needsCameraUpdate = !0) : this._needsCameraUpdate && (this._needsCameraUpdate = !1, this._model.trigger("targetChanged"));
                        var c = je.vec3.dist(t, l) / s,
                            h = this._pivotNode.getMatrix();
                        je.vec3.set(i, c, c, c), je.mat4.fromTranslation(h, l), je.mat4.scale(h, h, i);
                        var d = this._centerNode.getMatrix();
                        je.mat4.invert(d, n.getViewMatrix()), je.mat4.setTranslation(d, je.vec3.ZERO), je.mat4.scale(d, d, $e), this._pivotNode.dirtyBound(), this._centerNode.dirtyBound()
                    }
                }(),
                updateConstraints: function () {
                    var e = this._model.get("usePitchConstraints"),
                        t = this._model.get("useYawConstraints"),
                        i = e ? this._model.get("up") : this._defaults.up,
                        n = e ? this._model.get("down") : this._defaults.down,
                        r = .5 * (i + n);
                    this._updatePitchWidget(this._circleUp, i), this._updatePitchWidget(this._circleDown, n), this._updatePitchWidget(this._circleCenter, r);
                    var a = t ? this._model.get("offset") : this._defaults.offset,
                        o = t ? this._model.get("angle") : this._defaults.angle,
                        s = .5 * o;
                    e || t ? (this._circleNode.setNodeMask(-1), this._arcNode.setNodeMask(-1), je.mat4.fromZRotation(this._circleNode.getMatrix(), a - .5 * Math.PI), je.mat4.fromZRotation(this._arcCenter.getMatrix(), a), je.mat4.fromZRotation(this._arcLeft.getMatrix(), a - s), je.mat4.fromZRotation(this._arcRight.getMatrix(), a + s), je.mat4.fromZRotation(this._arcHalfLeft.getMatrix(), a - .5 * s), je.mat4.fromZRotation(this._arcHalfRight.getMatrix(), a + .5 * s)) : (this._circleNode.setNodeMask(0), this._arcNode.setNodeMask(0)), this._updateHandles(e, t, i, n, r, s), je.mat4.fromTranslation(this._pivotNode.getMatrix(), this._model.get("target")), this._uUp.getInternalArray()[0] = Math.sin(i), this._uDown.getInternalArray()[0] = Math.sin(n), this._uHUp.getInternalArray()[0] = -Math.cos(.5 * o), this.dirtyBound(), this._pivotNode.dirtyBound(), this._circleNode.dirtyBound(), U.Z.draw()
                },
                _updateHandles: function (e, t, i, n, r, a) {
                    if (e) {
                        this._handleUp.setNodeMask(-1), this._handleDown.setNodeMask(-1);
                        var o = i - n;
                        this._updateHandleWidget(this._handleUp, o < .07 ? r + .035 : i, 0), this._updateHandleWidget(this._handleDown, o < .07 ? r - .035 : n, 0)
                    } else this._handleUp.setNodeMask(0), this._handleDown.setNodeMask(0);
                    t ? (this._handleRight.setNodeMask(-1), this._handleLeft.setNodeMask(-1), this._handleCenter.setNodeMask(-1), a = (a = a < .035 ? .035 : a) > Math.PI - .035 ? Math.PI - .035 : a, this._updateHandleWidget(this._handleRight, r, a), this._updateHandleWidget(this._handleLeft, r, -a), this._updateHandleWidget(this._handleCenter, r, 0)) : (this._handleRight.setNodeMask(0), this._handleLeft.setNodeMask(0), this._handleCenter.setNodeMask(0))
                },
                _updateHandleWidget: function (e, t, i) {
                    var n = e.getMatrix();
                    je.mat4.fromZRotation(n, i), je.mat4.rotateY(n, n, t), je.mat4.translate(n, n, Ke), e.dirtyBound()
                },
                _updatePitchWidget: (ke = je.vec3.create(), Ze = je.vec3.create(), function (e, t) {
                    var i = e.getMatrix(),
                        n = Math.sin(t),
                        r = Math.cos(t);
                    je.vec3.set(ke, 0, 0, n), je.vec3.set(Ze, r, r, 1), je.mat4.fromTranslation(i, ke), je.mat4.scale(i, i, Ze)
                })
            });
            const st = ot;
            var lt, ut = i("3XAv"),
                ct = i("PpZu"),
                ht = g.Z.osg,
                dt = g.Z.osgAnimation,
                gt = function (e, t, i) {
                    this.cameraUpdateCallback = i, this._fpsDist = -1, this._manipulator = e, this._eyeEnd = ht.vec3.create(), this._eyeDeltaLen = 0, this._targetEnd = ht.vec3.create(), this._targetDeltaLen = 0, this._lastRatio = 0, this._preventFlip = !1, ct.Z.call(this, t), this._finished = !0, this._easingFunction = dt.easeOutQuart
                };
            ht.createPrototypeObject(gt, ht.objectInherit(ct.Z.prototype, {
                setTargetAndEye: (lt = ht.vec3.create(), function (e, t, i) {
                    if (this._preventFlip = i, this._finished) {
                        var n = this._manipulator.getManipulatorList()[Ee.FPS];
                        this._fpsDist = n.getDistance()
                    }
                    ht.vec3.copy(this._eyeEnd, t), this._manipulator.getEyePosition(lt), this._eyeDeltaLen = ht.vec3.len(ht.vec3.sub(lt, t, lt)), ht.vec3.copy(this._targetEnd, e), this._manipulator.getTarget(lt), this._targetDeltaLen = ht.vec3.len(ht.vec3.sub(lt, e, lt)), this._lastRatio = 0, this.reset()
                }),
                update: function () {
                    var e = ht.vec3.create(),
                        t = ht.vec3.create(),
                        i = ht.vec3.create(),
                        n = ht.vec3.create();
                    return function (r, a) {
                        if (!0 === this._finished) return !0;
                        var o = this._manipulator,
                            s = o.getCurrentManipulatorIndex();
                        s === Ee.FPS && o.setManipulatorIndex(Ee.ORBIT);
                        var l = a.getFrameStamp().getSimulationTime(),
                            u = this.interpolate(l, r, a),
                            c = (u = this._easingFunction(u)) - this._lastRatio;
                        this._lastRatio = u;
                        var h = this._manipulator;
                        if (h.getEyePosition(e), h.getTarget(t), ht.vec3.sub(i, this._targetEnd, t), ht.vec3.normalize(i, i), ht.vec3.add(n, t, ht.vec3.scale(n, i, c * this._targetDeltaLen)), h.setTarget(n), ht.vec3.sub(i, this._eyeEnd, e), ht.vec3.normalize(i, i), ht.vec3.add(n, e, ht.vec3.scale(n, i, c * this._eyeDeltaLen)), h.setEyePosition(n, this._preventFlip), s === Ee.FPS) {
                            var d = o.getDistance();
                            o.setManipulatorIndex(s), o.getCurrentManipulator().setDistance(this._finished ? this._fpsDist : d)
                        }
                        return this.cameraUpdateCallback(!0 === this._finished), !0
                    }
                }(),
                setEasingFunction: function (e) {
                    this._easingFunction = dt[e]
                }
            }), "osgtestdemo2024", "UpdateCallbackCameraAnimation");
            const ft = gt;
            var mt = g.Z.osg,
                pt = g.Z.InputGroups,
                vt = Math.PI / 180,
                _t = 3.14159265,
                St = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.model;
                        e.bind("change:indexManipulator", this.onIndexManipulatorChanged, this), e.bind("change:node", this.onNodeChanged, this), e.bind("change:minSpeed", this.onNodeChanged, this), e.bind("change:webVR", this.setVR, this), e.bind("change:fov", this.onFov, this), e.bind("change:nearFarRatio", this.onNearFarRatio, this), e.bind("change:animationDuration", this.onDurationChanged, this), e.bind("change:easingFunction", this.onEasingChanged, this), e.bind("setTargetAndEye", this.onTargetAndEyeChanged, this), e.bind("change:useCameraConstraints", this._onUseCamConstrainsToggle, this), e.bind("change:usePanConstraints", this.refreshConstraints, this), e.bind("change:useZoomConstraints", this.refreshConstraints, this), e.bind("change:zoomIn", this.refreshConstraints, this), e.bind("change:zoomOut", this.refreshConstraints, this), e.bind("change:usePitchConstraints", this.refreshConstraints, this), e.bind("change:right", this.refreshConstraints, this), e.bind("change:useYawConstraints", this.refreshConstraints, this), e.bind("change:up", this.refreshConstraints, this), e.bind("change:down", this.refreshConstraints, this), e.bind("targetChanged", this.onTargetChanged, this), e.bind("refreshConstraints", this.refreshConstraints, this), e.bind("saveZoomIn", this._saveZoom.bind(this, "zoomIn")), e.bind("saveZoomOut", this._saveZoom.bind(this, "zoomOut")), e.bind("change:displayGizmo", this._updateGizmoDisplay.bind(this)), this._viewer = this.options.context.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._switchManipulator = new Ee(this._viewer.getInputManager(), this.cameraMove.bind(this)), this._viewerOSGJS.setupManipulator(this._switchManipulator), this._featureNode = new mt.Node("Camera");
                        var t = e.shouldPlayFirstCameraAnimation();
                        if (this._callbackCameraAnimation = new ft(this._switchManipulator, e.get("animationDuration"), function (i) {
                            if (i)
                                if (t) L.Z.resolveFirstCameraAnimation(), t = !1;
                                else {
                                    var n = e.get("userEndAnimationCallback");
                                    n && (n(), e.set("userEndAnimationCallback", void 0))
                                }
                            this.cameraMove()
                        }.bind(this)), this._featureNode.addUpdateCallback(this._callbackCameraAnimation), this.model.bind("change:enableCameraConstraints", this.focusOnTarget, this), this.onIndexManipulatorChanged(), this._dolly = !1, this.onFov(), this.onNearFarRatio(), this._dolly = !0, L.Z.getFirstCameraAnimation().then(function () {
                            !e.get("webVR") && this.model.get("useCameraConstraints") && (this._updateGizmoDisplay(), this.focusOnTarget(), this._switchManipulator.getOrbitManipulator().enableRecenter(!this.model.get("useCameraConstraints")), this.initFeatureBridge())
                        }.bind(this)), !(0, ut.Z)()) {
                            this._cameraIdle = !0;
                            var i = U.Z.getFrameTimeAverage();
                            this.cameraIdleNessDetectBinded = this.cameraIdleNessDetect.bind(this), this.timer = window.setTimeout(this.cameraIdleNessDetectBinded, i)
                        }
                    },
                    initFeatureBridge: function () {
                        this.model._viewer.getFeatures().inspector.getModel().bind("change:uiVisible", this._onInspectorVisiblilityChange.bind(this))
                    },
                    _onInspectorVisiblilityChange: function (e) {
                        var t = e.get("uiVisible");
                        this.model.set("enableCameraConstraints", !t)
                    },
                    setVR: function () {
                        var e = this._viewerOSGJS.getManipulator(),
                            t = this.model.get("webVR");
                        e.setDelay(t ? 1 : .15);
                        var i = this._viewerOSGJS.getInputManager();
                        if (this._viewerOSGJS.requestContinuousUpdate(!0), t) {
                            this.lastMode = this.model.get("indexManipulator");
                            var n = !!this._viewerOSGJS.getVRSession();
                            i.setEnable(pt.FPS_MANIPULATOR_TOUCH, !1), i.setEnable(pt.FPS_MANIPULATOR_WEBVR, n), i.setEnable(pt.FPS_MANIPULATOR_DEVICEORIENTATION, !n), this.model.set("indexManipulator", Ee.FPS)
                        } else i.setEnable(pt.FPS_MANIPULATOR_TOUCH, !0), i.setEnable(pt.FPS_MANIPULATOR_WEBVR, !1), i.setEnable(pt.FPS_MANIPULATOR_DEVICEORIENTATION, !1), void 0 !== this.lastMode && this.model.set("indexManipulator", this.lastMode);
                        var r = this._viewer.getFeatures();
                        r && !r.webVR && e.computeHomePosition()
                    },
                    onDurationChanged: function () {
                        this._callbackCameraAnimation.setDuration(this.model.get("animationDuration"))
                    },
                    onEasingChanged: function () {
                        this._callbackCameraAnimation.setEasingFunction(this.model.get("easingFunction"))
                    },
                    onTargetAndEyeChanged: function (e) {
                        this._callbackCameraAnimation.setTargetAndEye(this.model.get("animationTarget"), this.model.get("animationEye"), e)
                    },
                    canMoveTarget: function () {
                        return this.model.get("indexManipulator") === Ee.FPS || !this._switchManipulator.getOrbitManipulator().isConstrainPan()
                    },
                    onFov: function () {
                        var e = this._viewer.getCamera(),
                            t = e.getViewport(),
                            i = t.width() / t.height();
                        if (mt.mat4.perspective(e.getProjectionMatrix(), this.model.get("fov") * vt, i, 1, 1e3), U.Z.draw(), !this.model.get("dollyPrevent")) {
                            if (this._dolly) {
                                var n = this.options.context.getViewer().getViewerOSGJS().getManipulator(),
                                    r = n.getCurrentManipulator();
                                if (r) {
                                    var a = r.getHomeBoundingSphere();
                                    a && n.setDistance(r.getHomeDistance(a))
                                }
                            }
                            this.model.saveCameraPosition()
                        }
                    },
                    onNearFarRatio: function () {
                        this.model.set("minSpeed", 15 * this.model.get("nearFarRatio")), U.Z.draw()
                    },
                    getNode: function () {
                        return this._featureNode
                    },
                    getWidgetNode: function () {
                        return this._widgetNode || (this._widgetNode = new mt.Node, this._widgetNode.setNodeMask(0)), this._widgetNode
                    },
                    onIndexManipulatorChanged: function () {
                        this._switchManipulator.setManipulatorIndex(this.model.get("indexManipulator"))
                    },
                    onNodeChanged: function () {
                        if (this._dolly) {
                            var e = this._switchManipulator;
                            e.setNode(this.model.get("node"));
                            var t = e.getOrbitManipulator(),
                                i = this._switchManipulator.getHomeBoundingSphere().radius();
                            t.setMinSpeed(this.model.get("minSpeed") * i)
                        }
                    },
                    focusOnTarget: function () {
                        this.model.get("enableCameraConstraints") && !this.model.get("preventCameraConstraintsFocus") && this.lookatTarget(), this.refreshConstraints()
                    },
                    lookatTarget: function () {
                        var e = mt.vec3.create();
                        return function () {
                            this._switchManipulator.getOrbitManipulator().getEyePosition(e), this._viewer.getFeaturesManager().focusOnTargetAndEye(this.model.get("target"), e, .3, !0)
                        }
                    }(),
                    onTargetChanged: function () {
                        this.model.get("usePanConstraints") && this.model.get("enableCameraConstraints") && this.focusOnTarget()
                    },
                    _initGizmo: function () {
                        this._widgetNode = new mt.Camera, this._widgetNode.setName("Camera - Constraints - Widgets"), this._featureNode.addChild(this._widgetNode), this._widgetNode.setNearFarRatio(5e-5), this._widgetNode.setNodeMask(Pe.Z.NO_SHADOW), this._gizmo = new st(this._switchManipulator.getOrbitManipulator(), this.model), this._widgetNode.addChild(this._gizmo), this._widgetNode.addUpdateCallback(this)
                    },
                    _updateGizmoDisplay: function () {
                        if (L.Z.getFirstCameraAnimation().isFulfilled()) {
                            var e = this.model.get("displayGizmo");
                            !this._gizmo && e && (this._initGizmo(), this.refreshConstraints(), (0, o.Z)() && this._gizmo.setPivotSelected(this.model.get("useCameraConstraints"))), this._gizmo && this._gizmo.setVisible(e)
                        }
                    },
                    _onUseCamConstrainsToggle: function () {
                        var e = this.model.get("useCameraConstraints");
                        this._gizmo && this._gizmo.setPivotSelected(e), this.refreshConstraints(), this._switchManipulator.getOrbitManipulator().enableRecenter(!e)
                    },
                    refreshConstraints: function () {
                        L.Z.getFirstCameraAnimation().isFulfilled() && this.applyConstraints()
                    },
                    applyConstraints: function () {
                        if (!this._hasHotSpots()) {
                            var e = this.model,
                                t = e.getInstance();
                            e.get("enableCameraConstraints") && this._applyModel(t);
                            var i = this._switchManipulator.getOrbitManipulator();
                            i.setLimitYawLeft(t.left), i.setLimitYawRight(t.right), i.setConstrainYaw(t.useYawConstraints);
                            var n = .5 * Math.PI * .99;
                            i.setLimitPitchDown(Math.min(n, Math.max(-n, t.down))), i.setLimitPitchUp(Math.min(n, Math.max(-n, t.up))), i.setConstrainPitch(t.usePitchConstraints), -1 === t.zoomOut && (t.zoomOut = 1 / 0), i.setLimitZoomOut(t.zoomOut), i.setConstrainZoom(t.useZoomConstraints);
                            var r = !(t.usePanConstraints && e.get("enableCameraConstraints") && e.get("useCameraConstraints"));
                            if (t.zoomIn > 0) i.setLimitZoomIn(t.zoomIn);
                            else {
                                var a = this._switchManipulator.getHomeBoundingSphere().radius();
                                i.setLimitZoomIn(.001 * a), t.useCameraConstraints && t.useZoomConstraints && this.model.set("zoomIn", t.zoomIn)
                            }
                            t.zoomIn >= t.zoomOut && (t.zoomOut = 1 / 0, i.setLimitZoomOut(t.zoomOut), t.useCameraConstraints && t.useZoomConstraints && this.model.set("zoomOut", t.zoomOut)), i.setAutoPushTarget(r && !t.useZoomConstraints), i.setConstrainPan(!r), i.setPanConstraintTarget(e.get("target")), this._gizmo && (this._gizmo.updateConstraints(), r || this.lookatTarget()), U.Z.draw()
                        }
                    },
                    update: function () {
                        if (this._hasHotSpots()) return !1;
                        var e = this._viewer.getOptions().widgetAPI,
                            t = e && e.getTabbedWidget().get();
                        return this.model.get("displayGizmo") && this._gizmo.update(this._viewer.getCamera()), "scene" === t ? this._currentTab !== t && this.model.trigger("TabEnter") : this._currentTab !== t && (this.model.trigger("TabLeave"), this.model.set("displayGizmo", !1)), this._currentTab = t, !0
                    },
                    _hasHotSpots: function () {
                        if (this.model.get("viewer-api-hotspots")) return !1;
                        var e = this._viewer.getFeatures().hotspot.getModel(),
                            t = e.get("hotspots").length && e.get("visible");
                        return t && this.model.get("useCameraConstraints") && (this.model.set("useCameraConstraints", !1), (0, o.Z)() && this.model.trigger("ForceDisable")), t
                    },
                    _applyModel: function (e) {
                        var t = this.model;
                        t.get("useCameraConstraints") && (e.useCameraConstraints = !0, e.usePanConstraints = t.get("usePanConstraints"), e.useZoomConstraints = t.get("useZoomConstraints"), e.useZoomConstraints && (e.zoomIn = t.get("zoomIn"), e.zoomOut = t.get("zoomOut")), e.useYawConstraints = t.get("useYawConstraints"), e.useYawConstraints && (e.left = Math.max(t.get("left"), -_t), e.right = Math.min(t.get("right"), _t)), e.usePitchConstraints = t.get("usePitchConstraints"), e.usePitchConstraints && (e.up = t.get("up"), e.down = t.get("down")), (0, o.Z)() && (0, l.Z)().apiLog && (console.log("------"), console.log("Viewer API  Camera Constraints json:"), console.log(t.editorGetJSON()), console.log("------")))
                    },
                    _saveZoom: function (e) {
                        var t = this.model.limits(),
                            i = Math.max(this._switchManipulator.getOrbitManipulator().getDistance(), t[e].min);
                        this.model.set(e, i)
                    },
                    cameraMove: function (e) {
                        e && U.Z.draw(), this._cameraMoved = mt.Timer.instance().tick(), this._cameraIdle && (this._viewer.trigger("cameraStart"), this._cameraIdle = !1)
                    },
                    cameraIdleNessDetect: function () {
                        var e = 2 * U.Z.getFrameTimeAverage();
                        this.timer = window.setTimeout(this.cameraIdleNessDetectBinded, e), mt.Timer.instance().tick() - this._cameraMoved - e <= e || this._cameraIdle || (this._viewer.trigger("cameraStop"), this._cameraIdle = !0)
                    }
                });
            var xt = {
                FeatureName: "camera",
                ModelType: ee,
                ViewListType: [St]
            },
                Ct = n.Z.create(xt);
            Ct.prototype.getManipulator = function () {
                return this._views[0]._switchManipulator
            }, Ct.prototype.canMoveTarget = function () {
                return this._views[0].canMoveTarget()
            }, Ct.prototype.getNode = function () {
                return this._views[0].getNode()
            }, Ct.prototype.getWidgetNode = function () {
                return this._views[0].getWidgetNode()
            };
            const Tt = Ct;
            var Mt = i("mv18"),
                bt = i("QG/p"),
                yt = g.Z.osg,
                At = function () {
                    yt.NodeVisitor.call(this, yt.NodeVisitor.TRAVERSE_ALL_CHILDREN), this._source = "", this._authoringTool = "", this._sourceTool = ""
                };
            yt.createPrototypeObject(At, yt.objectInherit(yt.NodeVisitor.prototype, {
                getSource: function () {
                    return this._source
                },
                getAuthoringTool: function () {
                    return this._authoringTool
                },
                getSourceTool: function () {
                    return this._sourceTool
                },
                extractSource: function (e) {
                    for (var t = 0, i = e.length; t < i; ++t) {
                        var n = e[t],
                            r = n.Name;
                        "source" === r ? this._source = n.Value : "authoring_tool" === r ? this._authoringTool = n.Value : "source_tool" === r && (this._sourceTool = n.Value)
                    }
                },
                checkStateSet: function (e) {
                    e && e.getUserData() && this.extractSource(e.getUserData())
                },
                checkNode: function (e) {
                    var t = e.getUserData();
                    if (!t) {
                        if ("LightSource" !== e.className()) return;
                        if (!e.getLight()) return;
                        if (!(t = e.getLight().getUserData())) return
                    }
                    this.extractSource(t)
                },
                apply: function (e) {
                    this._source || (this.checkNode(e), this._source || (this.checkStateSet(e.getStateSet()), this._source || this.traverse(e)))
                }
            }));
            const Rt = At;
            var wt = i("oQ3C"),
                Et = i("3K6F"),
                Pt = i("/Ybn"),
                Nt = i("UZbZ"),
                Ot = i("lqp/"),
                Dt = i("IAxr"),
                It = i("RYQm"),
                Ft = i("mSEu"),
                Lt = i("vrT6"),
                Vt = i("md6q"),
                Bt = i("5Mmo"),
                Ut = i("kRpH"),
                kt = g.Z.osg,
                Zt = function (e, t, i) {
                    kt.NodeVisitor.call(this, kt.NodeVisitor.TRAVERSE_ALL_CHILDREN), this._lights = [], this._materials = [], this._materialManager = e, this._stateSetsProcessed = {}, this._authoringTool = t, this._source = i, this._style = "", this._hasMetal = void 0, this._globalEnforceRoughness = void 0, this._dictionary = Ft.Z.channelNames, this._dictionaryKeys = Object.keys(Ft.Z.channelNames), this._sortedImages = void 0, this._textureFactor1 = !1, this._textureUnit0 = !1
                };
            kt.createPrototypeObject(Zt, kt.objectInherit(kt.NodeVisitor.prototype, {
                getStyle: function () {
                    return this._style
                },
                hasMetallicWorkflow: function () {
                    return this._hasMetal
                },
                getLights: function () {
                    return this._lights
                },
                getMaterials: function () {
                    return this._materials
                },
                copyDiffuse: function (e) {
                    var t = e.getChannels().DiffuseColor,
                        i = e.getChannels().AlbedoPBR,
                        n = e.getChannels().DiffusePBR,
                        r = t.get("UVTransforms"),
                        a = t.getColor(),
                        o = t.getFactor(),
                        s = t.getTextureModel();
                    a && (i.setColor(a), n.setColor(a)), i.setFactor(o), n.setFactor(o), s && (i.setTextureModel(s), n.setTextureModel(s)), r && (i.set("UVTransforms", r), n.set("UVTransforms", r))
                },
                matchNameAgainstDict: function (e, t, i) {
                    var n = (0, Vt.Z)(e);
                    if (!t) return !1;
                    for (var r = 0; r < t.length; r++) {
                        var a = t[r],
                            o = (0, Lt.Z)(n, a);
                        if (o < i && o < a.length) return !0
                    }
                    return !1
                },
                channelTextureExtract: function (e, t) {
                    var i = e.getChannels()[t];
                    if (i) {
                        var n = i.getTextureModel();
                        if (n) return n.getImageModel().get("name")
                    }
                },
                channelTextureMatch: function (e, t, i, n) {
                    var r = this.channelTextureExtract(e, t);
                    return r && this.matchNameAgainstDict(r, i, n)
                },
                hasTextureChannel: function (e, t) {
                    return void 0 !== this.channelTextureExtract(e, t)
                },
                channelTextureCopy: function (e, t, i) {
                    var n = e.getChannels();
                    if (this.channelTextureExtract(e, t))
                        for (var r = n[t].get("UVTransforms"), a = i.length; a--;) n[i[a]].setTextureModel(n[t].getTextureModel().clone()), void 0 !== r && n[i[a]].set("UVTransforms", r)
                },
                checkPBRSlot: function (e) {
                    if (e)
                        for (var t = 0; t < this._dictionaryKeys.length; t++) {
                            var i = this._dictionaryKeys[t],
                                n = this._dictionary[i];
                            if (this.matchNameAgainstDict(e, n, Ft.Z.maxLevenshteinDistance)) return i
                        }
                },
                assignPBRTextureFromFilenames: function (e, t) {
                    for (var i = 0, n = e.length; i < n; ++i) {
                        var r = e[i],
                            a = r.getName(),
                            o = this.checkPBRSlot(a);
                        if (!o && r.getImage() && (a = r.getImage().getURL(), o = this.checkPBRSlot(a)), o) {
                            var s = t.getChannels()[o];
                            if (!s.getTextureModel()) {
                                var l = this.createTextureOptionsFromTextureOSG(r);
                                l && s.setupTextureModel(l)
                            }
                        }
                    }
                },
                checkChannelsAndSetWorkFlowRoughGloss: function (e) {
                    if (e) {
                        var t = e.getChannels(),
                            i = this.hasTextureChannel(e, "GlossinessPBR"),
                            n = this.hasTextureChannel(e, "SpecularPBR"),
                            r = this.hasTextureChannel(e, "RoughnessPBR");
                        this.hasTextureChannel(e, "BumpMap") && t.BumpMap.setFactor(10), this.hasTextureChannel(e, "MetalnessPBR") && (this._hasMetal = !0), n && void 0 === this._hasMetal && (this._hasMetal = !1);
                        var a = r || this._globalEnforceRoughness;
                        a || (a = !i && void 0 === this._globalEnforceRoughness), e.setWorkFlowRoughGloss(a, !1)
                    }
                },
                matchFullNameAgainstDict: function (e, t) {
                    if (!t) return !1;
                    for (var i = 0; i < t.length; ++i)
                        if (!(t[i].length < 4) && -1 !== e.indexOf(t[i])) return !0;
                    return !1
                },
                setChannelsFromImagesNames: function (e, t, i, n) {
                    for (var r = Ft.Z.maxLevenshteinDistance, a = 0, o = t.length; a < o; a++)
                        for (var s = t[a], l = this._dictionary[s], u = 0, c = i.length; u < c; u++) {
                            var h = i[u].get("name").toLowerCase();
                            if (n ? this.matchFullNameAgainstDict(h, l) : this.matchNameAgainstDict(h, l, r)) {
                                var d = e.getChannels()[s];
                                d.setTextureModel(new Bt.Z({
                                    image: i[u]
                                })), d.setFactor(1), e.setChannelEnable(d.get("name"), !0)
                            }
                        }
                },
                setGlossinessPBRFromSpecularGlossiness: function (e, t, i) {
                    var n = .2126 * t[0] + .7152 * t[1] + .0722 * t[2],
                        r = Math.pow(1e4 * i, .25) / 100 * n;
                    e.setChannelFactor("GlossinessPBR", r), e.setChannelEnable("GlossinessPBR", !0), this._globalEnforceRoughness = !1
                },
                getPBRChannels: function (e) {
                    var t = [],
                        i = e.getChannels();
                    for (var n in i) - 1 !== n.indexOf("PBR") && t.push(n);
                    return t
                },
                channelMatchAndCopy: function (e, t, i) {
                    var n = this._dictionary[i];
                    if (this.channelTextureMatch(e, t, n, 2)) return this.channelTextureCopy(e, t, [i])
                },
                checkForPBRTextureFromChannelsAndFilenames: function (e) {
                    if (e) {
                        for (var t = this.getPBRChannels(e), i = t.length; i--;)
                            if (void 0 !== this.channelTextureExtract(e, t[i])) return;
                        this.channelTextureCopy(e, "DiffuseColor", ["AlbedoPBR", "DiffusePBR"]), this.channelTextureCopy(e, "DiffuseIntensity", ["AOPBR"]), this.channelMatchAndCopy(e, "SpecularColor", "MetalnessPBR") || this.channelMatchAndCopy(e, "SpecularHardness", "MetalnessPBR") || this.channelMatchAndCopy(e, "SpecularColor", "SpecularPBR") || this.channelMatchAndCopy(e, "SpecularHardness", "SpecularPBR"), this.channelMatchAndCopy(e, "SpecularColor", "RoughnessPBR") || this.channelMatchAndCopy(e, "SpecularHardness", "RoughnessPBR") || this.channelMatchAndCopy(e, "SpecularColor", "GlossinessPBR") || this.channelMatchAndCopy(e, "SpecularHardness", "GlossinessPBR")
                    }
                },
                getOrCreateSortedImagesList: function () {
                    return void 0 === this._sortedImages && (this._sortedImages = this._materialManager.getImageCollection().clone(), this._sortedImages.comparator = function (e, t) {
                        return (e.get("version") || 0) - (t.get("version") || 0)
                    }, this._sortedImages.sort()), this._sortedImages
                },
                checkForPBRTextureFromMaterialAndFilenames: function (e, t) {
                    if (e && 0 !== this._materialManager.getImageCollection().length) {
                        var i = [],
                            n = e.getChannels();
                        for (var r in n) this.channelTextureExtract(e, r) || i.push(r);
                        for (var a = [], o = this.getOrCreateSortedImagesList(), s = e.get("name").toLowerCase(), l = 0; l < o.length; l++) {
                            var u = o.models[l].get("name");
                            (t || -1 !== u.toLowerCase().indexOf(s)) && a.push(o.models[l])
                        }
                        this.setChannelsFromImagesNames(e, i, a, t)
                    }
                },
                hasMaterialAttributes: function (e) {
                    return e.getAttribute("Material")
                },
                hasTextureAttributes: function (e) {
                    for (var t = 0, i = e.getNumTextureAttributeLists(); t < i; t++)
                        if (e.getTextureAttribute(t, "Texture")) return !0;
                    return !1
                },
                processDefaultMaterial: function (e, t) {
                    t.removeAttribute("Material");
                    for (var i = 0, n = t.getNumTextureAttributeLists(); i < n; i++) t.removeTextureAttribute(i, "Texture")
                },
                getReferencedTextures: function (e) {
                    for (var t = [], i = 0; i < e.getNumTextureAttributeLists(); i++) {
                        var n = e.getTextureAttribute(i, "Texture");
                        n && ("PackedMaterialTexture" === n.className() && (n = n.getTexture()), t[i] = n)
                    }
                    return t
                },
                createMaterial: function (e, t) {
                    var i = this._materialManager.createMaterial(e, t);
                    return this._materials.push(i), i
                },
                createTextureOptionsFromTextureOSG: function (e) {
                    var t = Ut.Z.getOptions(e),
                        i = e.getImage().getURL(),
                        n = this._materialManager.getImageCollection().getImageFromURL(i);
                    if (n) return t.image = n, t;
                    kt.error("Cannot find image in collection : " + i)
                },
                mapTexturesOnMaterial: function (e, t) {
                    for (var i = ["EmitColor", "DiffuseColor", "SpecularColor"], n = this.getReferencedTextures(e), r = e.getNumTextureAttributeLists(), a = 0, o = r; a < o; a++)
                        if (e.getTextureAttribute(a, "Texture")) {
                            var s = 1 === r ? "DiffuseColor" : i[a];
                            if (s && n[a]) {
                                var l = this.createTextureOptionsFromTextureOSG(n[a]);
                                if (l) {
                                    var u = new Bt.Z(l);
                                    this.setMaterialChannelTexture(e, t, a, s, u)
                                }
                            }
                        }
                },
                applyExistingMaterial: function (e, t) {
                    if (e) {
                        var i = this._materialManager.getMaterialByStateSet(e);
                        if (i) {
                            var n = (i.get("stateSet") || e).getInstanceID();
                            if (!0 === this._stateSetsProcessed[n]) return i;
                            this._stateSetsProcessed[n] = !0;
                            var r = e.getAttributeMap().Material,
                                a = this._materialManager.getUniqueMaterialName(r, e, t);
                            return i.set("name", a), i.setStateSet(e), this._materials.push(i), i
                        }
                        this._stateSetsProcessed[e.getInstanceID()] = !0
                    }
                },
                processLightSource: function () { },
                pushLight: function (e) {
                    var t = this.nodePath[this.nodePath.length - 1];
                    t instanceof kt.LightSource && (t.setNodeMask(0), t.setLight(e)), e._worldMatrix = kt.computeLocalToWorld(this.nodePath), this._lights.push(e)
                },
                processNode: function (e) {
                    var t = e.getStateSet();
                    if (t) {
                        var i = this.applyExistingMaterial(t, e);
                        if (i) e.setStateSet(i.get("stateSet"));
                        else {
                            var n = t.getUserData();
                            if (this.hasMaterialAttributes(t) || this.hasTextureAttributes(t))
                                if (n) {
                                    var r = f.Z.convertUserDataToObject(n);
                                    this.processMaterial(e, t, r)
                                } else this.processDefaultMaterial(e, t);
                            i = this._materialManager.getMaterialByStateSet(t), this.checkForPBRTextureFromChannelsAndFilenames(i), this.checkForPBRTextureFromMaterialAndFilenames(i), this.checkChannelsAndSetWorkFlowRoughGloss(i)
                        }
                    }
                },
                apply: function (e) {
                    e.typeID === kt.LightSource.typeID && this.processLightSource(e), this.processNode(e), this.traverse(e)
                },
                handleSingleMaterialMapping: function () {
                    if (1 === this.getMaterials().length) {
                        var e = this.getMaterials()[0];
                        this.checkForPBRTextureFromMaterialAndFilenames(e, !0), this.checkChannelsAndSetWorkFlowRoughGloss(e)
                    }
                },
                setMaterialChannelColor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    return r.setColor && r.setColor(n), r.setEnable(!0), r
                },
                setMaterialChannelFactor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    return r.setFactor(n), r.setEnable(!0), r
                },
                setMaterialChannelTexture: function (e, t, i, n, r) {
                    e.removeTextureAttribute(i, "Texture");
                    var a = t.getChannels()[n];
                    return a.setTextureModel(r), a.resetTextureFormat(), this._textureFactor1 && a.setFactor(1), a.setTexCoordUnit(this._textureUnit0 ? 0 : i), a.setEnable(!0), a
                },
                setChannelsFromMetaDataFactor: function (e, t) {
                    if (this._metaMapFactor) {
                        var i = this._metaMapFactor;
                        for (var n in i)
                            if (void 0 !== e[n]) {
                                var r = JSON.parse(e[n]);
                                this.setMaterialChannelFactor(e, t, i[n], r)
                            }
                    }
                },
                setChannelsFromMetaDataColor: function (e, t) {
                    if (this._metaMapColor) {
                        var i = this._metaMapColor;
                        for (var n in i)
                            if (void 0 !== e[n]) {
                                var r = JSON.parse(e[n]);
                                this.setMaterialChannelColor(e, t, i[n], r)
                            }
                    }
                },
                setChannelsFromMetaDataTexture: function (e, t, i) {
                    if (this._metaMapTexture) {
                        var n = this.getReferencedTextures(t),
                            r = this._metaMapTexture;
                        for (var a in r)
                            if (void 0 !== e[a]) {
                                var o = JSON.parse(e[a]),
                                    s = n[o];
                                if (s) {
                                    var l = this.createTextureOptionsFromTextureOSG(s);
                                    if (l) {
                                        var u = new Bt.Z(l),
                                            c = r[a];
                                        this.setMaterialChannelTexture(t, i, o, c, u)
                                    }
                                }
                            }
                    }
                },
                handleSeparatedAlphaMaskChannel: function (e) {
                    var t = e.getChannels();
                    if ("alphaMask" === t.Opacity.getTransparency()) {
                        if (t.AlphaMask.setEnable(!0), t.AlphaMask.setFactor(t.Opacity.getFactor()), t.AlphaMask.set("invert", t.Opacity.get("invert")), t.Opacity.getTextureModel()) {
                            t.AlphaMask.setTextureModel(t.Opacity.getTextureModel()), t.Opacity.setTextureModel(void 0);
                            var i = t.Opacity.get("UVTransforms");
                            i && t.AlphaMask.set("UVTransforms", i)
                        }
                        t.Opacity.setTransparency("alphaBlend"), t.Opacity.setFactor(1)
                    }
                }
            }));
            const Ht = Zt;
            var Gt = g.Z.osg,
                zt = function () {
                    Gt.Light.apply(this, arguments)
                };
            zt.DIRECTION = Gt.Light.DIRECTION, zt.SPOT = Gt.Light.SPOT, zt.POINT = Gt.Light.POINT, zt.HEMI = Gt.Light.HEMI, Gt.createPrototypeStateAttribute(zt, Gt.objectInherit(Gt.Light.prototype, {
                attributeType: "testdemo2024Light",
                isDirectionLight: function () {
                    return 0 === this._position[3] && (-1 === this._ground[3] || 0 === this._ground[3])
                }
            }), "osgtestdemo2024", "Light");
            var Wt = Gt.vec3.create();
            Gt.LightSource.prototype.computeBoundingSphere = function (e) {
                if (Gt.Node.prototype.computeBoundingSphere.call(this, e), !e.valid()) return e;
                if (void 0 !== this._light && this._referenceFrame === Gt.Transform.RELATIVE_RF) {
                    var t = this._light.getPosition();
                    0 !== t[3] && e.expandByVec3(Gt.vec3.scale(Wt, t, 1 / t[3]))
                }
                return e
            };
            const jt = zt;
            var Xt = g.Z.osg,
                Yt = function () {
                    Ht.apply(this, arguments)
                };
            Xt.createPrototypeObject(Yt, Xt.objectInherit(Ht.prototype, {
                _handleCycleDefaultValue: function (e, t, i, n, r, a) {
                    if (void 0 !== e)
                        if (Array.isArray(e))
                            if ("Opacity" === t)
                                if ("Color" === i) {
                                    var o = e[0] * e[1] * e[2] * e[3];
                                    1 === o && (o = .15), n[r](t, o)
                                } else n[r](t, e);
                            else "SpecularPBR" === t ? ("Color" === i || (e = e[0] * e[1] * e[2] * e[3]), n[r](t, e)) : "Color" === i && "NormalMap" === t || n[r](t, e);
                        else "setChannelFactor" === r && ("Strength" === i && "Emission" === a && (e /= 10), n[r](t, e))
                },
                _handleCycleLinkSpecular: function (e, t, i, n, r, a) {
                    for (var o = 0; o < e.links.length; o++) {
                        var s = e.links[o];
                        if (s.from_node) {
                            var l = t.nodes[s.from_node],
                                u = l && l.texture_slot,
                                c = l && i.getTextureAttribute(u, "Texture");
                            if (!l || !c) return void Xt.warn("Missing Texture linked in " + a + " node destined to " + r);
                            var h = this.createTextureOptionsFromTextureOSG(c);
                            if (h) {
                                var d = n.getChannels()[r];
                                d.setupTextureModel(h), d.resetTextureFormat(), d.setTexCoordUnit(u), d.setEnable(!0), this._texturesAssigned.push(c)
                            }
                        }
                    }
                },
                cyclesNodeToMaterial: function (e, t, i, n, r, a, o) {
                    var s = e.nodes[r];
                    if (void 0 !== s)
                        if (!s.value || s.inputs) {
                            for (var l = 0; l < s.inputs.length; l++) {
                                var u = s.inputs[l];
                                if (u.name === a) {
                                    var c = u.default_value;
                                    if (this._handleCycleDefaultValue(c, o, a, t, n, r), u.links && "SpecularPBR" !== o) return void this._handleCycleLinkSpecular(u, e, i, t, o, r)
                                }
                            } (s = this.findNodeByValueCyclesMetadata(e.nodes, r)) && s.value && t[n](o, s.value)
                        } else t[n](o, s.value)
                },
                findNodeByValueCyclesMetadata: function (e, t) {
                    for (var i in e) {
                        var n = e[i];
                        if (n instanceof Object) {
                            var r = this.findNodeByValueCyclesMetadata(n, t);
                            if (void 0 !== r) return r
                        } else if (n === t) return e
                    }
                },
                metaDataToMaterial: function (e, t, i, n, r, a) {
                    if (void 0 !== e[n]) {
                        void 0 === r && (r = n);
                        var o = "setChannel" + i;
                        void 0 !== t[o] ? void 0 === a || !0 === a ? t[o](r, JSON.parse(e[n])) : t[o](r, e[n]) : Xt.warn("material has not method " + o)
                    }
                },
                setTextureFromBlender: function (e, t, i, n, r) {
                    var a = this.createTextureOptionsFromTextureOSG(n);
                    if (a) {
                        var o = e.getChannels()[t];
                        o.setFactor(r), o.setupTextureModel(a), o.setTexCoordUnit(i), o.setEnable(!0)
                    }
                },
                processDefaultMaterial: function (e, t) {
                    t.removeAttribute("Material");
                    for (var i = 0, n = t.getNumTextureAttributeLists(); i < n; i++) t.removeTextureAttribute(i, "Texture");
                    e.setStateSet(void 0)
                },
                processLightSource: function (e) {
                    var t = e.getLight();
                    if (t && void 0 !== t.getUserData() && t.typeID !== jt.typeID) {
                        var i = t.getUserData(),
                            n = f.Z.convertUserDataToObject(i),
                            r = new jt;
                        "AREA" !== n.Type && "SUN" !== n.Type && "HEMI" !== n.Type || (n.Type = "DIRECTION"), r.setLightType(n.Type), void 0 !== n.SpotSize && r.setSpotCutoff(90 * JSON.parse(n.SpotSize) / Math.PI), void 0 !== n.SpotBlend && r.setSpotBlend(JSON.parse(n.SpotBlend)), Xt.vec3.scale(r.getDiffuse(), JSON.parse(n.Color), JSON.parse(n.Energy));
                        var a = 1 / JSON.parse(n.Distance);
                        r.setQuadraticAttenuation(Math.abs(a) === 1 / 0 ? 0 : a), this.pushLight(r)
                    }
                },
                processCyclesGraph: function (e, t, i) {
                    var n;
                    try {
                        n = JSON.parse(i.NodeTree)
                    } catch (e) {
                        return Xt.warn("error in blender cycle graph json " + e), !0
                    }
                    if (void 0 === n) return !0;
                    this._texturesAssigned = [], this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Diffuse BSDF", "Color", "DiffusePBR"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Diffuse BSDF", "Roughness", "RoughnessPBR"), this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Diffuse BSDF", "Normal", "NormalMap"), this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Glossy BSDF", "Color", "SpecularPBR"), e.setChannelFactor("SpecularPBR", 1), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Glossy BSDF", "Roughness", "RoughnessPBR"), this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Glossy BSDF", "Normal", "NormalMap"), this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Bump", "Height", "NormalMap"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Bump", "Strength", "NormalMap"), this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Emission", "Color", "EmitColor"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Emission", "Strength", "EmitColor"), this.cyclesNodeToMaterial(n, e, t, "setChannelColor", "Ambient Occlusion", "Color", "AOPBR"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Ambient Occlusion", "Strength", "AOPBR"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Transparency", "Strength", "Opacity"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Transparent BSDF", "Color", "Opacity"), this.cyclesNodeToMaterial(n, e, t, "setChannelFactor", "Glass BSDF", "Color", "Opacity");
                    for (var r = [], a = 0, o = t.getNumTextureAttributeLists(); a < o; a++) {
                        var s = t.getTextureAttribute(a, "Texture");
                        s && -1 === this._texturesAssigned.indexOf(s) && r.push(s)
                    }
                    return this.assignPBRTextureFromFilenames(r, e), e.setWorkFlowMetalSpec(!1, !1), e.setWorkFlowRoughGloss(!0, !1), this._hasMetal = !1, !1
                },
                processMaterial: function (e, t, i) {
                    var n = this.createMaterial(e, t),
                        r = t.getAttribute("Material"),
                        a = r && r.getUserData(),
                        o = f.Z.convertUserDataToObject(a),
                        s = !0;
                    o.NodeTree && (s = this.processCyclesGraph(n, t, o)), s && (this.metaDataToMaterial(o, n, "Color", "DiffuseColor"), this.metaDataToMaterial(o, n, "Factor", "DiffuseIntensity", "DiffuseColor"), n.setChannelEnable("DiffuseColor", !0), this.metaDataToMaterial(o, n, "Color", "SpecularColor"), this.metaDataToMaterial(o, n, "Factor", "SpecularIntensity", "SpecularColor"), n.setChannelEnable("SpecularColor", !0), this.metaDataToMaterial(o, n, "Factor", "Emit", "EmitColor"), n.setChannelEnable("EmitColor", !0), this.metaDataToMaterial(o, n, "Factor", "SpecularHardness"), n.setChannelEnable("SpecularHardness", !0), void 0 !== o.Translucency && (n.setChannelFactor("Opacity", 1 - JSON.parse(o.Translucency)), n.setChannelEnable("Opacity", !0)), void 0 !== i.Shadeless && n.set("shadeless", i.Shadeless));
                    var l = (0, wt.Z)([function (e) {
                        return (0, Mt.Z)(e, (function (e) {
                            var t = e.Name.substr(0, 2),
                                i = parseInt(t, 10);
                            if (!isNaN(i)) return i
                        }))
                    }, function (e) {
                        return (0, Et.Z)(e, void 0)
                    }, Pt.Z, function (e) {
                        return (0, Nt.Z)(e, (function (e) {
                            return e
                        }))
                    }]),
                        u = l(t.getUserData());
                    t.removeAttribute("Material");
                    var c = {},
                        h = ["DiffuseColor", "DiffuseIntensity", "SpecularColor", "Normal", "Bump", "Translucency", "Alpha", "EmitColor", "SpecularHardness"],
                        d = this;
                    for (var g in (0, Ot.Z)(u, (function (e) {
                        var i = (0, Dt.Z)(t.getUserData(), (function (t) {
                            var i = t.Name.substr(0, 2);
                            return parseInt(i, 10) === e
                        }));
                        (0, Ot.Z)(i, (function (e) {
                            var i = e.Name.substr(0, 2),
                                r = parseInt(i, 10),
                                a = t.getTextureAttribute(r, "Texture");
                            if (void 0 !== a) {
                                c[r] = a;
                                var o = e.Name.substr(3);
                                if (!0 === (0, It.Z)(h, o)) {
                                    var s = parseFloat(e.Value);
                                    "DiffuseColor" === o ? void 0 !== n.getChannels().DiffuseColor.getTextureModel() && void 0 === n.getChannels().DiffuseIntensity.getTextureModel() && (o = "DiffuseIntensity") : "Alpha" === o ? o = "Opacity" : "Translucency" === o ? (o = "Opacity", s = 1 - s) : "Normal" === o ? o = "NormalMap" : "Bump" === o && (o = "BumpMap"), d.setTextureFromBlender(n, o, r, a, s)
                                } else "UsePremultiplyAlpha" === o ? Xt.warn("UsePremultiplyAlpha not supported") : "UseAlpha" === o ? Xt.warn("UseAlpha not supported") : Xt.warn("channel " + o + " not supported")
                            } else Xt.warn("missing texture")
                        }))
                    })), c) t.removeTextureAttribute(parseInt(g, 10), "Texture");
                    "ksp" === o.source && (-1 === n.attributes.name.toLowerCase().indexOf("wheel") ? n.getChannels().MetalnessPBR.setFactor(1) : n.getChannels().SpecularF0.setFactor(0), -1 !== n.attributes.name.toLowerCase().indexOf("fairing") && n.getChannels().Opacity.setFactor(.25)), n.setStateSet(t)
                }
            }));
            const Jt = Yt;
            var qt = g.Z.osg,
                Kt = function () {
                    Ht.apply(this, arguments), this._metaMapColor = {
                        emission_color: "EmitColor",
                        diffuse_color: "DiffuseColor",
                        specular_color: "SpecularColor",
                        transparency_color: "Opacity"
                    }, this._metaMapFactor = {
                        bump_amount: "BumpMap",
                        normal_amount: "NormalMap",
                        shininess_amount: "SpecularHardness",
                        transparency_amount: "Opacity"
                    }, this._metaMapTexture = {
                        emissive_unit: "EmitColor",
                        diffuse_unit: "DiffuseColor",
                        specular_unit: "SpecularColor",
                        shininess_unit: "SpecularHardness",
                        transparency_unit: "Opacity",
                        bump_unit: "BumpMap",
                        normal_unit: "NormalMap"
                    }
                };
            qt.createPrototypeObject(Kt, qt.objectInherit(Ht.prototype, {
                setMaterialChannelColor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    r.setEnable(!0), "Opacity" !== i ? (r.setColor && r.setColor(n), "SpecularColor" === i && r.setFactor(1)) : r.setFactor(n[3])
                },
                setMaterialChannelFactor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    if (r.setEnable(!0), "SpecularHardness" === i) {
                        n *= 128;
                        var a = e.specular_color ? JSON.parse(e.specular_color) : qt.vec3.ZERO;
                        this.setGlossinessPBRFromSpecularGlossiness(t, a, n)
                    }
                    r.setFactor(n)
                },
                _extractMetaData: function (e, t, i) {
                    for (var n in t)
                        if (n.startsWith(i)) {
                            var r = n.substr(i.length + 1);
                            e[r] || (e[r] = t[n])
                        }
                },
                _cleanMetaData: function (e) {
                    var t = {};
                    return this._extractMetaData(t, e, "lambert"), this._extractMetaData(t, e, "blinn"), this._extractMetaData(t, e, "phong"), this._extractMetaData(t, e, "extra"), t
                },
                processMaterial: function (e, t, i) {
                    var n = this.createMaterial(e, t),
                        r = n.getChannels();
                    i = this._cleanMetaData(i), this.setChannelsFromMetaDataFactor(i, n), this.setChannelsFromMetaDataColor(i, n), this.setChannelsFromMetaDataTexture(i, t, n), i.transparency_alphamask && r.Opacity.getTextureModel() && r.Opacity.setTransparency("alphaMask"), "substancepainter" === this._source && r.NormalMap.set("flipY", !1), this.handleSeparatedAlphaMaskChannel(n), t.removeAttribute("Material"), n.setStateSet(t)
                }
            }));
            const Qt = Kt;
            var $t = g.Z.osg,
                ei = function () {
                    Ht.apply(this, arguments)
                };
            $t.createPrototypeObject(ei, $t.objectInherit(Ht.prototype, {
                processMaterial: function (e, t) {
                    return this.processDefaultMaterial(e, t)
                },
                processDefaultMaterial: function (e, t) {
                    var i = this.createMaterial(e, t),
                        n = t.getAttribute("Material");
                    return void 0 !== n && (i.setChannelColor("EmitColor", n.getAmbient()), i.setChannelColor("DiffuseColor", n.getDiffuse()), i.setChannelColor("SpecularColor", n.getSpecular()), i.setChannelFactor("SpecularHardness", n.getShininess()), i.setChannelFactor("Opacity", n.getDiffuse()[3]), i.setChannelEnable("EmitColor", !0), i.setChannelEnable("DiffuseColor", !0), i.setChannelEnable("SpecularColor", !0), i.setChannelEnable("SpecularHardness", !0), i.setChannelEnable("Opacity", !0), t.removeAttribute("Material")), this.mapTexturesOnMaterial(t, i), i.setStateSet(t), i
                }
            }));
            const ti = ei;
            var ii = g.Z.osg,
                ni = function () {
                    Ht.apply(this, arguments), this._textureFactor1 = !0, this._metaMapColor = {
                        LambertDiffuseColor: "DiffuseColor",
                        LambertEmissiveColor: "EmitColor",
                        PhongSpecularColor: "SpecularColor"
                    }, this._metaMapFactor = {
                        LambertDiffuseFactor: "DiffuseColor",
                        LambertBumpFactor: "BumpMap",
                        LambertEmissiveFactor: "EmitColor",
                        PhongSpecularFactor: "SpecularColor",
                        PhongShininess: "SpecularHardness"
                    }, this._metaMapTexture = {
                        sDiffuse: "DiffuseColor",
                        sNormalMap: "NormalMap",
                        sBump: "BumpMap",
                        sEmissive: "EmitColor",
                        sSpecular: "SpecularColor",
                        sOpacity: "Opacity",
                        sAo: "AOPBR",
                        sRoughness: "RoughnessPBR",
                        sMetallic: "MetalnessPBR"
                    }
                };
            ii.createPrototypeObject(ni, ii.objectInherit(Ht.prototype, {
                setMaterialChannelColor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    r.setColor && r.setColor(n), r.setEnable(!0)
                },
                setMaterialChannelFactor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    if (r.setFactor(n), r.setEnable(!0), "SpecularHardness" === i) {
                        var a = e.PhongSpecularColor ? JSON.parse(e.PhongSpecularColor) : [0, 0, 0];
                        this.setGlossinessPBRFromSpecularGlossiness(t, a, n)
                    }
                },
                processLightSource: function (e) {
                    var t = e.getLight();
                    if (t) {
                        var i = t.getUserData();
                        if (void 0 !== i && t.typeID !== jt.typeID) {
                            var n = f.Z.convertUserDataToObject(i),
                                r = new jt;
                            if ("directional" === n.Type) r.setLightType("DIRECTION");
                            else if ("point" === n.Type) r.setLightType("POINT");
                            else {
                                if ("spot" !== n.Type) return;
                                r.setLightType("SPOT")
                            }
                            if ("spot" === n.Type) {
                                r.setSpotCutoff(JSON.parse(n.OuterAngle) / 2);
                                var a = JSON.parse(n.InnerAngle) / JSON.parse(n.OuterAngle);
                                r.setSpotBlend(a != a || Math.abs(a) === 1 / 0 ? .5 : Math.min(a, 1))
                            }
                            ii.vec3.scale(r.getDiffuse(), JSON.parse(n.Color), JSON.parse(n.Intensity) / 100);
                            var o = 1 / JSON.parse(n.DecayStart);
                            r.setQuadraticAttenuation(Math.abs(o) === 1 / 0 ? 0 : o), this.pushLight(r)
                        }
                    }
                },
                processMaterial: function (e, t, i) {
                    var n = this.createMaterial(e, t);
                    if (this.setChannelsFromMetaDataColor(i, n), this.setChannelsFromMetaDataFactor(i, n), this.setChannelsFromMetaDataTexture(i, t, n), i.LambertBumpFactor && !i.sBump && n.getChannels().BumpMap.setEnable(!1), "Agisoft Metashape" === this._authoringTool) {
                        var r = n.getChannels().NormalMap;
                        r.getTextureModel() && r.set("flipY", !1)
                    }
                    if ("Tilt Brush" === this._authoringTool) {
                        var a = n.getChannels(),
                            o = a.EmitColor;
                        if (o.set("type", "multiplicative"), !o.getTextureModel()) {
                            var s = o.getColor();
                            0 === s[0] && 0 === s[1] && 0 === s[2] && o.setColor(ii.vec3.ONE)
                        }
                        a.SpecularF0.setFactor(0), a.RoughnessPBR.setFactor(1);
                        var l = i.BlendMode;
                        "AlphaMask" === l ? (a.Opacity.setFactor(JSON.parse(i.LambertTransparencyFactor || 0)), a.Opacity.setTransparency("alphaMask")) : "AdditiveBlend" === l ? (a.Opacity.setFactor(1 - JSON.parse(i.LambertTransparencyFactor || 0)), a.Opacity.setTransparency("additive")) : a.Opacity.setEnable(!1)
                    }
                    this.handleSeparatedAlphaMaskChannel(n), t.removeAttribute("Material"), n.setStateSet(t)
                }
            }));
            const ri = ni;
            var ai = g.Z.osg,
                oi = function () {
                    Ht.apply(this, arguments), this._metaMapTexture = {
                        diffuse: "DiffuseColor",
                        specular: "SpecularColor",
                        transparency: "Opacity"
                    }
                };
            ai.createPrototypeObject(oi, ai.objectInherit(Ht.prototype, {
                processMaterial: function (e, t, i) {
                    var n = this.createMaterial(e, t);
                    this.setChannelsFromMetaDataTexture(i, t, n), t.removeAttribute("Material"), n.setStateSet(t)
                }
            }));
            const si = oi;
            var li = g.Z.osg,
                ui = function () {
                    Ht.apply(this, arguments), this._metaMapColor = {
                        kd: "DiffuseColor",
                        ka: "EmitColor",
                        ks: "SpecularColor"
                    }, this._metaMapFactor = {
                        ns: "SpecularHardness",
                        tr: "Opacity",
                        d: "Opacity"
                    }, this._metaMapTexture = {
                        map_ka: "EmitColor",
                        map_kd: "DiffuseColor",
                        map_occlusion: "DiffuseIntensity",
                        map_d: "Opacity",
                        map_ks: "SpecularColor",
                        map_ns: "SpecularHardness",
                        map_normal: "NormalMap",
                        bump: "BumpMap"
                    }
                };
            li.createPrototypeObject(ui, li.objectInherit(Ht.prototype, {
                checkOpacityFactor: function (e) {
                    var t = e.getChannels().Opacity;
                    t.getFactor() < .001 && t.setFactor(1)
                },
                setMaterialChannelColor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    r.setColor && r.setColor(n), r.setEnable(!0), "SpecularColor" === i && r.setFactor(1)
                },
                setMaterialChannelFactor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    if (r.setFactor(n), r.setEnable(!0), "SpecularHardness" === i) {
                        var a = void 0 !== e.ks ? JSON.parse(e.ks) : [0, 0, 0];
                        this.setGlossinessPBRFromSpecularGlossiness(t, a, n)
                    }
                },
                processMaterial: function (e, t, i) {
                    var n = this.createMaterial(e, t);
                    this.setChannelsFromMetaDataColor(i, n), this.setChannelsFromMetaDataFactor(i, n), this.setChannelsFromMetaDataTexture(i, t, n), this.checkOpacityFactor(n), t.removeAttribute("Material"), n.setStateSet(t)
                }
            }));
            const ci = ui;
            var hi = g.Z.osg,
                di = function () {
                    Ht.apply(this, arguments), this._metaMapColor = {
                        kd: "DiffuseColor"
                    }, this._metaMapFactor = {
                        tr: "Opacity",
                        d: "Opacity"
                    }
                };
            hi.createPrototypeObject(di, hi.objectInherit(ci.prototype, {
                isSelfIlluminationSurface: function (e) {
                    if (!e.length) return !1;
                    var t = e[0].getImage().getURL().split("/").pop().split(".").shift();
                    return !!(t.match("carrot_crop_(.*)") || t.match("crops_(.*)") || "fern" === t || "dead_shrub" === t || "flower_red" === t || "flower_yellow" === t || "lilypad" === t || "mushroom_brown" === t || "mushroom_red" === t || t.match("netherwart_(.*)") || t.match("potato_crop_(.*)") || t.match("sapling_(.*)") || "tall_grass" === t || "torch" === t || "torch_flame" === t)
                },
                getReferencedTextures: function (e) {
                    for (var t = [], i = 0; i < e.getNumTextureAttributeLists(); i++) {
                        var n = e.getTextureAttribute(i, "Texture");
                        void 0 !== n && ("PackedMaterialTexture" === n.className() && (n = n.getTexture()), t[i] = n)
                    }
                    return t
                },
                setMaterialChannelTexture: function (e, t, i, n, r, a, o) {
                    e.removeTextureAttribute(i, "Texture");
                    var s = t.getChannels()[r],
                        l = this.createTextureOptionsFromTextureOSG(n);
                    l && (l.wrapT = hi.Texture[a], l.wrapS = hi.Texture[a], o && (l.minFilter = hi.Texture.NEAREST_MIPMAP_LINEAR, l.magFilter = hi.Texture.NEAREST), s.setupTextureModel(l), s.setTexCoordUnit(0), s.setEnable(!0))
                },
                processMaterial: function (e, t, i) {
                    var n, r, a = this.createMaterial(e, t);
                    this.setChannelsFromMetaDataColor(i, a), this.setChannelsFromMetaDataFactor(i, a), void 0 !== i.ka && (a.setChannelFactor("EmitColor", .1), a.setChannelEnable("EmitColor", !0)), a.setChannelColor("SpecularColor", hi.vec3.create()), a.setChannelEnable("SpecularColor", !0), a.setChannelFactor("SpecularHardness", 1), a.setChannelEnable("SpecularHardness", !0), this.checkOpacityFactor(a);
                    var o = "mineways" === i.source,
                        s = this.getReferencedTextures(t),
                        l = this.isSelfIlluminationSurface(s),
                        u = l ? "CLAMP_TO_EDGE" : "REPEAT";
                    if (void 0 !== i.map_kd && void 0 !== (r = s[n = JSON.parse(i.map_kd)]) && this.setMaterialChannelTexture(t, a, n, r, "DiffuseColor", u, o), l || (void 0 !== i.map_ke ? void 0 !== (r = s[n = JSON.parse(i.map_ke)]) && (this.setMaterialChannelTexture(t, a, n, r, "EmitColor", u, o), a.setChannelFactor("EmitColor", 1)) : void 0 !== i.map_ka ? void 0 !== (r = s[n = JSON.parse(i.map_ka)]) && this.setMaterialChannelTexture(t, a, n, r, "EmitColor", u, o) : void 0 !== i.map_kd && void 0 !== (r = s[n = JSON.parse(i.map_kd)]) && (this.setMaterialChannelTexture(t, a, n, r, "EmitColor", u, o), a.setChannelFactor("EmitColor", .1))), l && (a.set("shadeless", !0), a.setChannelFactor("EmitColor", 0), a.setChannelEnable("EmitColor", !0)), void 0 !== i.map_d && void 0 !== (r = s[n = JSON.parse(i.map_d)])) {
                        this.setMaterialChannelTexture(t, a, n, r, "Opacity", u, o);
                        var c = a.getChannels().Opacity;
                        o ? (c.getTextureModel().set("internalFormat", hi.Texture.ALPHA), -1 !== a.attributes.name.toLowerCase().indexOf("leaves") && (c.setTransparency("alphaMask"), a.setChannelFactor("Opacity", .2))) : (c.getTextureModel().set("internalFormat", hi.Texture.LUMINANCE), c.setTransparency("alphaBlend")), a.set("cullFace", hi.CullFace.BACK)
                    }
                    if (a.setChannelFactor("RoughnessPBR", 1), a.setChannelFactor("SpecularF0", 0), !this._lights.length) {
                        var h = new jt;
                        h.setLightType("DIRECTION"), hi.vec3.set(h.getDiffuse(), 1, 1, 1), this._lights.push(h), h._worldMatrix = hi.mat4.fromRotation(hi.mat4.create(), Math.PI / 6, hi.vec3.fromValues(1, 1, 0))
                    }
                    this.handleSeparatedAlphaMaskChannel(a), t.removeAttribute("Material"), a.setStateSet(t)
                }
            }));
            const gi = di;
            var fi = g.Z.osg,
                mi = function () {
                    Ht.apply(this, arguments), this._textureFactor1 = !0, this._metaMapColor = {
                        DiffuseColor: "DiffuseColor",
                        SpecularPBRColor: "SpecularPBR",
                        EmissiveColor: "EmitColor"
                    }, this._metaMapFactor = {
                        DiffuseFactor: "DiffuseColor",
                        EmissiveFactor: "EmitColor",
                        MetallicFactor: "MetalnessPBR",
                        RoughnessFactor: "RoughnessPBR",
                        GlossinessPBRFactor: "GlossinessPBR",
                        SpecularPBRFactor: "SpecularPBR",
                        AOFactor: "AOPBR",
                        NormalFactor: "NormalMap",
                        ClearcoatFactor: "ClearCoat",
                        ClearcoatRoughnessFactor: "ClearCoatRoughness",
                        SpecularF0Factor: "SpecularF0"
                    }, this._metaMapTexture = {
                        sDiffuse: "DiffuseColor",
                        sMetallic: "MetalnessPBR",
                        sRoughness: "RoughnessPBR",
                        sSpecularPBR: "SpecularPBR",
                        sGlossinessPBR: "GlossinessPBR",
                        sNormalMap: "NormalMap",
                        sEmissive: "EmitColor",
                        sOpacity: "Opacity",
                        sAO: "AOPBR",
                        sClearCoat: "ClearCoat",
                        sClearCoatNormal: "ClearCoatNormalMap",
                        sClearCoatRoughness: "ClearCoatRoughness",
                        sSheenColor: "Sheen",
                        sSheenRoughness: "SheenRoughness",
                        sSpecularF0: "SpecularF0"
                    }
                };
            fi.createPrototypeObject(mi, fi.objectInherit(Ht.prototype, {
                setMaterialChannelColor: function (e, t, i, n) {
                    var r = t.getChannels()[i];
                    r.getTextureModel() || (r.setColor && r.setColor(n), r.setFactor(1))
                },
                checkWorkflowPBR: function (e) {
                    e.sMetallic || e.MetallicFactor || !e.sSpecularPBR && !e.SpecularPBRColor && !e.SpecularPBRFactor ? this._hasMetal = !0 : void 0 === this._hasMetal && (this._hasMetal = !1)
                },
                checkWorkflowRoughGloss: function (e) {
                    e.RoughnessPBR || e.RoughnessFactor || !e.GlossinessPBR && !e.GlossinessPBRFactor ? this._globalEnforceRoughness = !0 : void 0 === this._globalEnforceRoughness && (this._globalEnforceRoughness = !1)
                },
                checkAlphaMode: function (e, t) {
                    var i = t.getChannels();
                    if (e.alphaMode && "OPAQUE" !== e.alphaMode) {
                        var n = i.Opacity;
                        if ("gltf" === this._source && this.hasTextureChannel(t, "DiffuseColor")) {
                            var r = i.DiffuseColor,
                                a = r.getTextureModel().clone();
                            if (a && a.getImageModel() && a.getImageModel().get("alpha")) {
                                a.set("internalFormat", fi.Texture.ALPHA), a.updateMultiresTexture(), n.setTextureModel(a), n.setTexCoordUnit(r.getTexCoordUnit());
                                var o = r.get("UVTransforms");
                                o && n.set("UVTransforms", o)
                            }
                        }
                        if ("BLEND" === e.alphaMode ? n.setFactor(JSON.parse(e.OpacityFactor || 1)) : "MASK" === e.alphaMode && (n.setTransparency("alphaMask"), n.setFactor(JSON.parse(e.alphaCutoff || .5))), n.setEnable(!0), "usd" === this._source) {
                            var s = n.getTextureModel();
                            s && s.getImageModel() && !s.getImageModel().get("alpha") && n.setEnable(!1)
                        }
                    }
                },
                checkNormalMap: function (e, t) {
                    t.getChannels().NormalMap.set("flipY", void 0 !== e.yUp && !1 === JSON.parse(e.yUp))
                },
                checkCullFace: function (e, t) {
                    void 0 !== e.doubleSided && !1 !== JSON.parse(e.doubleSided) || t.set("cullFace", fi.CullFace.BACK)
                },
                checkClearCoat: function (e, t) {
                    void 0 === e.ClearcoatFactor && void 0 === e.ClearcoatRoughnessFactor && void 0 === e.sClearCoat && void 0 === e.sClearCoatNormal && void 0 === e.sClearCoatRoughness || (t.getChannels().ClearCoat.setEnable(!0), t.getChannels().ClearCoatRoughness.setEnable(!0), t.getChannels().ClearCoatNormalMap.setEnable(!0), t.getChannels().ClearCoatNormalMap.set("flipY", void 0 !== e.yUp && !1 === JSON.parse(e.yUp)))
                },
                applyTextureTransforms: function (e, t, i) {
                    for (var n in t)
                        if (!(void 0 === this._metaMapTexture[n] || t[n] >= e.length)) {
                            var r = e[JSON.parse(t[n])];
                            if (r && 0 !== r.length) {
                                var a = this._metaMapTexture[n],
                                    o = i.getChannels()[a],
                                    s = f.Z.convertUserDataToObject(r[0]._object._userdata),
                                    l = void 0 !== s.offset && JSON.parse(s.offset) || [0, 0],
                                    u = void 0 !== s.scale && JSON.parse(s.scale) || [1, 1],
                                    c = void 0 !== s.rotation && JSON.parse(s.rotation) || 0;
                                if (1 !== u[0] || 1 !== u[1] || 0 !== c || 0 !== l[0] || 0 !== l[1]) {
                                    var h = o.getOrCreateUVTransforms();
                                    h.offset = fi.vec2.fromValues(l[0], l[1]), h.scale = fi.vec2.fromValues(u[0], u[1]), h.rotation = c, o.set("UVTransforms", h)
                                }
                            }
                        }
                },
                handleTransmissionExtension: function (e, t, i) {
                    if (void 0 !== e.TransmissionFactor || void 0 !== e.sTransmission) {
                        var n = t.getChannels().Opacity;
                        n.setEnable(!0), n.setTransparency("refraction"), n.set("ior", 1), n.set("invert", !0);
                        var r = JSON.parse(e.TransmissionFactor || 0);
                        n.setFactor(1 - r);
                        var a = JSON.parse(e.DiffuseColor || [1, 1, 1, 1]);
                        t.getChannels().DiffuseColor.getTextureModel() ? (n.set("useAlbedoTint", !1), n.set("refractionColor", [a[0], a[1], a[2]])) : n.set("useAlbedoTint", !0);
                        var o = t.getChannels().RoughnessPBR.getEnable() ? t.getChannels().RoughnessPBR.getFactor() : t.getChannels().GlossinessPBR.getFactor();
                        n.set("roughnessFactor", o), n.set("useMicrosurfaceTexture", !0);
                        var s = JSON.parse(e.sTransmission || -1);
                        if (-1 !== s) {
                            var l = this.getReferencedTextures(i)[s];
                            if (l) {
                                var u = this.createTextureOptionsFromTextureOSG(l);
                                if (u) {
                                    var c = new Bt.Z(u);
                                    n.setTextureModel(c), n.setFactor(1)
                                }
                            }
                        }
                    }
                },
                checkSheen: function (e, t) {
                    if (void 0 !== e.sheenColorFactor || void 0 !== e.sheenRoughnessFactor || void 0 !== e.sSheenColor || void 0 !== e.sSheenRoughness) {
                        var i = t.getChannels().Sheen;
                        i.setEnable(!0), i.setFactor(1);
                        var n = JSON.parse(e.sheenColorFactor || [0, 0, 0]);
                        i.set("colorFactor", n);
                        var r = JSON.parse(e.sheenRoughnessFactor || 0),
                            a = t.getChannels().SheenRoughness;
                        a.setEnable(!0), a.setFactor(r)
                    }
                },
                processMaterial: function (e, t, i) {
                    var n = this.createMaterial(e, t),
                        r = JSON.parse(JSON.stringify(e.getStateSet()._textureAttributeArrayList));
                    this.checkWorkflowPBR(i), this.checkWorkflowRoughGloss(i), this.setChannelsFromMetaDataTexture(i, t, n), this.setChannelsFromMetaDataFactor(i, n), this.setChannelsFromMetaDataColor(i, n), n.getChannels().EmitColor.setFactor(JSON.parse(i.EmissiveFactor || 1)), this.checkNormalMap(i, n), this.checkCullFace(i, n), this.checkClearCoat(i, n), this.checkSheen(i, n), this.applyTextureTransforms(r, i, n), this.checkAlphaMode(i, n), n.getChannels().AOPBR.set("occludeSpecular", !0), this.copyDiffuse(n), this.handleSeparatedAlphaMaskChannel(n), this.handleTransmissionExtension(i, n, t), t.removeAttribute("Material"), n.setStateSet(t)
                }
            }));
            const pi = {
                default: ti,
                wavefront: ci,
                blender: Jt,
                ksp: Jt,
                lightwave: si,
                minecraft: gi,
                collada: Qt,
                fbx: ri,
                substancepainter: Qt,
                mineways: gi,
                gltf: mi,
                usd: mi
            };
            var vi = i("z1JG"),
                _i = function (e) {
                    this._materialManager = e
                };
            _i.prototype = {
                apply: function (e) {
                    var t = new Rt;
                    e.accept(t);
                    var i = t.getSource(),
                        n = t.getAuthoringTool();
                    i = i ? i.toLowerCase() : "default";
                    var r = new (pi[i] ? pi[i] : pi.default)(this._materialManager, n, i);
                    e.accept(r), (0, vi.Z)() && r.handleSingleMaterialMapping();
                    var a = !f.Z.hasTriangles && !f.Z.hasVertexNormals;
                    ("q3d" === i || a) && (r._style = "shadeless");
                    var o = e.getUserData() || [];
                    return o.push({
                        Name: "source",
                        Value: i
                    }), o.push({
                        Name: "authoringTool",
                        Value: n
                    }), o.push({
                        Name: "sourceTool",
                        Value: t.getSourceTool()
                    }), e.setUserData(o), e.userDataMap = f.Z.convertUserDataToObject(o), r
                }
            };
            const Si = _i;
            var xi = g.Z.osg,
                Ci = function () {
                    xi.NodeVisitor.call(this, xi.NodeVisitor.TRAVERSE_ALL_CHILDREN), this._paths = [], this._pathsStateSet = [], this._currentStateSet = [], this._stateSetMap = {}, this._stateSetMapNodes = {}, this._wireframePaths = [], this._noGeometryPaths = [], this.nodeMaskOverride = -1
                };
            xi.createPrototypeObject(Ci, xi.objectInherit(xi.NodeVisitor.prototype, {
                getPathList: function () {
                    return this._paths
                },
                getStateSetMap: function () {
                    return this._stateSetMap
                },
                getStateSetMapNodes: function () {
                    return this._stateSetMapNodes
                },
                getStateSetPathList: function () {
                    return this._pathsStateSet
                },
                getWireframePathList: function () {
                    return this._wireframePaths
                },
                getNoGeometryPathList: function () {
                    return this._noGeometryPaths
                },
                apply: function (e) {
                    var t = e.getStateSet();
                    if (t) {
                        var i = t._uniqueID;
                        this._stateSetMap[i] || (this._stateSetMap[i] = t, this._stateSetMapNodes[i] = []), this._stateSetMapNodes[i].push(e), this._currentStateSet.push(t)
                    }
                    e instanceof xi.Geometry ? e.userDataMap && e.userDataMap.wireframe ? this._wireframePaths.push(this.nodePath.slice(0)) : (this._pathsStateSet.push(this._currentStateSet.slice(0)), this._paths.push(this.nodePath.slice(0))) : (this.traverse(e), 0 === e.getChildren().length && this._noGeometryPaths.push(this.nodePath.slice(0))), t && this._currentStateSet.pop()
                }
            }));
            const Ti = Ci;
            var Mi = i("Rdny"),
                bi = i("KXnA"),
                yi = i("078t"),
                Ai = i("pXO4"),
                Ri = i("QKpV"),
                wi = g.Z.osg,
                Ei = g.Z.osgAnimation,
                Pi = function () {
                    wi.NodeVisitor.call(this), this._stats = {
                        nodeCount: 0,
                        matrixTransformCount: 0,
                        geometryCount: 0,
                        boneCount: 0,
                        skeletonCount: 0,
                        morphGeometryCount: 0,
                        rigGeometryCount: 0
                    }
                },
                Ni = new bt.Z;
            Pi.stats = window.testdemo2024ViewerStats = {
                promiseReady: Ni.promise,
                materialCountBefore: 0,
                materialCountAfter: 0,
                nodeCountBefore: 0,
                nodeCountAfter: 0,
                matrixTransformCountBefore: 0,
                matrixTransformCountAfter: 0,
                geometryCountBefore: 0,
                geometryCountAfter: 0,
                boneCountBefore: 0,
                boneCountAfter: 0,
                skeletonCountBefore: 0,
                skeletonCountAfter: 0,
                morphGeometryCountBefore: 0,
                morphGeometryCountAfter: 0,
                rigGeometryCountBefore: 0,
                rigGeometryCountAfter: 0
            }, Pi.registerStats = function (e, t) {
                var i = new Pi;
                e.accept(i);
                var n = i.getStats(),
                    r = Pi.stats;
                r["nodeCount" + t] = n.nodeCount, r["matrixTransformCount" + t] = n.matrixTransformCount, r["geometryCount" + t] = n.geometryCount, r["boneCount" + t] = n.boneCount, r["skeletonCount" + t] = n.skeletonCount, r["morphGeometryCount" + t] = n.morphGeometryCount, r["rigGeometryCount" + t] = n.rigGeometryCount
            };
            var Oi = function (e) {
                for (var t = ["geometry", "rigGeometry", "morphGeometry"], i = 0, n = 0; n < t.length; ++n) i += Pi.stats[t[n] + e];
                return i
            };
            Pi.computeStats = function (e) {
                if (!(0, ut.Z)() && !window.RunningTests) {
                    var t = Pi.stats;
                    if ((0, l.Z)().graphOptimizer) {
                        var i = Oi("CountBefore"),
                            n = Oi("CountAfter");
                        Ri.Z.logMessage("Geometry count : before " + i + ", after " + n)
                    }
                    if ((0, l.Z)().mergeMaterials) {
                        var r = "Material count : before ";
                        r += t.materialCountBefore, r += ", after ", r += t.materialCountAfter, Ri.Z.logMessage(r)
                    }
                    var a = e.getFeatures(),
                        o = a.animation.getModel(),
                        s = a.environment.getModel(),
                        u = a.lighting.getModel(),
                        c = o.getEnabledAnimationsCount(),
                        h = 0,
                        d = 0,
                        g = 0;
                    if (bi.Z.get("mask") & bi.Z.LIT) {
                        for (var f = u.get("lights"), m = 0, p = f.length; m < p; ++m) {
                            var v = f[m];
                            v && v.get("enable") && "NONE" !== v.get("type") && (g++, v.isCastingShadows() && (d++, (c || v.isAttachedToCamera()) && h++))
                        }
                        s.get("enable") && (g++, s.get("shadowEnable") && (g++, d++, c && h++)), t.pbr = bi.Z.get("mask") & bi.Z.PBR ? 1 : 0
                    }
                    t.lights = g, t.shadows = d, t.realTimeShadows = h, t.vertexCount = e._currentScene._dataScene.vertexCount;
                    var _ = t.materialCountAfter / 10;
                    _ *= g > 0 && t.pbr ? t.lights + t.shadows : 1, _ *= t.transparent ? 4 : 1;
                    var S = 0;
                    S += t.boneCountAfter / 35, S += t.morphGeometryCountAfter / 2, S += t.geometryCountAfter / 5, S += t.vertexCount / 15e4, S += t.matrixTransformCountAfter / 50, S += t.nodeCountAfter / 100;
                    var x = _ + (S *= t.realTimeShadows > 0 ? t.realTimeShadows + 1 : 1);
                    t.complexity = x, t.shadingComplexity = _, t.meshComplexity = S, Ni.resolve(t)
                }
            };
            var Di = wi.Node.typeID,
                Ii = wi.MatrixTransform.typeID,
                Fi = Ei.Bone.typeID,
                Li = Ei.Skeleton.typeID,
                Vi = wi.Geometry.typeID,
                Bi = Ei.MorphGeometry.typeID,
                Ui = Ei.RigGeometry.typeID;
            wi.createPrototypeObject(Pi, wi.objectInherit(wi.NodeVisitor.prototype, {
                getStats: function () {
                    return this._stats
                },
                apply: function (e) {
                    var t = this._stats,
                        i = e.typeID;
                    e.userDataMap && e.userDataMap.wireframe || (i === Di ? t.nodeCount++ : i === Ii ? t.matrixTransformCount++ : i === Vi ? t.geometryCount++ : i === Fi ? t.boneCount++ : i === Li ? t.skeletonCount++ : i === Bi ? t.morphGeometryCount++ : i === Ui ? (t.rigGeometryCount++, e.getSourceGeometry().typeID === Bi && t.morphGeometryCount++) : console.error("Unknown node type ID : " + i + " " + e.className()), this.traverse(e))
                }
            }));
            const ki = Pi;
            var Zi = g.Z.osg,
                Hi = Zi.WebGLCaps.instance().getWebGLExtension("OES_element_index_uint") ? 4294967296 : 65535,
                Gi = {
                    splitLimit: Math.min((0, l.Z)().splitLimit, Hi),
                    limitMergePerMaterial: 100,
                    canMergeGeometry: !0,
                    isWireframe: !1,
                    bakedGeometriesFromID: {},
                    hasTransparency: !0,
                    multiParentPathFromGeometryID: {},
                    protectedGeometries: {}
                },
                zi = {};
            zi[Zi.primitiveSet.POINTS] = !0, zi[Zi.primitiveSet.LINES] = !0, zi[Zi.primitiveSet.TRIANGLES] = !0;
            var Wi = {};
            Wi[Zi.primitiveSet.POINTS] = !0, Wi[Zi.primitiveSet.LINES] = !0, Wi[Zi.primitiveSet.TRIANGLES] = !0, Wi[Zi.primitiveSet.TRIANGLE_STRIP] = !0;
            var ji = {
                Vertex: 1,
                Normal: 1,
                Tangent: 1
            },
                Xi = function (e) {
                    var t = e.getStateSet();
                    return t && t.getAttribute("testdemo2024Material") ? t : void 0
                },
                Yi = function (e, t) {
                    var i = e[e.length - 1].getVertexAttributeList().Vertex;
                    return t[t.length - 1].getVertexAttributeList().Vertex.getElements().length - i.getElements().length
                },
                Ji = function (e) {
                    return e.getVertexAttributeList().Vertex.getElements().length / 3
                },
                qi = function (e) {
                    return e[e.length - 1].getVertexAttributeList().Vertex.getElements().length / 3
                },
                Ki = function (e) {
                    var t = e[e.length - 1].getInstanceID(),
                        i = Gi.multiParentPathFromGeometryID;
                    return Boolean(i[t])
                },
                Qi = function (e, t) {
                    t.xmin < e.xmin && (e.xmin = t.xmin), t.ymin < e.ymin && (e.ymin = t.ymin), t.zmin < e.zmin && (e.zmin = t.zmin), t.xmax > e.xmax && (e.xmax = t.xmax), t.ymax > e.ymax && (e.ymax = t.ymax), t.zmax > e.zmax && (e.zmax = t.zmax)
                },
                $i = function (e, t) {
                    var i = Math.min(e.xmax - e.xmin, t.xmax - t.xmin),
                        n = Math.min(e.ymax - e.ymin, t.ymax - t.ymin),
                        r = Math.min(e.zmax - e.zmin, t.zmax - t.zmin);
                    return Qi(e, t), i = 0 === i ? 0 : (e.xmax - e.xmin) / i, n = 0 === n ? 0 : (e.ymax - e.ymin) / n, r = 0 === r ? 0 : (e.zmax - e.zmin) / r, Math.max(i, n, r) > (0, l.Z)().zratio
                },
                en = function (e, t, i) {
                    if (!t._FQU) {
                        var n = e.getElements().length,
                            r = Math.min(n, t.getElements().length - i);
                        t._boxTest || (t._boxTest = t.computeMinMaxVertex({}, 0, i));
                        var a = t.computeMinMaxVertex({}, i, r);
                        t._FQU = $i(t._boxTest, a)
                    }
                },
                tn = function (e, t, i) {
                    var n = e.getElements(),
                        r = t.getElements(),
                        a = e.getItemSize(),
                        o = t.getItemSize();
                    if (a !== o)
                        for (var s = r.length / o, l = 0; l < s; ++l) {
                            var u = l * a,
                                c = l * o;
                            n[i + u] = r[c], n[i + u + 1] = r[c + 1], n[i + u + 2] = r[c + 2]
                        } else n.set(r, i)
                },
                nn = function (e, t, i) {
                    var n = t.getVertexAttributeList().Vertex,
                        r = e.getVertexAttributeList().Vertex.getElements(),
                        a = n.getElements();
                    n.setElements(r.subarray(i, i + a.length)), e._boundingBox.copy(t.getBoundingBox()), e._boundingBoxComputed = !0;
                    var o = t.getBoundingSphere(),
                        s = e._boundingSphere;
                    s.set(Zi.vec3.copy(s.center(), o.center()), o.radius()), e._boundingSphereComputed = !0, n.setElements(a), t.dirtyBound()
                },
                rn = function (e, t, i, n) {
                    var r = Gi.bakedGeometriesFromID[t.getInstanceID()];
                    if (r || (Gi.bakedGeometriesFromID[i.getInstanceID()] = !0), r || function (e) {
                        return 9 === e.length ? Zi.mat3.equals(Zi.mat3.IDENTITY, e) : Zi.mat4.equals(Zi.mat4.IDENTITY, e)
                    }(e)) i !== t && tn(i, t, n || 0);
                    else {
                        var a = i.getElements();
                        n && (a = a.subarray(n));
                        for (var o = t.getElements(), s = 9 === e.length ? Zi.vec3.transformMat3 : Zi.vec3.transformMat4, l = t.getItemSize(), u = Zi.vec3.create(), c = Math.min(o.length, a.length), h = 0; h < c; h += l) u[0] = o[h], u[1] = o[h + 1], u[2] = o[h + 2], s(u, u, e), a[h] = u[0], a[h + 1] = u[1], a[h + 2] = u[2], 4 === l && (a[h + 3] = o[h + 3])
                    }
                },
                an = function (e, t, i, n) {
                    var r = i.getIndices().getElements(),
                        a = i.getCount(),
                        o = 0,
                        s = i.getMode(),
                        l = e[s].primitive,
                        u = l.getIndices().getElements(),
                        c = l.getCount(),
                        h = Wi[s] && Gi.canMergeGeometry,
                        d = c;
                    if (s === Zi.primitiveSet.TRIANGLE_STRIP && h) {
                        var g = c > 0,
                            f = g ? u[c - 1] : void 0,
                            m = r[0] + n,
                            p = g && f !== m ? 2 : 0;
                        p && (u[c] = f, u[c + 1] = m);
                        var v = c % 2;
                        v && (u[c + p] = m), d += p + v
                    }
                    u.set(r, d), l.setCount(d + a);
                    var _ = d + a;
                    for (o = d; o < _; ++o) u[o] += n;
                    h || (i.setIndices(l.getIndices()), i.setCount(a), i.setFirst(d * u.BYTES_PER_ELEMENT), Gi.canMergeGeometry && t.push(i))
                },
                on = function (e, t, i, n) {
                    for (var r = i.length, a = Gi.canMergeGeometry, o = e.DrawElements, s = e.DrawArrays, l = 0; l < r; ++l) {
                        var u = i[l],
                            c = u.getMode();
                        if (u instanceof Zi.DrawElements) an(o, t, u, n);
                        else if (u instanceof Zi.DrawArrays) {
                            var h = s[c];
                            if (a)
                                if (h && h.primitive.count === n && 0 === u.getFirst()) h.primitive.count += u.getCount();
                                else {
                                    var d = u.getFirst() + n;
                                    t.push(new Zi.DrawArrays(c, d, u.getCount()))
                                }
                            else u.first += n
                        } else if (u instanceof Zi.DrawArrayLengths)
                            if (a) {
                                var g = u.getFirst() + n,
                                    f = u.getArrayLengths().slice();
                                t.push(new Zi.DrawArrayLengths(c, g, f))
                            } else u.first += n
                    }
                },
                sn = function (e, t) {
                    var i = e.getElements(),
                        n = i.BYTES_PER_ELEMENT;
                    e.setNormalize(4 !== n);
                    var r = 1;
                    1 === n ? r = 255 : 2 === n && (r = 65535);
                    for (var a = i.length, o = t * e.getItemSize(); o < a; ++o) i[o] = r
                },
                ln = function (e, t) {
                    var i = new Zi.Geometry;
                    return i.setName(t.getName()),
                        function (e, t, i) {
                            if (Ki(e))
                                for (var n = 0, r = i.length; n < r; ++n) {
                                    var a, o = i[n],
                                        s = o.getMode(),
                                        l = o.getFirst();
                                    if (o instanceof Zi.DrawElements) {
                                        var u = o.getIndices(),
                                            c = u.getElements(),
                                            h = new c.constructor(c),
                                            d = u.getItemSize(),
                                            g = new Zi.BufferArray(Zi.BufferArray.ELEMENT_ARRAY_BUFFER, h, d);
                                        a = new Zi.DrawElements(s, g)
                                    } else o instanceof Zi.DrawArrays ? a = new Zi.DrawArrays(s, l, o.getCount()) : o instanceof Zi.DrawArrayLengths && (a = new Zi.DrawArrayLengths(s, l, o.getArrayLengths().slice()));
                                    t.push(a)
                                } else Array.prototype.push.apply(t, i)
                        }(e, i.getPrimitiveSetList(), t.getPrimitiveSetList()), i
                },
                un = function (e, t, i) {
                    var n = t[t.length - 1],
                        r = e.getVertexAttributeList(),
                        a = n.getVertexAttributeList(),
                        o = Zi.computeLocalToWorld(t),
                        s = Zi.mat3.create();
                    for (var l in Zi.mat3.normalFromMat4(s, o), a) {
                        var u = r[l],
                            c = a[l],
                            h = i * u.getItemSize();
                        if (ji[l]) rn("Vertex" === l ? o : s, c, u, h), "Vertex" === l && en(c, u, h);
                        else tn(u, c, h)
                    }
                },
                cn = function (e, t, i) {
                    for (var n in t)
                        if (!e[n]) {
                            var r = t[n].getItemSize(),
                                a = "Color" === n,
                                o = new (a ? t[n].getElements().constructor : Float32Array)(i * r),
                                s = new Zi.BufferArray(Zi.BufferArray.ARRAY_BUFFER, o, r);
                            e[n] = s, a && sn(s, 0)
                        }
                },
                hn = function (e, t, i, n) {
                    for (var r = t.DrawElements, a = t.DrawArrays, o = Gi.canMergeGeometry, s = 0, l = i.length; s < l; ++s) {
                        var u = i[s],
                            c = u.getMode();
                        if (u instanceof Zi.DrawElements) {
                            var h = r[c];
                            if (!h) {
                                var d = u.getIndices().getItemSize(),
                                    g = new Zi.BufferArray(Zi.BufferArray.ELEMENT_ARRAY_BUFFER, new Uint16Array, d);
                                h = r[c] = {
                                    primitive: new Zi.DrawElements(c, g),
                                    lastElement: -1,
                                    initCount: 0
                                }, o && e.push(h.primitive)
                            }
                            var f = h.primitive;
                            if (c === Zi.primitiveSet.TRIANGLE_STRIP && Wi[c] && o) {
                                var m = u.getIndices().getElements(),
                                    p = m[0] + n,
                                    v = h.lastElement !== p && 0 !== f.getCount() ? 2 : 0,
                                    _ = f.getCount() % 2;
                                f.setCount(f.getCount() + u.getCount() + v + _), h.lastElement = m[m.length - 1] + n
                            } else f.setCount(f.getCount() + u.getCount())
                        } else u instanceof Zi.DrawArrays && zi[c] && o && (a[c] || (a[c] = {
                            primitive: new Zi.DrawArrays(c, 0, 0),
                            initCount: 0
                        }, e.push(a[c].primitive)))
                    }
                },
                dn = function (e, t, i, n) {
                    for (var r = e.getVertexAttributeList(), a = e.getPrimitiveSetList(), o = Ji(e), s = n, l = 0, u = t.length; l < u; ++l) {
                        var c = t[l],
                            h = c[c.length - 1];
                        cn(r, h.getVertexAttributeList(), o), hn(a, i, h.getPrimitiveSetList(), s), s += qi(c)
                    } ! function (e, t) {
                        for (var i in e) {
                            var n = e[i].primitive,
                                r = n.getIndices(),
                                a = r.getElements(),
                                o = t >= 65535 ? Uint32Array : Uint16Array;
                            r.setElements(new o(n.getCount())), r.getElements().set(a), n.setIndices(r), n.setCount(a.length)
                        }
                    }(i.DrawElements, o)
                },
                gn = function (e, t) {
                    var i = e.pathList,
                        n = i.pop(),
                        r = Ji(n[n.length - 1]),
                        a = function (e, t, i) {
                            var n = e[e.length - 1],
                                r = ln(e, n),
                                a = Zi.computeLocalToWorld(e),
                                o = Zi.mat3.create();
                            Zi.mat3.normalFromMat4(o, a);
                            var s = function (e, t) {
                                var i = t.getVertexAttributeList().Color;
                                if (i && 4 === i.getItemSize()) return 4;
                                for (var n = 0, r = e.length; n < r; ++n) {
                                    var a = e[n],
                                        o = a[a.length - 1].getVertexAttributeList().Color;
                                    if (o && 4 === o.getItemSize()) return 4
                                }
                                return 3
                            }(i, n),
                                l = t !== Ji(n),
                                u = Ki(e),
                                c = r.getVertexAttributeList(),
                                h = n.getVertexAttributeList();
                            for (var d in h) {
                                var g, f = h[d],
                                    m = ji[d],
                                    p = "Color" === d,
                                    v = p ? s : f.getItemSize();
                                if (l ? g = new (p ? f.getElements().constructor : Float32Array)(t * v) : m && u ? g = new Float32Array(f.getElements().length) : c[d] = f, g) {
                                    var _ = new Zi.BufferArray(Zi.BufferArray.ARRAY_BUFFER, g, v);
                                    p && sn(_, f.getElements().length / f.getItemSize()), c[d] = _, m || tn(_, f, 0)
                                }
                                m && rn("Vertex" === d ? a : o, f, c[d], 0)
                            }
                            return Gi.canMergeGeometry || nn(r, n, 0), r
                        }(n, e.nbVertex, i);
                    if (t.addChild(a), 0 !== i.length) {
                        var o = a.getPrimitiveSetList(),
                            s = function (e) {
                                for (var t = {
                                    DrawElements: {},
                                    DrawArrays: {}
                                }, i = Gi.canMergeGeometry, n = 0, r = e.length; n < r; ++n) {
                                    var a = e[n],
                                        o = a.getMode();
                                    if (a instanceof Zi.DrawElements) {
                                        var s = a.getIndices().getElements();
                                        t.DrawElements[o] = {
                                            primitive: a,
                                            lastElement: s[s.length - 1],
                                            initCount: a.getCount()
                                        }
                                    } else a instanceof Zi.DrawArrays && zi[o] && i && (t.DrawArrays[o] = {
                                        primitive: a,
                                        first: a.getFirst(),
                                        initCount: a.getCount()
                                    })
                                }
                                return t
                            }(o);
                        dn(a, i, s, r);
                        for (var l = Gi.canMergeGeometry, u = 0, c = i.length; u < c; ++u) {
                            var h = i[u];
                            un(a, h, r);
                            var d = h[h.length - 1];
                            if (!l || Ki(h)) {
                                var g = ln(h, d);
                                l || (g._attributes = a.getVertexAttributeList(), t.addChild(g), nn(g, d, 3 * r)), d = g
                            }
                            var f = d.getPrimitiveSetList();
                            on(s, o, f, r), r += qi(h)
                        } ! function (e) {
                            var t = e.DrawElements,
                                i = Gi.canMergeGeometry;
                            for (var n in t) {
                                var r = t[n];
                                i && Wi[n] || r.primitive.setCount(r.initCount)
                            }
                        }(s)
                    }
                },
                fn = function (e) {
                    var t = e.localRoot;
                    e.renderPathList.sort(Yi);
                    for (var i = function (e) {
                        for (var t = [{
                            nbVertex: qi(e[0]),
                            pathList: [e[0]]
                        }], i = e.length, n = 1; n < i; ++n) {
                            for (var r = e[n], a = t[t.length - 1], o = qi(r), s = !1, l = r[r.length - 1]._primitives, u = 0; u < l.length; u++)
                                if (l[u].getMode() === Zi.primitiveSet.TRIANGLES && l[u].getCount() % 3 != 0) {
                                    console.error("incorrect number (" + l[u].getCount() + ") in Triangles IndexBuffer"), s = !0;
                                    break
                                }
                            s || (o + a.nbVertex >= Gi.splitLimit ? t.push({
                                nbVertex: o,
                                pathList: [r]
                            }) : (a.nbVertex += o, a.pathList.push(r)))
                        }
                        return t
                    }(e.renderPathList), n = i.length, r = 0; r < n; ++r) gn(i[r], t)
                },
                mn = function (e, t) {
                    for (var i = e.getAttribute("testdemo2024Material").getMaterialModel(), n = i.get(Gi.isWireframe ? "wireframeList" : "geometryList"), r = Gi.protectedGeometries, a = [], o = 0, s = n.length; o < s; ++o) {
                        var l = n[o];
                        r[l.getInstanceID()] && a.push(l)
                    }
                    n.length = 0, Array.prototype.push.apply(n, a), Array.prototype.push.apply(n, t.getChildren()), Gi.isWireframe && i.getChannels().Displacement.updateGeometryOffsets(),
                        function (e) {
                            if (!Gi.isWireframe)
                                for (var t = {
                                    xmin: 1 / 0,
                                    ymin: 1 / 0,
                                    zmin: 1 / 0,
                                    xmax: -1 / 0,
                                    ymax: -1 / 0,
                                    zmax: -1 / 0
                                }, i = Gi.bakedGeometriesFromID, n = {}, r = 0, a = e.length; r < a; ++r) {
                                    var o = e[r].getVertexAttributeList().Vertex;
                                    i[o.getInstanceID()] && (o._minMax || (o._minMax = t, o.computeMinMaxVertex(n), t.xmin === 1 / 0 || t._FQU || o._FQU ? (o._FQU && (t._FQU = !0), Qi(t, n)) : t._FQU = $i(t, n)))
                                }
                        }(n)
                },
                pn = function (e) {
                    var t = e.localRoot,
                        i = t.getStateSet(),
                        n = i && i.getBinNumber() === Oe.Z.TRANSPARENT;
                    n && (Gi.hasTransparency = !0), Gi.canMergeGeometry = !n, e.renderPathList.length > Gi.limitMergePerMaterial && (Gi.canMergeGeometry = !0), fn(e), mn(i, t)
                },
                vn = function (e, t, i) {
                    var n = function (e, t) {
                        for (var i = t || 0, n = e.length - 1; n >= i; --n) {
                            var r = Xi(e[n]);
                            if (r) return r
                        }
                    }(e),
                        r = n.getInstanceID(),
                        a = t[r];
                    a || (t[r] = a = {
                        localRoot: new Zi.Node,
                        renderPathList: []
                    }, a.localRoot.setStateSet(n), a.localRoot.setName(n.getName()), i.addChild(a.localRoot)), a.renderPathList.push(e), e[0] === i && e.shift()
                };
            Gi.optimizePaths = function (e, t, i) {
                Gi.isWireframe = !!i;
                for (var n = {}, r = t.length, a = 0; a < r; ++a) vn(t[a], n, e);
                for (var o in n) pn(n[o])
            }, Gi.optimizeWireframe = function (e, t, i) {
                var n = e.getChildren(),
                    r = n.length;
                Gi.optimizePaths(e, t, !0);
                for (var a = n.length, o = r; o < a; ++o) i.push(n[o])
            };
            const _n = Gi;
            var Sn, xn, Cn, Tn = g.Z.osg,
                Mn = g.Z.osgAnimation,
                bn = {},
                yn = function (e) {
                    var t = e.getStateSet();
                    return t && t.getAttribute("testdemo2024Material") ? t : void 0
                },
                An = function (e, t) {
                    for (var i = t || 0, n = e.length - 1; n >= i; --n) {
                        var r = yn(e[n]);
                        if (r) return r
                    }
                },
                Rn = function (e) {
                    for (var t = 0, i = e.length; t < i; ++t) e[t].removeChildren()
                },
                wn = function (e) {
                    for (var t = 0, i = e.length - 1; t < i; ++t) e[t].addChild(e[t + 1])
                },
                En = function (e) {
                    for (var t = e.length, i = 0; i < t; ++i) Rn(e[i])
                },
                Pn = function (e) {
                    for (var t = !1, i = bn, n = 0, r = e.length; n < r; ++n) {
                        var a, o = e[n],
                            s = !1;
                        if (o instanceof Mn.Bone) a = Mn.UpdateBone;
                        else {
                            if (!(o instanceof Tn.MatrixTransform)) continue;
                            a = Mn.UpdateMatrixTransform, s = !0
                        }
                        for (var l = o.getUpdateCallbackList(), u = l.length - 1; u >= 0; --u) {
                            var c = l[u];
                            c instanceof a != !1 && (i[c.getName()] || !s ? t = !0 : (c.update(o), o.removeUpdateCallback(c)))
                        }
                    }
                    var h = e[e.length - 1];
                    return t || h instanceof Mn.RigGeometry || h instanceof Mn.MorphGeometry
                },
                Nn = (Sn = [], function (e) {
                    return Sn[0] = e, Pn(Sn)
                });
            g.Z.osgDB.Input.prototype.getJSON = function () {
                return Cn = this, this._json.Animations && (xn = this._json), this._json
            };
            var On = function (e, t, i) {
                for (var n = t.length - 1; n >= 0; --n) {
                    var r = t[n],
                        a = r.length,
                        o = r[a - 1],
                        s = o._uniqueID;
                    if (o.getVertexAttributeList && (s = o.getVertexAttributeList().Vertex.getInstanceID()), e[o._uniqueID] || e[s]) e[s] = !0, i.push(r), t.splice(n, 1);
                    else if (o instanceof Tn.Geometry || o instanceof Mn.Bone) Pn(r) && (i.push(r), t.splice(n, 1));
                    else {
                        for (var l = a - 2; l >= 0; --l)
                            if (r[l] instanceof Mn.Bone) {
                                i.push(r);
                                break
                            }
                        t.splice(n, 1)
                    }
                }
            },
                Dn = function (e) {
                    for (var t = _n.protectedGeometries, i = 0, n = e.length; i < n; ++i) {
                        var r = e[i],
                            a = r[r.length - 1];
                        a instanceof Tn.Geometry && (t[a.getInstanceID()] = !0)
                    }
                },
                In = function (e) {
                    for (var t = _n.multiParentPathFromGeometryID, i = 0, n = e.length; i < n; ++i) {
                        for (var r = e[i], a = !1, o = 0, s = r.length; o < s; ++o)
                            if (r[o].getParents().length > 1) {
                                a = !0;
                                break
                            }
                        t[r[r.length - 1].getInstanceID()] = a
                    }
                },
                Fn = function (e, t) {
                    var i = e.length;
                    if (0 !== i)
                        for (var n = e[0].indexOf(t), r = t.getStateSet() ? 0 : 1, a = 0; a < i; ++a) {
                            e[a].splice(0, n + r)
                        }
                },
                Ln = function (e) {
                    for (var t = e.getUpdateCallbackList(), i = 0, n = t.length; i < n; ++i) {
                        var r = t[i];
                        if (r instanceof Mn.BasicAnimationManager) return e.removeUpdateCallback(r), r
                    }
                },
                Vn = function (e, t) {
                    ! function (e) {
                        var t, i = e.getFeatures().material.getModel().attributes,
                            n = {},
                            r = Mi.Z.length;
                        for (var a in i) {
                            var o = i[a];
                            if (!o.get("uidUniqueMerged")) {
                                var s = o.get("texCoordUnitList");
                                s.length = 0;
                                var l = o.getChannels();
                                for (t = 0; t < r; ++t) {
                                    var u = Mi.Z[t],
                                        c = l[u];
                                    if (c.isEnableEffective() && c.getTextureModel() && "Matcap" !== u) {
                                        var h = c.getTexCoordUnit(); - 1 === s.indexOf(h) && s.push(h)
                                    }
                                }
                                var d = o.get("geometryList"),
                                    g = d.length;
                                for (t = 0; t < g; ++t) {
                                    var f = d[t],
                                        m = n[f.getInstanceID()];
                                    if (m)
                                        for (var p = s.length, v = 0; v < p; ++v) - 1 === m.uvList.indexOf(s[v]) && m.uvList.push(s[v]);
                                    else n[f.getInstanceID()] = {
                                        geometry: f,
                                        uvList: s.slice()
                                    }
                                }
                            }
                        }
                        for (var _ in n) {
                            var S = n[_],
                                x = S.uvList,
                                C = S.geometry.getVertexAttributeList();
                            for (var T in C) - 1 !== T.indexOf("TexCoord") && -1 === x.indexOf(parseInt(T.substring(8))) && delete C[T]
                        }
                    }(t);
                    var i = t.getOrCreateScene().getWireframeNodes();
                    i.length = 0;
                    var n = [],
                        r = [],
                        a = e.getPathList(),
                        o = e.getWireframePathList();
                    ! function (e) {
                        var t = bn;
                        if (!xn || !xn.Animations || L.Z.OSG_VERSION < 8) return t;
                        for (var i = e.getFeatures().animation.getModel(), n = xn.Animations, r = 0, a = n.length; r < a; ++r) {
                            var o = n[r]["osgAnimation.Animation"],
                                s = Cn.setJSON(o.UserDataContainer).readUserDataContainer(),
                                l = f.Z.convertUserDataToObject(s);
                            if (i.getAnimationByUID(l.AnimationUID))
                                for (var u = o.Channels, c = 0, h = u.length; c < h; ++c) {
                                    var d = u[c];
                                    t[d[Object.keys(d)[0]].TargetName] = 1
                                }
                        }
                    }(t);
                    var s = function (e) {
                        for (var t, i, n = e.getPathList(), r = n[0][0], a = r, o = []; ;) {
                            t = yn(a) || t, i = i || Ln(a);
                            var s = a.getChildren();
                            if (1 !== s.length) break;
                            if (s[0] instanceof Mn.Skeleton) break;
                            if (s[0] instanceof Tn.Geometry) break;
                            if (Nn(a)) break;
                            o.push(a), a = s[0]
                        }
                        if (r.removeChildren(), i && r.addUpdateCallback(i), r === a) return a;
                        for (var l = a.getParents(), u = 0, c = l.length; u < c; ++u) l[u].removeChild(a);
                        r.setStateSet(void 0), a.setStateSet(t);
                        var h = Tn.computeLocalToWorld(o);
                        if (Tn.mat4.equals(Tn.mat4.IDENTITY, h)) r.addChild(a);
                        else {
                            var d = new Tn.MatrixTransform;
                            d.setName("Optim - RootMatrix"), Tn.mat4.copy(d.getMatrix(), h), r.addChild(d), d.addChild(a)
                        }
                        return Fn(n, a), Fn(e.getWireframePathList(), a), Fn(e.getNoGeometryPathList(), a), a
                    }(e);
                    if (function (e) {
                        In(e.getPathList()), In(e.getNoGeometryPathList()), In(e.getWireframePathList())
                    }(e), s.removeChildren(), function (e) {
                        En(e.getPathList()), En(e.getNoGeometryPathList()), En(e.getWireframePathList())
                    }(e), function (e, t, i, n) {
                        var r = function (e) {
                            var t = e.getFeatures(),
                                i = t.hotspot.getModel().get("hotspots"),
                                n = i.length,
                                r = {},
                                a = 0;
                            for (a = 0; a < n; ++a) {
                                var o = i.at(a).get("geometryUid");
                                o >= 0 && (r[o] = !0)
                            }
                            var s = t.sound.getModel().get("soundtracks"),
                                l = s.length;
                            for (a = 0; a < l; ++a) {
                                var u = s.at(a).get("geometryUid");
                                u >= 0 && (r[u] = !0)
                            }
                            return r
                        }(e);
                        On(r, t.getPathList(), i), On(r, t.getNoGeometryPathList(), i), On(r, t.getWireframePathList(), n), Dn(i), Dn(n)
                    }(t, e, n, r), _n.optimizePaths(s, a), function (e, t, i, n) {
                        var r = 0,
                            a = e.length,
                            o = i.length,
                            s = !1;
                        for (r = a - 1; r >= 0; --r) {
                            var l = e[r];
                            wn(l);
                            var u = l[0] === t;
                            An(l, u ? 1 : 0) || (s = !0), u || t.addChild(l[0])
                        }
                        for (r = o - 1; r >= 0; --r) {
                            var c = i[r];
                            wn(c), n.push(c[c.length - 1]), c[0] !== t && t.addChild(c[0])
                        }
                        s || t.setStateSet(void 0)
                    }(n, s, r, i), o.length > 0) {
                        var l = i.slice(0);
                        L.Z.getWireframe().then((function () {
                            for (var e = i.length = l.length, t = 0; t < e; ++t) i[t] = l[t];
                            Tn.time("optimizer - wireframe"), _n.optimizeWireframe(s, o, i), Tn.timeEnd("optimizer - wireframe"), L.Z.resolveWireframeOptimized()
                        }))
                    } else L.Z.getWireframe().then((function () {
                        L.Z.resolveWireframeOptimized()
                    }))
                },
                Bn = function (e, t) {
                    for (var i = t.length, n = 0; n < i; ++n) - 1 === e.indexOf(t[n]) && e.push(t[n]);
                    t.length = 0
                },
                Un = {};
            Un.reports = ki.stats, Un.optimize = function (e, t) {
                (0, l.Z)().graphOptimizer || L.Z.getWireframe().then(L.Z.resolveWireframeOptimized);
                var i = t.getRootModel();
                (0, l.Z)().graphOptimizer || (0, l.Z)().mergeMaterials ? (Tn.time("optimizer"), ki.registerStats(i, "Before"), (0, l.Z)().mergeMaterials && (Tn.time("optimizer - materials"), function (e) {
                    var t = e.getFeatures().material.getModel().attributes,
                        i = {},
                        n = {},
                        r = Mi.Z.length,
                        a = 0;
                    for (var o in t) {
                        var s = t[o],
                            l = s.get("stateSet");
                        if (!l) return;
                        var u = s.getChannels(),
                            c = bi.Z.get("mask"),
                            h = [];
                        h.push(s.get("cullFace") ? 1 : 0), h.push(s.hasOnlyPoints() ? 1 : 0), c & bi.Z.LIT && h.push(s.get("shadeless") ? 1 : 0), c === bi.Z.CLASSIC_LIT && h.push(s.get("reflection")), c !== bi.Z.MATCAP && h.push(s.get("hasVertexColor") ? 1 : 0), (u.Opacity.isEffective() || u.AlphaMask.isEffective()) && h.push(s.get("hasVertexAlpha") ? 1 : 0);
                        for (var d = 0; d < r; ++d) {
                            var g = Mi.Z[d],
                                f = u[g];
                            if (f.isEnableEffective()) {
                                var m = f.isEffective() ? JSON.stringify(f.getJSON()) : f.getFactor();
                                h.push(g + m)
                            }
                        }
                        var p = i[h = h.join(" / ")];
                        if (p) {
                            n[l.getInstanceID()] = p.get("stateSet"), a++, p.get("uidListUnusedDuplicates").push(s.get("id")), s.set("uidUniqueMerged", p.get("id"));
                            var v = s.get("stateSetWireframe");
                            if (v) {
                                var _ = p.get("stateSetWireframe");
                                n[v.getInstanceID()] = _
                            }
                            Bn(p.get("geometryList"), s.get("geometryList")), Bn(p.get("wireframeList"), s.get("wireframeList")), s.get("texCoordUnitList").length = 0
                        } else i[h] = s
                    }
                    var S = Object.keys(n).length,
                        x = Object.keys(t).length;
                    if (ki.stats.materialCountBefore = x, ki.stats.materialCountAfter = x - a, 0 !== S) {
                        var C = function () {
                            Tn.NodeVisitor.call(this)
                        };
                        Tn.createPrototypeObject(C, Tn.objectInherit(Tn.NodeVisitor.prototype, {
                            apply: function (e) {
                                var t = e.getStateSet();
                                if (t) {
                                    var i = n[t.getInstanceID()];
                                    i && e.setStateSet(i)
                                }
                                this.traverse(e)
                            }
                        }));
                        var T = e.getRootModel(),
                            M = new C;
                        M.setNodeMaskOverride(-1), T.accept(M)
                    }
                }(t), Tn.timeEnd("optimizer - materials")), (0, l.Z)().graphOptimizer && (Tn.time("optimizer - nodes"), Vn(e, t), Tn.timeEnd("optimizer - nodes"), ki.stats.transparent = _n.hasTransparency), ki.registerStats(i, "After"), ki.computeStats(t), Tn.timeEnd("optimizer")) : ki.registerStats(i, "Stats")
            };
            const kn = Un;
            var Zn = i("/K0U"),
                Hn = new Zn.Z({
                    hasTransparency: !1,
                    hasScattering: !1,
                    hasRefraction: !1,
                    hasExtra: !1,
                    protectDepthAndColorUnit: !1
                }),
                Gn = function (e, t, i) {
                    var n = t.getInstanceID();
                    !!e.activeStateSets[n] !== i && (e.activeStateSets[n] = i, e.count += i ? 1 : -1, Hn.set(e.modelkey, e.count > 0))
                };
            Hn.registerStateSetIsTransparent = Gn.bind(Gn, {
                modelkey: "hasTransparency",
                activeStateSets: {},
                count: 0
            }), Hn.registerStateSetIsScattering = Gn.bind(Gn, {
                modelkey: "hasScattering",
                activeStateSets: {},
                count: 0
            }), Hn.registerStateSetIsRefraction = Gn.bind(Gn, {
                modelkey: "hasRefraction",
                activeStateSets: {},
                count: 0
            });
            var zn = !1,
                Wn = !1,
                jn = !1,
                Xn = !1,
                Yn = !1,
                Jn = !1,
                qn = function () {
                    Hn.set("hasExtra", Yn || Xn || zn || Wn || jn || Jn || (0, l.Z)().debug3D || (0, o.Z)() || !(0, l.Z)().vrStereo)
                };
            Hn.setHotspot = function (e) {
                Wn = e, qn()
            }, Hn.setWireframe = function (e) {
                zn = e, qn()
            }, Hn.setGizmo = function (e) {
                jn = e, qn()
            }, Hn.setDebugNormal = function (e) {
                Xn = e, qn()
            }, Hn.setOutline = function (e) {
                Jn = e, qn()
            }, Hn.setDebugSkeleton = function (e) {
                Yn = e, qn()
            }, qn();
            const Kn = Hn;
            var Qn = g.Z.osg,
                $n = V.Z.extend({
                    getName: function () {
                        return "MaterialManagerView3D"
                    },
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this.model.bind("change", this.render, this), bi.Z.bind("change:mask", this.cleanAndApplyMaterials, this), this._sceneLights = [], this._defaultStateSet = void 0, this._defaultMaterial = void 0, this._tracePathVisitor = new Ti, this.model.setImageCollection(this.getTextureCollection()), this.model.setMatcapCollection(this.getMatcapCollection()), this.init()
                    },
                    init: function () {
                        this._context = this.options.context, this._viewer = this._context.getViewer();
                        var e = this._context.getScene();
                        this._resourceDefer = new bt.Z, e.addResourcePromise(this._resourceDefer), L.Z.getPolygon().then(this.initSceneGraph.bind(this))
                    },
                    getTextureCollection: function () {
                        return this.getResourceManager().getTextureCollection()
                    },
                    getMatcapCollection: function () {
                        return this.getResourceManager().getMatcapCollection()
                    },
                    getResourceManager: function () {
                        return this._resourceManager || s.Z.instance
                    },
                    getOrCreateDefaultStateSet: function () {
                        return void 0 === this._defaultStateSet && (this._defaultStateSet = new Qn.StateSet, this._defaultStateSet._uniqueID = 0), this._defaultStateSet
                    },
                    setDefaultMaterial: function (e, t) {
                        var i = this.getOrCreateDefaultStateSet();
                        if (e.setStateSet(i), !this._defaultMaterial) {
                            if (this._defaultMaterial = t.getMaterialByStateSet(i), this._defaultMaterial) {
                                var n = i.getAttributeMap().Material,
                                    r = t.getUniqueMaterialName(n, i, e);
                                this._defaultMaterial.set("name", r)
                            } else this._defaultMaterial = t.createMaterial(e, i);
                            this._defaultMaterial.setStateSet(i)
                        }
                    },
                    addDefaultMaterial: function (e, t, i) {
                        0 === e.getMaterials().length && this.setDefaultMaterial(t, i);
                        for (var n = this._tracePathVisitor.getPathList(), r = 0, a = n.length; r < a; ++r) {
                            for (var o = n[r], s = o.length, l = !1, u = 0; u < s; ++u) {
                                var c = o[u].getStateSet();
                                if (c && c.getAttribute("testdemo2024Material")) {
                                    l = !0;
                                    break
                                }
                            }
                            if (!l) {
                                var h = o[s - 1];
                                this.setDefaultMaterial(h, i)
                            }
                        }
                    },
                    _handleCullFace: function (e) {
                        var t = this._context.getModel().get("options"),
                            i = e.userDataMap.sourceTool.toLowerCase(),
                            n = (0, l.Z)().singleSided,
                            r = -1 !== i.indexOf("sketchup"),
                            a = r && t.version < 6,
                            o = r && (0, vi.Z)();
                        if (void 0 !== n || o || a) {
                            var s = !1 === n ? Qn.CullFace.DISABLE : Qn.CullFace.BACK,
                                u = this.model.getMaterials();
                            for (var c in u) u[c].set("cullFace", s)
                        }
                    },
                    processSceneGraph: function (e, t) {
                        var i = new Si(t).apply(e);
                        (e.accept(this._tracePathVisitor), this.deleteUnusedMaterials(this._tracePathVisitor), this.addDefaultMaterial(i, e, t), this._sceneLights = i.getLights(), this._handleCullFace(e), (0, vi.Z)() && "substancepainter" === e.userDataMap.source) && this._viewer.getFeatures().shadingStyle.getModel().set("vertexColorEnable", !1);
                        return (0, vi.Z)() && "quixel" === e.userDataMap.source && 0 === i.getMaterials().length && (i.checkForPBRTextureFromMaterialAndFilenames(this._defaultMaterial, !0), i.checkChannelsAndSetWorkFlowRoughGloss(this._defaultMaterial)), i
                    },
                    getSceneLights: function () {
                        return this._sceneLights
                    },
                    initSceneGraph: function () {
                        var e = this.model,
                            t = this._viewer.getRootModel(),
                            i = this._viewer.getFeatures();
                        if (Qn.time("initSceneGraph - create saved materials"), !1 === (0, l.Z)().processMaterial) {
                            var n = this._context.getModel().get("options").materials;
                            for (var r in n) e.addMaterial(n[r])
                        }
                        Qn.timeEnd("initSceneGraph - create saved materials"), Qn.time("initSceneGraph - processSceneGraph");
                        var a = this.processSceneGraph(t, e);
                        Qn.timeEnd("initSceneGraph - processSceneGraph"), Qn.time("initSceneGraph - apply materials"), e.removeUnboundMaterial();
                        var o = i.shadingStyle.getModel(),
                            s = o.get("vertexColorEnable") && o.get("vertexColorUseAlpha");
                        e.tagMaterialWithGeometryInfo(t, s), this._requestTextures(), e._style = a.getStyle();
                        var u = a.hasMetallicWorkflow();
                        void 0 !== u && e.setWorkFlowMetalSpec(u, !1), e.overrideMaterialChannels((0, l.Z)()), e.enforceWorkflowPerMaterial(), e.updateTexCoordUnitList(), Kn.set("protectDepthAndColorUnit", this._checkProtectDepthColor()), this.applyMaterials(), this.setWireframeStateSets(), Qn.timeEnd("initSceneGraph - apply materials"), kn.optimize(this._tracePathVisitor, this._viewer), i.quality && i.quality.getModel().trigger("updateTexelPolicy"), L.Z.resolveMaterial(), Ai.Z.packAllMaterialsTextures(e.getMaterials())
                    },
                    _checkProtectDepthColor: function () {
                        if (window.RunningTests) return !1;
                        if ((0, o.Z)() || (0, l.Z)().materialShowcase || (0, l.Z)().apiVersion) return !0;
                        if (this._viewer.getFeatures().postProcess.getModel().isEffectiveSsr()) return !0;
                        var e = this.model.getMaterials();
                        for (var t in e) {
                            var i = e[t].getChannels().Opacity;
                            if ("refraction" === i.getTransparency() && i.isEffective()) return !0
                        }
                        return !1
                    },
                    setWireframeStateSets: function () {
                        if (this._viewer.hasIntegratedWireframe()) {
                            var e = 0,
                                t = this.model,
                                i = {},
                                n = this._tracePathVisitor.getPathList(),
                                r = n.length;
                            for (e = 0; e < r; ++e) {
                                var a = n[e],
                                    o = a[a.length - 1];
                                if (o instanceof Qn.Geometry != !1) {
                                    var s = o.getVertexAttributeList().Vertex;
                                    s && (i[s.getInstanceID()] = a)
                                }
                            }
                            var l = {},
                                u = this._tracePathVisitor.getWireframePathList(),
                                c = this._context.getScene().getWireframeNodes(),
                                h = c.length;
                            for (e = 0; e < h; ++e) {
                                var d = c[e],
                                    g = i[d.getVertexAttributeList().Vertex.getInstanceID()];
                                if (g) {
                                    var f = g[g.length - 1],
                                        m = t.findFirstMaterial(g);
                                    m.get("wireframeList").push(d);
                                    var p = m.get("stateSet");
                                    d._attributes = f.getVertexAttributeList();
                                    var v = p.getAttribute("testdemo2024Material"),
                                        _ = v.getInstanceID(),
                                        S = l[_];
                                    S || ((S = l[_] = new yi.Z)._textureAttributeArrayList = p._textureAttributeArrayList, S._activeTextureAttributeUnit = p._activeTextureAttributeUnit, S._activeTextureAttribute = p._activeTextureAttribute, S.setAttributeAndModes(v), v.getMaterialModel().set("stateSetWireframe", S)), d.setStateSet(S)
                                } else {
                                    c.splice(e, 1), e--, h--;
                                    for (var x = d.getParents(), C = 0, T = x.length; C < T; ++C) x[C].removeChild(d);
                                    for (var M = 0; M < u.length; ++M) {
                                        var b = u[M];
                                        b[b.length - 1] === d && (u.splice(M, 1), M--)
                                    }
                                }
                            }
                        }
                    },
                    deleteUnusedMaterials: function (e) {
                        for (var t = e.getStateSetMapNodes(), i = e.getStateSetPathList(), n = e.getStateSetMap(), r = {}, a = 0, o = i.length; a < o; a++) {
                            var s = i[a];
                            if (s.length > 0) {
                                var l = s.length - 1;
                                r[s[l]._uniqueID] = s[l]
                            }
                        }
                        for (var u in t)
                            if (void 0 === r[u]) {
                                this.model.removeMaterialByStateSet(n[u]);
                                for (var c = 0, h = t[u].length; c < h; c++) {
                                    t[u][c].setStateSet(void 0)
                                }
                            }
                    },
                    cleanAndApplyMaterials: function () {
                        var e = this.model.getMaterials();
                        for (var t in e) {
                            var i = e[t];
                            i.get("stateSet") && i.trigger("change:stateSet")
                        }
                        this.applyMaterials()
                    },
                    applyMaterials: function () {
                        var e = this.model.getMaterials();
                        for (var t in e) {
                            e[t].trigger("apply")
                        }
                    },
                    _requestTexture: function (e, t, i) {
                        if (e) {
                            var n = e.getChannels()[t],
                                r = n.getTextureModel();
                            if (r && n.isEffective()) {
                                var a = r.getMultiresTexture();
                                if (a) {
                                    if (0 !== a.getImageCount()) return (i ? a.getImageSmallest() : a.getImageMaxSupported()).promise;
                                    n.setColor && n.setColor(Qn.vec3.fromValues(.9, .9, .9))
                                }
                            }
                        }
                    },
                    _requestAllTextures: function (e, t) {
                        for (var i = [], n = new window.Set, r = 0; r < Mi.Z.length; ++r) {
                            var a = Mi.Z[r];
                            for (var o in e) {
                                var s = e[o],
                                    l = this._requestTexture(s, a, t);
                                l && !n.has(l) && (n.add(l), i.push(l))
                            }
                        }
                        return i
                    },
                    _resolvePromiseTextures: function (e, t, i) {
                        for (var n = (new Date).getTime() - t, r = 0, a = 0, o = e.length; a < o; ++a) !0 !== e[a] && r++;
                        (i ? L.Z.resolveLowResLoaded : L.Z.resolveHighResLoaded)({
                            time: r > 0 ? n : 0,
                            count: r
                        })
                    },
                    requestAllLowResTextures: function (e) {
                        return this._requestAllTextures(e, !0)
                    },
                    requestAllHighResTextures: function (e) {
                        for (var t = this._requestAllTextures(e, !1), i = 0, n = 0, r = t.length; n < r; n++) i += t[n].progressSize;
                        return L.Z.resolveDataSizeTextures(i), t
                    },
                    _resolvePromiseLowResTextures: function (e, t) {
                        return this._resolvePromiseTextures(e, t, !0)
                    },
                    _resolvePromiseHighResTextures: function (e, t) {
                        return this._resolvePromiseTextures(e, t, !1)
                    },
                    _startHighResAfterLowRes: function (e, t, i, n) {
                        var r = Date.now();
                        this._resolvePromiseLowResTextures(e, t);
                        var a = this.requestAllHighResTextures(n);
                        this._viewer.setFakeProgress(a, !i, "texture");
                        var o = this;
                        d().all((0, Mt.Z)(a, (function (e) {
                            return e.reflect()
                        }))).then((function () {
                            o._resolvePromiseHighResTextures(a, r), i && o._resourceDefer.resolve()
                        })), i || this._resourceDefer.resolve()
                    },
                    _requestTextures: function () {
                        var e = (0, l.Z)().preload,
                            t = this.model.toJSON();
                        if (e) this._startHighResAfterLowRes(d().resolve(), Date.now(), e, t);
                        else {
                            var i = Date.now(),
                                n = this.requestAllLowResTextures(t);
                            this._viewer.setFakePrimaryProgress(n, "texture");
                            var r = this;
                            d().all((0, Mt.Z)(n, (function (e) {
                                return e.reflect()
                            }))).then((function () {
                                r._startHighResAfterLowRes(n, i, e, t)
                            }))
                        }
                    },
                    _getUniqueTextures: function () {
                        var e = {},
                            t = this.model.getMaterials(),
                            i = [];
                        for (var n in t)
                            for (var r = t[n].get("stateSet"), a = r.getNumTextureAttributeLists(), o = 0; o < a; ++o) {
                                var s = r.getTextureAttribute(o, "Texture");
                                s && s.getChannelPacking && (s.isTextureNull() || s.isColorAtlas() || e[s.getInstanceID()] || (e[s.getInstanceID()] = !0, i.push(s)))
                            }
                        return i
                    },
                    getOrCreateTexelInfos: function () {
                        if (this._infoTex) return this._infoTex;
                        for (var e = this._infoTex = {
                            missingTextures: {},
                            gpuTextureCount: 0,
                            gpuPixelCount: 16777216,
                            min: 1 / 0,
                            max: -1 / 0
                        }, t = {
                            width: 0,
                            height: 0,
                            missingTextures: e.missingTextures
                        }, i = this._getUniqueTextures(), n = i.length, r = 0; r < n; ++r) {
                            t = i[r].getMaxTextureSizePacked(t), e.gpuTextureCount++, e.gpuPixelCount += t.width * t.height;
                            var a = Math.max(t.width, t.height);
                            e.min = Math.min(a, e.min), e.max = Math.max(a, e.max)
                        }
                        return e
                    }
                });
            const er = $n;
            var tr = i("R4My"),
                ir = i.n(tr),
                nr = i("X9mO"),
                rr = i("WoEt"),
                ar = i("Majl"),
                or = g.Z.osg,
                sr = function (e, t) {
                    return e - t
                },
                lr = {
                    Matcap: "Matcap",
                    SubsurfaceScattering: "Subsurface scattering",
                    SubsurfaceTranslucency: "Subsurface translucency",
                    DiffuseColor: "Diffuse",
                    DiffuseIntensity: "Lightmap",
                    SpecularColor: "Specular Color",
                    SpecularHardness: "Glossiness",
                    Displacement: "Displacement",
                    NormalMap: "Normal map",
                    BumpMap: "Bump map",
                    AlphaMask: "Alpha Mask",
                    Opacity: "Opacity",
                    EmitColor: "Emission",
                    DiffusePBR: "Albedo",
                    AlbedoPBR: "Base Color",
                    SpecularPBR: "Specular",
                    GlossinessPBR: "Glossiness",
                    RoughnessPBR: "Roughness",
                    MetalnessPBR: "Metalness",
                    Sheen: "Sheen",
                    SheenRoughness: "SheenRoughness",
                    SpecularF0: "Specular F0",
                    AOPBR: "Ambient Occlusion",
                    CavityPBR: "Cavity",
                    ClearCoat: "Clear Coat",
                    ClearCoatRoughness: "Clear Coat roughness",
                    ClearCoatNormalMap: "Clear Coat normap map",
                    Anisotropy: "Anisotropy"
                },
                ur = a.Z.extend({
                    initDefaults: function (e) {
                        var t = e.channels;
                        for (var i in delete e.channels, e.reflection = (0, vi.Z)() ? .1 : .3, e.verison = 3, a.Z.prototype.initDefaults.call(this, e), t.Inspector = {
                            factor: 1,
                            enable: !0,
                            maskThreshold: 0,
                            invert: !1,
                            color: or.vec3.fromValues(1, 1, 1)
                        }, t) {
                            var n = t[i];
                            switch (n.name = i, n.material = this, n.displayName = lr[i], i) {
                                case "DiffuseColor":
                                    n.color = (0, vi.Z)() ? or.vec3.fromValues(1, 1, 1) : or.vec3.fromValues(.5, .5, .5);
                                    break;
                                case "Opacity":
                                    n.useAlbedoTint = !(0, vi.Z)(), n.thinLayer = !(0, vi.Z)()
                            }
                            t[i] = new ar.Z[i].model(n)
                        }
                        this.set("channels", t)
                    },
                    getModelOptionPath: function () {
                        return "materials:0"
                    },
                    getName: function () {
                        return this.get("name")
                    },
                    defaults: function () {
                        return {
                            geometryList: [],
                            wireframeList: [],
                            texCoordUnitList: [],
                            vertexColorColorSpace: "srgb",
                            vertexColorEnable: !1,
                            vertexAlphaEnable: !1,
                            hasVertexColor: !1,
                            hasVertexAlpha: !1,
                            hasTriangles: !1,
                            hasPoints: !1,
                            hasLines: !1,
                            stateSet: void 0,
                            stateSetWireframe: void 0,
                            uidUniqueMerged: "",
                            uidListUnusedDuplicates: []
                        }
                    },
                    setMaterial: function (e) {
                        this.set(e);
                        var t = this.getChannels();
                        for (var i in e.channels) t[i].set(e.channels[i])
                    },
                    setMaterialJSON: function (e, t, i) {
                        var n = i || {},
                            r = e.channels;
                        n.ignore = ["channels"];
                        var o = a.Z.prototype.setJSON.call(this, e, n);
                        if (r) {
                            var s = this.getChannels();
                            if (r.Opacity) {
                                var l = r.Opacity;
                                "alphaMask" === l.type && (r.AlphaMask = {
                                    enable: l.enable,
                                    factor: l.factor,
                                    invert: l.invert,
                                    texture: l.texture
                                }, l.factor = 1, l.type = "alphaBlend", l.texture = {}, l.enable = !1)
                            }
                            for (var u = Mi.Z.length, c = 0; c < u; ++c) {
                                var h = Mi.Z[c],
                                    d = r[h];
                                if (d) {
                                    var g = s[h];
                                    if (g) {
                                        var f = g.setChannelJSON(d, t, n);
                                        f.length && o.concat(f)
                                    }
                                }
                            }
                            return o
                        }
                    },
                    getChannels: function () {
                        return this.get("channels")
                    },
                    getStateSet: function () {
                        return this.get("stateSet")
                    },
                    setStateSet: function (e) {
                        return this.set("stateSet", e), this
                    },
                    setChannelEnable: function (e, t) {
                        var i = this.get("channels");
                        return i[e] ? (i[e].setEnable(t), this) : this
                    },
                    setChannelColor: function (e, t) {
                        var i = this.get("channels")[e];
                        return i && i.setColor ? (i.setColor(t), this) : this
                    },
                    setChannelTexture: function (e, t) {
                        var i = this.get("channels");
                        return i[e] ? (i[e].setTextureModel(t), this) : this
                    },
                    setChannelFactor: function (e, t) {
                        var i = this.get("channels");
                        return i[e] ? (i[e].setFactor(t), this) : this
                    },
                    getJSON: function () {
                        var e = a.Z.prototype.getJSON.call(this, {
                            ignore: ["channels"]
                        });
                        e.version = 3, e.channels = {};
                        var t = this.get("channels");
                        for (var i in t) "Inspector" !== i && (e.channels[i] = t[i].getJSON());
                        return e
                    },
                    copyDualChannel: function (e, t) {
                        var i = this.getChannels(),
                            n = i[e],
                            r = i[t],
                            a = r.getTextureModel(),
                            o = "MetalnessPBR" === e || "SpecularPBR" === e,
                            s = "NormalMap" === e || "BumpMap" === e;
                        a ? (a = a.clone(), (o || s) && (a.setImageModel(a.getImageModel()), a.set("internalFormat", "NormalMap" === e || "SpecularPBR" === e ? or.Texture.RGB : or.Texture.LUMINANCE), a.updateMultiresTexture()), n.setTextureModel(a)) : o || (n.setColor ? r.getColor && n.setColor(r.getColor()) : n.setTextureModel(void 0)), s || n.setFactor(r.getFactor())
                    },
                    isWorkflowMetalness: function () {
                        return this.getChannels().MetalnessPBR.getEnable()
                    },
                    setWorkFlowRoughGloss: function (e, t) {
                        var i = e ? "GlossinessPBR" : "RoughnessPBR",
                            n = e ? "RoughnessPBR" : "GlossinessPBR",
                            r = this.getChannels();
                        r[i].setEnable(!1), r[n].setEnable(!0), t && this.copyDualChannel(n, i, r)
                    },
                    setWorkFlowMetalSpec: function (e, t) {
                        var i = e ? "DiffusePBR" : "AlbedoPBR",
                            n = e ? "SpecularPBR" : "MetalnessPBR",
                            r = e ? "AlbedoPBR" : "DiffusePBR",
                            a = e ? "MetalnessPBR" : "SpecularPBR",
                            o = this.getChannels();
                        o[i].setEnable(!1), o[n].setEnable(!1), o.SpecularF0.setEnable(e), o[r].setEnable(!0), o[a].setEnable(!0), t && (this.copyDualChannel(r, i), this.copyDualChannel(a, n))
                    },
                    hasOnlyPoints: function () {
                        return this.get("hasPoints") && !this.get("hasTriangles") && !this.get("hasLines")
                    },
                    updateTexCoordUnitList: function () {
                        var e = this.get("texCoordUnitList");
                        e.length = 0;
                        for (var t, i, n = this.get("geometryList"), r = n.length, a = "TexCoord", o = [], s = [], l = 0; l < r; ++l) {
                            var u = n[l].getVertexAttributeList();
                            for (var c in s.length = 0, u) - 1 !== c.indexOf("TexCoord") && s.push(parseInt(c.substring(8)));
                            for (0 === s.length && this.set("missingUvs", !0), s.sort(sr), t = s.length - 1; t >= 0; --t) {
                                var h = s[t],
                                    d = u[a + h];
                                for (i = 0; i < t; ++i) {
                                    var g = s[i];
                                    if (d === u[a + g]) {
                                        var f = o[h];
                                        void 0 !== f && f !== g ? -1 === e.indexOf(h) && e.push(h) : o[h] = g;
                                        break
                                    }
                                }
                                var m = s[i]; - 1 === e.indexOf(m) && e.push(m)
                            }
                        }
                        if (e.sort(sr), 0 !== o.length) {
                            var p = e.length;
                            for (t = 0; t < p; ++t) o[e[t]] = e[t];
                            var v = this.getChannels(),
                                _ = Mi.Z.length;
                            for (t = 0; t < _; ++t) {
                                var S = v[Mi.Z[t]];
                                S.setTexCoordUnit(o[S.getTexCoordUnit()])
                            }
                        }
                    },
                    enforceWorkflow: function () {
                        var e = this.getChannels(),
                            t = e.MetalnessPBR.getEnable();
                        e.AlbedoPBR.setEnable(t), e.SpecularF0.setEnable(t), e.DiffusePBR.setEnable(!t), e.SpecularPBR.setEnable(!t);
                        var i = e.RoughnessPBR.getEnable();
                        e.GlossinessPBR.setEnable(!i), e.BumpMap.getEnable() && e.NormalMap.getEnable() && e.BumpMap.setEnable(!1)
                    }
                });
            const cr = ur;
            var hr = i("avzw"),
                dr = g.Z.osg,
                gr = {};
            gr[dr.Texture.LUMINANCE] = "r", gr[dr.Texture.ALPHA] = "a", gr[dr.Texture.RGB] = "rgb";
            var fr = function (e) {
                dr.Texture.call(this), this._texture = e, this._isColorAtlas = !1, this._channels = [], this._packedTextures = {}
            },
                mr = function (e, t) {
                    var i = Mi.Z.getDefaultComponentCount(e),
                        n = Mi.Z.getDefaultComponentCount(t);
                    return n === i ? e < t ? 1 : -1 : n - i
                };
            dr.createPrototypeStateAttribute(fr, dr.objectInherit(dr.Texture.prototype, {
                attributeType: "Texture",
                invalidate: function () {
                    this._isColorAtlas || (this._texture = void 0)
                },
                isColorAtlas: function () {
                    return this._isColorAtlas
                },
                setIsColorAtlas: function (e) {
                    this._isColorAtlas = e
                },
                getChannelPacking: function (e) {
                    var t = this._packedTextures[e];
                    return t ? t.pack : ""
                },
                getPackedTextures: function () {
                    return this._packedTextures
                },
                getOrderedChannels: function () {
                    return this._channels
                },
                getTexture: function () {
                    return this._texture || (this._texture = Ai.Z.packTextures(this)), this._texture
                },
                setTexture: function (e) {
                    this._texture = e
                },
                getChannelCount: function () {
                    return this._channels.length
                },
                addChannel: function (e, t, i) {
                    this._packedTextures[e] || (this._packedTextures[e] = {
                        texture: t,
                        pack: "rgb"
                    }, i || this._channels.push(e), this._isColorAtlas || (this._texture = void 0, this.updatePacking()))
                },
                removeChannel: function (e) {
                    this._packedTextures[e] && (delete this._packedTextures[e], this._channels.splice(this._channels.indexOf(e), 1), this._isColorAtlas || (this._texture = void 0, this.updatePacking()))
                },
                packChannelIfPossible: function (e, t) {
                    if (this._isColorAtlas || !(0, l.Z)().materialPacking || t.isVideo()) return !1;
                    var i = this._channels,
                        n = i.length;
                    if (0 === n) return !1;
                    for (var r = 4, a = 0; a < n; ++a) r -= this._packedTextures[i[a]].pack.length;
                    return 0 !== r && (!(Mi.Z.getDefaultComponentCount(e) > r) && (!!this.isFilteringFriendly(t, this._packedTextures[i[0]].texture) && (i.push(e), this.addChannel(e, t, !0), this.updatePacking(), !0)))
                },
                isFilteringFriendly: function (e, t) {
                    return e.getMinFilter() === t.getMinFilter() && (e.getMagFilter() === t.getMagFilter() && (e.getWrapS() === t.getWrapS() && e.getWrapT() === t.getWrapT()))
                },
                getSinglePacking: function (e, t) {
                    if ("Opacity" === e || "AlphaMask" === e) {
                        var i = t.getInternalFormat() && gr[t.getInternalFormat()];
                        return i && 1 === i.length ? i : "r"
                    }
                    return "EmitColor" === e && t.getInternalFormat() === dr.Texture.ALPHA ? "aaa" : Mi.Z.getDefaultFormatComponent(e)
                },
                updatePacking: function () {
                    var e = this._channels,
                        t = 0,
                        i = e.length;
                    if (1 !== i) {
                        e.sort(mr);
                        for (var n = 0; n < i; ++n) {
                            var r = e[n],
                                a = this._packedTextures[r];
                            if (a) {
                                var o = Mi.Z.getDefaultFormatComponent(r).length;
                                a.pack = "rgba".substr(t, o), t += o
                            }
                        }
                    } else {
                        var s = this._packedTextures[e[0]];
                        s.pack = this.getSinglePacking(e[0], s.texture)
                    }
                },
                getMaxTextureSizePacked: function (e) {
                    e.width = 0, e.height = 0;
                    for (var t = this._channels, i = t.length, n = 0; n < i; ++n) {
                        var r = t[n],
                            a = this._packedTextures[r];
                        if (a) {
                            var o = a.texture;
                            if (o.getImageJSONMaxSupported) {
                                var s = o.getImageJSONMaxSupported();
                                if (e.width = Math.max(e.width, s.width), e.height = Math.max(e.height, s.height), !(s.width <= 512 && s.height <= 512)) {
                                    var l = o.getImageJSONMaxSupported(512);
                                    if (512 !== l.width && 512 !== l.height) {
                                        var u = o.getImageModel().getUID(),
                                            c = e.missingTextures[u];
                                        c ? -1 === c.indexOf("channelName") && c.push(r) : e.missingTextures[u] = [r]
                                    }
                                }
                            }
                        }
                    }
                    return e
                },
                isProtectedTexture: function () {
                    for (var e = rr.Z.compilerChannels[rr.Z.EARLYZ_COMPILER], t = 0; t < e.length; ++t)
                        if (this._packedTextures[e[t]]) return !0;
                    return !1
                },
                getImage: function () {
                    return this.getTexture().getImage()
                },
                cloneType: function () {
                    return new fr(new hr.Z)
                },
                isTextureNull: function () {
                    return !(!this._isColorAtlas || 0 !== this._channels.length) || this.getTexture().isTextureNull()
                },
                apply: function (e) {
                    var t = e.getGraphicContext();
                    this.setGraphicContext(t);
                    var i = this.getTexture(),
                        n = i._textureObject && !i.isDirty();
                    i.apply(e), n || (this._packedTextures.AlphaMask || this._packedTextures.Opacity || this._packedTextures.Displacement) && U.Z.redrawShadowNextFrame()
                },
                getHash: function () {
                    return ""
                }
            }), "osgtestdemo2024", "PackedMaterialTexture");
            const pr = fr;
            var vr = i("WvFz"),
                _r = g.Z.osg,
                Sr = _r.Texture.textureNull,
                xr = Le.Z.CULL_BACK,
                Cr = Le.Z.CULL_DISABLE,
                Tr = new _r.PointSizeAttribute,
                Mr = new _r.PointSizeAttribute;
            Mr.setCircleShape(!0);
            var br = function (e) {
                this._stateSet = void 0, this._materialModel = e, this._material = new rr.Z, this._material.setMaterialModel(this._materialModel), this._material.setStateSetContext(this);
                var t = new _r.Texture;
                t.setImage(new Uint8Array(12), _r.Texture.RGB), t.setTextureSize(4, 1), t.setMinFilter(_r.Texture.NEAREST), t.setMagFilter(_r.Texture.NEAREST), this._colorAtlas = new pr(t), this._colorAtlas.setIsColorAtlas(!0), this._packedMaterialTextureCache = {}, this._maxTextureUnits = (0, vr.Z)()
            };
            br.cachedSquarePoint = Tr, br.cachedCirclePoint = Mr, br.prototype = {
                dirtyMaterial: function () {
                    this._material && this._material.dirtyMaterial()
                },
                getStateSet: function () {
                    return this._stateSet
                },
                getChannelPacking: function (e) {
                    var t = this._packedMaterialTextureCache[e];
                    return t.getChannelPacking && t.getChannelPacking(e)
                },
                setStateSet: function (e) {
                    this._stateSet = e, e.getAttribute("testdemo2024Material") || (this._material.setName(e.getName()), e.setAttributeAndModes(this._material));
                    for (var t = 0, i = e.getNumTextureAttributeLists(); t < i; t++) e.removeTextureAttribute(t, "Texture")
                },
                setStateSetAlphaBlending: function () {
                    this._stateSet && (this._stateSet.setRenderBinDetails(Oe.Z.TRANSPARENT, "DepthSortedBin"), Kn.registerStateSetIsTransparent(this._stateSet, !0), Kn.registerStateSetIsRefraction(this._stateSet, !1))
                },
                setStateSetOpaque: function () {
                    this._stateSet && (this._stateSet.setRenderBinDetails(Oe.Z.OPAQUE, "RenderBin"), Kn.registerStateSetIsTransparent(this._stateSet, !1), Kn.registerStateSetIsRefraction(this._stateSet, !1))
                },
                setStateSetRefraction: function () {
                    this._stateSet && (this._stateSet.setRenderBinDetails(Oe.Z.REFRACTION, "RenderBin"), Kn.registerStateSetIsTransparent(this._stateSet, !1), Kn.registerStateSetIsRefraction(this._stateSet, !0))
                },
                setCullface: function (e) {
                    this._stateSet && (this._stateSet.setAttributeAndModes(e ? xr : Cr), this._material.dirtyMaterial())
                },
                setPointCircle: function (e) {
                    this._stateSet && (this._stateSet.setAttributeAndModes(e ? Mr : Tr), this._material.dirtyMaterial())
                },
                isFreeSlot: function (e, t) {
                    return void 0 === e || e === Sr || (!(!e.getChannelCount || 0 !== e.getChannelCount()) || !(!t || e !== this._colorAtlas))
                },
                isProtectedUnit: function (e) {
                    return !(!Kn.get("protectDepthAndColorUnit") || 4 !== e && 5 !== e) || (6 === e || 8 === e || (0, l.Z)().shadowAtlas && 7 === e)
                },
                _getFirstFreeUnit: function (e) {
                    for (; this.isProtectedUnit(e);) e++;
                    return Math.min(e, this._maxTextureUnits - 1)
                },
                getAvailableTextureUnit: function (e, t) {
                    for (var i = t === this._colorAtlas, n = t === Sr, r = this._stateSet, a = r.getNumTextureAttributeLists(), o = this._getFirstFreeUnit(a), s = -1, l = 0; l <= o; ++l)
                        if (!this.isProtectedUnit(l)) {
                            var u = r.getTextureAttribute(l, "Texture");
                            if (-1 === s && this.isFreeSlot(u, i) && (s = l, i || n)) break;
                            if (!n && !i && u && u.packChannelIfPossible && u.packChannelIfPossible(e, t)) {
                                s = l;
                                break
                            }
                        }
                    return s
                },
                setPackedMaterialTextureToStateSet: function (e, t) {
                    var i = e.getName(),
                        n = this._packedMaterialTextureCache[i];
                    n && n instanceof pr && (n.removeChannel(i), Ai.Z.removePackedTexture(n));
                    var r = this.getAvailableTextureUnit(i, t);
                    if (r < 0) return this._packedMaterialTextureCache[i] = Sr, void this._material.setChannelMapping(i, -1);
                    var a = this._stateSet.getTextureAttribute(r, "Texture");
                    t === this._colorAtlas ? a = this._colorAtlas : a && a !== this._colorAtlas || (a = new pr), a.setName("Texture" + r), this._material.setChannelMapping(i, t === Sr ? -1 : r), this._packedMaterialTextureCache[i] = a, a && a.addChannel && t !== Sr && a.addChannel(i, t);
                    var o = a instanceof pr,
                        s = o && a.isProtectedTexture() ? _r.StateAttribute.PROTECTED : _r.StateAttribute.ON;
                    this._stateSet.setTextureAttributeAndModes(r, a, s), o && Ai.Z.addPackedTexture(a)
                },
                setTexture: function (e) {
                    var t = e.getTextureModel(),
                        i = t.getImageModel(),
                        n = t.getMultiresTexture();
                    if (i && n) {
                        this.setPackedMaterialTextureToStateSet(e, n), n.isTextureNull() && n.setTextureSize(1, 1);
                        var r = L.Z.getLowResLoaded();
                        if (r.isFulfilled()) return n.setImageMaxSupported();
                        n.setImageSmallest().promise.then((function () {
                            r.then(n.setImageMaxSupported.bind(n))
                        }))
                    }
                },
                setColor: function (e) {
                    var t = Mi.Z.getColorPacking(e.getName());
                    if (t < 0) this.setPackedMaterialTextureToStateSet(e, Sr);
                    else {
                        var i = e.getColor();
                        t *= 3;
                        var n = this._colorAtlas.getTexture(),
                            r = n.getImage().getImage();
                        r[t] = Math.round(255 * i[0]), r[t + 1] = Math.round(255 * i[1]), r[t + 2] = Math.round(255 * i[2]), n.dirty(), this.setPackedMaterialTextureToStateSet(e, this._colorAtlas)
                    }
                },
                setChannelEnable: function (e, t) {
                    return !1 === t ? this.setPackedMaterialTextureToStateSet(e, Sr) : e.getTextureModel() ? this.setTexture(e) : void this.setColor(e)
                },
                setChannelOpacity: function (e, t) {
                    var i = e.getTransparency(),
                        n = "alphaBlend" === i,
                        r = !n && "additive" === i,
                        a = !r && !n && "dithering" === i,
                        o = !r && !n && !a && "refraction" === i;
                    n || a || !o || r || "alphaMask" !== i || this.model.get("material").getChannels().AlphaMask._migrate();
                    return this._material && this._material.updateOpacity(), !1 === t || a ? this.setStateSetOpaque() : n || r ? this.setStateSetAlphaBlending() : o ? this.setStateSetRefraction() : void _r.warn("Unknow opacity type : " + i)
                },
                updateChannel: function (e) {
                    if (this._stateSet) {
                        var t = e.isEffective();
                        this.setChannelEnable(e, t);
                        var i = e.getName();
                        "Opacity" === i && this.setChannelOpacity(e, t), "SubsurfaceScattering" === i && (Kn.registerStateSetIsScattering(this._stateSet, t), this._materialModel.getChannels().Opacity.trigger("updateChannel")), this._material.dirtyMaterial()
                    }
                }
            };
            const yr = br;
            const Ar = V.Z.extend({
                initialize: function () {
                    V.Z.prototype.initialize.apply(this, arguments), this.model.bind("change:stateSet", this.stateSet, this), this.model.bind("change:cullFace", this.onCullFace, this), this.model.bind("change:shadeless", this.onDirty, this), this.model.bind("change:vertexColorEnable", this.onDirty, this), this.model.bind("change:vertexColorColorSpace", this.onDirty, this), this.model.bind("change:vertexAlphaEnable", this.onDirty, this), bi.Z.bind("change:hasSsr", this.onDirty, this), this.model.bind("change:hasPoints", this.onPrimitive, this), this.model.bind("change:hasTriangles", this.onPrimitive, this), this.model.bind("change:hasLines", this.onPrimitive, this), this.model.bind("apply", this.apply, this), this.model.bind("change", U.Z.draw), this._context = new yr(this.model), this._views = {};
                    for (var e = this.model.get("channels"), t = Mi.Z.length, i = 0; i < t; ++i) {
                        var n = Mi.Z[i],
                            r = e[n];
                        this._views[n] = new ar.Z[n].view({
                            model: r,
                            stateSetContext: this._context
                        }), this._views[n].stateSetContext = this._context, r.bind("change:enable", this.model.enforceWorkflow, this.model)
                    }
                },
                getStateSetContext: function () {
                    return this._context
                },
                stateSet: function () {
                    var e = this.model.get("stateSet");
                    return e.setName(this.model.get("name")), this.getStateSetContext().setStateSet(e), this
                },
                apply: function () {
                    for (var e in this._views) this._views[e].updateChannel();
                    this.onCullFace(), this.onDirty()
                },
                onDirty: function () {
                    this.getStateSetContext().dirtyMaterial()
                },
                onCullFace: function () {
                    this.getStateSetContext().setCullface(this.model.get("cullFace"))
                },
                onPrimitive: function () {
                    this.getStateSetContext().setPointCircle(this.model.hasOnlyPoints())
                }
            });

            function Rr() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (e) {
                    var t = 16 * Math.random() | 0;
                    return ("x" === e ? t : 3 & t | 8).toString(16)
                }))
            }
            var wr = i("JBIs"),
                Er = g.Z.osg,
                Pr = 1,
                Nr = function () {
                    Er.NodeVisitor.call(this, Er.NodeVisitor.TRAVERSE_PARENTS), this._material = void 0, this._manager = void 0
                };
            Er.createPrototypeObject(Nr, Er.objectInherit(Er.NodeVisitor.prototype, {
                setManager: function (e) {
                    this._manager = e
                },
                reset: function () {
                    this.nodePath.length = 0, this._material = void 0
                },
                apply: function (e) {
                    if (!this._material) {
                        var t = e.getStateSet();
                        t && (this._material = this._manager.getMaterialByStateSet(t)), this._material || this.traverse(e)
                    }
                }
            }));
            var Or = function (e, t) {
                Er.NodeVisitor.call(this), this._manager = e, this._useVertexAlpha = t, this._stackMaterial = []
            };
            Er.createPrototypeObject(Or, Er.objectInherit(Er.NodeVisitor.prototype, {
                apply: function (e) {
                    var t = e.getStateSet(),
                        i = t && this._manager.getMaterialByStateSet(t);
                    if (i && this._stackMaterial.push(i), e instanceof Er.Geometry && this._stackMaterial.length > 0) {
                        var n = this._stackMaterial[this._stackMaterial.length - 1];
                        e.getVertexAttributeList().Color && (n.set("hasVertexColor", !0), !n.get("hasVertexAlpha") && e.userDataMap.hasVertexAlpha && (n.set("hasVertexAlpha", !0), n.set("vertexAlphaEnable", this._useVertexAlpha))), e.userDataMap && (n.set("hasPoints", e.userDataMap.hasPoints), n.set("hasTriangles", e.userDataMap.hasTriangles), n.set("hasLines", e.userDataMap.hasLines)), n.get("geometryList").push(e)
                    }
                    this.traverse(e), i && this._stackMaterial.pop()
                }
            }));
            var Dr, Ir = ir().Model.extend({
                initialize: function () {
                    this._materialByStateSetID = {}, this._materialNames = {
                        material_: 0
                    }
                },
                getImageCollection: function () {
                    return this._imageCollection || g.Z.osg.error("ImageCollection not initialized in MaterialManager, something is wrong"), this._imageCollection
                },
                setImageCollection: function (e) {
                    this._imageCollection = e
                },
                getMatcapCollection: function () {
                    return this._matcapCollection || g.Z.osg.error("matcapCollection not initialized in MaterialManager, somewhing wrong"), this._matcapCollection
                },
                setMatcapCollection: function (e) {
                    this._matcapCollection = e
                },
                setNewMaterial: function (e, t) {
                    this.attributes[e] = t;
                    var i = t.get("stateSetID");
                    void 0 !== i && (this._materialByStateSetID[i] = t)
                },
                addMaterial: function (e) {
                    var t = new cr,
                        i = this.getImageCollection();
                    return t.setMaterialJSON(e, i), new Ar({
                        model: t
                    }), this.setNewMaterial(e.id, t), t
                },
                getMaterials: function () {
                    return this.attributes
                },
                getMaterialStateID: function (e) {
                    if (void 0 !== e._materialID) return e._materialID;
                    var t = e.getUserData();
                    if (t)
                        for (var i = t.length - 1; i >= 0; --i)
                            if ("UniqueID" === t[i].Name) {
                                e._materialID = parseInt(t[i].Value, 10);
                                break
                            }
                    return void 0 === e._materialID && (void 0 !== e._uniqueID ? e._materialID = e._uniqueID : (g.Z.osg.warn("v0 StateSet detected"), this.createMaterialStateId(e))), e._materialID
                },
                createMaterialStateId: function (e) {
                    for (e._materialID = Pr++; this._materialByStateSetID[e._materialID];) e._materialID = Pr++;
                    return e._materialID
                },
                getMaterialByStateSetID: function (e) {
                    return void 0 !== e ? this._materialByStateSetID[e] : void 0
                },
                getMaterialByStateSet: function (e) {
                    return this.getMaterialByStateSetID(this.getMaterialStateID(e))
                },
                _getChannel: function (e, t) {
                    var i = this.getMaterialByStateSetID(e);
                    if (!i) return "Unknown material for id" + e;
                    var n = i.get("channels")[t];
                    return n && n.changeTexCoordTransform ? n : "Couldn't find channel " + t + " or it doesn't have a texture"
                },
                setUVOffset: function (e, t, i, n) {
                    var r = this._getChannel(e, t);
                    if (r.length) return r;
                    var a = r.getOrCreateUVTransforms();
                    a.offset = Er.vec2.fromValues(i, n), r.set("UVTransforms", a), r.changeTexCoordTransform()
                },
                setUVRotation: function (e, t, i) {
                    var n = this._getChannel(e, t);
                    if (n.length) return n;
                    var r = n.getOrCreateUVTransforms();
                    r.rotation = i, n.set("UVTransforms", r), n.changeTexCoordTransform()
                },
                setUVScale: function (e, t, i, n) {
                    var r = this._getChannel(e, t);
                    if (r.length) return r;
                    var a = r.getOrCreateUVTransforms();
                    a.scale = Er.vec2.fromValues(i, n), r.set("UVTransforms", a), r.changeTexCoordTransform()
                },
                _deleteMaterialById: function (e) {
                    var t = this.attributes[e];
                    t && delete this._materialByStateSetID[t.get("stateSetID")], delete this.attributes[e]
                },
                removeMaterialByStateSetID: function (e) {
                    var t = this.attributes;
                    for (var i in t) t[i].get("stateSetID") === e && this._deleteMaterialById(i)
                },
                removeMaterialByStateSet: function (e) {
                    var t = this.attributes;
                    for (var i in t) {
                        if (t[i].get("stateSet") === e) return void this._deleteMaterialById(i)
                    }
                },
                removeUnboundMaterial: function () {
                    var e = this.attributes;
                    for (var t in e) {
                        e[t].get("stateSet") || this._deleteMaterialById(t)
                    }
                },
                getMaxUvCount: function () {
                    var e = this.attributes,
                        t = 0;
                    for (var i in e) {
                        var n = e[i];
                        if (!n.get("uidUniqueMerged")) {
                            var r = n.get("texCoordUnitList").length;
                            r > t && (t = r)
                        }
                    }
                    return t
                },
                createMaterial: function (e, t) {
                    void 0 === t && (t = e.getOrCreateStateSet());
                    var i = new cr;
                    new Ar({
                        model: i
                    });
                    var n = Rr();
                    return i.set("id", n), i.set("stateSetID", this.getMaterialStateID(t)), i.set("name", this.getUniqueMaterialName(t.getAttributeMap().Material, t, e)), this.setNewMaterial(n, i), i
                },
                makeMaterial: function (e) {
                    var t = new cr;
                    e && (t.setMaterialJSON(e, this.getImageCollection()), void 0 !== e.vertexColorEnable && t.set("vertexColorEnable", e.vertexColorEnable), void 0 !== e.vertexColorColorSpace && t.set("vertexColorColorSpace", e.vertexColorColorSpace), void 0 !== e.vertexColorAlphaEnable && matematerialModelrial.set("vertexColorUseAlpha", e.vertexColorEnable)), new Ar({
                        model: t
                    });
                    var i = new Er.StateSet;
                    i.setAttribute(new wr.Z), t.setStateSet(i);
                    var n = Rr();
                    return t.set("id", n), t.set("stateSetID", this.createMaterialStateId(i)), t.set("name", this.getUniqueMaterialName(i.getAttributeMap().Material, i, t)), this.setNewMaterial(n, t), (new rr.Z).setMaterialModel(t), t.trigger("apply"), this.trigger("addMaterial", t), U.Z.draw(), t
                },
                destroyMaterial: function (e) {
                    var t = this.get(e).get("stateSetID");
                    void 0 !== t && delete this._materialByStateSetID[t], this.unset(e)
                },
                assignMaterial: function (e, t) {
                    var i = this.get(t);
                    i ? e.setStateSet(i.getStateSet()) : console.error("Unknown material", t)
                },
                getUniqueMaterialName: function (e, t, i) {
                    var n = this._materialNames,
                        r = e && e.getAttribute() ? e.getAttribute().getName() : void 0;
                    return void 0 === r && (r = void 0 !== t.getName() ? t.getName() : i.getName()), void 0 === r ? "material_" + n.material_++ : (void 0 === n[r] ? n[r] = 0 : r += "_" + n[r]++, r)
                },
                setWorkFlowMetalSpec: function (e, t) {
                    var i = this.attributes;
                    for (var n in i) i[n].setWorkFlowMetalSpec(e, t)
                },
                setWorkFlowRoughGloss: function (e, t) {
                    var i = this.attributes;
                    for (var n in i) i[n].setWorkFlowRoughGloss(e, t)
                },
                overrideMaterialChannels: function (e) {
                    if (!(0, o.Z)() && e.materialShowcase) {
                        var t = e.materialDisplacement,
                            i = e.materialDisplacementFactor,
                            n = e.materialNormal,
                            r = e.materialDiffuse,
                            a = e.materialMetalness,
                            s = e.materialRoughness,
                            l = e.materialGlossiness,
                            u = e.materialSpecular,
                            c = e.materialEmissive,
                            h = e.materialTransparency,
                            d = e.materialCavity,
                            g = e.materialAO,
                            f = e.materialF0,
                            m = (e.materialNames || "main_material").split(";");
                        if (e.substanceDisplacement && void 0 !== t) {
                            var p = this.attributes["ae605e73-2987-4b0f-b25b-bdf1dc02e6ed"];
                            p || (p = (0, nr.Z)(this.attributes, (function (e) {
                                return "Sides" === e.get("name")
                            }))), p && this._replaceChannelURL(p.getChannels(), "Displacement", t, !0, i)
                        }
                        for (var v in this.attributes) {
                            var _ = this.attributes[v];
                            if (-1 !== m.indexOf(_.get("name"))) {
                                var S = _.getChannels();
                                r && (this._replaceChannelURL(S, "DiffuseColor", r), this._replaceChannelURL(S, "AlbedoPBR", r), this._replaceChannelURL(S, "DiffusePBR", r)), void 0 !== f && (f.length ? this._replaceChannelURL(S, "SpecularF0", f) : (S.SpecularF0.reset(), S.SpecularF0.setFactor(.5))), void 0 !== n && this._replaceChannelURL(S, "NormalMap", n, !0), void 0 !== t && this._replaceChannelURL(S, "Displacement", t, !0, i), void 0 !== d && this._replaceChannelURL(S, "CavityPBR", d, !0), void 0 !== c && this._replaceChannelURL(S, "EmitColor", c, !0), void 0 !== h && this._replaceChannelURL(S, "Opacity", h, !0), void 0 !== g && (this._replaceChannelURL(S, "AOPBR", g, !0), this._replaceChannelURL(S, "DiffuseIntensity", g, !0)), (u || a) && (this._replaceChannelURL(S, "SpecularPBR", u), this._replaceChannelURL(S, "MetalnessPBR", a), _.setWorkFlowMetalSpec(Boolean(a))), (s || l) && (this._replaceChannelURL(S, "RoughnessPBR", s), this._replaceChannelURL(S, "GlossinessPBR", l), _.setWorkFlowRoughGloss(Boolean(s)))
                            }
                        }
                    }
                },
                enforceWorkflowPerMaterial: function () {
                    var e = this.attributes;
                    for (var t in e) e[t].enforceWorkflow()
                },
                _replaceChannelURL: function (e, t, i, n, r) {
                    var a = e[t];
                    if (i && i.length) {
                        var o = this.getImageCollection().addNewImage({
                            url: i,
                            name: i,
                            width: 1,
                            height: 1
                        });
                        a.setupTextureModel({
                            image: o
                        }), n && a.setEnable(!0), a.setFactor(void 0 === r ? 1 : r)
                    } else a.setEnable(!1)
                },
                tagMaterialWithGeometryInfo: function (e, t) {
                    var i = new Or(this, t);
                    e.accept(i)
                },
                updateTexCoordUnitList: function () {
                    var e = this.attributes;
                    for (var t in e) e[t].updateTexCoordUnitList()
                },
                findFirstMaterial: (Dr = new Nr, function (e) {
                    var t = e.length,
                        i = e[t - 1];
                    if (i._mostInfluencedRig) return Dr.reset(), Dr.setManager(this), i._mostInfluencedRig.accept(Dr), Dr._material;
                    for (var n = t - 1; n >= 0; --n) {
                        var r = e[n].getStateSet();
                        if (r) {
                            var a = this.getMaterialByStateSet(r);
                            if (a) return a
                        }
                    }
                }),
                getJSON: function () {
                    var e = {},
                        t = this.attributes;
                    for (var i in t) e[i] = t[i].getJSON();
                    return e
                },
                editorGetJSON: function () {
                    var e = {},
                        t = this.getImageCollection(),
                        i = this.getMatcapCollection();
                    for (var n in this.attributes) {
                        var r = this.attributes[n].getJSON(),
                            a = r.channels;
                        for (var o in a) {
                            var s = a[o];
                            if (s.texture) {
                                var l = ("Matcap" === o ? i : t).get(s.texture.uid).get("name");
                                s.texture.name = l, delete s.texture.uid, delete s.texture.texCoordUnit, delete s.texture.textureTarget
                            }
                        }
                        e[n] = {
                            shadeless: r.shadeless,
                            name: r.name,
                            cullFace: r.cullFace,
                            reflection: r.reflection,
                            channels: a
                        }
                    }
                    return e
                },
                editorSetJSON: function (e) {
                    var t = this.getImageCollection(),
                        i = this.getMatcapCollection(),
                        n = function (e, n) {
                            for (var r = [], a = 0, o = Mi.Z.length; a < o; a++) {
                                var s = Mi.Z[a],
                                    l = e.channels[s];
                                if (l && l.texture && l.texture.name) {
                                    var u = ("Matcap" === s ? i : t).where({
                                        name: l.texture.name
                                    })[0];
                                    u ? l.texture.uid = u.getUID() : (e.channels[s] = void 0, r.push("texture " + l.texture.name + " not found in the current scene, skipping channel " + s + " for material " + n.get("name")))
                                }
                            }
                            var c = n.setMaterialJSON(e, t, {
                                validate: !0
                            });
                            return c ? d().reject(c) : d().resolve(r)
                        },
                        r = [];
                    for (var a in this.attributes) {
                        var o = e[a];
                        o && r.push(n(o, this.attributes[a]))
                    }
                    return d().all(r)
                }
            });
            Ir.createMaterialModel = function (e) {
                var t = new cr;
                new Ar({
                    model: t
                });
                var i = e.getName();
                return i && t.set("name", i), (new rr.Z).setMaterialModel(t), t.setStateSet(e), t
            };
            const Fr = Ir;
            var Lr = {
                FeatureName: "material",
                ModelType: Fr.extend({
                    _textureTrashbin: [],
                    _matcapTrashbin: [],
                    getName: function () {
                        return "Material"
                    }
                }),
                ViewListType: [er]
            },
                Vr = n.Z.create(Lr);
            Vr.prototype.getSceneLights = function () {
                return this._views[0].getSceneLights()
            };
            const Br = Vr;
            var Ur = a.Z.extend({
                initialize: function () {
                    a.Z.prototype.initialize.apply(this, arguments), this._wireframeSchema = this.getSubSchema("wireframe");
                    var e = this.getInstance(this._wireframeSchema);
                    this.set("wireframeEnable", e.enable), this.set("wireframeColor", e.color)
                },
                getModelOptionPath: function () {
                    return "shading"
                },
                defaults: function () {
                    return {
                        hasWireframe: !0,
                        hasVertexColor: !1,
                        hasVertexAlpha: !1,
                        hasPoints: !1,
                        hasLines: !1,
                        hasTriangles: !1,
                        webVR: !1
                    }
                },
                getName: function () {
                    return "ShadingStyle"
                },
                init: function (e) {
                    this.set("hasWireframe", !!e.getScene().getWireframeSize()), this.set("vertexColorUseAlpha", (0, vi.Z)()), this.set("vertexColorColorSpace", (0, vi.Z)() ? "srgb" : "linear"), this.set("pointSize", (0, vi.Z)() ? 2 : 0);
                    var t = e.getModel().get("options"),
                        i = t.shading,
                        n = t.wireframe;
                    i && this.setJSON({
                        shading: i,
                        wireframe: n
                    }), (0, vi.Z)() && L.Z.getMaterial().then(function () {
                        var t = e.getFeatures().material.getModel();
                        this.set("renderer", "pbr", {
                            copyChannel: !0,
                            overrideTexture: !1
                        }), t._style && this.set("type", t._style)
                    }.bind(this))
                },
                setWireframeColorSmooth: function (e) {
                    this.trigger("setWireframeColorSmooth", e)
                },
                setWireframeJSON: function (e, t) {
                    if (t && t.validate) {
                        var i = this.validate(e, {
                            schema: this._wireframeSchema
                        });
                        if (i.length) return i.join("\n")
                    }
                    return void 0 !== e.enable && this.set("wireframeEnable", e.enable), e.color && e.enable && this.set("wireframeColor", e.color), []
                },
                setJSON: function (e, t) {
                    var i = a.Z.prototype.setJSON.call(this, e.shading, t),
                        n = this.setWireframeJSON(e.wireframe, t);
                    return i.concat(n), i
                },
                getJSON: function () {
                    return {
                        shading: a.Z.prototype.getJSON.call(this),
                        wireframe: {
                            enable: this.get("wireframeEnable"),
                            color: this.get("wireframeColor")
                        }
                    }
                },
                editorGetJSON: function () {
                    return this.getJSON()
                },
                editorSetJSON: function (e) {
                    return this.setJSON(e, {
                        validate: !0
                    })
                }
            });
            const kr = Ur;
            var Zr, Hr = g.Z.osg,
                Gr = V.Z.extend({
                    initialize: function (e) {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var t = this.model;
                        t.bind("change:webVR", this.onWebVRChanged, this), t.bind("change:renderer", this.onRendererChanged, this), t.bind("change:type", this.onShadingChanged, this), t.bind("change:pointSize", this.onPointSizeChanged, this), t.bind("change:wireframeEnable", this.onWireframeEnableChanged, this), t.bind("change:wireframeColor", this.onWireframeColorChanged, this), t.bind("change:vertexColorEnable", this.onVertexColorChanged, this), t.bind("change:vertexColorUseAlpha", this.onVertexColorChanged, this), t.bind("change:vertexColorColorSpace", this.onVertexColorChanged, this), t.bind("setWireframeColorSmooth", this.onSetWireframeColorSmooth, this), this._viewer = e.context.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._rootStateSet = this._viewerOSGJS.getSceneData().getOrCreateStateSet(), this._rootStateSet.setShaderGeneratorName(this.getCompilerName()), this.updateShadingGlobal(), this._wireframeNodes = e.context.getScene().getWireframeNodes(), L.Z.getPolygon().then(function () {
                            this.model.set("hasVertexColor", rr.Z.hasVertexColor), this.model.set("hasVertexAlpha", rr.Z.hasVertexAlpha), !1 === rr.Z.hasVertexColor && this.model.set("vertexColorEnable", !1), !1 === rr.Z.hasVertexAlpha && this.model.set("vertexColorUseAlpha", !1), this.onVertexColorChanged(), this.model.set("hasPoints", f.Z.hasPoints), this.model.set("hasTriangles", f.Z.hasTriangles), this.model.set("hasLines", f.Z.hasLines)
                        }.bind(this)), J.Z.getBoxReady().then(this.onPointSizeChanged.bind(this)), L.Z.getWireframeOptimizedSplit().then(this.initWireframe.bind(this)), this._viewer.bind("resizeRatio", this.updatePointSize, this), L.Z.getMaterial().then(function () {
                            this._viewer.getFeatures().camera.getModel().bind("change:fov", this.onPointSizeChanged, this)
                        }.bind(this))
                    },
                    onWebVRChanged: function () {
                        for (var e = this._wireframeNodes, t = 0, i = e.length; t < i; ++t) e[t].getStateSet().setRenderBinVR(this.model.get("webVR"))
                    },
                    updatePointSize: function () {
                        var e = this._viewer.getFeatures(),
                            t = this._viewer.getFeaturesManager(),
                            i = J.Z.getModelBoxWithDisplacement().radius();
                        i *= this.model.get("pointSize"), i *= 45 / e.camera.getModel().get("fov"), i *= 75e-5 * t.getViewport3d().height(), yr.cachedSquarePoint.setPointSize(i), yr.cachedCirclePoint.setPointSize(i)
                    },
                    onPointSizeChanged: function () {
                        this.updatePointSize(), U.Z.draw()
                    },
                    initWireframe: function () {
                        var e = !0 === this.model.get("wireframeEnable") ? Pe.Z.NO_PICK_NO_SHADOW : 0;
                        this.setWireframeNodesMask(e);
                        var t = this.setWireframeNodesMask.bind(this, 0);
                        yi.Z.updateCallback.setFinishCallback(t), this.onWireframeColorChanged(), this.model.get("wireframeEnable") && this.onWireframeEnableChanged()
                    },
                    setWireframeNodesMask: function (e) {
                        for (var t = this._wireframeNodes, i = 0, n = t.length; i < n; ++i) t[i].setNodeMask(e);
                        Kn.setWireframe(0 !== e)
                    },
                    getCompilerName: function () {
                        var e = this.model.get("type");
                        return "matcap" === e || "inspector" === e ? e : e + "-" + this.model.get("renderer")
                    },
                    updateShadingGlobal: function () {
                        var e, t = this.model.get("type"),
                            i = "pbr" === this.model.get("renderer");
                        e = "matcap" === t ? bi.Z.MATCAP : "inspector" === t ? bi.Z.INSPECTOR : "shadeless" === t ? i ? bi.Z.PBR_SHADELESS : bi.Z.CLASSIC_SHADELESS : i ? bi.Z.PBR_LIT : bi.Z.CLASSIC_LIT, bi.Z.set("mask", e)
                    },
                    _overrideChannelTexture: function (e, t, i) {
                        e.getTextureModel() ? !i && t.getTextureModel() || t.setTextureModel(e.getTextureModel().clone()) : !t.getTextureModel() && t.setColor && e.getColor && t.setColor(e.getColor())
                    },
                    copyChannels: function (e, t, i) {
                        var n = {
                            DiffusePBR: "DiffuseColor",
                            AlbedoPBR: "DiffuseColor",
                            AOPBR: "DiffuseIntensity"
                        };
                        for (var r in n) {
                            var a = t.getChannels(),
                                o = a[r],
                                s = a[n[r]];
                            if ("pbr" !== e) {
                                var l = t.isWorkflowMetalness();
                                (l && "DiffusePBR" !== r || !l && "AlbedoPBR" !== r) && this._overrideChannelTexture(o, s, i)
                            } else this._overrideChannelTexture(s, o, i)
                        }
                    },
                    onRendererChanged: function (e, t, i) {
                        this.onShadingChanged();
                        var n = this.model.get("renderer"),
                            r = void 0 === i.copyChannel || i.copyChannel,
                            a = void 0 === i.overrideTexture || i.overrideTexture,
                            o = this._viewer.getFeatures().material;
                        if (o) {
                            var s = o.getModel().attributes;
                            if (r)
                                for (var l in s) this.copyChannels(n, s[l], a);
                            U.Z.draw()
                        } else Hr.error("The renderer has been changed before the material feature is initialized")
                    },
                    onShadingChanged: function () {
                        this.updateShadingGlobal(), this._rootStateSet.setShaderGeneratorName(this.getCompilerName()), U.Z.draw()
                    },
                    onWireframeColorChanged: function () {
                        for (var e = this._wireframeNodes, t = 0, i = e.length; t < i; ++t) e[t].getStateSet().setWireframeColor(this.getRGBA())
                    },
                    onSetWireframeColorSmooth: function (e) {
                        var t = this.model;
                        t.off("change:wireframeColor", this.onWireframeColorChanged, this), t.set("wireframeColor", e), t.bind("change:wireframeColor", this.onWireframeColorChanged, this);
                        for (var i = this._wireframeNodes, n = 0, r = i.length; n < r; ++n) i[n].getStateSet().setWireframeColorSmooth(this.getRGBA());
                        t.off("change:wireframeColor", this.onWireframeColorChanged, this), t.set("wireframeColor", e), t.on("change:wireframeColor", this.onWireframeColorChanged, this)
                    },
                    onWireframeEnableChanged: function () {
                        this.setWireframeNodesMask(Pe.Z.NO_PICK_NO_SHADOW);
                        for (var e = this._wireframeNodes, t = this.model.get("wireframeEnable"), i = 0, n = e.length; i < n; ++i) e[i].getStateSet().setWireframeEnable(t, this.getRGBA())
                    },
                    getRGBA: (Zr = Hr.vec4.create(), function (e) {
                        var t = e || this.model.get("wireframeColor");
                        return Zr[0] = parseInt(t.substr(0, 2), 16) / 255, Zr[1] = parseInt(t.substr(2, 2), 16) / 255, Zr[2] = parseInt(t.substr(4, 2), 16) / 255, Zr[3] = parseInt(t.substr(6, 2), 16) / 255, Zr
                    }),
                    _inspectorForceAlpha: function () {
                        var e = this._viewer.getFeatures().inspector.getModel();
                        return "Default" !== e.get("displayView") && -1 !== e.get("availableDisplayView").indexOf("VertexAlpha")
                    },
                    onVertexColorChanged: function () {
                        var e = this._viewer.getFeatures().material;
                        if (e) {
                            var t = this.model.get("vertexColorEnable"),
                                i = this.model.get("vertexColorColorSpace"),
                                n = this.model.get("vertexColorUseAlpha") && (this._inspectorForceAlpha() || t),
                                r = e.getModel().attributes;
                            for (var a in r) {
                                var o = r[a];
                                o.set("vertexColorEnable", t && o.get("hasVertexColor")), o.set("vertexColorColorSpace", i);
                                var s = n && o.get("hasVertexAlpha");
                                o.set("vertexAlphaEnable", s)
                            }
                            U.Z.draw()
                        }
                    }
                });
            var zr = {
                FeatureName: "shadingStyle",
                ModelType: kr,
                ViewListType: [Gr]
            };
            const Wr = n.Z.create(zr);
            var jr = i("R2Pi"),
                Xr = g.Z.osg;
            const Yr = Zn.Z.extend({
                defaults: function () {
                    var e = 1;
                    return jr.default.any ? e = 0 : (0, o.Z)() && (e = 2), this._deferReady = (0, bt.Z)(), {
                        promiseReady: this._deferReady.promise,
                        level: e,
                        maxQuality: !1,
                        dynamicResolutionScaling: Xr.vec2.fromValues(1, 1)
                    }
                },
                getBudget: function () {
                    var e = (0, l.Z)();
                    return void 0 !== e.pixelBudget ? e.pixelBudget < 0 ? 1 / 0 : e.pixelBudget : this.getBudgetFromLevel(this.get("level"))
                },
                getBudgetFromLevel: function (e) {
                    return 0 === e ? 6144 : 1 === e ? 12288 : 1 / 0
                },
                getName: function () {
                    return "Quality"
                }
            });
            var Jr = i("N8nW"),
                qr = i("YxXF"),
                Kr = g.Z.osg.Timer.instance(),
                Qr = (0, l.Z)().drs ? (0, l.Z)().drsRatio : 0,
                $r = (0, l.Z)().drsMin,
                ea = 1e3 / (0, l.Z)().drsFps,
                ta = 1e3 / 55,
                ia = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.options.context;
                        this._viewer = e.getViewer(), this._fMaterial = e.getFeatures().material, this._version = e.getModel().get("options").version, this.model.bind("change:level", this.onLevelChanged, this), this.model.bind("updateTexelPolicy", this.updateTexelPolicy, this), this.model.bind("updateDynamicResolutionScaling", this._updatePixelRatio.bind(this)), this._maxSize = (0, Jr.Z)(), this._resumeDrs = 1, this._resumeQuality = 1, this._resumeAfterSSAA = !0, this._drsTest = (0, l.Z)().drsTest, this._lastTickIncreaseDrs = 0, this._lastTickIncreasePP = 0, this._continuousDrs = 0, this._continuousQuality = 0, L.Z.getFirstCameraAnimation().then(this.initTimers.bind(this))
                    },
                    initTimers: function () {
                        this._lastTick = Kr.tick(), this._viewer.getRootScene().addUpdateCallback(this)
                    },
                    _updatePixelRatio: function () {
                        var e = this.model.get("dynamicResolutionScaling"),
                            t = this._viewer.getViewerOSGJS().getCanvasPixelRatio(),
                            i = this._viewer.getInputManager().getParam("pixelRatio");
                        i[0] = t * e[0], i[1] = t * e[1]
                    },
                    _forceFullRes: function () {
                        if (this.model.get("maxQuality")) return !0;
                        var e = this._viewer.getSuperSample();
                        return !(!e.isEnabled() && !e.isFakeEnabled()) || !!this._viewer.getFeatures().webVR.getModel().get("enable")
                    },
                    _sceneBeingDrawn: function () {
                        return this._viewer.getFeatures().postProcess.getCamera().getNodeMask()
                    },
                    _handleQualitySSAA: function () {
                        var e = this._viewer.getFeatures().postProcess.getModel(),
                            t = this.model.get("dynamicResolutionScaling");
                        if (this._forceFullRes()) {
                            if (this._resumeAfterSSAA) return !0;
                            this._resumeQuality = e.getQuality(), this._resumeDrs = t[0], t[0] = 1;
                            var i = this.model.get("maxQuality") ? 1.01 : Math.max(.5, .3 + this._resumeQuality);
                            return e.setQuality(i), this._resumeAfterSSAA = !0, !0
                        }
                        return !this._sceneBeingDrawn() || !!this._resumeAfterSSAA && (this._resumeAfterSSAA = !1, t[0] = this._resumeDrs, e.setQuality(this._resumeQuality), this._continuousQuality = this._resumeQuality, this._continuousDrs = this._resumeDrs, !0)
                    },
                    _updateQuality: function (e, t) {
                        if (!this._handleQualitySSAA()) {
                            var i = e - t,
                                n = this._viewer.getFeatures().postProcess.getModel(),
                                r = this.model.get("dynamicResolutionScaling"),
                                a = (ea - i) / ea;
                            this._continuousDrs = this._continuousDrs + this._continuousDrs * Qr * a, this._continuousDrs = Math.min(1, Math.max($r, this._continuousDrs));
                            var o = Math.min(1, 1.2 * r[0]);
                            if (this._continuousDrs < r[0] ? (r[0] = this._continuousDrs, this._lastTickIncreaseDrs = e) : this._continuousDrs >= o && e - this._lastTickIncreaseDrs > 500 && (r[0] = o, this._lastTickIncreaseDrs = e), this._drsTest) {
                                this._drsTest++, r[0] = this._drsTest % 200 > 100 ? 1 : .3, U.Z.draw()
                            }
                            var s = (ta - i) / ta;
                            this._continuousQuality = Math.min(Math.max(0, this._continuousQuality + s), 1);
                            var l = n.getQuality(),
                                u = Math.min(1, l + .2),
                                c = Math.max(0, l - .2);
                            e - this._lastTickIncreasePP > 500 && (this._continuousQuality < c ? (n.setQuality(c), this._lastTickIncreasePP = e) : this._continuousQuality >= u && (n.setQuality(u), this._lastTickIncreasePP = e))
                        }
                    },
                    update: function () {
                        var e = this.model.get("dynamicResolutionScaling"),
                            t = e[0],
                            i = Kr.tick();
                        return this._updateQuality(i, this._lastTick), this._lastTick = i, e[1] = e[0], t !== e[0] && this.model.trigger("updateDynamicResolutionScaling"), !0
                    },
                    getMaterials: function () {
                        return this._fMaterial.getModel().attributes
                    },
                    onLevelChanged: function () {
                        this.updateTexelPolicy();
                        var e = this._fMaterial._views[0].requestAllHighResTextures(this._fMaterial.getModel().attributes);
                        this._viewer.setFakeSecondaryProgress(e, "texture"), this._fMaterial._views[0].cleanAndApplyMaterials()
                    },
                    getOrCreateTexelInfos: function () {
                        return this._fMaterial._views[0].getOrCreateTexelInfos()
                    },
                    getMaxSizeFromBudget: function (e) {
                        var t = e * e,
                            i = this.getOrCreateTexelInfos();
                        if (0 === i.gpuTextureCount || i.gpuPixelCount <= t) return this._maxSize;
                        var n = Math.min(this._maxSize, Math.sqrt(t / i.gpuTextureCount));
                        return n = qr.Z.snapToPowerOf2(n, .75), this._version < 2 && (n < 1024 ? n = 512 : n >= 1024 && n < 2048 && (n = 2048)), i.max <= n || i.gpuPixelCount <= n * n ? this._maxSize : n
                    },
                    _printErrorMissingResolution: function (e) {
                        var t = Object.keys(e.missingTextures).length;
                        if (0 === t) return 0;
                        var i = "",
                            n = e.missingTextures;
                        for (var r in n) i += "\n" + r + " (" + n[r].join(", ") + ")";
                        return console.error("Multi-resolution textures missing : " + t + i), t
                    },
                    updateTexelPolicy: function () {
                        if ((0, l.Z)().imageCompression) {
                            var e = this.getOrCreateTexelInfos(),
                                t = this._printErrorMissingResolution(e);
                            0 === e.gpuTextureCount || t >= e.gpuTextureCount || (this.model.get("promiseReady").isPending() && this.initAvailableTextureQuality(), (0, l.Z)().maxTextureSize = this.getMaxSizeFromBudget(this.model.getBudget()))
                        }
                    },
                    initAvailableTextureQuality: function () {
                        var e = this.getMaxSizeFromBudget(this.model.getBudgetFromLevel(0)),
                            t = this.getMaxSizeFromBudget(this.model.getBudgetFromLevel(1)),
                            i = {
                                low: !0,
                                mid: t !== e,
                                high: t !== this._maxSize
                            },
                            n = this.model.get("level");
                        i.high || 2 !== n || (n = 1), i.mid || 1 !== n || (n = 0), 1 === n && (i.low = !1), this.model.off(null, this.onLevelChanged, this), this.model.set("level", n), this.model.on("change:level", this.onLevelChanged, this), this.model._deferReady.resolve(i)
                    }
                });
            var na = {
                FeatureName: "quality",
                ModelType: Yr,
                ViewListType: [ia]
            },
                ra = n.Z.create(na);
            ra.prototype.prepareForScreenShot = function () {
                this._model.set("maxQuality", !0)
            }, ra.prototype.resetAfterScreenShot = function () {
                this._model.set("maxQuality", !1)
            };
            const aa = ra;
            const oa = ir().Model.extend({
                defaults: {
                    enable: !1,
                    paused: !1,
                    speed: .6
                },
                getName: function () {
                    return "Autospin"
                },
                init: function () {
                    var e = (0, l.Z)();
                    void 0 !== e.autospin && (this.set("enable", !!e.autospin), this.set("speed", e.autospin))
                }
            });
            var sa, la = g.Z.osg,
                ua = function (e, t, i) {
                    this._speed = void 0 !== e ? e : -.6, this._fadeStart = void 0 !== t ? t : 2, this._fadeEnd = void 0 !== i ? i : 2, this._enable = !0, this._rotation = 0, this._lastTime = -1, this._startTime = 0, this._endTime = 0, this._checkIfFinished = !1, this._fixedCenter = void 0
                };
            la.createPrototypeObject(ua, {
                setSpeed: function (e) {
                    this._speed = e
                },
                setFadeStart: function (e) {
                    this._fadeStart = e
                },
                setFadeEnd: function (e) {
                    this._fadeEnd = e
                },
                deactivate: function () {
                    this._enable = !1
                },
                resume: function () {
                    this._enable = !0, this._checkIfFinished = !1;
                    var e = Math.max((this._endTime - this._lastTime) / this._fadeEnd, 0);
                    this._startTime = this._lastTime - this._fadeStart * e, this._endTime = this._lastTime, U.Z.draw()
                },
                pause: function () {
                    var e = Math.min((this._lastTime - this._startTime) / this._fadeStart, 1);
                    this._endTime = this._lastTime + this._fadeEnd * e, this._checkIfFinished = !0
                },
                update: (sa = la.mat4.create(), function (e, t) {
                    if (!1 === this._enable) return !0;
                    U.Z.draw();
                    var i = t.getFrameStamp().getSimulationTime();
                    if (!0 === this._checkIfFinished && this._endTime < i) return this._enable = !1, this._checkIfFinished = !1, this._lastTime = -1, !0;
                    if (this._lastTime < 0) return this._lastTime = i, this._startTime = i, !0;
                    var n = i - this._lastTime;
                    this._lastTime = i, this._endTime > i ? this._rotation += n * la.smoothStep(0, 1, (this._endTime - i) / this._fadeEnd) : i - this._startTime < this._fadeStart ? this._rotation += n * la.smoothStep(0, 1, (i - this._startTime) / this._fadeStart) : this._rotation += n;
                    var r = e.getMatrix();
                    la.mat4.fromZRotation(r, -this._rotation * this._speed);
                    var a = e.getChildren();
                    if (a.length > 0) {
                        if (!this._fixedCenter) {
                            var o = a[0].getMinimumBound();
                            o.valid() && (this._fixedCenter = la.vec3.create(), la.vec3.copy(this._fixedCenter, o.center()))
                        }
                        var s = this._fixedCenter || a[0].getMinimumBound().center();
                        la.vec3.negate(s, s), la.mat4.fromTranslation(sa, s), la.mat4.multiply(r, r, sa), la.vec3.negate(s, s), la.mat4.fromTranslation(sa, s), la.mat4.multiply(r, sa, r)
                    }
                    return e.dirtyBound(), !0
                })
            }, "osgtestdemo2024", "UpdateCallbackAutospin");
            const ca = ua;
            var ha = g.Z.osg,
                da = g.Z.InputGroups,
                ga = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this._viewer = this.options.context.getViewer(), this._inputManager = this._viewer.getInputManager();
                        var e = this.model;
                        e.bind("change:enable", this.onEnableChanged, this), e.bind("change:paused", this.onPausedChanged, this), e.bind("change:speed", this.onSpeedChanged, this), this._nodeAutospin = new ha.MatrixTransform, this._nodeAutospin.setName("Feature - Autospin"), this._callbackAutospin = new ca(e.get("speed"), 1, 1), this._nodeAutospin.addUpdateCallback(this._callbackAutospin), !1 === e.get("enable") && this._callbackAutospin.deactivate(), Ve.Z.initAutospin(this, this.model.get("enable")), L.Z.getModelDisplayed().then(this.linkWithEvents.bind(this))
                    },
                    isOrbit: function () {
                        var e = this._viewer.getFeatures().camera;
                        return e && e.getModel().get("indexManipulator") === Ee.ORBIT
                    },
                    linkWithEvents: function () {
                        this._viewer.getFeatures().camera.getModel().bind("change:indexManipulator", this.onManipulatorChange.bind(this)), this.onManipulatorChange()
                    },
                    onManipulatorChange: function () {
                        clearTimeout(this._timerAutospin), this.model.set("paused", !this.isOrbit())
                    },
                    pause: function () {
                        clearTimeout(this._timerAutospin), this.model.set("paused", !0)
                    },
                    resume: function () {
                        if (this.isOrbit()) {
                            var e = this.model;
                            this._timerAutospin = setTimeout((function () {
                                e.set("paused", !1)
                            }), 5e3)
                        }
                    },
                    onEnableChanged: function () {
                        !0 === this.model.get("enable") ? (this._callbackAutospin.resume(), this._inputManager.setEnable(da.AUTOSPIN, !0)) : (this._callbackAutospin.deactivate(), this._inputManager.setEnable(da.AUTOSPIN, !1))
                    },
                    onPausedChanged: function () {
                        !1 !== this.model.get("enable") && (!0 === this.model.get("paused") ? this._callbackAutospin.pause() : this._callbackAutospin.resume())
                    },
                    onSpeedChanged: function () {
                        this._callbackAutospin.setSpeed(this.model.get("speed"))
                    }
                });
            var fa = {
                FeatureName: "autospin",
                ModelType: oa,
                ViewListType: [ga]
            },
                ma = n.Z.create(fa);
            ma.prototype.getNode = function () {
                return this._views[0]._nodeAutospin
            };
            const pa = ma;
            var va = g.Z.osg,
                _a = a.Z.extend({
                    getModelOptionPath: function () {
                        return "orientation"
                    },
                    defaults: {
                        showGizmo: !1
                    },
                    getName: function () {
                        return "Orientation"
                    },
                    init: function (e) {
                        this.setJSON(e.getModel().get("options").orientation);
                        var t = (0, l.Z)().scale,
                            i = this.get("matrix");
                        1 !== t && va.mat4.scale(i, i, va.vec3.fromValues(t, t, t))
                    },
                    editorGetJSON: function () {
                        return this.getJSON()
                    },
                    editorSetJSON: function (e) {
                        return this.setJSON(e, {
                            validate: !0
                        })
                    }
                });
            const Sa = _a;
            var xa = g.Z.osg,
                Ca = function (e, t, i, n) {
                    this._model = i.model, this._manipulator = e, this._applyWithoutTranslation = !1, this._quatCurrent = xa.mat4.getRotation(xa.quat.create(), this._model.get("matrix")), this._quatTarget = xa.quat.create(), this._quatStart = xa.quat.create(), this._nodeGrid = i._nodeGrid, ct.Z.call(this, t), this._finished = !0, this._nodeGizmo = i._nodeGizmo, this._gizmoTra = i._gizmoTra, this._gizmoMode = !1, this._rootModel = n, this._nodeOrientation = i._nodeOrientation, this._features = i.options.context.getFeatures(), this._viewer = i._viewer, this._scaleModel = xa.vec3.create(), this._worldCenter = xa.vec3.create(), this._negateLocalCenter = xa.vec3.create(), J.Z.getBoxReady().then(this.initModelBound.bind(this))
                };
            xa.createPrototypeObject(Ca, xa.objectInherit(ct.Z.prototype, {
                setQuatTarget: function (e) {
                    xa.quat.copy(this._quatStart, this._quatCurrent), xa.quat.copy(this._quatTarget, e), this.reset(), this._gizmoMode = !1
                },
                initModelBound: function () {
                    var e = J.Z.getModelBoxWithoutDisplacement();
                    e.center(this._worldCenter);
                    var t = this._rootModel.getMinimumBound();
                    xa.vec3.negate(this._negateLocalCenter, t.center());
                    var i = e.radius();
                    xa.vec3.set(this._scaleModel, i, i, i), this._nodeGizmo.getMatrix()[14] -= .51 * (e.getMax()[2] - e.getMin()[2])
                },
                setGizmoMode: function (e) {
                    this._gizmoMode = e, this.rotateNode(this._nodeOrientation)
                },
                getQuatTarget: function () {
                    return this._quatTarget
                },
                getQuatStart: function () {
                    return this._quatStart
                },
                update: function (e, t) {
                    if (this._gizmoMode) {
                        xa.mat4.getRotation(this._quatCurrent, this._nodeGizmo.getMatrix()), this.rotateNode(e);
                        var i = this._viewer.getFeaturesManager().getNodeGizmo();
                        return this._editing && !i.isEditing() && this._model.trigger("orientationDirty"), this._editing = i.isEditing(), !0
                    }
                    if (this._finished) return !0;
                    U.Z.draw();
                    var n = t.getFrameStamp().getSimulationTime(),
                        r = this.interpolate(n, e, t);
                    if (r = xa.smoothStep(0, 1, r), xa.quat.slerp(this._quatCurrent, this._quatStart, this._quatTarget, r), this.rotateNode(e), this._finished) {
                        var a = this._nodeGizmo.getMatrix(),
                            o = a[14];
                        xa.mat4.fromQuat(a, this._quatCurrent), a[14] = o, this._gizmoMode = this._model.get("showGizmo"), this._model.trigger("orientationDirty")
                    }
                    return !0
                },
                rotateNode: function () {
                    var e = xa.mat4.create();
                    return function (t) {
                        var i = this._gizmoTra.getMatrix();
                        xa.mat4.fromTranslation(i, this._worldCenter);
                        var n = t.getMatrix();
                        xa.mat4.fromQuat(n, this._quatCurrent), xa.mat4.mul(n, i, n), xa.mat4.translate(n, n, this._negateLocalCenter);
                        var r = this._nodeGrid.getMatrix();
                        xa.mat4.scale(r, i, this._scaleModel), r[14] += this._nodeGizmo.getMatrix()[14], xa.mat4.invert(e, n), xa.mat4.mul(r, e, r), this.updateShadows(), t.dirtyBound()
                    }
                }(),
                updateShadows: function () {
                    var e = this._features.environment;
                    e && e.getNode().updateShadow();
                    var t = this._features.lighting;
                    if (t)
                        for (var i = t.getModel().get("lights"), n = 0, r = i.length; n < r; ++n) i[n].dirty()
                }
            }));
            const Ta = Ca;
            var Ma = i("kTKr");
            var ba = g.Z.osg,
                ya = function () {
                    ba.MatrixTransform.call(this), this._timeGrid = 0;
                    var e = ba.Uniform.createFloat4(ba.vec4.fromValues(.5, .5, .5, 0), "uColor");
                    this._callbackColor = new Ma.Z(e.getInternalArray(), 1), this._callbackColor.setFinishCallback(this._disableGrid.bind(this)), this.addUpdateCallback(this._callbackColor);
                    var t = this.getOrCreateStateSet();
                    t.setAttributeAndModes(Le.Z.DEPTH_LEQUAL_WRITE), t.setAttributeAndModes(Le.Z.BLEND_SUBSTRACTIVE), t.setRenderBinDetails(Oe.Z.GRID, "RenderBin"), t.addUniform(e), this._grid = ba.createGridGeometry(-1, -1, 0, 2, 0, 0, 0, 2, 0, 10, 10), this._axis = ba.createAxisGeometry(1), this.addChild(this._grid), this.addChild(this._axis), this._grid.getOrCreateStateSet().setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec3 Vertex;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex, 1.0);\n}\n", "uniform vec4 uColor;\n\nvoid main(void) {\n  gl_FragColor = vec4(uColor.xyz * uColor.a, uColor.a);\n}\n", "orientation-grid", "Grid")), this._axis.getOrCreateStateSet().setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec3 Vertex;\nattribute vec4 Color;\nvarying vec4 vColor;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n    vColor = Color;\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex, 1.0);\n}\n", "uniform vec4 uColor;\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vec4( vec3(vColor) * uColor.a, uColor.a);\n}\n", "orientation-axis", "OrientationAxis")), this._disableGrid()
                };
            ba.createPrototypeNode(ya, ba.objectInherit(ba.MatrixTransform.prototype, {
                showGridTemporary: function (e) {
                    this._grid.dirtyBound(), this._axis.dirtyBound(), this.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._callbackColor.show(), window.clearTimeout(this._timeGrid), e && (this._timeGrid = window.setTimeout(this.hideGrid.bind(this), 1e3 * e))
                },
                _invalidateNodeBound: function (e) {
                    e.dirtyBound(), e.getBoundingBox().init(), e.getBoundingSphere().init()
                },
                _disableGrid: function () {
                    this.setNodeMask(0), this._invalidateNodeBound(this._grid), this._invalidateNodeBound(this._axis), this._invalidateNodeBound(this)
                },
                hideGrid: function () {
                    this._timeGrid = 0, this._callbackColor.hide()
                }
            }), "osgtestdemo2024", "Grid");
            const Aa = ya;
            var Ra = g.Z.osg,
                wa = g.Z.osgUtil,
                Ea = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.model;
                        e.bind("change:matrix", this.onMatrixChanged, this), e.bind("change:showGizmo", this.onGizmoShowChanged, this), e.bind("turn", this.onTurn, this), e.bind("reset", this.onReset, this), e.bind("orientationDirty", this.onOrientationDirty, this);
                        var t = this.options.context;
                        this._viewer = t.getViewer(), this._nodeGrid = new Aa, this._nodeGrid.setName("Node grid"), this._nodeOrientation = new Ra.MatrixTransform, this._nodeOrientation.setName("Feature - Orientation"), this._nodeOrientation.addChild(this._nodeGrid), this._nodeGizmo = new Ra.MatrixTransform, this._nodeGizmo.setCullingActive(!1), this._nodeGizmo.editMask = wa.NodeGizmo.PICK_ARC | wa.NodeGizmo.PICK_ARROW_Z, this._gizmoTra = new Ra.MatrixTransform, this._gizmoTra.setReferenceFrame(Ra.Transform.ABSOLUTE_RF), this._gizmoTra.addChild(this._nodeGizmo);
                        var i = this.model.get("matrix");
                        this._nodeOrientation.setMatrix(i);
                        var n = Ra.mat4.getRotation(Ra.quat.create(), i);
                        Ra.mat4.fromQuat(this._nodeGizmo.getMatrix(), n);
                        var r = this._viewer.getRootModel(),
                            a = this._viewer.getViewerOSGJS().getManipulator();
                        this._callbackOrientation = new Ta(a, .5, this, r), this._nodeOrientation.addUpdateCallback(this._callbackOrientation)
                    },
                    onReset: function () {
                        var e = Ra.mat4.getTranslation(Ra.vec3.create(), this.model.get("matrix"));
                        Ra.mat4.fromTranslation(this.model.get("matrix"), e), this.onMatrixChanged()
                    },
                    onTurn: function (e, t) {
                        var i = "right" === t ? 1 : -1,
                            n = "x" === e ? i : 0,
                            r = "y" === e ? i : 0,
                            a = "z" === e ? i : 0,
                            o = Ra.mat4.fromRotation(Ra.mat4.create(), -Math.PI / 2, Ra.vec3.fromValues(n, r, a)),
                            s = this.model.get("matrix");
                        Ra.mat4.multiply(s, o, s), this.onMatrixChanged()
                    },
                    onGizmoShowChanged: function () {
                        var e = this.model.get("showGizmo"),
                            t = this._viewer.getFeaturesManager();
                        if (t) {
                            var i = t.getNodeGizmo();
                            if (i) {
                                var n = this._nodeGizmo.getMatrix(),
                                    r = n[14];
                                Ra.mat4.copy(n, this.model.get("matrix")), n[12] = 0, n[13] = 0, n[14] = r, i.setForcePicking(e), i.setRotateInLocal(!e), i.setTranslateInLocal(!e), i.attachToNode(e ? this._nodeGizmo : null), this._nodeGrid.showGridTemporary(e ? 0 : 2.5), this._callbackOrientation.setGizmoMode(e)
                            }
                        }
                    },
                    onMatrixChanged: function () {
                        this.model.get("showGizmo") || this._nodeGrid.showGridTemporary(2.5), this._callbackOrientation.setQuatTarget(Ra.mat4.getRotation(Ra.quat.create(), this.model.get("matrix")))
                    },
                    onOrientationDirty: function () {
                        var e = this.options.context.getFeatures().orientation.getNode();
                        J.Z.computePreciseBox(e), this.model.trigger("orientationChanged")
                    },
                    getNodeGrid: function () {
                        return this._nodeGrid
                    },
                    getNodeOrientation: function () {
                        return this._nodeOrientation
                    }
                });
            var Pa = {
                FeatureName: "orientation",
                ModelType: Sa,
                ViewListType: [Ea]
            },
                Na = n.Z.create(Pa);
            Na.prototype.getNode = function () {
                return this._views[0].getNodeOrientation()
            }, Na.prototype.getWidgetNode = function () {
                return this._views[0].getNodeGrid()
            };
            const Oa = Na;
            var Da, Ia = i("k46e"),
                Fa = {
                    substancepainter: {
                        "80fba9759ab94307a782f38d359b8ea8": {
                            rotation: 1.57,
                            environmentExposure: 8.5,
                            lightIntensity: 1.5,
                            brightness: 1
                        },
                        "2e9c3708feb74137b0436f946b8b66b8": {
                            rotation: 1.6,
                            environmentExposure: 2.5,
                            lightIntensity: 2,
                            brightness: 1.12
                        },
                        "268447ca0a954f44b06d1387863d114e": {
                            rotation: 6.25,
                            environmentExposure: 1.2,
                            lightIntensity: 2.5,
                            brightness: 1
                        },
                        "3e2ad3e1f1ea47679f045a7eb0e6af49": {
                            rotation: .3,
                            environmentExposure: .59,
                            lightIntensity: 2.5,
                            brightness: 1
                        },
                        "2fa15e0b1cee45a5b02605a288934e1b ": {
                            rotation: .68,
                            environmentExposure: 2.5,
                            lightIntensity: 2.5,
                            brightness: 1
                        },
                        "9190e8da70694ef3b9d1d0c01541917e": {
                            rotation: 3.24,
                            environmentExposure: 1.7,
                            lightIntensity: 2.5,
                            brightness: .57
                        },
                        "749a0594343e4ff9a2875cb411d0ad1a": {
                            rotation: 4.73,
                            environmentExposure: .35,
                            lightIntensity: 3,
                            brightness: 1
                        },
                        f2dabeb04674446696486eea67028bd8: {
                            rotation: 4.71,
                            environmentExposure: .35,
                            lightIntensity: 3,
                            brightness: 1.5
                        },
                        df380da788ee444885722735039b0c09: {
                            rotation: .27,
                            environmentExposure: .55,
                            lightIntensity: 3,
                            brightness: 1.46
                        },
                        "16cdcddf277d423d99094f8db0c731e9": {
                            rotation: 3.73,
                            environmentExposure: 1.5,
                            lightIntensity: 2.2,
                            brightness: .53
                        },
                        c281dff366844cbc8b33179337037f42: {
                            rotation: 3.64,
                            environmentExposure: 4.5,
                            lightIntensity: 3,
                            brightness: .53
                        }
                    }
                };
            Da = {
                e871dd2920334a0f9c3107a00da3c24a: {
                    uid: "e871dd2920334a0f9c3107a00da3c24a",
                    name: "Gareoult",
                    environmentExposure: .7,
                    lightIntensity: 3
                },
                "102d22e28ca34190a8470402ccdc35d3": {
                    uid: "102d22e28ca34190a8470402ccdc35d3",
                    name: "Milkyway",
                    environmentExposure: 6.8,
                    lightIntensity: 3
                },
                cd5e5b1607d844cdb928e96ff9c36b5c: {
                    uid: "cd5e5b1607d844cdb928e96ff9c36b5c",
                    name: "QueenMary chimney",
                    environmentExposure: 7,
                    lightIntensity: 3
                },
                "8653449395004fd58820874bfff93ce7": {
                    uid: "8653449395004fd58820874bfff93ce7",
                    name: "Kirby_cove",
                    environmentExposure: .6,
                    lightIntensity: 4
                },
                "3e2ad3e1f1ea47679f045a7eb0e6af49": {
                    uid: "3e2ad3e1f1ea47679f045a7eb0e6af49",
                    name: "Gdansk shipyard buildings",
                    environmentExposure: .4,
                    lightIntensity: 3
                },
                d348dfd2a8104ab0b8528f885d645eb3: {
                    uid: "d348dfd2a8104ab0b8528f885d645eb3",
                    name: "footprint",
                    environmentExposure: 1.2,
                    lightIntensity: 5
                },
                "2fa15e0b1cee45a5b02605a288934e1b": {
                    uid: "2fa15e0b1cee45a5b02605a288934e1b",
                    name: "glazed patio by restaurant",
                    environmentExposure: 2.7,
                    lightIntensity: 3
                },
                "5335c7c5c2434866ac8a442157f24f5e": {
                    uid: "5335c7c5c2434866ac8a442157f24f5e",
                    name: "tropical ruins",
                    environmentExposure: 2,
                    lightIntensity: 3
                },
                "9190e8da70694ef3b9d1d0c01541917e": {
                    uid: "9190e8da70694ef3b9d1d0c01541917e",
                    name: "industrial room",
                    environmentExposure: 1,
                    lightIntensity: 3
                },
                df380da788ee444885722735039b0c09: {
                    uid: "df380da788ee444885722735039b0c09",
                    name: "studio",
                    environmentExposure: .8,
                    lightIntensity: 3
                },
                "4eda3e78ed214dc8852c439dc64b9c9d": {
                    uid: "4eda3e78ed214dc8852c439dc64b9c9d",
                    name: "road in dordogne",
                    environmentExposure: .6,
                    lightIntensity: 2.5
                },
                "749a0594343e4ff9a2875cb411d0ad1a": {
                    uid: "749a0594343e4ff9a2875cb411d0ad1a",
                    name: "road in tenerife mountain",
                    environmentExposure: .7,
                    lightIntensity: 3.5
                },
                c281dff366844cbc8b33179337037f42: {
                    uid: "c281dff366844cbc8b33179337037f42",
                    name: "urban exploring interior",
                    environmentExposure: 12,
                    lightIntensity: 3.3
                },
                "41192cc664484a0fa565da3361d10c9c": {
                    uid: "41192cc664484a0fa565da3361d10c9c",
                    name: "muir wood",
                    environmentExposure: .9,
                    lightIntensity: 3
                },
                "5e7120378b00431ea18151e97a8366ec": {
                    uid: "5e7120378b00431ea18151e97a8366ec",
                    name: "treasure island",
                    environmentExposure: .55,
                    lightIntensity: 3.5
                },
                e00dc642058b4176a4aaa449ea8ad5f8: {
                    uid: "e00dc642058b4176a4aaa449ea8ad5f8",
                    name: "trinitatis church",
                    environmentExposure: .6,
                    lightIntensity: 4
                },
                e2aa1ab3582c4feab7371baf1e4cd734: {
                    uid: "e2aa1ab3582c4feab7371baf1e4cd734",
                    name: "arche pinetree",
                    environmentExposure: 2.3,
                    lightIntensity: 3.5
                },
                "2a016b232e444ef3a6ba323c51aa5063": {
                    uid: "2a016b232e444ef3a6ba323c51aa5063",
                    name: "tokyo bigsight",
                    environmentExposure: 2.3,
                    lightIntensity: 3.5
                },
                "08468d6fcf9846039cc3e51accddd9f9": {
                    uid: "08468d6fcf9846039cc3e51accddd9f9",
                    name: "studio soft",
                    environmentExposure: 2.3,
                    lightIntensity: 3
                }
            };
            const La = function (e) {
                return Fa[e] || Da
            };
            var Va = i("1XKa"),
                Ba = g.Z.osg,
                Ua = {
                    uid: "9190e8da70694ef3b9d1d0c01541917e",
                    brightness: 1.6868
                },
                ka = a.Z.extend({
                    _trashbin: [],
                    getModelOptionPath: function () {
                        return "environment"
                    },
                    getRandomEnvironment: function () {
                        var e = [];
                        return this.environmentCollection.each((function (t) {
                            t.get("isDefault") && -1 === Va.Z.indexOf(t.get("uid")) && e.push({
                                uid: t.get("uid"),
                                brightness: t.get("brightness")
                            })
                        })), 0 === e.length ? Ua : e[Math.round(Math.random() * (e.length - 1))]
                    },
                    resetToDefaultEnvironment: function () {
                        return this.set("uid", Ua.uid), this.set("exposure", Ua.brightness), this
                    },
                    defaults: function () {
                        return {}
                    },
                    initDefaults: function (e) {
                        e.enable = (0, vi.Z)(), e.uid = Ua.uid, e.exposure = Ua.brightness, e.shadowEnable = (0, vi.Z)(), a.Z.prototype.initDefaults.call(this, e)
                    },
                    init: function (e) {
                        this._context = e, this._viewer = e.getViewer();
                        var t = e.getModel().get("options").environment,
                            i = void 0 === t.uid;
                        t && this.setJSON(t), this.environmentCollection = s.Z.instance.getEnvironmentCollection(), i && this.resetToDefaultEnvironment(), this.checkEnvironmentValidity(), (0, vi.Z)() ? L.Z.getPolygon().then(this.updateEnvironmentConfig.bind(this)) : L.Z.getPolygon().then(function () {
                            var e = this.getEnvironment();
                            if (e) {
                                var t = this._getYRotationFromLightDirection(e);
                                this.set("lightRotation", t)
                            } else this.checkEnvironmentValidity()
                        }.bind(this)), (0, o.Z)() && (0, l.Z)().apiLog && (console.log("------"), console.log("Viewer API environment uid list:"), this.environmentCollection.each((function (e) {
                            console.log("- " + e.get("name") + ": " + e.get("uid"))
                        })), console.log("------"))
                    },
                    _getYRotationFromLightDirection: function (e) {
                        var t = e.get("lights"),
                            i = 0;
                        if (t.length) {
                            var n = Ba.vec3.clone(t[0].direction);
                            if (Math.abs(n[1]) < .99999) {
                                n[1] = 0, Ba.vec3.normalize(n, n);
                                var r = Math.acos(n[0]);
                                i = n[2] > 0 ? r : 2 * Math.PI - r
                            }
                        }
                        return i
                    },
                    updateEnvironmentConfig: function () {
                        var e = this.getEnvironment();
                        if (e) {
                            var t = this.get("rotation"),
                                i = this.get("lightRotation"),
                                n = this._getYRotationFromLightDirection(e);
                            this.set("lightRotation", n);
                            var r = 0;
                            void 0 !== i && (r = i - n);
                            var a = 2 * Math.PI,
                                o = (a + t + r) % a,
                                s = La(this._viewer.getRootUserData().source)[e.get("uid")];
                            s ? (void 0 !== s.environmentExposure && this.set("exposure", parseFloat(s.environmentExposure)), void 0 !== s.lightIntensity && this.set("lightIntensity", parseFloat(s.lightIntensity)), void 0 !== s.brightness && this.set("backgroundExposure", parseFloat(s.brightness)), void 0 !== s.rotation && (o = parseFloat(s.rotation))) : this.set("exposure", parseFloat(e.get("brightness")) || 1), this.set("rotation", o);
                            var l = this._viewer.getRootUserData();
                            (0, vi.Z)() && "Tilt Brush" === l.authoringTool && (this.set("uid", "3e2ad3e1f1ea47679f045a7eb0e6af49"), this.set("exposure", .5))
                        } else this.checkEnvironmentValidity()
                    },
                    getEnvironmentCollection: function () {
                        return this.environmentCollection
                    },
                    checkEnvironmentValidity: function () {
                        this.getEnvironment() || (this.set("uid", Ua.uid), this.set("exposure", Ua.brightness))
                    },
                    getName: function () {
                        return "Environment"
                    },
                    getEnvironment: function () {
                        var e = this.get("uid");
                        return this.environmentCollection.find((function (t) {
                            return t.get("uid") === e
                        }))
                    },
                    isShadowEnable: function () {
                        return this.get("shadowEnable")
                    },
                    editorGetJSON: function () {
                        return this.getJSON()
                    },
                    editorSetJSON: function (e) {
                        return this.setJSON(e, {
                            validate: !0
                        })
                    }
                });
            const Za = ka,
                Ha = "#ifdef ICON\nattribute vec2 TexCoord0;\nvarying vec2 vTexCoord0;\n#endif\n\n#ifdef HEMI\nvarying vec3 vLocalVertex;\n#endif\n\nattribute vec3 Vertex;\n\nvarying vec4 vViewPos;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n#ifdef ICON\n  vTexCoord0 = TexCoord0;\n#endif\n\n#ifdef HEMI\n  vLocalVertex = Vertex;\n#endif\n\n  vViewPos = uModelViewMatrix * vec4(Vertex.xyz, 1.0);\n  gl_Position = uProjectionMatrix * vViewPos;\n}\n",
                Ga = '#pragma include "utils/functions.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\n#ifdef HEMI\nuniform vec4 uGround;\nvarying vec3 vLocalVertex;\nuniform float uRadius;\n#endif\n\n#ifdef ICON\nuniform sampler2D uTextureIcon;\nvarying vec2 vTexCoord0;\nuniform int uEnable;\n#endif\n\nvarying vec4 vViewPos;\nuniform vec2 uNearFar;\nuniform sampler2D uTextureDepth;\nuniform vec2 uGlobalTexSize;\nuniform vec2 uGlobalTexRatio;\n\nuniform vec4 uColor;\n\nvoid main(void) {\n  float distDepth = distanceToDepth(uTextureDepth, uGlobalTexRatio * gl_FragCoord.xy / uGlobalTexSize, vViewPos, uNearFar);\n  float alpha = distDepth < 0.0 ? 1.0 : 0.1;\n\n  // handles colors with values higher than 1\n  vec3 normColor = uColor.rgb / max(max(1.0, uColor.r), max(uColor.g, uColor.b));\n\n#ifdef HEMI\n  gl_FragColor = vec4(mix(uGround.rgb, normColor, vLocalVertex.z / uRadius), alpha);\n#endif\n\n#ifdef LINE\n  gl_FragColor = vec4(normColor, alpha);\n#endif\n\n#ifdef ICON\n  gl_FragColor = vec4(float(uEnable) * normColor, alpha) * texture2D(uTextureIcon, vTexCoord0);\n#endif\n\n  gl_FragColor.rgb *= gl_FragColor.a;\n\n  gl_FragColor.rgb = sRGBToLinear(gl_FragColor.rgb);\n}\n';
            var za = g.Z.osg,
                Wa = {},
                ja = function (e, t) {
                    if (Wa[e]) return Wa[e];
                    var i = e.toLowerCase();
                    return Wa[e] = Ne.Z.getOrCreateShader(Ha, Ga, i, t, e), Wa[e]
                },
                Xa = function () {
                    return ja("LINE", "LightingLineGizmo")
                },
                Ya = Le.Z.BLEND_SUBSTRACTIVE,
                Ja = {},
                qa = function (e) {
                    if (Ja[e]) return Ja[e];
                    var t = De.iconsLight[e];
                    t || (t = De.iconsLight.DIRECTION);
                    var i = s.Z.instance.getOrCreateTexture(t, {
                        internalFormat: za.Texture.RGBA
                    });
                    return Ja[e] = i.texture, i.texture
                },
                Ka = {};
            Ka.createIconGeometry = function () {
                var e = za.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0),
                    t = e.getOrCreateStateSet();
                return t.setTextureAttributeAndModes(1, qa("DIRECTION")), t.addUniform(za.Uniform.createInt(1, "uTextureIcon")), t.setAttributeAndModes(Ya), t.setAttributeAndModes(ja("ICON", "LightingIcon")), e.setLightType = function (e) {
                    t.setTextureAttributeAndModes(1, qa(e))
                }, e
            }, Ka.createDirectionalGeometry = function (e) {
                for (var t = void 0 === e ? -1 : -e, i = t / 15, n = 2 * Math.PI, r = new Float32Array(180), a = 0; a < 5; ++a) {
                    var o = 6 * a,
                        s = n * a / 5;
                    r[o] = r[o + 3] = Math.cos(s) * i, r[o + 1] = r[o + 4] = Math.sin(s) * i, r[o + 5] = t
                }
                var l = new za.DrawArrays(za.primitiveSet.LINES, 0, 30),
                    u = new za.Geometry;
                return u.getAttributes().Vertex = new za.BufferArray(za.BufferArray.ARRAY_BUFFER, r, 3), u.getPrimitives().push(l), u.getOrCreateStateSet().setAttributeAndModes(Xa()), u.getOrCreateStateSet().setAttributeAndModes(Ya), u
            }, Ka.createSpotGeometry = function (e) {
                var t = void 0 === e ? -1 : -e,
                    i = 50,
                    n = 2 * Math.PI,
                    r = new za.Geometry,
                    a = new Float32Array(300),
                    o = r.getAttributes().Vertex = new za.BufferArray(za.BufferArray.ARRAY_BUFFER, a, 3),
                    s = 0,
                    l = new Uint16Array(i);
                for (s = 0; s < i; ++s) l[s] = 2 * s + 1;
                var u = new za.DrawElements(za.primitiveSet.LINE_LOOP, new za.BufferArray(za.BufferArray.ELEMENT_ARRAY_BUFFER, l, 1)),
                    c = new Uint16Array(10);
                for (s = 0; s < 5; ++s) c[2 * s] = 20 * s, c[2 * s + 1] = 20 * s + 1;
                var h = new za.DrawElements(za.primitiveSet.LINES, new za.BufferArray(za.BufferArray.ELEMENT_ARRAY_BUFFER, c, 1));
                return r.getPrimitives().push(h, u), r.getOrCreateStateSet().setAttributeAndModes(Xa()), r.getOrCreateStateSet().setAttributeAndModes(Ya), r.updateCone = function (e, l) {
                    var u = l ? 2 * -l : t,
                        c = Math.cos(e) * u,
                        h = Math.sin(e) * u;
                    for (s = 0; s < i; ++s) {
                        var d = 6 * s,
                            g = n * s / i;
                        a[d + 3] = Math.cos(g) * h, a[d + 4] = Math.sin(g) * h, a[d + 5] = c
                    }
                    o.dirty(), r.dirtyBound()
                }, r.updateCone(.1), r
            }, Ka.createHemiGeometry = function (e) {
                for (var t = void 0 === e ? -1 : -e, i = 50, n = new za.Geometry, r = new Float32Array(450), a = Math.PI, o = 150, s = 0; s < i; ++s) {
                    var l = 3 * s,
                        u = a * s / 49,
                        c = Math.cos(u),
                        h = Math.sin(u);
                    r[l] = c * t, r[l + 2] = -h * t, r[o + l + 1] = c * t, r[o + l + 2] = -h * t, u = 2 * a * s / 49, r[300 + l] = Math.cos(u) * t, r[300 + l + 1] = Math.sin(u) * t
                }
                n.getAttributes().Vertex = new za.BufferArray(za.BufferArray.ARRAY_BUFFER, r, 3);
                var d = new za.DrawArrays(za.primitiveSet.LINE_STRIP, 0, i),
                    g = new za.DrawArrays(za.primitiveSet.LINE_STRIP, i, i),
                    f = new za.DrawArrays(za.primitiveSet.LINE_STRIP, 100, i);
                n.getPrimitives().push(d, g, f);
                var m = n.getOrCreateStateSet();
                return m.setAttributeAndModes(ja("HEMI", "LightingHemiGizmo")), m.setAttributeAndModes(Ya), m.addUniform(za.Uniform.createFloat(-t, "uRadius")), n
            }, Ka.createPointGeometry = function () {
                var e = 2 * Math.PI,
                    t = 50,
                    i = new za.Geometry,
                    n = new Float32Array(1350),
                    r = i.getAttributes().Vertex = new za.BufferArray(za.BufferArray.ARRAY_BUFFER, n, 3),
                    a = new za.DrawArrays(za.primitiveSet.LINE_STRIP, 0, t),
                    o = new za.DrawArrays(za.primitiveSet.LINE_STRIP, t, t),
                    s = new za.DrawArrays(za.primitiveSet.LINE_STRIP, 100, t);
                return i.getPrimitives().push(a, o, s), i.getOrCreateStateSet().setAttributeAndModes(Xa()), i.getOrCreateStateSet().setAttributeAndModes(Ya), i.updateRadius = function (a) {
                    for (var o = 0; o < t; ++o) {
                        var s = 3 * o,
                            l = e * o / 49;
                        n[s] = n[150 + s] = n[300 + s + 1] = Math.cos(l) * a, n[s + 1] = n[150 + s + 2] = n[300 + s + 2] = Math.sin(l) * a
                    }
                    r.dirty(), i.dirtyBound()
                }, i.updateRadius(1), i
            };
            const Qa = Ka;
            var $a, eo = i("8WLf"),
                to = i("ZmEo"),
                io = g.Z.osg,
                no = (0, l.Z)().shadow,
                ro = (0, l.Z)().shadowAtlas,
                ao = ro ? 7 : 12,
                oo = (0, l.Z)().shadowTextureSize;
            g.Z.osgShadow.ShadowMap.prototype._preventTextureBindingDuringShadowCasting = function () {
                for (var e = (0, vr.Z)(), t = io.StateAttribute.OVERRIDE_ON, i = 0; i < e; i++) this._casterStateSet.setTextureAttributeAndModes(i, io.Texture.textureNull, t)
            };
            var so, lo, uo = function (e) {
                return ($a = new g.Z.osgShadow.ShadowSettings).setLight(e), $a.setShadowCastShaderGeneratorName("shadowcast"), $a.setCastsShadowDrawTraversalMask(Pe.Z.SHADOW), $a.setCastsShadowBoundsTraversalMask(Pe.Z.SHADOW_BOUNDS), $a.userShadowCasterVisitor = !1, $a.kernelSizePCF = (0, l.Z)().shadowPCF, $a.fakePCF = !1, $a.setTextureSize((0, l.Z)().shadowTextureSize), $a
            };
            ro && ((so = uo()).atlasSize = 2 * oo, so.setTextureSize(oo), (lo = new g.Z.osgShadow.ShadowMapAtlas(so)).setTextureUnitBase(ao));
            var co = to.Z.uShadowMapSize.getInternalArray();
            co[0] = oo, co[1] = oo;
            var ho = function (e, t, i) {
                var n = new io.MatrixTransform;
                n.setName(e + " - LightNode " + t), n.getOrCreateStateSet().setAttributeAndModes(Le.Z.DEPTH_DISABLE);
                var r = new jt(t);
                i && r.setLightType(i), r.setName(e + " - Light " + t), io.vec3.copy(r.getAmbient(), io.vec3.ZERO), io.vec3.copy(r.getSpecular(), io.vec3.ZERO), r.setLinearAttenuation(0);
                var a, o, s = new io.LightSource;
                if (s.setName("skfb" + e + " - LightSource " + t), s.setLight(r), !no) return {
                    node: n,
                    light: r,
                    lightSource: s,
                    shadowSettings: lo ? so : uo(r),
                    enableShadow: !1
                };
                if (lo ? (o = so, a = lo.addLight(r)) : (o = uo(r), (a = new g.Z.osgShadow.ShadowMap(o)).setTextureUnitBase(ao), a.setContinuousUpdate(!1), a.setTextureSize((0, l.Z)().shadowTextureSize)), a.setJitterOffset((0, l.Z)().shadowJitterOffset), (0, l.Z)().stats) {
                    var u = a.getCamera(),
                        c = eo.Z.getTimerGPU();
                    u.setInitialDrawCallback((function () {
                        c.start("ShadowMap"), c.start("ShadowMap" + t)
                    })), u.setFinalDrawCallback((function () {
                        c.end("ShadowMap" + t), c.end("ShadowMap")
                    }))
                }
                return {
                    node: n,
                    light: r,
                    lightSource: s,
                    shadowSettings: o,
                    shadowMap: a,
                    enableShadow: no && (0, vr.Z)() > ao
                }
            },
                go = function (e, t) {
                    no && (t.setContinuousUpdate(!1), ro ? (e.addShadowTechnique(lo), lo.addShadowMap(t)) : e.addShadowTechnique(t))
                },
                fo = function (e, t) {
                    ro ? lo.removeShadowMap(t) : e.removeShadowTechnique(t)
                },
                mo = i("Qf9l"),
                po = g.Z.osg;
            const vo = {
                ambient: po.Uniform.createInt1(0, "uAmbient"),
                texture0: po.Uniform.createInt1(0, "uTexture0"),
                backgroundExposure: po.Uniform.createFloat(1, "uBackgroundExposure"),
                size: po.Uniform.createFloat(1, "uSize"),
                color: po.Uniform.createFloat3(po.vec3.fromValues(0, 0, 1), "uBackgroundColor"),
                scale: po.Uniform.createFloat2(po.vec2.fromValues(1, 1), "uFixedScale")
            };
            var _o = g.Z.osg,
                So = function () {
                    _o.Node.call(this), this._geometry = _o.createTexturedBoxGeometry(0, 0, 0, 5, 5, 5), this._show = "NONE", this._bgEnv = null, this._bgFixed = null, this._texRatio = 1, this._canvasWidth = 1, this._canvasHidth = 1, this.init(), this.hide()
                };
            _o.createPrototypeNode(So, _o.objectInherit(_o.Node.prototype, {
                init: function () {
                    var e = this._geometry,
                        t = e.getOrCreateStateSet();
                    for (var i in t.setAttributeAndModes(Le.Z.DEPTH_LEQUAL_BACKGROUND_NO_WRITE, _o.StateAttribute.PROTECTED), t.setRenderBinDetails(Oe.Z.BACKGROUND, "RenderBin"), t.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec3 Vertex;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uHalton;\nuniform vec2 uGlobalTexSize;\nuniform vec2 uGlobalTexRatio;\n\nvarying vec3 vLocalVertex;\n\nvoid main(void)\n{\n    vLocalVertex = Vertex.rgb;\n\n    mat4 projectionMatrix = uProjectionMatrix;\n    vec2 halt = uGlobalTexRatio.xy * uHalton.xy / uGlobalTexSize.xy;\n    projectionMatrix[2][0] += halt.x;\n    projectionMatrix[2][1] += halt.y;\n\n    gl_Position = (projectionMatrix * (uModelViewMatrix * vec4(Vertex, 1.0))).xyww;\n}\n", 'varying vec3 vLocalVertex;\n\n// common stuffs\nuniform int uOutputLinear;\nuniform float uRGBMRange;\n\nuniform float uEnvironmentExposure;\nuniform float uBackgroundExposure;\n\nuniform vec3 uDiffuseSPH[9];\nuniform samplerCube uTexture0;\nuniform float uSize;\nuniform int uAmbient;\n\nuniform float uFrameModTaaSS;\n\n#pragma include "utils/functions.glsl"\n#pragma include "utils/cubemap.glsl"\n#pragma include "utils/rand.glsl"\n\n// sph env\nvec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in vec3 n) {\n    // https://github.com/cedricpinson/envtools/blob/master/Cubemap.cpp#L523\n    vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));\n    return max(result, vec3(0.0));\n}\n\nvoid main(void) {\n\n    vec3 color;\n    if (uAmbient == 1) {\n        vec3 normal = normalize(vLocalVertex + mix(-0.5/255.0, 0.5/255.0, pseudoRandom(gl_FragCoord.xy))*2.0);\n        // vec3 normal = normalize(vLocalVertex + (interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS) - 0.5) * 0.4);\n        color = evaluateDiffuseSphericalHarmonics(uDiffuseSPH, normal);\n    } else {\n        color = textureCubeFixed(uTexture0, normalize(vLocalVertex), uSize);\n    }\n\n    color *= uEnvironmentExposure * uBackgroundExposure;\n\n    if (uOutputLinear == 0 ) color = linearTosRGB(color);\n\n    gl_FragColor = encodeRGBM(color, uRGBMRange);\n}\n', "environment-background", "Environment")), t.setTextureAttributeAndModes(0, mo.Z.dummyTexture), vo) t.addUniform(vo[i]);
                    this.addChild(e)
                },
                rescale: function (e, t) {
                    e && (this._canvasWidth = e), t && (this._canvasHeight = t);
                    var i = this._canvasWidth / this._canvasHeight,
                        n = vo.scale.getInternalArray();
                    i >= this._texRatio ? (n[0] = 1, n[1] = this._texRatio / i) : (n[0] = i / this._texRatio, n[1] = 1)
                },
                getBackground: function () {
                    return this._bgFixed
                },
                getEnvironment: function () {
                    return this._bgEnv
                },
                hide: function () {
                    this._show = "NONE", this._update()
                },
                showColor: function () {
                    this._show = "COLOR", this._update()
                },
                showEnvironment: function () {
                    this._show = "ENV", this._update()
                },
                setEnvironment: function (e, t) {
                    this._bgEnv = e, void 0 !== t && vo.size.setFloat(t), this._update()
                },
                setExposure: function (e) {
                    vo.backgroundExposure.setFloat(e)
                },
                showAmbient: function () {
                    this._show = "AMBIENT", this._update()
                },
                showBackground: function () {
                    this._show = "FIXED", this._update()
                },
                setBackground: function (e) {
                    this._texRatio = e.getWidth() / e.getHeight(), this._bgFixed = e, this._update()
                },
                _update: function () {
                    U.Z.draw(), "ENV" === this._show || "AMBIENT" === this._show ? (this._geometry.setNodeMask(-1), vo.ambient.getInternalArray()[0] = "AMBIENT" === this._show, this._bgEnv && "ENV" === this._show && this._geometry.getOrCreateStateSet().setTextureAttributeAndModes(0, this._bgEnv)) : this._geometry.setNodeMask(0)
                }
            }), "osgtestdemo2024", "Background");
            const xo = So;
            var Co = g.Z.osg;
            const To = {
                environmentTransform: Co.Uniform.createMatrix3("uEnvironmentTransform"),
                exposure: Co.Uniform.createFloat1(1, "uEnvironmentExposure"),
                diffuseSPH: Co.Uniform.createFloat3Array(new Float32Array(27), "uDiffuseSPH"),
                textureSpecular: Co.Uniform.createInt1("sEnvironmentSpecular"),
                textureSpecularPBR: Co.Uniform.createInt1("sSpecularPBR"),
                textureIntegrateBRDF: Co.Uniform.createInt1("sIntegrateBRDF"),
                factorShadowEnv0: Co.Uniform.createFloat(0, "uFactorShadowEnv0")
            };
            var Mo = g.Z.osg,
                bo = function (e, t) {
                    this._texture = e, this._channel = t || "Specular", this._isCubemap = !1, this._hash = "Specular" === t ? "EnvSpec" : "SpecularPBR" === t ? "EnvSpecPBR" : "EnvBRDF"
                };
            bo.uniforms = {}, Mo.createPrototypeStateAttribute(bo, Mo.objectInherit(Mo.Texture.prototype, {
                attributeType: "Texture",
                channelType: ["Specular", "SpecularPBR", "IntegrateBRDF"],
                getUniformName: function (e) {
                    return "uTextureEnvironment" + this.getChannel() + e
                },
                getOrCreateUniforms: function () {
                    var e = bo.uniforms,
                        t = this.getChannel();
                    if (e[t]) return e[t];
                    var i = this._texture;
                    return e[t] = {
                        size: Mo.Uniform.createFloat2([i.getWidth(), i.getHeight()], this.getUniformName("TextureSize"))
                    }, e[t]
                },
                setIsCubemap: function (e) {
                    this._isCubemap = e
                },
                getIsCubemap: function () {
                    return this._isCubemap
                },
                getUniforms: function () {
                    return To
                },
                getTexture: function () {
                    return this._texture
                },
                getChannel: function () {
                    return this._channel
                },
                cloneType: function () {
                    return new bo(new Mo.Texture)
                },
                getHash: function () {
                    return this._hash
                },
                updateLodRange: function (e) {
                    var t = this.getOrCreateUniforms(),
                        i = Math.log(this._texture.getWidth()) / Math.LN2,
                        n = i - Math.log(e) / Math.LN2;
                    if (t.lodRange) {
                        var r = t.lodRange.getInternalArray();
                        r[0] = i, r[1] = n
                    } else t.lodRange = Mo.Uniform.createFloat2([i, n], this.getUniformName("LodRange"))
                },
                apply: function (e, t) {
                    var i = this._texture;
                    void 0 !== i && i.apply(e);
                    var n = this.getOrCreateUniforms(t).size.getInternalArray();
                    n[0] = i.getWidth(), n[1] = i.getHeight()
                }
            }), "osgtestdemo2024", "TextureEnvironment");
            const yo = bo;
            var Ao = i("GhWR"),
                Ro = g.Z.osg,
                wo = function (e) {
                    Ro.Node.call(this), this.getOrCreateStateSet(), this._enable = !0, this._viewer = e, this._isPBR = !1, this._textureSpecular = void 0, this._textureSpecularUnit = 6, this._textureSpecularPBR = void 0, this._textureIntegrateBRDF = void 0, this._textureSpecularPBRUnit = 6, this._textureIntegrateBRDFUnit = 8, this._nodeBackground = new xo, this._adjustRotation = Ro.mat4.fromXRotation(Ro.mat4.create(), Math.PI / 2), this._root = new Ro.MatrixTransform, Ro.mat4.multiply(this._root.getMatrix(), this._root.getMatrix(), this._adjustRotation), this._lightProbes = [];
                    var t = ho("Environment", 3, jt.DIRECTION);
                    this._light = t.light, this._mtLight = t.node, this._shadow = t.shadowMap, this._mtLight.addChild(t.lightSource), this._lightIntensity = 1, this._lightShadowEnabled = !1, this._shadowBias = 5e-4, this._shadowedScene = void 0, this._lightNodeRoot = new Ro.MatrixTransform, this._lightNodeRoot.setName("Env Lighting - Light"), Ro.mat4.copy(this._lightNodeRoot.getMatrix(), this._root.getMatrix()), this._lightNodeRoot.addChild(this._mtLight), this.addUpdateCallback(this), bi.Z.bind("change:mask", this.updateLightShadow, this)
                };
            Ro.createPrototypeNode(wo, Ro.objectInherit(Ro.Node.prototype, {
                getBackground: function () {
                    return this._nodeBackground
                },
                enable: function () {
                    this._enable = !0, this.setTexturesStateSet(), U.Z.draw()
                },
                disable: function () {
                    this._enable = !1, this.removeTexturesStateSet(), U.Z.draw()
                },
                setBackgroundExposure: function (e) {
                    this._nodeBackground.setExposure(e), U.Z.draw()
                },
                setBackgroundTexture: function (e, t) {
                    this._nodeBackground.setEnvironment(e, t), U.Z.draw()
                },
                createCameraNode: function () {
                    var e = {},
                        t = this,
                        i = Ro.mat4.create(),
                        n = To.environmentTransform.getInternalArray(),
                        r = new Ro.Camera;
                    return r.setName("Environment - Camera"), r.setCullCallback(new function () {
                        this.cull = function (r, a) {
                            Ro.mat4.getPerspective(e, t._mainCamera.getProjectionMatrix()), Ro.mat4.perspective(a.getCurrentProjectionMatrix(), e.fovy * Math.PI / 180, e.aspectRatio, 1, 1e3), Ro.mat4.copy(a.getCurrentModelViewMatrix(), t._mainCamera.getViewMatrix()), Ro.mat4.setTranslation(a.getCurrentModelViewMatrix(), Ro.vec3.ZERO);
                            var o = a.getCurrentModelViewMatrix();
                            return Ro.mat4.multiply(i, o, t._root.getMatrix()), Ro.mat3.fromMat4(n, i), Ro.mat3.transpose(n, n), !0
                        }
                    }), r.setReferenceFrame(Ro.Transform.ABSOLUTE_RF), Ao.Z.cameraEnvironment = r, r
                },
                init: function (e, t) {
                    for (var i in this._mainCamera = e, this._shadowedScene = t, this._shadowedScene.addChild(this._lightNodeRoot), To) this.getStateSet().addUniform(To[i]);
                    var n = this.createCameraNode();
                    n.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this.addChild(n), n.addChild(this._root), this._root.addChild(this._nodeBackground), this.updateTextureUnits(), this.updateLightShadow()
                },
                setLightShadowEnabled: function (e) {
                    this._lightShadowEnabled = e && (0, l.Z)().shadow, this.updateLightShadow()
                },
                setLightIntensity: function (e) {
                    this._lightIntensity = e, this.updateLightColorAndIntensity(), U.Z.draw()
                },
                setShadowBias: function (e) {
                    this._shadowBias = e, this._shadow && (this._shadow.setBias(e), this._shadow.requestRedraw(), U.Z.draw())
                },
                setLightProbes: function (e) {
                    this._lightProbes = e, this.updateLightShadow()
                },
                removeTexturesStateSet: function () {
                    var e = this.getStateSet();
                    e && (this._isPBR ? (this._textureSpecularPBR && e.removeTextureAttribute(this._textureSpecularPBRUnit, this._textureSpecularPBR.getTypeMember()), this._textureIntegrateBRDF && e.removeTextureAttribute(this._textureIntegrateBRDFUnit, this._textureIntegrateBRDF.getTypeMember())) : this._textureSpecular && e.removeTextureAttribute(this._textureSpecularUnit, this._textureSpecular.getTypeMember()))
                },
                setTexturesStateSet: function () {
                    var e = this.getStateSet();
                    e && (this._isPBR ? (this._textureSpecularPBR && e.setTextureAttributeAndModes(this._textureSpecularPBRUnit, this._textureSpecularPBR), this._textureIntegrateBRDF && e.setTextureAttributeAndModes(this._textureIntegrateBRDFUnit, this._textureIntegrateBRDF)) : this._textureSpecular && e.setTextureAttributeAndModes(this._textureSpecularUnit, this._textureSpecular))
                },
                updateLightColorAndIntensity: function () {
                    if (this._light && 0 !== this._lightProbes.length) {
                        var e = To.exposure.getInternalArray()[0] / this._defaultExposure,
                            t = this._lightProbes[0].color;
                        Ro.vec3.normalize(t, t), Ro.vec3.scale(this._light.getDiffuse(), t, this._lightIntensity * e)
                    }
                },
                setDefaultExposure: function (e) {
                    this._defaultExposure = e
                },
                setExposure: function (e) {
                    To.exposure.setFloat(e), this.updateLightColorAndIntensity()
                },
                updateLightFromProbes: function () {
                    var e = this._lightProbes[0].direction,
                        t = Math.abs(e[2]) > .999 ? Ro.vec3.fromValues(0, 1, 0) : Ro.vec3.fromValues(0, 0, 1),
                        i = this._mtLight.getMatrix();
                    Ro.mat4.lookAtDirection(i, Ro.vec3.ZERO, e, t), Ro.mat4.invert(i, i), this.updateLightColorAndIntensity(), (0, l.Z)().debugEnvShadow && this._debugShadow()
                },
                _debugShadow: function () {
                    if (!this._debugDone) {
                        this._debugDone = !0;
                        var e = Ro.createAxisGeometry(),
                            t = new Ro.MatrixTransform;
                        t.setMatrix(Ro.mat4.fromScaling(Ro.mat4.create(), [100, 100, -500])), Ro.mat4.setTranslation(t.getMatrix(), [0, 0, 500]), t.addChild(e);
                        var i = new Qa.createDirectionalGeometry(5);
                        t.addChild(i), t.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._mtLight.addChild(t)
                    }
                },
                isUsingLightShadow: function () {
                    return bi.Z.get("mask") & bi.Z.LIT && this._lightShadowEnabled && this._lightProbes.length > 0
                },
                updateLightShadow: function () {
                    if (this._shadowedScene) {
                        var e = this.isUsingLightShadow();
                        if (this._light.setEnabled(e), fo(this._shadowedScene, this._shadow), e) {
                            var t = (0, vr.Z)();
                            ((0, l.Z)().shadowAtlas && t > 7 || t > 12) && go(this._shadowedScene, this._shadow), this._shadow.setBias(this._shadowBias), Ro.mat4.copy(this._lightNodeRoot.getMatrix(), this._root.getMatrix()), this.updateLightFromProbes(), this._shadow.requestRedraw(), U.Z.draw()
                        }
                    }
                },
                update: function (e, t) {
                    if (e.getNumChildrenRequiringUpdateTraversal() > 0 && t.traverse(e), !this._light || !this._shadow) return !1;
                    var i = this._viewer.getFeaturesManager();
                    return i && i.getShadowForcedUpdate() && this._shadow.requestRedraw(), !1
                },
                updateShadow: function () {
                    this._light && this._shadow && this._shadow.requestRedraw()
                },
                updateRotation: function (e) {
                    Ro.mat4.fromZRotation(this._root.getMatrix(), -e), Ro.mat4.multiply(this._root.getMatrix(), this._root.getMatrix(), this._adjustRotation), Ro.mat4.copy(this._lightNodeRoot.getMatrix(), this._root.getMatrix()), this._shadow && this._shadow.requestRedraw()
                },
                setDiffuseSPH: function (e) {
                    for (var t = To.diffuseSPH.getInternalArray(), i = 1 / (2 * Math.sqrt(Math.PI)), n = -.5 * Math.sqrt(3 / Math.PI), r = -n, a = n, o = .5 * Math.sqrt(15 / Math.PI), s = -o, l = .25 * Math.sqrt(5 / Math.PI), u = s, c = .25 * Math.sqrt(15 / Math.PI), h = [i, i, i, n, n, n, r, r, r, a, a, a, o, o, o, s, s, s, l, l, l, u, u, u, c, c, c], d = 0; d < 27; ++d) t[d] = e[d] * h[d]
                },
                setSpecularTexture: function (e) {
                    this._enable && (this._textureSpecular = new yo(e, "Specular"), this._textureSpecular.setIsCubemap(!0), this.updateTextureUnits(), To.textureSpecular.setInt(this._textureSpecularUnit), U.Z.draw())
                },
                setSpecularPBRTexture: function (e, t) {
                    if (this._enable) {
                        this._textureSpecularPBR = new yo(e, "SpecularPBR");
                        var i = "TextureCubeMap" === e.className();
                        this._textureSpecularPBR.setIsCubemap(i), this._textureSpecularPBR.updateLodRange(t), this.updateTextureUnits(), To.textureSpecularPBR.setInt(this._textureSpecularPBRUnit), U.Z.draw()
                    }
                },
                setIntegrateBRDFTexture: function (e) {
                    this._enable && (this._textureIntegrateBRDF = new yo(e, "IntegrateBRDF"), this.updateTextureUnits(), To.textureIntegrateBRDF.setInt(this._textureIntegrateBRDFUnit), U.Z.draw())
                },
                updateTextureUnits: function () {
                    this.setTexturesStateSet()
                },
                setIsPBR: function (e) {
                    this._isPBR = e
                }
            }), "osgtestdemo2024", "Environment");
            const Eo = wo;
            var Po, No, Oo = i("0aN2"),
                Do = g.Z.osg,
                Io = g.Z.InputGroups,
                Fo = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this._viewer = this.options.context.getViewer(), this._inputManager = this._viewer.getInputManager(), this._nodeEnvironment = new Eo(this._viewer), this._nodeEnvironment.setName("Feature - Environment"), this._backgroundLoaded = {}, this.model.bind("change:enable", this.onEnableChanged, this), this.model.bind("change:exposure", this.onExposureChanged, this), this.model.bind("change:backgroundExposure", this.onExposureChanged, this), this.model.bind("change:rotation", this.onRotationChanged, this), this.model.bind("change:uid", this.onUIDChanged, this), this.model.bind("updateBackground", this.onBackgroundEnableChanged, this), this.model.bind("change:blur", this.onBlurChanged, this), bi.Z.bind("change:mask", this.onEnvironmentChanged, this), this.model.bind("change", U.Z.draw), this._resourceDefer = new bt.Z, this.options.context.getScene().addResourcePromise(this._resourceDefer), this.model.bind("change:shadowEnable", this.onShadowEnable, this), this.model.bind("change:shadowBias", this.onShadowBiasChanged, this), this.model.bind("change:lightIntensity", this.onLightIntensityChanged, this), L.Z.getMaterial().then(function () {
                            this.initEnvironment(), this.initRotateEnvironment()
                        }.bind(this))
                    },
                    getBackgroundEnableType: function () {
                        var e = this._viewer.getFeatures().background;
                        return e ? e.getModel().getEnableType() : "none"
                    },
                    isBackgroundEnvironment: function () {
                        return "environment" === this.getBackgroundEnableType()
                    },
                    initEnvironment: function () {
                        this.onRotationChanged(), this.onExposureChanged(), this.onEnableChanged(), this.model.get("enable") || L.Z.resolveDataSizeEnvironment(0)
                    },
                    initRotateEnvironment: function () {
                        this._viewer.getViewerOSGJS() && ((0, l.Z)().preventUserLightRotation || (this._rotEnv = !1, this.mx_ = 0, Ve.Z.initEnvironment(this)))
                    },
                    startRotate: function (e) {
                        (0, l.Z)().preventUserLightRotation || (this._rotEnv = !0, this.mx_ = e.canvasX, this._inputManager.setEnable(Io.MANIPULATORS, !1))
                    },
                    _computeDelta: function (e) {
                        U.Z.draw();
                        var t = (e.canvasX - this.mx_) / 100;
                        return this.mx_ = e.canvasX, t
                    },
                    rotateEnv: function (e, t) {
                        if (this._rotEnv) {
                            t || (t = this._computeDelta(e));
                            var i = (this.model.get("rotation") + t) % (2 * Math.PI);
                            this.model.set("rotation", i < 0 ? i + 2 * Math.PI : i)
                        }
                    },
                    rotateLight: (Po = Do.mat4.create(), No = Do.mat4.create(), function (e, t) {
                        if (this._rotEnv) {
                            t || (t = this._computeDelta(e));
                            var i = this.options.context.getFeatures().lighting;
                            if (i) {
                                var n = this._viewer.getFeaturesManager().getWorldNode().getMinimumBound().center();
                                Do.mat4.fromZRotation(Po, -t % (2 * Math.PI)), Do.vec3.negate(n, n), Do.mat4.multiply(Po, Po, Do.mat4.fromTranslation(No, n)), Do.vec3.negate(n, n), Do.mat4.multiply(Po, Do.mat4.fromTranslation(No, n), Po);
                                for (var r = i.getModel().get("lights"), a = 0, o = r.length; a < o; ++a) {
                                    var s = r[a];
                                    if (!s.isAttachedToCamera()) {
                                        var l = s.get("matrix");
                                        Do.mat4.multiply(l, Po, l), s.dirty()
                                    }
                                }
                            }
                        }
                    }),
                    rotateEnvAndLight: function (e) {
                        if (this._rotEnv) {
                            var t = this._computeDelta(e);
                            this.rotateEnv(e, t), this.rotateLight(e, t)
                        }
                    },
                    endRotate: function () {
                        this._rotEnv && (this._rotEnv = !1, this._inputManager.setEnable(Io.MANIPULATORS, !0))
                    },
                    onUIDChanged: function () {
                        this.model.updateEnvironmentConfig(), this.onEnvironmentChanged(), this.onBackgroundEnableChanged()
                    },
                    getRotating: function () {
                        return this._rotEnv
                    },
                    getNodeEnvironment: function () {
                        return this._nodeEnvironment
                    },
                    getResourceManager: function () {
                        return this._resourceManager || s.Z.instance
                    },
                    onEnableChanged: function () {
                        this.model.get("enable") ? (this._nodeEnvironment.enable(), this._nodeEnvironment.setLightShadowEnabled(this.model.get("shadowEnable")), this._nodeEnvironment.setLightIntensity(this.model.get("lightIntensity")), this._nodeEnvironment.setShadowBias(this.model.get("shadowBias"))) : (this._nodeEnvironment.disable(), this._nodeEnvironment.setLightShadowEnabled(!1)), this.onEnvironmentChanged()
                    },
                    onShadowEnable: function () {
                        var e = this.getEnvironment().get("lights");
                        !this.model.get("shadowEnable") || e && 0 !== e.length ? this._nodeEnvironment.setLightShadowEnabled(this.model.get("shadowEnable")) : this.model.set("shadowEnable", !1)
                    },
                    onShadowBiasChanged: function () {
                        this._nodeEnvironment.setShadowBias(this.model.get("shadowBias"))
                    },
                    onLightIntensityChanged: function () {
                        this._nodeEnvironment.setLightIntensity(this.model.get("lightIntensity"))
                    },
                    onExposureChanged: function () {
                        this._nodeEnvironment.setExposure(this.model.get("exposure")), this._nodeEnvironment.setBackgroundExposure(this.model.get("backgroundExposure"))
                    },
                    onRotationChanged: function () {
                        this._nodeEnvironment.updateRotation(this.model.get("rotation"))
                    },
                    onBlurChanged: function () {
                        this.abortLastDownloadEnv(), this.isBackgroundEnvironment() && this.setBackgroundTexture()
                    },
                    onBackgroundEnableChanged: function () {
                        var e = this.getBackgroundEnableType();
                        "environment" === e ? this.setBackgroundTexture() : "ambient" === e && this.setBackgroundAmbient()
                    },
                    resolvePreload: function () {
                        this._resourceDefer && (this._resourceDefer.resolve(), this._resourceDefer = void 0)
                    },
                    onEnvironmentChanged: function () {
                        var e = this.getEnvironment();
                        e && this.model.get("enable") ? (this._onlyLowRes = !0, this.setEnvironment(e).then(function () {
                            var t = e.get("uid") === this.model.get("uid");
                            (0, l.Z)().preload && t || this.resolvePreload(), t && (this._onlyLowRes = !1, this.setEnvironment(e).finally(this.resolvePreload.bind(this)))
                        }.bind(this))) : this.resolvePreload()
                    },
                    getEnvironment: function () {
                        return this.model.getEnvironment()
                    },
                    getName: function () {
                        return "Environment3D"
                    },
                    abortLastDownloadEnv: function () {
                        for (var e = this.model.get("uid"), t = this.model.get("blur"), i = this.getResourceManager()._resourceLoader._processing, n = 0, r = i.length; n < r; ++n) {
                            var a = i[n],
                                o = a.getXHR();
                            o && (void 0 !== a._envUID && a._envUID !== e && o.abort(), void 0 !== a._envBlur && a._envBlur !== t && o.abort())
                        }
                    },
                    setEnvironment: function (e) {
                        this.abortLastDownloadEnv();
                        var t = [];
                        if (bi.Z.get("mask") & bi.Z.LIT) {
                            var i = bi.Z.get("mask") & bi.Z.PBR;
                            this._nodeEnvironment.setIsPBR(i), this._nodeEnvironment.setDiffuseSPH(e.get("diffuseSPH"));
                            var n = e.get("lights") || [];
                            this._nodeEnvironment.setLightProbes(n, e.id), this.model.get("shadowEnable") && this.model.set("shadowEnable", n.length > 0), this._nodeEnvironment.setDefaultExposure(e.get("brightness")), i ? this.setEnvironmentPBR(e, t) : this.setEnvironmentOld(e, t), this.setProgress(t.slice(), "environment")
                        }
                        return this.isBackgroundEnvironment() && t.push(this.setBackgroundTexture()), 0 === t.length ? d().resolve() : d().all((0, Mt.Z)(t, (function (e) {
                            return e.reflect()
                        })))
                    },
                    setEnvironmentPBR: function (e, t) {
                        var i = this._nodeEnvironment,
                            n = e.get("textures"),
                            r = !1;
                        Do.WebGLCaps.instance().getWebGLExtension("EXT_shader_texture_lod") && (r = !0), (0, l.Z)().panorama && (r = !1);
                        var a = (0, nr.Z)(n, {
                            encoding: "luv",
                            type: "specular_ue4",
                            format: r ? "cubemap" : "panorama"
                        }),
                            o = this.getImageRes(a),
                            s = {
                                cubemap: r,
                                panoramaLUV: !r,
                                cubemapLUV: r,
                                size: o.width,
                                minFilter: r ? Do.Texture.LINEAR_MIPMAP_LINEAR : Do.Texture.LINEAR,
                                magFilter: Do.Texture.LINEAR,
                                wrapS: Do.Texture.CLAMP_TO_EDGE,
                                wrapT: Do.Texture.CLAMP_TO_EDGE,
                                transferToGPU: !0,
                                internalFormat: Do.Texture.RGBA
                            },
                            u = this.getResourceManager().getOrCreateTexture(o.file, s);
                        this.markLastXHR(this.model.get("uid")), u.texture.setFlipY(!r), this._onlyLowRes && i.setSpecularPBRTexture(u.texture, a.limitSize);
                        var c = this.getPromiseTexture(u);
                        c.then(i.setSpecularPBRTexture.bind(i, u.texture, a.limitSize)), t.push(c);
                        var h = o.sizeCompressed,
                            d = (0, vr.Z)();
                        if (!jr.default.any && d > 8) {
                            var g = (0, nr.Z)(n, {
                                type: "brdf_ue4"
                            });
                            s = {
                                integrateBRDFLUV: !0,
                                minFilter: Do.Texture.NEAREST,
                                magFilter: Do.Texture.NEAREST,
                                wrapS: Do.Texture.CLAMP_TO_EDGE,
                                wrapT: Do.Texture.CLAMP_TO_EDGE,
                                transferToGPU: !0,
                                internalFormat: Do.Texture.RGBA
                            }, h += (o = this.getImageRes(g)).sizeCompressed;
                            var f = this.getResourceManager().getOrCreateTexture(o.file, s);
                            this.markLastXHR(this.model.get("uid")), f.texture.setFlipY(!1), i.setIntegrateBRDFTexture(f.texture);
                            var m = this.getPromiseTexture(f);
                            m.then(i.setIntegrateBRDFTexture.bind(i, f.texture)), t.push(m)
                        }
                        L.Z.resolveDataSizeEnvironment(h)
                    },
                    getBackgroundResource: function (e, t, i) {
                        var n, r = (0, nr.Z)(e, {
                            encoding: "luv",
                            type: "background",
                            format: "cubemap"
                        });
                        return n = void 0 !== i ? this.getClosestBlur(r, i) : this.getImageRes(r, 512), t.cubemap = !0, t.cubemapLUV = !0, t.size = n.width, t.minFilter = Do.Texture.LINEAR, t.magFilter = Do.Texture.LINEAR, t.wrapS = Do.Texture.CLAMP_TO_EDGE, t.wrapT = Do.Texture.CLAMP_TO_EDGE, t.transferToGPU = !0, t.internalFormat = Do.Texture.RGBA, n
                    },
                    setEnvironmentOld: function (e, t) {
                        var i = this._nodeEnvironment,
                            n = {},
                            r = this.getBackgroundResource(e.get("textures"), n),
                            a = this.getResourceManager().getOrCreateTexture(r.file, n);
                        this.markLastXHR(this.model.get("uid")), this._onlyLowRes && i.setSpecularTexture(a.texture);
                        var o = this.getPromiseTexture(a);
                        o.then(i.setSpecularTexture.bind(i, a.texture)), L.Z.resolveDataSizeEnvironment(r.sizeCompressed), t.push(o)
                    },
                    setBackgroundTexture: function () {
                        var e = this.getEnvironment();
                        if (!e) return d().reject(new Error);
                        var t = {},
                            i = this.getBackgroundResource(e.get("textures"), t, this.model.get("blur")),
                            n = this._backgroundLoaded;
                        if (this.getRequestLowRes()) {
                            if (n[i.file]) return n[i.file].promise;
                            i = this.getBackgroundResource(e.get("textures"), t, 1)
                        }
                        var r = this._nodeEnvironment,
                            a = this.getResourceManager().getOrCreateTexture(i.file, t);
                        this.markLastXHR(this.model.get("uid"), this.model.get("blur"));
                        var o = this.getPromiseTexture(a);
                        return o.then((function () {
                            r.setBackgroundTexture(a.texture, i.width), n[i.file] = a
                        })), this.setProgress(o, "background"), o
                    },
                    setProgress: function (e, t) {
                        var i = this._viewer.setFakeSecondaryProgress.bind(this._viewer, e, t);
                        L.Z.getHighResLoaded().then(i)
                    },
                    setBackgroundAmbient: function () {
                        var e = this.getEnvironment();
                        return e ? (this._nodeEnvironment.setDiffuseSPH(e.get("diffuseSPH")), d().resolve()) : d().reject(new Error)
                    },
                    markLastXHR: function (e, t) {
                        var i = this.getResourceManager()._resourceLoader._processing;
                        if (i.length > 0) {
                            var n = i[i.length - 1];
                            n._envUID = e, void 0 === t || this.getRequestLowRes() || (n._envBlur = t)
                        }
                    },
                    getPromiseTexture: function (e) {
                        return this._onlyLowRes || (0, l.Z)().preload ? e.promise : d().all([e.promise, L.Z.getFirstCameraAnimation()])
                    },
                    getRequestLowRes: function () {
                        return this._onlyLowRes && !(0, l.Z)().preload
                    },
                    getImageRes: function (e, t) {
                        var i = new Oo.Z(e);
                        if (this.getRequestLowRes()) return i.findImageSmallest();
                        var n = void 0 !== t ? t : 1 / 0;
                        return i.findImageNearestPowerOfTwoUpToResolution(n, n)
                    },
                    getClosestBlur: function (e, t) {
                        for (var i = e.images, n = 0, r = 1 / 0, a = 0, o = i.length; a < o; ++a) {
                            var s = Math.abs(i[a].blur - t);
                            s < r && (n = a, r = s)
                        }
                        return i[n]
                    }
                });
            var Lo = {
                FeatureName: "environment",
                ModelType: Za,
                ViewListType: [Fo]
            },
                Vo = n.Z.create(Lo);
            Vo.prototype = (0, Ia.Z)({}, n.Z.prototype, {
                getNode: function () {
                    return this._views[0].getNodeEnvironment()
                },
                getRotating: function () {
                    return this._views[0].getRotating()
                }
            });
            const Bo = Vo;
            var Uo = g.Z.osg,
                ko = a.Z.extend({
                    _trashbin: [],
                    getModelOptionPath: function () {
                        return "background"
                    },
                    defaults: function () {
                        return {
                            webVR: !1
                        }
                    },
                    init: function (e) {
                        this.backgroundCollection = s.Z.instance.getBackgroundCollection(), this._defaultBackground = this.get("uid"), this.set("enable", (0, vi.Z)() ? "color" : "fixed");
                        var t = e.getModel().get("options").background;
                        t && this.setJSON(t), (0, l.Z)().transparent && this.set("enable", "none");
                        var i = e.getViewer();
                        (0, vi.Z)() && L.Z.getPolygon().then(function () {
                            "Tilt Brush" === i.getRootUserData().authoringTool && (this.set("enable", "color"), this.set("color", Uo.vec3.create()))
                        }.bind(this)), (0, o.Z)() && (0, l.Z)().apiLog && (console.log("------"), console.log("Viewer Api Background uid list:"), this.backgroundCollection.each((function (e) {
                            console.log("- " + e.get("name") + ": " + e.get("uid"))
                        })), console.log("------"))
                    },
                    getName: function () {
                        return "Background"
                    },
                    setBackground: function (e) {
                        return this.setBackgroundUID(e.uid)
                    },
                    setBackgroundUID: function (e) {
                        e && this.set("uid", e)
                    },
                    getBackground: function () {
                        if (this.backgroundCollection) {
                            var e = this.get("uid"),
                                t = this.backgroundCollection.find((function (t) {
                                    return t.get("uid") === e || t.get("id") === e
                                }));
                            if (t) return t;
                            this.set("uid", this._defaultBackground)
                        }
                    },
                    resetToDefaultBackground: function () {
                        return this.set("uid", this._defaultBackground), this
                    },
                    getEnableType: function () {
                        var e = this.get("enable");
                        return "fixed" !== e && "none" !== e || !this.get("webVR") || (0, l.Z)().vrAr ? e : "ambient"
                    },
                    getColor: function () {
                        return this.get("color")
                    },
                    validate: function (e, t) {
                        var i = a.Z.prototype.validate.call(this, e, t),
                            n = this.get("uid");
                        n !== this._defaultBackground && (this.getBackground() || console.warn("Couldn't find background " + n));
                        return i
                    },
                    editorGetJSON: function () {
                        return this.getJSON()
                    },
                    editorSetJSON: function (e) {
                        return this.setJSON(e, {
                            validate: !0
                        })
                    }
                });
            const Zo = ko;
            var Ho = g.Z.osg;
            var Go = {
                FeatureName: "background",
                ModelType: Zo,
                ViewListType: [V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this.model.bind("change:enable", this.onEnableChanged, this), this.model.bind("change:webVR", this.onEnableChanged, this), this.model.bind("change:uid", this.onBackgroundChanged, this), this.model.bind("change", U.Z.draw), this._viewer = this.options.context.getViewer();
                        var e = this.options.context.getFeatures().environment;
                        e && (this._resourceDefer = new bt.Z, this.options.context.getScene().addResourcePromise(this._resourceDefer.promise), this._modelEnvironment = e.getModel(), this._nodeBackground = e.getNode().getBackground(), this._nodeBackground.addUpdateCallback(this), L.Z.getMaterial().then(this.onEnableChanged.bind(this)), this._viewer = this.options.context.getViewer())
                    },
                    getResourceManager: function () {
                        return this._resourceManager || s.Z.instance
                    },
                    onBackgroundChanged: function () {
                        var e = this.model.getBackground();
                        if (e) {
                            var t = this.options.context.getViewer(),
                                i = Math.max((0, Jr.Z)(t.getWidth()), (0, Jr.Z)(t.getHeight())),
                                n = e.findImageNearestToResolution(i, i).url;
                            return this.getResources(n)
                        }
                    },
                    getResources: function (e) {
                        for (var t = {
                            minFilter: Ho.Texture.LINEAR,
                            magFilter: Ho.Texture.LINEAR,
                            transferToGPU: !0,
                            convertNPOT: !1,
                            backgroundUid: this.model.get("uid"),
                            internalFormat: Ho.Texture.RGB
                        }, i = this.getResourceManager()._resourceLoader._processing, n = 0; n < i.length; ++n) {
                            var r = i[n],
                                a = r._options;
                            a && a.backgroundUid && a.backgroundUid !== this.model.get("uid") && r.abort()
                        }
                        var o = this.getResourceManager().getOrCreateTexture(e, t);
                        o.promise.then(function (e) {
                            this._nodeBackground.setBackground(e), this._nodeBackground.rescale(this._viewWidth, this._viewHeight), this.model.trigger("backgroundUpdated", e), this._viewer.trigger("backgroundLoaded"), "fixed" === this.model.getEnableType() && this._nodeBackground.showBackground()
                        }.bind(this));
                        var s = this.options.context.getViewer();
                        return this._resourceDefer ? (o.promise.finally(this._resourceDefer.resolve.bind(this._resourceDefer)), this._resourceDefer = void 0) : L.Z.getHighResLoaded().then(s.setFakeSecondaryProgress.bind(s, o.promise, "background")), o.promise
                    },
                    onEnableChanged: function () {
                        var e = this.model.getEnableType();
                        "color" === e ? this._nodeBackground.showColor() : "fixed" === e ? this._nodeBackground.getBackground() ? this._nodeBackground.showBackground() : void 0 !== this.model.get("uid") && this.onBackgroundChanged() : "environment" === e ? (this._modelEnvironment.trigger("updateBackground"), this._nodeBackground.showEnvironment()) : "ambient" === e ? (this._modelEnvironment.trigger("updateBackground"), this._nodeBackground.showAmbient()) : "none" === e && this._nodeBackground.hide(), this._resourceDefer && (this._resourceDefer.resolve(), this._resourceDefer = void 0)
                    },
                    requireBiggerTexture: function () {
                        var e = this.options.context.getViewer(),
                            t = Math.max((0, Jr.Z)(e.getWidth()), (0, Jr.Z)(e.getHeight())),
                            i = this.model.getBackground();
                        if (i) {
                            var n = i.findImageNearestUpToResolution(t, t);
                            if (void 0 !== this._nodeBackground && !this._nodeBackground.getBackground()) return !1;
                            if (n.width < this._nodeBackground.getBackground().getWidth()) return !1
                        }
                        return !0
                    },
                    update: function () {
                        if ("fixed" !== this.model.getEnableType()) return !0;
                        var e = this._viewer.getCamera().getViewport(),
                            t = e.width(),
                            i = e.height();
                        return this._viewWidth === t && this._viewHeight === i || (this._viewWidth = t, this._viewHeight = i, !0 === this.requireBiggerTexture() && this.onBackgroundChanged(), this._nodeBackground.rescale(t, i)), !0
                    }
                })]
            };
            const zo = n.Z.create(Go);
            var Wo = i("AyNe"),
                jo = i("8Tsk"),
                Xo = i("SM3V"),
                Yo = i("YBVK"),
                Jo = i("uyWM"),
                qo = g.Z.osg,
                Ko = function (e) {
                    var t = qo.vec3.create(),
                        i = qo.vec3.create();
                    if (e.getFeatures().camera.getModel().getCameraPosition(t, i), this.set("eye", t), this.set("target", i), (0, o.Z)()) {
                        var n = e.getScreenShot(128, 128).toDataURL("image/jpeg");
                        this.set("uidImage", void 0), this.set("imageFile", (0, Xo.Z)(n)), this.set("preview", n)
                    }
                },
                Qo = a.Z.extend({
                    getModelOptionPath: function () {
                        return "hotspot"
                    },
                    defaults: function () {
                        return {
                            webVR: !1,
                            currentHotspotIndex: -1
                        }
                    },
                    getName: function () {
                        return "Hotspot"
                    },
                    getResourceManager: function () {
                        return this._resourceManager || s.Z.instance
                    },
                    init: function (e) {
                        var t = this.getResourceManager().getHotspotCollection();
                        this.set("hotspots", t), t.on("remove", this.onRemove, this), this._viewer = e.getViewer(), this.hotspotsToBeDeleted = [];
                        var i = e.getModel().get("options").hotspot;
                        this.setJSON(i)
                    },
                    onRemove: function (e) {
                        e.isNew() || this.hotspotsToBeDeleted.push(e)
                    },
                    setUpdateCallback: function (e) {
                        this.callback = e
                    },
                    _hotspotInitialize: function (e, t, i) {
                        return this.get("visible") || this.set("visible", !0), e.add(t, {
                            sort: !1
                        }), t.set("order", e.indexOf(t)), t.set("refreshAction", Ko.bind(t, this._viewer)), t.get("refreshAction")(), void 0 === i && e.trigger("select", t), this.get("started") || this.set("started", !0), t
                    },
                    preventHotspotCameraAction: function (e, t) {
                        this.get("hotspots").each((function (i) {
                            i.set("cameraPreventAnimation", e), i.set("cameraPreventMove", t)
                        }))
                    },
                    createHotspotFromWorldPosition: function (e, t, i) {
                        var n = this.get("hotspots"),
                            r = new Yo.Z;
                        return r.set("building", i), r.set("uid", "tmp_" + (0, Wo.Z)()), (0, Jo.D1)(r, e), this._hotspotInitialize(n, r, t)
                    },
                    createHotspotFromScenePosition: function (e, t, i) {
                        var n = this.get("hotspots"),
                            r = new Yo.Z;
                        return r.set("building", i), r.set("uid", "tmp_" + (0, Wo.Z)()), (0, Jo.cW)(r, e), this._hotspotInitialize(n, r, t)
                    },
                    createHotspot: function (e, t) {
                        var i = this.get("hotspots"),
                            n = new Yo.Z;
                        return n.set("uid", "tmp_" + (0, Wo.Z)()), (0, Jo.hP)(n, e), this._hotspotInitialize(i, n, t)
                    },
                    setJSON: function (e, t) {
                        if (t && t.validate) {
                            var i = this.validate(e);
                            if (i.length) return i.join("\n")
                        }
                        void 0 !== (0, l.Z)().annotationsVisible ? this.set("visible", (0, l.Z)().annotationsVisible) : void 0 !== e.visible ? this.set("visible", e.visible) : this.set("visible", !0);
                        var n = e && e.hotspots && (0, jo.Z)(e.hotspots, "uid"),
                            r = this.get("hotspots");
                        return r.each(function (e) {
                            e.collection = null;
                            var t = e.get("images")[0];
                            t && (e.set("uidImage", t.uid), e.set("imageFile", (0, Xo.Z)(t.url)), e.set("preview", t.url)), e.set("refreshAction", Ko.bind(e, this._viewer));
                            var i = n && n[e.get("uid")];
                            i && (e.set("geometryUid", i.geometryUid), e.set("indices", i.indices), e.set("barycentricWeights", i.barycentricWeights), e.set("localPosition", i.localPosition)), r.add(e)
                        }.bind(this)), []
                    },
                    getJSON: function () {
                        var e = [];
                        return this.get("hotspots").each((function (t) {
                            var i = {
                                uid: t.get("uid"),
                                geometryUid: t.get("geometryUid"),
                                indices: t.get("indices"),
                                barycentricWeights: t.get("barycentricWeights"),
                                localPosition: t.get("localPosition")
                            };
                            e.push(i)
                        })), (0, o.Z)() && (0, l.Z)().apiLog && (console.log("------"), console.log("Viewer API environment hotspot list:"), this.get("hotspots").each((function (e) {
                            var t = {
                                ScenePosition: e.get("lastComputedScenePosition"),
                                WorldPosition: e.get("lastComputedWorldPosition"),
                                eye: e.get("eye"),
                                target: e.get("target"),
                                title: e.get("name"),
                                text: e.get("content") ? e.get("content").raw : ""
                            };
                            console.log(t)
                        })), console.log("------")), {
                            hotspots: e,
                            visible: this.get("visible")
                        }
                    }
                });
            const $o = Qo;
            var es = i("LLYa"),
                ts = i("eKF4"),
                is = {
                    STRIP: Uint16Array,
                    TRIANGLES: Uint16Array,
                    VERTEX: Float32Array,
                    NORMAL: Float32Array,
                    COLOR: Float32Array
                },
                ns = function (e) {
                    for (var t in e) {
                        var i = e[t];
                        e[t] = i.length ? new is[t](i) : ns(i)
                    }
                    return e
                };
            const rs = function (e) {
                i.e(4919).then(i.bind(i, "76jN")).then((function (t) {
                    e(t.default)
                }))
            },
                as = function (e) {
                    i.e(716).then(i.bind(i, "hb52")).then((function (t) {
                        e(ns(t.default))
                    }))
                },
                os = function (e) {
                    i.e(5967).then(i.bind(i, "dT0p")).then((function (t) {
                        e(ns(t.default))
                    }))
                },
                ss = function (e) {
                    i.e(1631).then(i.bind(i, "NdA1")).then((function (t) {
                        e(ns(t.default))
                    }))
                },
                ls = function (e) {
                    i.e(319).then(i.bind(i, "STgn")).then((function (t) {
                        e(ns(t.default))
                    }))
                },
                us = function (e) {
                    i.e(4199).then(i.bind(i, "SApQ")).then((function (t) {
                        e(ns(t.default))
                    }))
                },
                cs = function (e) {
                    i.e(211).then(i.bind(i, "dABv")).then((function (t) {
                        e(ns(t.default))
                    }))
                };
            var hs, ds, gs, fs, ms = g.Z.osg,
                ps = ms.BufferArray,
                vs = ms.Geometry,
                _s = ms.primitiveSet,
                Ss = ms.DrawElements,
                xs = ms.vec4.fromValues(1, 1, 1, 1),
                Cs = "WHOLE_PANEL",
                Ts = function (e, t, i, n, r, a) {
                    ms.MatrixTransform.call(this), this._subX = void 0 !== r ? r : 1, this._subY = void 0 !== a ? a : 1, this._curveAxis = i, this._curveFactor = n, this._distanceFromCam = 2.5, this._width = 1, t && (this._distanceFromCam = t), e && (this._width = e), this._clickActions = {}, this._opacity = 1, this._round = .02, this._opaqueRollover = !1, this._visible = !0, this._currentPage = 0, this._enabled = !0
                };
            Ts.AXIS_X = 0, Ts.AXIS_Y = 1, Ts.AXIS_BOTH = 2, ms.createPrototypeNode(Ts, ms.objectInherit(ms.MatrixTransform.prototype, {
                initialize: function (e, t) {
                    this._texPanel = e, this._metaData = this._computeMetaData(t), this._panelGeom = this._createGridGeometry(this._metaData.cells), this.addChild(this._panelGeom);
                    var i = this._panelGeom.getOrCreateStateSet(),
                        n = ms.Uniform.createFloat1(this._opacity, "uAlpha");
                    this._uAlpha = n.getInternalArray(), i.addUniform(n);
                    var r = ms.Uniform.createFloat1(t.aspectRatio, "uRatio");
                    this._uRatio = r.getInternalArray(), i.addUniform(r);
                    var a = ms.Uniform.createFloat1(this._enabled ? 1 : .5, "uVeilFactor");
                    this._uVeilFactor = a.getInternalArray(), i.addUniform(a), i.addUniform(ms.Uniform.createFloat1(this._opaqueRollover ? 1 : 0, "uHoveredOpaque"));
                    var o = ms.Uniform.createFloat1(this._round, "uRound");
                    i.addUniform(o), i.addUniform(ms.Uniform.createInt(0, "uTexturePanel")), i.setTextureAttributeAndModes(0, this._texPanel), i.setAttributeAndModes(Le.Z.CULL_DISABLE);
                    var s = Ne.Z.getOrCreateShader("attribute vec2 TexCoord0;\nattribute vec3 Vertex;\n\nvarying vec2 vTexCoord0;\n\n// uniform mat4 uModelMatrix;\n// uniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uModelViewMatrix;\n\nvoid main(void) {\n  vTexCoord0 = TexCoord0;\n  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex.xyz, 1.0);\n}\n", 'varying vec2 vTexCoord0;\n\nuniform sampler2D uTexturePanel;\nuniform vec4 uHoveredArea;\nuniform float uHoveredOpaque;\nuniform float uAlpha;\nuniform float uRatio;\nuniform float uRound;\nuniform float uVeilFactor;\n\n#pragma include "utils/functions.glsl"\n\n// signed distance to a 2D rounded box\nfloat sdRoundBox( const in vec2 p, const in vec2 b, const in float r ) {\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    float d = (m.x > 0.0) ? length(q) : m.y;\n    return d - r;\n}\n\nvoid main(void) {\n  vec4 color = texture2D(uTexturePanel, vTexCoord0);\n\n  float lerpValue = step(0.0, -vTexCoord0.x);\n  lerpValue += step(1.0, vTexCoord0.x);\n\n  float round = uRound;\n  float left = uHoveredArea.x + round;\n  float right = uHoveredArea.y - round;\n  float top = uHoveredArea.z - round;\n  float bottom = uHoveredArea.w + round;\n\n  vec2 halfSize = abs(vec2(left - right, top - bottom) * 0.5);\n  vec2 center = vec2(halfSize.x + left, halfSize.y + bottom);\n\n  lerpValue += max(0.0, -sign(sdRoundBox( vTexCoord0 - center, halfSize, round)));\n\n  color.rgba = mix(color.rgba, color.rgba + vec4(0.109, 0.664, 0.848, step(0.1, uHoveredOpaque)), lerpValue);\n\n  color.a *= uAlpha;\n  color.rgb *= (color.a * uVeilFactor);\n\n  gl_FragColor = color;\n}\n', "textured-panel", "TexturedPanel");
                    i.setAttributeAndModes(s);
                    var l = ms.Uniform.createFloat4(xs, "uHoveredArea");
                    this._uHoveredArea = l.getInternalArray(), i.addUniform(l), i.setRenderBinDetails(Oe.Z.VR_MENU, "RenderBin"), i.setAttributeAndModes(Le.Z.BLEND_SUBSTRACTIVE), this.initPage(), this._initialized = !0
                },
                changeTexture: function (e) {
                    var t = this._panelGeom.getOrCreateStateSet();
                    this._texPanel = e, t.setTextureAttributeAndModes(0, this._texPanel)
                },
                updateMetaData: function (e) {
                    this._metaData = this._computeMetaData(e), this._uRatio[0] = this._metaData.aspectRatio
                },
                setEnabled: function (e) {
                    this._enabled = e, this._uVeilFactor && (this._uVeilFactor[0] = e ? 1 : .5)
                },
                setMetaData: function (e) {
                    this._metaData = e, this._uRatio[0] = this._metaData.aspectRatio
                },
                getTexture: function () {
                    return this._texPanel
                },
                isInitialized: function () {
                    return this._initialized
                },
                setVisible: function (e) {
                    if (this._visible !== e) {
                        if (this._animation) {
                            if (!this._animation.isFinished()) return;
                            e && this._doSetVisible(!0), this._animation.start(0)
                        } else this._doSetVisible(e);
                        this._visible = e
                    }
                },
                _doSetVisible: function (e) {
                    this.setNodeMask(e ? Pe.Z.PICK_GEOMETRY_FAST : 0), this._uAlpha && (this._uAlpha[0] = 1), e || this.initPage()
                },
                isVisible: function () {
                    return this._visible
                },
                setOpacity: function (e) {
                    this._opacity = e, this._uAlpha && (this._uAlpha[0] = e)
                },
                updateHit: function (e) {
                    if (this._initialized && this._enabled) {
                        var t = e && e._localIntersectionPoint;
                        if (e && -1 !== e._nodePath.indexOf(this)) {
                            var i = {
                                x: (t[0] + .5 * this._width) / this._width,
                                y: (t[1] + .5 * this._height) / this._height
                            },
                                n = this._metaData.pages ? this._findPage(i) : void 0,
                                r = i.x,
                                a = i.y;
                            if (n) {
                                var o = n.areas;
                                if (o)
                                    for (var s = 0; s < o.length; s++)
                                        if (this._checkArea(o[s], r, a, n.items[s], n)) return this
                            }
                            return this._currentHovered !== Cs && (this._currentHovered = Cs, ms.vec4.copy(this._uHoveredArea, xs)), this
                        }
                        void 0 !== this._currentHovered && (this._currentHovered = void 0, ms.vec4.copy(this._uHoveredArea, xs))
                    }
                },
                _findPage: function (e) {
                    for (var t = e.x, i = e.y, n = 0; n < this._metaData.cells.length; n++) {
                        var r = this._metaData.cells[n],
                            a = r.x / this._width,
                            o = 1 - r.y / this._height,
                            s = (r.x + r.width) / this._width,
                            l = 1 - (r.y + r.height) / this._height;
                        if (t >= a && t <= s && i <= o && i >= l) return e.x = (t - a) / (s - a), e.y = (i - l) / (o - l), r.page
                    }
                },
                _checkArea: function (e, t, i, n, r) {
                    return t > e[0] && t < e[1] && i < e[2] && i > e[3] && (this._currentHovered !== n && (this._currentHovered = n, r ? (this._uHoveredArea[0] = r.x + e[0] * r.width, this._uHoveredArea[1] = r.x + e[1] * r.width, this._uHoveredArea[2] = 1 - r.y - r.height + e[2] * r.height, this._uHoveredArea[3] = 1 - r.y - r.height + e[3] * r.height) : ms.vec4.copy(this._uHoveredArea, e)), !0)
                },
                click: function () {
                    if (this._currentHovered)
                        if (this._currentHovered !== Cs) {
                            var e = this._clickActions[this._currentHovered];
                            e && e()
                        } else this._panelClickAction && this._panelClickAction()
                },
                initPage: function () {
                    this._metaData && this._metaData.pages && this.setPageForCell(this._metaData.pages[0].id, this._metaData.cells[0].id)
                },
                setPageForCell: function (e, t) {
                    var i = this._getPage(e);
                    if (i) {
                        var n = this._getCell(t);
                        if (n) {
                            n.page = i;
                            for (var r = this._panelGeom.getAttributes().TexCoord0, a = r.getElements(), o = this._subY, s = this._subX, l = n.startIndex ? n.startIndex : 0, u = 0; u <= o; u++)
                                for (var c = 0; c <= s; c++) {
                                    var h = 2 * l;
                                    a[h] = i.x + c / s * i.width, a[h + 1] = 1 - i.y - u / o * i.height, l++
                                }
                            r.dirty(), this._panelGeom.dirty()
                        } else ms.log("can't find cell named " + t + " for panel " + (this._metaData ? this._metaData.id : "unknown"))
                    } else ms.log("can't find page named " + e + " for panel " + (this._metaData ? this._metaData.id : "unknown"))
                },
                _getPage: function (e) {
                    if (this._metaData && this._metaData.pages)
                        for (var t = 0; t < this._metaData.pages.length; t++)
                            if (this._metaData.pages[t].id === e) return this._metaData.pages[t]
                },
                _getCell: function (e) {
                    var t = this._metaData && this._metaData.cells;
                    if (t)
                        for (var i = 0; i < t.length; ++i)
                            if (t[i].id === e) return t[i]
                },
                setClickAction: function (e, t) {
                    this._clickActions[e] = t
                },
                removeClickAction: function (e) {
                    delete this._clickActions[e]
                },
                setPanelClickAction: function (e) {
                    this._panelClickAction = e
                },
                removePanelClickAction: function () {
                    this._panelClickAction = void 0
                },
                displayInView: (hs = ms.vec3.create(), ds = ms.vec3.create(), gs = ms.vec3.fromValues(0, 0, .1), fs = ms.vec3.create(), function (e, t, i) {
                    ms.vec3.copy(hs, t), hs[2] = e[2];
                    var n = ms.mat4.lookAt(this.getMatrix(), e, hs, gs);
                    ms.mat4.invert(n, n);
                    var r = i;
                    ms.mat4.scale(n, n, ms.vec3.set(ds, r, r, r)), ms.vec3.sub(fs, hs, e), ms.vec3.normalize(fs, fs), ms.vec3.scale(fs, fs, this._distanceFromCam * i), ms.vec3.add(fs, e, fs), fs[2] += -.2 * i, ms.mat4.setTranslation(n, fs), this.dirtyBound(), this.setVisible(!0)
                }),
                setAnimation: function (e) {
                    e.setOnFinishCallback(this._onAnimationFinished.bind(this)), this._animation = e, this.addUpdateCallback(e)
                },
                getAnimation: function () {
                    return this._animation
                },
                _onAnimationFinished: function () {
                    this._visible || this._doSetVisible(!1)
                },
                _computeMetaData: function (e) {
                    var t, i, n = (0, Ia.Z)(e, {
                        aspectRatio: e.cellsWidth ? e.cellsWidth / e.cellsHeight : e.width / e.height
                    });
                    if (this._height = this._width / n.aspectRatio, n.pages)
                        for (i = 0; i < n.pages.length; i++) {
                            var r = n.pages[i];
                            if (r.areas)
                                for (t = 0; t < r.areas.length; t++) {
                                    var a = r.areas[t];
                                    a[0] = a[0] / r.width, a[1] = a[1] / r.width, a[2] = 1 - a[2] / r.height, a[3] = 1 - a[3] / r.height
                                }
                            r.x /= e.width, r.y /= e.height, r.width /= e.width, r.height /= e.height
                        }
                    if (n.cells && n.cells.length > 0)
                        for (t = 0; t < n.cells.length; t++) {
                            var o = n.cells[t];
                            o.x = o.x / n.cellsWidth * this._width, o.y = o.y / n.cellsHeight * this._height, o.z /= 100, o.width = o.width / n.cellsWidth * this._width, o.height = o.height / n.cellsHeight * this._height
                        } else n.cells = [{
                            id: "default",
                            x: 0,
                            y: 0,
                            z: 0,
                            width: this._width,
                            height: this._height
                        }];
                    return n
                },
                _createTexturedGridGeometry: function (e, t, i, n, r, a, o, s, l, u, c, h) {
                    t *= -1, s && (l = void 0 !== l ? l : .2);
                    for (var d = n / a, g = r / o, f = this._verticesIndex, m = 0, p = 0, v = this._indicesIndex, _ = 0, S = 0, x = 0; x <= o; x++)
                        for (var C = 0; C <= a; C++) m = 3 * f, c[p = 2 * f] = C / a, c[p + 1] = 1 - x / o, s && (s !== Ts.AXIS_X && s !== Ts.AXIS_BOTH || (_ = (_ = C / a - .5) * _ * l), s !== Ts.AXIS_Y && s !== Ts.AXIS_BOTH || (S = (S = x / o - .5) * S * l)), u[m] = e + d * C, u[m + 1] = t - g * x, u[m + 2] = i + _ + S, f++;
                    var T = this._verticesIndex;
                    this._verticesIndex = f;
                    for (var M = 0; M < a * o; M++) v = this._indicesIndex + 6 * M, f = T + M + Math.floor(M / a), h[v] = f, h[v + 1] = a + 1 + f, h[v + 2] = a + 1 + f + 1, h[v + 3] = a + 1 + f + 1, h[v + 4] = f + 1, h[v + 5] = f;
                    this._indicesIndex = v + 6
                },
                _createGridGeometry: function (e) {
                    var t = this._subY,
                        i = this._subX,
                        n = (i + 1) * (t + 1) * e.length,
                        r = new vs,
                        a = new Float32Array(3 * n),
                        o = new Float32Array(2 * n),
                        s = new Uint8Array(i * t * 6 * e.length);
                    this._verticesIndex = 0, this._indicesIndex = 0;
                    for (var l = .5 * this._width, u = .5 * this._height, c = 0; c < e.length; c++) {
                        var h = e[c];
                        h.startIndex = this._verticesIndex, this._createTexturedGridGeometry(h.x - l, h.y - u, h.z, h.width, h.height, i, t, this._curveAxis, this._curveFactor, a, o, s)
                    }
                    r.getAttributes().Vertex = new ps(ps.ARRAY_BUFFER, a, 3), r.getAttributes().TexCoord0 = new ps(ps.ARRAY_BUFFER, o, 2);
                    var d = new Ss(_s.TRIANGLES, new ps(ps.ELEMENT_ARRAY_BUFFER, s, 1));
                    return r.getPrimitives().push(d), r
                }
            }), "osgtestdemo2024", "TexturedPanel");
            const Ms = Ts;
            var bs = i("5Eyw"),
                ys = i.n(bs),
                As = i("Hjnd"),
                Rs = i.n(As),
                ws = i("+VSF"),
                Es = g.Z.osg,
                Ps = new (ys())({
                    device: "VWR",
                    listen: !0
                }),
                Ns = {},
                Os = function (e) {
                    return 1 << Math.ceil(Math.log2(e))
                },
                Ds = function (e) {
                    var t, i, n = 0;
                    if (0 === e.length) return n;
                    for (t = 0, i = e.length; t < i; t++) n = (n << 5) - n + e.charCodeAt(t), n |= 0;
                    return "vr-browser-" + n
                },
                Is = function (e, t, i, n, r, a) {
                    Ms.call(this, e, t, i, n, r, a), this._uPaginate = void 0, this._textureWidth = 1024, this._textureHeight = 1024, this._useCache = !1
                };
            Is.prototype = Es.objectInherit(Ms.prototype, {
                initialize: function (e, t, i) {
                    ws.Z && !(0, l.Z)().isApp || (t = (0, Ia.Z)({}, t), rs(function (n) {
                        this._styles = n.vrStyles, this._appendVrElement();
                        var r = Rs()(n.TEMPLATES.getFromMacro(e, "panel", [t]));
                        this._templatePath = e, r.css("position", "absolute"), r.css("top", "0"), r.css("left", "0"), this._$uiPanelsDiv.append(r);
                        var a = this._extractMetaData(r);
                        if (this._useCache) {
                            var o = Ds(r.html()),
                                s = localStorage.getItem(o);
                            if (s) {
                                var u = new Image;
                                return u.crossOrigin = "anonymous", u.onload = function () {
                                    var e = new Es.Texture;
                                    e.setTextureSize(1, 1), e.setImage(u), this._applyTexture(e, a, i)
                                }.bind(this), u.src = s, void r.remove()
                            }
                        }
                        if (!(0, l.Z)().vrGenerateUiTextures) return i(hr.Z.dummyTexture, a), void r.remove();
                        this._rasterizeElement(n.rasterizeHTML, r).then(function (e) {
                            if (this._useCache) {
                                var t = e.toDataURL(),
                                    i = Ds(r.html());
                                this._storeInCache(i, t)
                            }
                            var n = new Es.Texture;
                            return n.setTextureSize(1, 1), n.setImage(e), n
                        }.bind(this)).then(function (e) {
                            this._applyTexture(e, a, i)
                        }.bind(this)), r.remove()
                    }.bind(this)))
                },
                _storeInCache: function (e, t) {
                    try {
                        localStorage.setItem(e, t)
                    } catch (n) {
                        localStorage.removeItem(localStorage.key(0));
                        for (var i = 0; i < localStorage.length && 0 !== localStorage.key(i).indexOf("vr-browser-"); i++) localStorage.removeItem(localStorage.key(i));
                        this._storeInCache(e, t)
                    }
                },
                setUseCache: function (e) {
                    this._useCache = e || !1
                },
                _applyTexture: function (e, t, i) {
                    this.isInitialized() ? (this.changeTexture(e), this.updateMetaData(t)) : Ms.prototype.initialize.call(this, e, t), i && i(e, t)
                },
                _appendVrElement: function () {
                    this._$uiPanelsDiv = Rs()("#vr-ui-panels"), this._$uiPanelsDiv.length || (this._$uiPanelsDiv = Rs()('<div id="vr-ui-panels" style="position:absolue; top:0;bottom:0;left:0;right:0; background:transparent"/>'), Rs()("body").append(this._$uiPanelsDiv), this._$uiPanelsDiv.append('<style id="vr-panel-style">' + this._styles + "</style>"))
                },
                _rasterizeElement: function (e, t) {
                    var i = document.createElement("canvas");
                    return i.width = t.outerWidth(), i.height = t.outerHeight(), e.drawHTML(this._$uiPanelsDiv.prop("outerHTML"), i, {
                        cacheBucket: Ns,
                        cache: "all"
                    }).then(function (e) {
                        if (jr.default.apple.phone) {
                            var t = "data:image/svg+xml;base64," + window.btoa(unescape(encodeURIComponent(e.svg))),
                                n = (0, Wo.Z)("rasterize");
                            return Ps.createMessage({
                                data: {
                                    _key: n,
                                    height: i.height + "",
                                    width: i.width + "",
                                    svg: t
                                }
                            }).appendToHash(), new (d())((function (e) {
                                Ps.on("message:" + n, (function (t) {
                                    var i, n = new Image;
                                    n.crossOrigin = "anonymous", n.onload = function () {
                                        e(n)
                                    }, t.b64 && (i = t.b64), t.data.b64 && (i = t.data.b64), i.indexOf("%3D") > -1 && (i = decodeURIComponent(i)), -1 === i.indexOf("data:image/png") && (i = "data:image/png;base64," + i), n.src = i
                                }))
                            }))
                        }
                        if (this._textureWidth = Os(i.width), this._textureHeight = Os(i.height), i.width === this._textureWidth && i.height === this._textureHeight) return i;
                        var r = document.createElement("canvas");
                        return r.width = this._textureWidth, r.height = this._textureHeight, r.getContext("2d").drawImage(i, 0, 0, this._textureWidth, this._textureHeight), r
                    }.bind(this), (function (e) {
                        console.log(e)
                    }))
                },
                _extractMetaData: function (e) {
                    var t = e.find(".page"),
                        i = e.outerHeight(!0),
                        n = e.outerWidth(!0),
                        r = {
                            id: e.attr("id"),
                            width: n,
                            height: i,
                            cells: [],
                            pages: []
                        };
                    if (0 === t.length) this._extractButtons(e, r, 0, "default");
                    else
                        for (var a = 0; a < t.length; a++) this._extractButtons(Rs()(t[a]), r, a, t[a].id);
                    return this._extractCells(e, r), r
                },
                _extractButtons: function (e, t, i, n) {
                    if (n) {
                        var r = e.find("button"),
                            a = e.offset().top,
                            o = e.offset().left,
                            s = e.outerHeight(!0),
                            l = e.outerWidth(!0);
                        t.pages[i] = {
                            id: n,
                            num: i,
                            x: o,
                            y: a,
                            width: l,
                            height: s,
                            items: [],
                            areas: []
                        };
                        for (var u = 0; u < r.length; u++) {
                            var c = r[u].id,
                                h = r[u].disabled;
                            if (c && !h) {
                                var d = Rs()(r[u]),
                                    g = Es.vec4.create();
                                g[0] = d.offset().left - o, g[1] = g[0] + d.outerWidth(), g[2] = d.offset().top - a, g[3] = g[2] + d.outerHeight(), g[0] > t.width && (g[0] %= t.width), g[1] > t.width && (g[1] %= t.width), t.pages[i].items.push(c), t.pages[i].areas.push(g)
                            }
                        }
                    }
                },
                _extractCells: function (e, t) {
                    for (var i = e.find(".cell"), n = e.offset().top, r = e.offset().left, a = 0, o = 1 / 0, s = 1 / 0, l = 0, u = 0; u < i.length; u++) {
                        var c = i[u].id;
                        if (c) {
                            var h = Rs()(i[u]),
                                d = {};
                            d.id = c, d.x = h.offset().left - r, d.y = h.offset().top - n;
                            var g = h.css("z-index");
                            d.z = isNaN(g) ? 0 : g, d.width = h.outerWidth(!1), d.height = h.outerHeight(!1);
                            var f = d.x + d.width;
                            f > a && (a = f), d.x < o && (o = d.x);
                            var m = d.y + d.height;
                            m > l && (l = m), d.y < s && (s = d.y), t.cells[u] = d
                        }
                    }
                    0 === i.length ? (t.cellsWidth = e.outerWidth(!1), t.cellsHeight = e.outerHeight(!1)) : (t.cellsWidth = a - o, t.cellsHeight = l - s)
                }
            });
            const Fs = Is;
            var Ls = g.Z.osg,
                Vs = function (e, t) {
                    Fs.call(this, e, t), this._round = .005
                };
            Vs.prototype = Ls.objectInherit(Fs.prototype, {
                initialize: function (e, t) {
                    Fs.prototype.initialize.call(this, e, t, function () {
                        this.setClickAction("nextPage", function () {
                            this.setPage(this._currentPage + 1)
                        }.bind(this)), this.setClickAction("prevPage", function () {
                            this.setPage(this._currentPage - 1)
                        }.bind(this))
                    }.bind(this)), this._nbColumns = t.column, this._currentPage = 0
                },
                setHinted: function (e) {
                    this._hinted = e, this.setNodeMask(e ? Pe.Z.NO_PICK : 0), this._uAlpha && (this._uAlpha[0] = .1)
                },
                isHinted: function () {
                    return this._hinted
                },
                getNbPage: function () {
                    return this._nbColumns
                },
                getCurrentPage: function () {
                    return this._currentPage
                },
                setPage: function (e) {
                    if (this._currentPage !== e) {
                        var t = this.getNbPage(),
                            i = Math.min(t - 1, Math.max(0, e));
                        this.setPageForCell("column" + i, "default"), this._currentPage = i
                    }
                }
            });
            const Bs = Vs;
            i("S+Xm");
            var Us = g.Z.osg,
                ks = g.Z.osgUtil,
                Zs = Us.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0),
                Hs = ks.GizmoGeometry.createCylinderGeometry(.0025, .0025, 1, 8, 1, !1, !1),
                Gs = new Us.MatrixTransform;
            Gs.getMatrix()[14] = .5, Gs.addChild(Hs), Hs._boundingBoxComputed = !0, Hs._boundingSphereComputed = !0;
            var zs = function (e, t) {
                Us.Node.call(this), this._idHotspot = e, this._viewer = t, this._hotspotMT = new Us.MatrixTransform, this._cardPanel = new Bs, this._lineToCardMT = new Us.MatrixTransform, this._hotspotMT.addChild(Zs), this.addChild(this._hotspotMT), this.addChild(this._lineToCardMT), this.addChild(this._cardPanel), this._cardPanel.setVisible(!1), this._lineToCardMT.setNodeMask(0), this._worldTeleportPos = void 0, this._cardInitialized = !1, this._texCard = new Us.Texture, this._texCard.setTextureSize(1, 1), this._canTeleport = !1, this._uAlpha = void 0, this._color = void 0, this._lineToCardMT.addChild(Gs), this._hotspotMT._boundingBoxComputed = !0, this._hotspotMT._boundingSphereComputed = !0, this.init()
            };
            zs.COLOR_NORMAL = Us.vec3.fromValues(1, 1, 1), zs.COLOR_HOVERED = Us.vec3.fromValues(0, .8, 1), zs.COLOR_DRAG_OK = Us.vec3.fromValues(0, .4, 1), zs.COLOR_DRAG_FAIL = Us.vec3.fromValues(.8, .2, .2), zs.initLineShader = function (e) {
                var t = Hs.getOrCreateStateSet();
                t.setAttributeAndModes(e), t.addUniform(Us.Uniform.createFloat4(Us.vec4.fromValues(.03, .59, .78, .4), "uLineColor")), t.setRenderBinDetails(Oe.Z.TOOLTIP, "RenderBin")
            }, Us.createPrototypeNode(zs, Us.objectInherit(Us.Node.prototype, {
                init: function () {
                    var e = this.getOrCreateStateSet();
                    e.addUniform(Us.Uniform.createFloat(this._idHotspot, "uHotspotIndex"));
                    var t = Us.Uniform.createFloat3(Us.vec3.fromValues(1, 1, 1), "uColor");
                    this._color = t.getInternalArray(), e.addUniform(t)
                },
                getIndex: function () {
                    return this._idHotspot
                },
                getHotspotMatrix: function () {
                    return this._hotspotMT.getMatrix()
                },
                getColor: function () {
                    return this._color
                },
                isFullyVisibleCard: function () {
                    return this._cardPanel.isVisible()
                },
                isVisibleCard: function () {
                    return this._cardPanel.isHinted() || this._cardPanel.isVisible()
                },
                canTeleport: function () {
                    return this._canTeleport && !this.isFullyVisibleCard()
                },
                setWorldTeleportPosition: function () {
                    var e = Us.vec3.create(),
                        t = Us.vec3.create(),
                        i = Us.vec3.create();
                    return function (n, r, a) {
                        if (!this.isFullyVisibleCard()) {
                            var o = this._cardPanel.getMatrix();
                            this._worldTeleportPos = Us.vec3.copy(this._worldTeleportPos || Us.vec3.create(), r), Us.vec3.copy(i, r), i[2] += 1.5 * a, Us.vec3.sub(t, n, i), t[2] = 0, Us.vec3.normalize(t, t), Us.vec3.scale(t, t, 1 * a), Us.vec3.add(t, i, t), this.lookToWorld(o, t, i, a), Us.vec3.sub(e, r, n);
                            var s = Us.vec3.length(e);
                            Us.vec3.sub(e, r, t);
                            var l = s < Us.vec3.length(e) ? -1 : 1;
                            t[2] += .5 * l * .5625 * a;
                            var u = this._lineToCardMT.getMatrix();
                            this.lookToWorld(u, n, t, 1);
                            var c = Us.vec3.dist(t, n);
                            Us.vec3.set(e, a, a, c), Us.mat4.scale(u, u, e), this._cardPanel.dirtyBound()
                        }
                    }
                }(),
                setCardVisibilityListener: function (e) {
                    this._cardVisibilityListener = e
                },
                setVisibleCard: function (e) {
                    this._isCardInitialized || this.initCard(), this._cardPanel.setVisible(e), this._lineToCardMT.setNodeMask(e ? Pe.Z.NO_PICK : 0), this._cardVisibilityListener && this._cardVisibilityListener(this, e)
                },
                setVisible: function (e) {
                    this.setNodeMask(e ? -1 : 0)
                },
                setHovered: function (e) {
                    this._isCardInitialized || this.initCard(), Us.vec3.copy(this.getColor(), e ? zs.COLOR_HOVERED : zs.COLOR_NORMAL), this.isFullyVisibleCard() || (this._cardPanel.setHinted(e), this._lineToCardMT.setNodeMask(e ? Pe.Z.NO_PICK : 0))
                },
                initCard: function () {
                    var e = Rs()(".hotspots"),
                        t = Rs()(e.get(0).childNodes[this._idHotspot]),
                        i = this._viewer.getFeatures().hotspot._views[0]._hotspots;
                    this._setDescriptionStyle(t, {
                        width: "1024px",
                        lineHeight: "2",
                        fontSize: "38px"
                    });
                    var n = t.find(".description").outerHeight() + 4 * t.find(".title").outerHeight(),
                        r = Math.max(1, Math.round(n / 576) + (n % 576 > 0 ? 1 : 0));
                    this._setDescriptionStyle(t, null), this._cardPanel.initialize("front/macros/hotspot", {
                        hotspotIndex: this._idHotspot,
                        displayNavigation: i.length && i.length > 1,
                        column: r,
                        widthContent: 1024 * r,
                        title: t.find(".title")[0].innerText,
                        description: t.find(".description").html()
                    }), this._isCardInitialized = !0
                },
                _setDescriptionStyle: function (e, t) {
                    e.find(".description").css({
                        width: null !== t ? t.width : "",
                        lineHeight: null !== t ? t.lineHeight : "",
                        fontSize: null !== t ? t.fontSize : ""
                    })
                },
                updateCardHit: function (e) {
                    this._hoveredCard = this._cardPanel.updateHit(e)
                },
                onCardHit: function (e) {
                    this._isCallbackSetup || (this._setupCallback(e), this._isCallbackSetup = !0), this._hoveredCard ? this._cardPanel.click() : this._cardPanel.setVisible(!1)
                },
                _setupCallback: function (e) {
                    this._cardPanel.setClickAction("closeButton", function () {
                        this.setVisibleCard(!1)
                    }.bind(this)), this._cardPanel.setClickAction("nextButton", (function () {
                        e.goToNextHotspot()
                    })), this._cardPanel.setClickAction("prevButton", (function () {
                        e.goToPrevHotspot()
                    }))
                },
                lookToWorld: function () {
                    var e = Us.vec3.create(),
                        t = Us.vec3.fromValues(0, 0, -1),
                        i = Us.mat4.fromXRotation(Us.mat4.create(), Math.PI);
                    return function (n, r, a, o) {
                        Us.mat4.lookAt(n, r, a, t), Us.mat4.multiply(n, i, n), Us.mat4.invert(n, n), Us.mat4.scale(n, n, Us.vec3.set(e, o, o, o))
                    }
                }(),
                updatePositionVR: function (e, t, i, n) {
                    var r = this._hotspotMT.getMatrix(),
                        a = e.get("lastComputedWorldPosition");
                    i = Math.max(1.5 * i, .1 * n), i = Math.min(4 * i, i), this.lookToWorld(r, a, t, i);
                    var o = 1 / 0;
                    this._worldTeleportPos && (o = Us.vec2.dist(this._worldTeleportPos, t));
                    var s = o < .5 * n;
                    this._canTeleport = !s, this._hotspotMT.dirtyBound()
                },
                updatePosition: function () {
                    var e = Us.vec3.create();
                    return function (t, i, n, r) {
                        var a = this._hotspotMT.getMatrix(),
                            o = t.get("lastComputedWorldPosition");
                        Us.mat4.copy(a, r), Us.vec3.set(e, n, n, n), Us.mat4.scale(a, a, e), Us.mat4.setTranslation(a, o), this.isVisibleCard() && this.setVisibleCard(!1), this._hotspotMT.dirtyBound()
                    }
                }()
            }), "osgtestdemo2024", "Hotspot");
            const Ws = zs;
            var js = i("RyS8");
            var Xs, Ys, Js = g.Z.osg,
                qs = g.Z.InputGroups,
                Ks = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this._nodeHotspot = new Js.Node, this._nodeHotspot.setName("Feature - Hotspot"), this._hotspots = this.model.get("hotspots");
                        var e = this._hotspots.length > 0;
                        Kn.setHotspot(e), this.model.set("started", e), this._hotspots.on("sort", U.Z.draw), this._hotspots.on("remove", this.onHotspotRemoved, this), this._hotspots.on("add", this.onHotspotAdded, this), this._hotspots.on("select", this.onHotspotSelected, this), this._hotspots.on("inserted", this.onHotspotInserted, this), this.model.on("change:started", this.onHotspotStarted, this), this.model.on("change:visible", this.onVisible, this), this.model.on("change:textureOptions", this.setTextureHotspot, this), this._lastSuccessHit = void 0;
                        var t = this.options.context;
                        this._viewer = t.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._manipulator = this._viewerOSGJS.getManipulator(), this._inputManager = this._viewerOSGJS.getInputManager(), this._idDragging = -1, this._dragHotspotStarted = !1, this._lastHoveredIndex = -1, this._dragCamera = !1, this._lastCoordNotDragging = Js.vec2.create(), this._proxyHotspot = new Js.Node, this._proxyHotspot.setName("Hotspot - Proxy"), this._proxyHotspot.setNodeMask(0), this._nodeHotspot.addChild(this._proxyHotspot), this.initHotspotProxy(), this._hotspots.each(this.onHotspotAdded.bind(this)), (e || (0, o.Z)()) && L.Z.getModelDisplayed().then(this.hotspotReady.bind(this))
                    },
                    onHotspotStarted: function () {
                        this.model.get("proxyModel") && this.model.get("proxyModel").set("annotationsVisible", !0), Kn.setHotspot(!0), this.hotspotReady()
                    },
                    getNodeHotspot: function () {
                        return this._nodeHotspot
                    },
                    getNodeProxy: function () {
                        return this._proxyHotspot
                    },
                    getScreenThresholdHover: function () {
                        return 20 * Ie.Z.getPixelRatio()[0]
                    },
                    onVisible: function () {
                        this._proxyHotspot.setNodeMask(this.model.get("visible") ? Pe.Z.NO_SHADOW : 0), U.Z.draw()
                    },
                    hotspotReady: function () {
                        Ve.Z.initHotspot(this), this.onVisible();
                        var e = this._viewer.getFeaturesManager().getTextureDepth();
                        e && this._proxyHotspot.getOrCreateStateSet().setTextureAttributeAndModes(0, e), U.Z.draw()
                    },
                    onHotspotInserted: function () {
                        for (var e = 0; e < this._proxyHotspot.children.length; e++) this._proxyHotspot.children[e].initCard()
                    },
                    initHotspotProxy: function () {
                        if (!this._proxyInitialized && this.model.get("hotspots").length) {
                            this._proxyHotspot.setCullCallback(this);
                            var e = this._proxyHotspot.getOrCreateStateSet();
                            e.setRenderBinDetails(Oe.Z.HOTSPOT, "RenderBin"), e.setAttributeAndModes(Le.Z.DEPTH_DISABLE), e.setAttributeAndModes(Le.Z.BLEND_SUBSTRACTIVE), this.model.set("textureOptions", {
                                url: De.iconHotspot,
                                colNumber: 10,
                                padding: 2,
                                iconSize: 48
                            }), this.setTextureHotspot(), e.addUniform(Js.Uniform.createInt(0, "uTextureDepth")), e.addUniform(Js.Uniform.createInt(1, "uTextureHotspot")), e.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec2 TexCoord0;\nattribute vec3 Vertex;\n\nvarying vec2 vTexCoord0;\nvarying vec4 vViewPos;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec2 uHotspotTextureSize;\nuniform float uHotspotCol;\n\nuniform float uHotspotIndex;\nuniform float uHotspotSize;\nuniform float uHotspotPadding;\n\n\nvoid main(void) {\n  // icon size uHotspotSize (48) pixel width\n  // uHotspotPadding (2) pixel padding between them (mipmapping)\n  vec2 ICON_SIZE = uHotspotSize / vec2(uHotspotTextureSize.x, -uHotspotTextureSize.y);\n  vec2 ICON_AND_PADDING = ICON_SIZE + uHotspotPadding / vec2(uHotspotTextureSize.x, -uHotspotTextureSize.y);\n\n  vec2 offset = vec2(mod(uHotspotIndex, uHotspotCol), floor(uHotspotIndex / uHotspotCol));\n  vTexCoord0 = vec2(TexCoord0.x, 1.0 - TexCoord0.y) * ICON_SIZE + offset * ICON_AND_PADDING;\n\n  vViewPos = uModelViewMatrix * vec4(Vertex.xyz, 1.0);\n  gl_Position = uProjectionMatrix * vViewPos;\n} \n", '#pragma include "utils/decodeDepth.glsl"\n\nvarying vec2 vTexCoord0;\nvarying vec4 vViewPos;\n\nuniform sampler2D uTextureHotspot;\nuniform vec3 uColor;\n\nuniform sampler2D uTextureDepth;\nuniform vec2 uGlobalTexSize;\nuniform vec2 uGlobalTexRatio;\nuniform vec2 uNearFar;\n\nconst float BIAS_VISIBILITY = 0.05;\n\nvoid main(void) {\n  float distDepth = distanceToDepth(uTextureDepth, uGlobalTexRatio * gl_FragCoord.xy / uGlobalTexSize, vViewPos, uNearFar);\n  float alpha = distDepth < BIAS_VISIBILITY ? 1.0 : 0.1;\n\n  gl_FragColor = vec4(uColor, 1.0) * texture2D(uTextureHotspot, vTexCoord0);\n  gl_FragColor.a *= alpha;\n\n  gl_FragColor.rgb *= gl_FragColor.a;\n}\n', "hotspot", "Hotspot")), e.setAttributeAndModes(Le.Z.CULL_DISABLE), Ws.initLineShader(Ne.Z.getOrCreateShader("attribute vec3 Vertex;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex.xyz, 1.0));\n}\n", 'uniform vec4 uLineColor;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n    vec4 color = sRGBToLinear(uLineColor);\n    color.rgb *= color.a;\n    gl_FragColor = linearTosRGB(color);\n}\n', "hotspotline", "VRHotspotLine")), this._proxyInitialized = !0
                        }
                    },
                    setTextureHotspot: function () {
                        var e = this.model.get("textureOptions"),
                            t = this._proxyHotspot.getOrCreateStateSet();
                        if (e.url) {
                            var i = s.Z.instance.getOrCreateTexture(e.url, {
                                internalFormat: Js.Texture.RGBA
                            });
                            t.setTextureAttributeAndModes(1, i.texture), i.promise.then(function (e) {
                                this._textureSize ? this._textureSize.setVec2(Js.vec2.fromValues(e._textureWidth, e._textureHeight)) : (this._textureSize = Js.Uniform.createFloat2(Js.vec2.fromValues(e._textureWidth, e._textureHeight), "uHotspotTextureSize"), t.addUniform(this._textureSize))
                            }.bind(this))
                        }
                        e.colNumber && (this._iconsCol ? this._iconsCol.setFloat(e.colNumber) : (this._iconsCol = Js.Uniform.createFloat(e.colNumber, "uHotspotCol"), t.addUniform(this._iconsCol))), e.padding && (this._iconPadding ? this._iconPadding.setFloat(e.padding) : (this._iconPadding = Js.Uniform.createFloat(e.padding, "uHotspotPadding"), t.addUniform(this._iconPadding))), e.iconSize && (this._iconSize ? this._iconSize.setFloat(e.iconSize) : (this._iconSize = Js.Uniform.createFloat(e.iconSize, "uHotspotSize"), t.addUniform(this._iconSize)))
                    },
                    createHotspot: function (e) {
                        if ("annotations" === this._viewer.getOptions().widgetAPI.getTabbedWidget().get()) {
                            var t = this.options.context.getModel().toJSON(),
                                i = (0, es.A8)(t),
                                n = Ft.Z.maxHotspotsPerModel[i];
                            if (this._hotspots.length >= n) this.model.trigger("hotspot-error", new js.r(void 0, "hotspot", this._hotspots.length, n, ts.Z.me().toJSON().account));
                            else if (this._viewer.getFeaturesManager()) {
                                var r = Fe.Z.pickNearestSurface(e);
                                r && this.model.createHotspot(r)
                            }
                        }
                    },
                    getColorHotspot: function (e) {
                        return this._proxyHotspot.getChildren()[e].getColor()
                    },
                    setHotspotHovered: function (e, t) {
                        t >= 0 && Js.vec3.copy(this.getColorHotspot(t), e ? Ws.COLOR_HOVERED : Ws.COLOR_NORMAL)
                    },
                    updateCameraDragged: function () {
                        var e = Js.vec2.create();
                        return function (t) {
                            this._dragCamera = this._dragCamera || Js.vec2.dist(Js.vec2.set(e, t.glX, t.glX), this._lastCoordNotDragging) > 5
                        }
                    }(),
                    hoverHotspot: function (e) {
                        var t = this.pickHotspot(e);
                        this.setHotspotHovered(0, this._lastHoveredIndex), this.setHotspotHovered(1, t), -1 === this._idDragging && Js.vec2.set(this._lastCoordNotDragging, e.glX, e.glY), this._lastHoveredIndex !== t && (-1 !== this._lastHoveredIndex && this._viewer.trigger("annotationMouseLeave", this._lastHoveredIndex), -1 !== t && this._viewer.trigger("annotationMouseEnter", t), this._lastHoveredIndex = t, U.Z.draw())
                    },
                    selectHotspot: function (e) {
                        var t = this.pickHotspot(e);
                        this._hotspots.trigger("select", this._hotspots.at(t))
                    },
                    startDrag: function (e) {
                        this._idDragging = this.pickHotspot(e), this._dragCamera = !1, Js.vec2.set(this._lastCoordNotDragging, e.glX, e.glY), this._idDragging >= 0 && this._inputManager.setEnable(qs.MANIPULATORS, !1)
                    },
                    cancelDrag: function () {
                        this._dragCamera = !0, this.stopDrag()
                    },
                    stopDrag: function () {
                        this._dragCamera ? this._idDragging >= 0 && (this._lastSuccessHit && (0, Jo.hP)(this._hotspots.at(this._idDragging), this._lastSuccessHit), Js.vec3.copy(this.getColorHotspot(this._idDragging), Ws.COLOR_NORMAL), U.Z.draw()) : this._hotspots.trigger("select", this._hotspots.at(this._idDragging)), this._idDragging >= 0 && this._inputManager.setEnable(qs.MANIPULATORS, !0), this._dragHotspotStarted = !1, this._dragCamera = !1, this._idDragging = -1
                    },
                    dragHotspot: function () {
                        var e = Js.vec3.create();
                        return function (t) {
                            if (!(this._idDragging < 0) && (this.updateCameraDragged(t), this._dragHotspotStarted = !0, Fe.Z.isInitialized())) {
                                var i = Fe.Z.pickNearestSurface(t),
                                    n = this._hotspots.at(this._idDragging);
                                Js.vec3.copy(this.getColorHotspot(this._idDragging), i ? Ws.COLOR_DRAG_OK : Ws.COLOR_DRAG_FAIL), i ? (this._lastSuccessHit = i, (0, Jo.hP)(n, i)) : (Js.vec2.set(e, t.glX, t.glY), e[2] = Fe.Z.getScreenPositionFromScenePoint(n.get("position"), Js.vec3.create())[2], Fe.Z.getScenePositionFromScreenPoint(e, n.get("position")), n.set("geometryUid", -1)), U.Z.draw()
                            }
                        }
                    }(),
                    onHotspotSelected: (Xs = Js.vec3.create(), Ys = Js.vec3.create(), function (e) {
                        if (e) {
                            var t = this._hotspots.indexOf(e),
                                i = this._viewer.getFeaturesManager();
                            i && (e.get("cameraPreventMove") || (Js.vec3.copy(Xs, e.get("eye")), Js.vec3.copy(Ys, e.get("target")), i.applyAutospinToCamera(Xs, Ys), i.focusOnTargetAndEye(Ys, Xs, e.get("cameraPreventAnimation") ? 0 : 1.5)), this._viewer.trigger("annotationSelect", t), U.Z.draw())
                        } else this._viewer.trigger("annotationSelect", -1)
                    }),
                    onHotspotAdded: function (e) {
                        this._proxyInitialized || this.initHotspotProxy();
                        var t = new Ws(this._hotspots.indexOf(e), this._viewer);
                        t.setCardVisibilityListener(this._onCardVisibilityChange.bind(this)), this._proxyHotspot.addChild(t), U.Z.draw()
                    },
                    _onCardVisibilityChange: function (e, t) {
                        t ? this._viewer.trigger("annotationFocus", e.getIndex()) : this._viewer.trigger("annotationBlur", e.getIndex())
                    },
                    onHotspotRemoved: function () {
                        this.setHotspotHovered(0, this._lastHoveredIndex), this._lastHoveredIndex = -1;
                        var e = this._proxyHotspot.getChildren();
                        this._proxyHotspot.removeChild(e[e.length - 1]), U.Z.draw()
                    },
                    screenDistanceToHotspot: function () {
                        var e = Js.vec3.create();
                        return function (t, i) {
                            return Fe.Z.getScreenPositionFromWorldPoint(t.get("lastComputedWorldPosition"), e), Js.vec2.dist(e, i)
                        }
                    }(),
                    pickHotspot: function () {
                        var e = Js.vec2.create(),
                            t = Js.vec3.create();
                        return function (i) {
                            if (!this._viewer.getFeaturesManager() || !this.model.get("visible")) return -1;
                            Js.vec2.set(e, i.glX, i.glY);
                            for (var n = 1 / 0, r = this._hotspots.length, a = -1, o = this.getScreenThresholdHover(), s = this._hotspots, l = 0; l < r; ++l) {
                                var u = s.at(l);
                                if (u.get("visible") && (Fe.Z.getScreenPositionFromWorldPoint(u.get("lastComputedWorldPosition"), t), t[2] <= 1 && t[2] >= 0)) {
                                    var c = Js.vec2.dist(t, e);
                                    c < o && c < n && (n = c, a = l)
                                }
                            }
                            return a
                        }
                    }(),
                    cull: function () {
                        var e = Js.mat4.create(),
                            t = Js.quat.create(),
                            i = Js.vec3.create();
                        return function () {
                            this.model.callback && this.model.callback();
                            var n = this._viewer.getFeaturesManager();
                            this._lastHoveredIndex >= 0 && -1 === this._idDragging && (this.screenDistanceToHotspot(this._hotspots.at(this._lastHoveredIndex), this._lastCoordNotDragging) >= this.getScreenThresholdHover() && this.setHotspotHovered(0, this._lastHoveredIndex));
                            var r = this._hotspots,
                                a = this._proxyHotspot.getChildren(),
                                o = a.length,
                                s = this._viewer.getFeatures().webVR.getModel().get("worldFactor"),
                                l = this.model.get("webVR");
                            this._manipulator.getEyePosition(i);
                            var u = n.getIconScaleFov();
                            if (!l) {
                                var c = this._viewer.getCamera();
                                Js.mat4.invert(e, c.getViewMatrix()), Js.mat4.fromQuat(e, Js.mat4.getRotation(t, e))
                            }
                            for (var h = 0; h < o; ++h) {
                                var d = a[h],
                                    g = r.at(h);
                                if (g.get("visible")) {
                                    d.setVisible(!0), (0, Jo.kR)(g);
                                    var f = g.get("lastComputedWorldPosition"),
                                        m = Js.vec3.dist(f, i) / u;
                                    l ? d.updatePositionVR(g, i, m, s) : d.updatePosition(g, i, m, e)
                                } else d.setVisible(!1)
                            }
                            return !0
                        }
                    }()
                });
            var Qs = {
                FeatureName: "hotspot",
                ModelType: $o,
                ViewListType: [Ks]
            },
                $s = n.Z.create(Qs);
            $s.prototype.getNode = function () {
                return this._views[0].getNodeHotspot()
            }, $s.prototype.getWidgetNode = function () {
                return this._views[0].getNodeProxy()
            };
            const el = $s;
            var tl = g.Z.osg,
                il = g.Z.osgUtil,
                nl = a.Z.extend({
                    getModelOptionPath: function () {
                        return "#.definitions.light"
                    },
                    defaults: function () {
                        return {
                            matrixPrev: tl.mat4.create(),
                            shadowNormalBias: (0, l.Z)().shadowNormalOffset ? .075 : void 0
                        }
                    },
                    initialize: function () {
                        a.Z.prototype.initialize.apply(this, arguments), bi.Z.bind("change:mask", this.dirty, this), this.createNode(arguments[0])
                    },
                    createNode: function (e) {
                        this._mtLight = new tl.MatrixTransform, this._mtLight.setName("Lighting - Mt");
                        var t = ho("Lighting", e);
                        this._shadowMap = t.shadowMap, this._light = t.light, this._lightSource = t.lightSource, this._node = t.node, this._enableShadow = t.enableShadow, this._mtQuad = new tl.MatrixTransform, this._mtQuad.setName("Lighting - TransformIcon " + e), this._quadGeom = Qa.createIconGeometry(), this._quadGeom.setName("Lighting -  GeomIcon " + e), this._pointGeom = new Qa.createPointGeometry, this._dirGeom = new Qa.createDirectionalGeometry(5), this._spotGeom = new Qa.createSpotGeometry(5), this._hemiGeom = new Qa.createHemiGeometry(4), this._hemiGeom.getOrCreateStateSet().addUniform(tl.Uniform.createFloat4(tl.vec4.fromValues(0, 0, 1, 1), "uGround")), this._scale = new tl.MatrixTransform, this._scale.setName("Lighting - ScaleIcon " + e), this._mtEditLight = new tl.MatrixTransform, this._mtEditLight.getOrCreateStateSet().setTextureAttributeAndModes(0, hr.Z.dummyTexture), this._mtEditLight.setName("Lighting - MtEditLight " + e);
                        var i = this._mtEditLight.getOrCreateStateSet();
                        i.addUniform(tl.Uniform.createFloat4(tl.vec4.fromValues(1, 1, 1, 1), "uColor")), i.addUniform(tl.Uniform.createInt(1, "uEnable")), i.addUniform(tl.Uniform.createInt(0, "uAttachedToCamera")), i.addUniform(tl.Uniform.createInt(0, "uTextureDepth")), this._node.addChild(this._mtLight), this._node.addChild(this._mtEditLight), this._mtLight.addChild(this._lightSource), this._mtEditLight.addChild(this._scale), this._mtEditLight.addChild(this._spotGeom), this._mtEditLight.addChild(this._pointGeom), this._scale.addChild(this._mtQuad), this._scale.addChild(this._dirGeom), this._scale.addChild(this._hemiGeom), this._mtQuad.addChild(this._quadGeom), this._dirty = !0, this._updateMatrixOnToggleCamera = !0, this._scene = null
                    },
                    setDepthTexture: function (e) {
                        e && this._mtEditLight.getOrCreateStateSet().setTextureAttributeAndModes(0, e)
                    },
                    setScene: function (e) {
                        this._scene = e
                    },
                    getShadowMap: function () {
                        return this._shadowMap
                    },
                    isCastingShadows: function () {
                        var e = this.get("type");
                        return this._enableShadow && this.get("castShadows") && ("DIRECTION" === e || "SPOT" === e)
                    },
                    getLightSource: function () {
                        return this._lightSource
                    },
                    getNodeScale: function () {
                        return this._scale
                    },
                    getNodeQuad: function () {
                        return this._mtQuad
                    },
                    getNode: function () {
                        return this._node
                    },
                    getNodeLight: function () {
                        return this._mtLight
                    },
                    getNodeEditLight: function () {
                        return this._mtEditLight
                    },
                    dirty: function () {
                        this._dirty = !0
                    },
                    isDirty: function () {
                        return this._dirty
                    },
                    updateNode: function () {
                        if (this._dirty) {
                            this._dirty = !1;
                            var e = this._node,
                                t = this._light,
                                i = this.get("type");
                            if ("NONE" === i) return e.setNodeMask(0), t.setEnabled(!1), void (this._mtEditLight.editMask = 0);
                            e.setNodeMask(-1), this._mtEditLight.editMask = "POINT" === i ? il.NodeGizmo.PICK_ARROW | il.NodeGizmo.PICK_PLANE : il.NodeGizmo.PICK_GIZMO, "HEMI" === i && bi.Z.get("mask") & bi.Z.PBR && (i = "DIRECTION");
                            var n = this.get("enable"),
                                r = this.get("falloff");
                            t.setLightType(i), t.setSpotCutoff("SPOT" === i ? this.get("angle") : 180), t.setEnabled(n), t.setConstantAttenuation("DIRECTION" !== i ? 1 : r), t.setQuadraticAttenuation("DIRECTION" !== i ? r : 0), t.setSpotBlend(this.get("hardness")), tl.mat4.copy(this._mtLight.getMatrix(), this.get("matrix")), this._mtLight.dirtyBound(), this._mtEditLight.dirtyBound(), tl.vec3.scale(t.getDiffuse(), this.get("color"), this.get("intensity")), tl.vec3.copy(t.getSpecular(), t.getDiffuse()), tl.vec3.scale(t.getGround(), this.get("ground"), this.get("intensityGround"));
                            var a = this.getShadowMap();
                            a && (a.setTextureSize((0, l.Z)().shadowTextureSize), a.setBias(this.get("shadowBias")), (0, l.Z)().shadowNormalOffset && a.setNormalBias(this.get("shadowNormalBias"))), this.isAttachedToCamera() ? (this._mtLight.setReferenceFrame(tl.Transform.ABSOLUTE_RF), this._mtLight.setCullingActive(!1)) : (this._mtLight.setReferenceFrame(tl.Transform.RELATIVE_RF), this._mtLight.setCullingActive(!0));
                            var o = this._scene.getMinimumBound(),
                                s = o.radius(),
                                u = this.multUI_ ? this.multUI_ : o.radius2() / 1e3,
                                c = Math.pow(r * u, .125),
                                h = .05 * s * (c = Math.min(Math.max(c, 0), 1)) + .8 * s * (1 - c);
                            "SPOT" === i && this._spotGeom.updateCone(t.getSpotCutoff() * Math.PI / 180, h), "POINT" === i && this._pointGeom.updateRadius(h), this._dirGeom.setNodeMask(n && "DIRECTION" === i ? Pe.Z.NO_PICK_NO_SHADOW : 0), this._spotGeom.setNodeMask(n && "SPOT" === i ? Pe.Z.NO_PICK_NO_SHADOW : 0), this._hemiGeom.setNodeMask(n && "HEMI" === i ? Pe.Z.NO_PICK_NO_SHADOW : 0), this._pointGeom.setNodeMask(n && "POINT" === i ? Pe.Z.NO_PICK_NO_SHADOW : 0), tl.vec3.copy(this._hemiGeom.getOrCreateStateSet().getUniform("uGround").getInternalArray(), t.getGround()), tl.vec3.copy(this._mtEditLight.getOrCreateStateSet().getUniform("uColor").getInternalArray(), this.get("color"));
                            var d = this._mtEditLight.getOrCreateStateSet();
                            d.getUniform("uEnable").setInt(0 | n), d.getUniform("uAttachedToCamera").setInt(0 | this.isAttachedToCamera()), this._quadGeom.setLightType(i)
                        }
                    },
                    setLightUnit: function (e) {
                        this._light.getLightNumber() !== e && (this._light.setLightNumber(e), this._light.setName("skfb" + this._light.getTypeMember()), this._shadowMap.dirty())
                    },
                    setIconVisibility: function (e) {
                        this._mtEditLight.setNodeMask(e ? Pe.Z.PICK_GIZMO_LIGHT : 0)
                    },
                    isAttachedToCamera: function () {
                        var e = this.get("type");
                        return ("DIRECTION" === e || "HEMI" === e) && this.get("attachedToCamera")
                    },
                    resetPosition: function () {
                        tl.mat4.identity(this._mtLight.getMatrix()), this._scene && tl.mat4.translate(this._mtLight.getMatrix(), this._mtLight.getMatrix(), this._scene.getMinimumBound().center()), U.Z.draw()
                    },
                    updateAttachedToCamera: function () {
                        var e = tl.mat4.create(),
                            t = tl.vec3.create();
                        return function (i) {
                            if (this._updateMatrixOnToggleCamera) {
                                var n = this.get("matrix");
                                tl.mat4.getTranslation(t, n), this.get("attachedToCamera") ? tl.mat4.copy(e, i.getViewMatrix()) : tl.mat4.invert(e, i.getViewMatrix()), tl.mat4.multiply(n, e, n), tl.mat4.setTranslation(n, t)
                            }
                        }
                    }(),
                    setUpdateMatrixOnToggleCamera: function (e) {
                        this._updateMatrixOnToggleCamera = e
                    }
                });
            const rl = nl;
            var al = g.Z.osg,
                ol = {
                    ThreePointLight: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(-.9815804500275482, .1909922167095499, -.004668327333101102, 0, .13548347102422797, .7131126062169096, .6878332937084056, 0, .13469984856318096, .6745312327912614, -.7258536813891331, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.7806122448979592, .7985214493960848, 1),
                            intensity: .96
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.7755211495104662, -.0666602860002539, .6277924441503967, 0, .2690483737361956, .9344846523281437, -.233133882464682, 0, -.5711216326246741, .3497067926613838, .7426474533145686, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, .8783319450229073, .7091836734693877),
                            intensity: 1
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.6903299131022926, -.7076363669144057, -.15064986988498263, 0, -.011089698239978026, .19785137301620165, -.9801692980238416, 0, .7234097246160907, .6783108479272498, .12873524736872857, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.423469387755102, .7352665556018328, 1),
                            intensity: .12,
                            ground: al.vec3.fromValues(.9642857142857143, .6484128636877489, .2607507288629738),
                            intensityGround: .06
                        }]
                    },
                    FullMoonNight: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.9997395789367833, .0037284998571004493, -.02251383121813605, 0, -.003172416108909601, .9996902441347245, .024685047253076783, 0, .02259889562202194, -.024607195505995896, .9994417320914686, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.14431486880466474, .20264621883738915, .3928571428571429),
                            intensity: 1.5400000000000005,
                            ground: al.vec3.fromValues(.9744897959183674, .6276245973191442, .3331164098292378),
                            intensityGround: .06
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.9321120105125691, .3015730438836578, -.2005514873067817, 0, .11902736304545063, -.7780729183457072, -.6167941476566071, 0, -.34205216956578893, .5510501183556175, -.7611465564236605, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, .613390254060806, .19387755102040816),
                            intensity: 2.9799999999999995
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.5165535747993983, -.2459126458378022, -.8201825254045677, 0, -.40819067915319995, .771302442076031, -.48833688402577136, 0, .7526970000035951, .5870430252243886, .29803978378898704, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, 1, 1),
                            intensity: .38
                        }]
                    },
                    LowKeyLight: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.022621146436927503, -.2660807408393079, -.9636852821789301, 0, -.18898982664775527, .9454138725983617, -.26547213586781604, 0, .9817184571747294, .1881319984823789, -.02890020742997683, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, 1, 1),
                            intensity: 1
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(-.9330760233019924, .058913139300351657, .35482161258401, 0, .19787524547993016, .9078715652207372, .36961413432105955, 0, -.30035732380815566, .4150885003001482, -.8587706416461712, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, 1, 1),
                            intensity: .22
                        }, {
                            type: "NONE",
                            enable: !0
                        }]
                    },
                    EvilGenius: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.9967621126545051, .025235816589958687, .07634424888336766, 0, .000702423157861877, -.9521689363972996, .3055713061819492, 0, .08040396369728874, -.3045282747481311, -.9491036468693457, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, .3450645564348185, .056122448979591844),
                            intensity: 1.5400000000000005
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !0,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(-.7932202797763206, .039941473670798935, .6076234577701727, 0, .16089796285361985, .9761307284151629, .14587887644631273, 0, -.5872933111326324, .21347945972549276, -.780713191238742, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.15368596418159094, .7346938775510203, .20111518159950362),
                            intensity: 1.9000000000000008
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.9998681367204546, .01574007797565349, .003994886292083951, 0, 0, .24600379421877677, -.9692688652948499, 0, -.016239124704439348, .9691410543235108, .24597135535169048, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.9897959183673469, .674842115105101, .02524989587671801),
                            intensity: .02,
                            ground: al.vec3.fromValues(.3, .2, .2),
                            intensityGround: .98
                        }]
                    },
                    FairyCamp: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.7285122591021403, -.5166704810444328, -.44980162555865727, 0, .2899427624247639, .827461680647148, -.4808745798834604, 0, .6206473095530125, .21990630067806594, .752620844826062, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.8476936693044566, .8957603762037927, .9948979591836735),
                            intensity: .9
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.08433618912371937, -.8568665398386119, -.5085932953835439, 0, -.8584235966554874, -.3216498975444721, .39956260099599905, 0, -.5059608047162799, .40289089877364465, -.7626811835729392, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.37244897959183676, .538942107455227, 1),
                            intensity: 1.7200000000000006
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.9766324883850551, -.001534767629049323, .21491074221438983, 0, .14494434684687327, -.7336231034872216, -.6639188793421307, 0, .15868244688039193, .6795548443783637, -.7162577012039377, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.3389212827988338, .7142857142857143, .346581781400607),
                            intensity: .5,
                            ground: al.vec3.fromValues(.9947417742607245, .48469387755102045, 1),
                            intensityGround: .14
                        }]
                    },
                    ThreePointLightV2: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !0,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(-.9815804500275482, .1909922167095499, -.004668327333101102, 0, .13548347102422797, .7131126062169096, .6878332937084056, 0, .13469984856318096, .6745312327912614, -.7258536813891331, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.7806122448979592, .7985214493960848, 1),
                            intensity: .96
                        }, {
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !0,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.7755211495104662, -.0666602860002539, .6277924441503967, 0, .2690483737361956, .9344846523281437, -.233133882464682, 0, -.5711216326246741, .3497067926613838, .7426474533145686, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, .8783319450229073, .7091836734693877),
                            intensity: 1
                        }, {
                            type: "HEMI",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(.6903299131022926, -.7076363669144057, -.15064986988498263, 0, -.011089698239978026, .19785137301620165, -.9801692980238416, 0, .7234097246160907, .6783108479272498, .12873524736872857, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.423469387755102, .7352665556018328, 1),
                            intensity: .12,
                            ground: al.vec3.fromValues(.9642857142857143, .6484128636877489, .2607507288629738),
                            intensityGround: .06
                        }]
                    },
                    TwoHeadLightV1: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !0,
                            castShadows: !1,
                            matrix: al.mat4.fromValues(Math.SQRT1_2, 0, Math.SQRT1_2, 0, -0, 1, 0, 0, -Math.SQRT1_2, -0, Math.SQRT1_2, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.6, .48, .3),
                            intensity: 1
                        }, {
                            enable: !0,
                            attachedToCamera: !0,
                            castShadows: !1,
                            type: "DIRECTION",
                            matrix: al.mat4.fromValues(Math.SQRT1_2, 0, -Math.SQRT1_2, 0, 0, 1, 0, 0, Math.SQRT1_2, 0, Math.SQRT1_2, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(.42, .42, .6),
                            intensity: 1
                        }, {
                            type: "NONE",
                            enable: !0
                        }]
                    },
                    LightFromAbove: function () {
                        return [{
                            type: "DIRECTION",
                            enable: !0,
                            attachedToCamera: !1,
                            castShadows: !0,
                            matrix: al.mat4.fromValues(.9997395789367833, .0037284998571004493, -.02251383121813605, 0, -.003172416108909601, .9996902441347245, .024685047253076783, 0, .02259889562202194, -.024607195505995896, .9994417320914686, 0, 0, 0, 0, 1),
                            color: al.vec3.fromValues(1, 1, 1),
                            intensity: .01
                        }, {
                            type: "NONE",
                            enable: !0
                        }, {
                            type: "NONE",
                            enable: !0
                        }]
                    }
                };
            const sl = ol;
            var ll = g.Z.osg,
                ul = a.Z.extend({
                    defaults: function () {
                        return {
                            select: -1,
                            lights: [new rl(0), new rl(1), new rl(2)],
                            webVR: !1,
                            forceShadowRedraw: !1
                        }
                    },
                    getName: function () {
                        return "Lighting"
                    },
                    getDefaultFalloff: function () {
                        var e = this._root.getMinimumBound().radius();
                        return e < 0 ? 0 : 3.90625 / (e * e)
                    },
                    setPreset: function (e) {
                        sl[e] || console.error("Preset does not exist: " + e), this.setJSON({
                            enable: this.get("enable"),
                            lights: sl[e]()
                        }, {
                            resetFalloff: !0
                        })
                    },
                    init: function (e) {
                        this._viewer = e.getViewer(), this._root = this._viewer.getRootModel(), this.set("enable", !(0, vi.Z)());
                        var t = e.getModel().get("options").lighting;
                        t && t.lights && (this._ignoreSceneLights = !0, this.setJSON(t)), L.Z.getModelDisplayed().then(this.initDepthTexture.bind(this))
                    },
                    initDepthTexture: function () {
                        for (var e = this._viewer.getFeaturesManager().getTextureDepth(), t = this.get("lights"), i = 0; i < 3; ++i) t[i].setDepthTexture(e)
                    },
                    dirtyScene: function () {
                        J.Z.getModelBoxWithoutDisplacement() ? this.recomputeLightsPositionAndFalloff() : J.Z.getBoxReady().then(this.recomputeLightsPositionAndFalloff.bind(this))
                    },
                    recomputeLightsPositionAndFalloff: function () {
                        for (var e = J.Z.getModelBoxWithoutDisplacement(), t = this.get("lights"), i = .8 * e.radius(), n = this.getDefaultFalloff(), r = e.center(ll.vec3.create()), a = ll.vec3.fromValues(0, 0, i), o = 0; o < 3; ++o) {
                            var s = t[o],
                                l = s.get("matrix");
                            s.get("falloff") < 0 && (s.set("falloff", n), l[12] = r[0], l[13] = r[1], l[14] = r[2], ll.mat4.translate(l, l, a)), s.dirty()
                        }
                    },
                    initLights: function (e) {
                        var t = 0,
                            i = this.get("lights");
                        for (t = 0; t < 3; ++t) i[t].setScene(this._root);
                        if (this._ignoreSceneLights) return this.trigger("uiReady");
                        var n = e.length;
                        if ((0, vi.Z)()) {
                            if (0 === n) return this.setPreset("ThreePointLight"), this.trigger("uiReady");
                            this.set("enable", !0)
                        } else {
                            for (t = 0; t < 3; ++t) i[t].set("castShadows", !1);
                            if (0 === n) return this.setPreset("TwoHeadLightV1"), this.trigger("uiReady");
                            if (n > 3) return this.setPreset("ThreePointLightV2"), this.trigger("uiReady")
                        }
                        e.sort((function (e, t) {
                            return ll.vec3.len(e.getDiffuse()) - ll.vec3.len(t.getDiffuse())
                        }));
                        var r = ll.vec3.create();
                        for (t = 0; t < 3; ++t) {
                            var a = e[t],
                                o = i[t];
                            if (a) {
                                var s = a.getLightType();
                                o.set("type", s), o.set("attachedToCamera", !1), "SPOT" === s && (o.set("angle", Math.min(90, a.getSpotCutoff())), o.set("hardness", a.getSpotBlend()));
                                var l = a.getDiffuse(),
                                    u = Math.max(l[0], l[1], l[2], 1);
                                o.set("intensity", u), ll.vec3.scale(o.get("color"), l, 1 / u);
                                var c = a.getGround(),
                                    h = Math.max(c[0], c[1], c[2], 1);
                                o.set("intensityGround", h), ll.vec3.scale(o.get("ground"), c, 1 / h), o.set("falloff", a.getQuadraticAttenuation());
                                var d = o.get("matrix");
                                ll.mat4.getScale(r, a._worldMatrix), ll.mat4.fromScaling(d, r), ll.mat4.invert(d, d), ll.mat4.multiply(d, a._worldMatrix, d)
                            } else o.set("falloff", this.getDefaultFalloff()), o.set("type", "NONE")
                        }
                        return this.trigger("uiReady")
                    },
                    getJSON: function () {
                        var e = {},
                            t = this.get("lights");
                        return e.enable = this.get("enable"), e.lights = [t[0].getJSON(), t[1].getJSON(), t[2].getJSON()], e
                    },
                    setJSON: function (e, t) {
                        var i = t || {};
                        i.ignore = ["lights"], a.Z.prototype.setJSON.call(this, e, i);
                        var n = this.get("lights");
                        void 0 !== e.enable && this.set("enable", e.enable);
                        for (var r = {
                            validate: i.validate
                        }, o = 0; o < 3; ++o) {
                            var s = e.lights[o];
                            if (s) {
                                var l = n[o];
                                l.setUpdateMatrixOnToggleCamera(!1), l.setJSON(s, r), l.setUpdateMatrixOnToggleCamera(!0), t && t.resetFalloff && l.set("falloff", -1), l.get("falloff") < 0 && this.dirtyScene()
                            }
                        }
                    },
                    editorGetJSON: function () {
                        return this.getJSON()
                    },
                    editorSetJSON: function (e) {
                        return this.setJSON(e, {
                            validate: !0,
                            resetFalloff: !0
                        })
                    }
                });
            const cl = ul;
            var hl = g.Z.osg,
                dl = V.Z.extend({
                    initialize: function (e) {
                        V.Z.prototype.initialize.apply(this, arguments), this.model.bind("change:select", this.onSelectChanged, this), this.model.bind("change:enable", this.onEnableChanged, this), this.model.bind("change", U.Z.draw), this._viewer = e.context.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._manipulator = this._viewerOSGJS.getManipulator(), this._isScreenshot = !1, this._nodeFeature = new hl.Node, this._nodeFeature.setName("Feature - Lighting"), this._shadowNode = new g.Z.osgShadow.ShadowedScene(uo()), this._shadowNode.setName("Shadowed scene"), this._lightNode = new hl.Camera, this._lightNode.setName("Lighting - Camera"), this._lightNode.setNearFarRatio(5e-5);
                        var t = this._lightNode.getOrCreateStateSet();
                        t.setRenderBinDetails(Oe.Z.EDITOR_GIZMO, "RenderBin"), this._lightNode.setNodeMask(Pe.Z.NO_SHADOW), this.initLightNode(), this.onEnableChanged(), this._nodeFeature.addChild(this._lightNode), L.Z.getMaterial().then(this.handleDirtyShadows.bind(this))
                    },
                    getNode: function () {
                        return this._nodeFeature
                    },
                    getNodeLight: function () {
                        return this._lightNode
                    },
                    getNodeShadow: function () {
                        return this._shadowNode
                    },
                    isLightNone: function (e) {
                        return -1 === e || "NONE" === this.model.get("lights")[e].get("type")
                    },
                    isTabLighting: function () {
                        var e = this._viewer.getFeaturesManager();
                        return e && "lighting" === e.getCurrentTabName()
                    },
                    handleDirtyShadows: function () {
                        var e = this._viewer.getFeatures().material;
                        if (e) {
                            var t = e.getModel().attributes,
                                i = this.model.get("lights"),
                                n = i.length;
                            for (var r in t)
                                for (var a = t[r], o = a.getChannels().Opacity, s = a.getChannels().Displacement, l = 0; l < n; ++l) {
                                    var u = i[l];
                                    o.bind("change", u.dirty, u), s.bind("change", u.dirty, u)
                                }
                        }
                    },
                    onEnableChanged: function () {
                        var e = this.model.get("enable");
                        if (this._lightNode.setNodeMask(e ? Pe.Z.NO_SHADOW : 0), !e) {
                            var t = this.getGizmo();
                            t && t.attachToNode(null)
                        }
                        for (var i = this.model.get("lights"), n = 0, r = i.length; n < r; ++n) {
                            var a = i[n],
                                o = e && a.get("enable");
                            a.getLightSource().getLight().setEnabled(o), (0, l.Z)().shadowAtlas && !o && fo(this._shadowNode, a.getShadowMap())
                        }
                        e && this._updateLightsAndIcons()
                    },
                    initLightNode: function () {
                        this._nodeFeature.addUpdateCallback(this);
                        for (var e = this.model.get("lights"), t = 0, i = e.length; t < i; ++t) {
                            var n = e[t];
                            n.setLightUnit(t), n.bind("change", n.dirty, n), n.bind("change:attachedToCamera", n.updateAttachedToCamera.bind(n, this._viewer.getCamera()), n), n.bind("change", U.Z.draw), this._lightNode.addChild(n.getNode())
                        }
                    },
                    getGizmo: function () {
                        var e = this._viewer.getFeaturesManager();
                        return e ? e.getNodeGizmo() : null
                    },
                    onSelectChanged: function () {
                        var e = this.getGizmo();
                        if (e) {
                            var t = this.model.get("select");
                            this.isLightNone(t) ? e.attachToNode(null) : e.attachToNode(this.model.get("lights")[t].getNodeEditLight())
                        }
                    },
                    updateSelection: function () {
                        var e = this.getGizmo();
                        if (e && !e._isEditing) {
                            var t = e._attachedNode;
                            if (!this.isLightNone(this.model.get("select")) || t)
                                for (var i = this.model.get("lights"), n = 0; n < 3; ++n)
                                    if (i[n].getNodeEditLight() === t) {
                                        e.updateGizmoMask(), this.model.set("select", n);
                                        break
                                    }
                        }
                    },
                    updateLightIcons: function () {
                        var e = hl.vec4.create(),
                            t = hl.vec3.create(),
                            i = hl.vec3.create(),
                            n = hl.quat.create();
                        return function () {
                            var r = this.model.get("lights"),
                                a = this._viewer.getCamera(),
                                o = this._viewer.getFeaturesManager().getIconScaleFov();
                            this._manipulator.getEyePosition(i);
                            for (var s = this.getGizmo(), l = 0; l < 3; ++l) {
                                var u = r[l];
                                if ("NONE" !== u.get("type")) {
                                    var c = u.getNodeEditLight(),
                                        h = u.getNodeLight(),
                                        d = u.getNodeQuad(),
                                        g = u.getNodeScale(),
                                        f = s._isEditing && s._attachedNode === c,
                                        m = d.getMatrix(),
                                        p = c.getMatrix(),
                                        v = h.getMatrix();
                                    u.isAttachedToCamera() ? f ? (hl.mat4.getTranslation(t, p), hl.mat4.multiply(v, a.getViewMatrix(), p), hl.mat4.setTranslation(v, t)) : (hl.mat4.getTranslation(t, v), hl.mat4.invert(p, a.getViewMatrix()), hl.mat4.multiply(p, p, v), hl.mat4.setTranslation(p, t)) : f ? hl.mat4.copy(v, p) : hl.mat4.copy(p, v), hl.mat4.copy(u.get("matrix"), v), c.getWorldMatrix(void 0, m), hl.mat4.getTranslation(t, m);
                                    var _ = hl.vec3.dist(i, t) / o;
                                    hl.mat4.fromScaling(g.getMatrix(), hl.vec3.set(e, _, _, _)), hl.mat4.multiply(m, a.getViewMatrix(), m), hl.mat4.invert(m, m), hl.mat4.fromQuat(m, hl.mat4.getRotation(n, m)), d.dirtyBound(), h.dirtyBound(), g.dirtyBound()
                                }
                            }
                        }
                    }(),
                    setIsScreenshot: function (e) {
                        this._isScreenshot = e
                    },
                    _updateLightsAndIcons: function () {
                        if (this._lightNode.getNodeMask() && this._shadowNode.getChildren().length) {
                            for (var e = this._viewer.getFeatures().shadingStyle, t = this._viewer.getFeatures().ARKit.getModel().get("enable") || "lit" === e.getModel().get("type"), i = !this._isScreenshot && t && this.isTabLighting(), n = this._viewer.getFeaturesManager().getShadowForcedUpdate(), r = this.model.get("webVR"), a = this.model.get("lights"), o = 0; o < 3; ++o) {
                                var s = a[o],
                                    l = n || s.isDirty();
                                s.updateNode();
                                var u = s.getShadowMap();
                                if (u) {
                                    var c = r && s.isAttachedToCamera();
                                    if (!c && t && s.get("enable") && s.isCastingShadows()) {
                                        if (!(l = l || s.isAttachedToCamera() || n)) {
                                            for (var h = s.get("matrix"), d = s.get("matrixPrev"), g = 0; g < 16; g++)
                                                if (h[g] !== d[g]) {
                                                    l = !0;
                                                    break
                                                }
                                            hl.mat4.copy(d, h)
                                        }
                                        l && u.requestRedraw(), go(this._shadowNode, u)
                                    } else (l || c) && fo(this._shadowNode, u);
                                    s.setIconVisibility(i)
                                }
                            }
                            i && (this.updateLightIcons(), this.updateSelection())
                        }
                    },
                    update: function (e, t) {
                        return e.getNumChildrenRequiringUpdateTraversal() > 0 && t.traverse(e), this._updateLightsAndIcons(), !1
                    }
                });
            var gl = {
                FeatureName: "lighting",
                ModelType: cl,
                ViewListType: [dl]
            },
                fl = n.Z.create(gl);
            fl.prototype.getNode = function () {
                return this._views[0].getNode()
            }, fl.prototype.getNodeShadow = function () {
                return this._views[0].getNodeShadow()
            }, fl.prototype.prepareForScreenShot = function () {
                this._views[0].setIsScreenshot(!0)
            }, fl.prototype.resetAfterScreenShot = function () {
                this._views[0].setIsScreenshot(!1)
            };
            const ml = fl;
            var pl = g.Z.osg,
                vl = a.Z.extend({
                    initialize: function () {
                        a.Z.prototype.initialize.apply(this, arguments), this._sssSchema = this.getSubSchema("scene.sssProfiles"), this.set("sssProfiles", this.getInstance(this._sssSchema))
                    },
                    getModelOptionPath: function () {
                        return "scene.postProcess"
                    },
                    defaults: {
                        postProcessReady: !1,
                        rgbmDefault: 7,
                        rgbmBloom: 1,
                        sssCurrentProfile: 0,
                        webVR: !1,
                        AR: !1,
                        veilFactor: 1,
                        doDistortionVR: !1,
                        distortion: pl.vec2.fromValues(.441, .156),
                        projectionLeft: pl.vec4.fromValues(1, 1, -.5, -.5),
                        unprojectionLeft: pl.vec4.fromValues(1, 1, -.5, -.5),
                        vrFadeLength: (0, l.Z)().vrFade / 1e3 / 2,
                        vrStartFade: !1,
                        vrFadeStartTime: 0,
                        vrFadeCallback: void 0,
                        vrFading: !1
                    },
                    getName: function () {
                        return "PostProcess"
                    },
                    getViewer: function () {
                        return this._viewer
                    },
                    useSSSLookupFloatLinear: function () {
                        return pl.WebGLCaps.instance().getWebGLExtension("OES_texture_float_linear")
                    },
                    getSSSWeightRange: function () {
                        return 2 * (0, l.Z)().sssHalfKernel - 1 > 20 ? 3 : 2
                    },
                    setQuality: function (e) {
                        void 0 !== (0, l.Z)().quality && (e = (0, l.Z)().quality), to.Z.uQuality.setFloat(e)
                    },
                    getQuality: function () {
                        return to.Z.uQuality.getInternalArray()[0]
                    },
                    _getBoundRadius: function () {
                        return J.Z.getModelBoxWithDisplacement().radius()
                    },
                    getMinimumSsaoRadius: function () {
                        return .01 * this._getBoundRadius()
                    },
                    getMaximumSsaoRadius: function () {
                        return .1 * this._getBoundRadius()
                    },
                    getMinimumSsaoBias: function () {
                        return .002 * this._getBoundRadius()
                    },
                    getMaximumSsaoBias: function () {
                        return .01 * this._getBoundRadius()
                    },
                    _makeValidOption: function (e, t, i, n) {
                        var r = this.get(e);
                        r < t * J.Z.BIAS_MIN || r > i * J.Z.BIAS_MAX ? this.set(e, n) : this.set(e, Math.min(Math.max(r, t), i))
                    },
                    _makeValidSsaoRadius: function () {
                        this._makeValidOption("ssaoRadius", this.getMinimumSsaoRadius(), this.getMaximumSsaoRadius(), .025 * this._getBoundRadius())
                    },
                    _makeValidSsaoBias: function () {
                        this._makeValidOption("ssaoBias", this.getMinimumSsaoBias(), this.getMaximumSsaoBias(), .005 * this._getBoundRadius())
                    },
                    _isEffectivePP: function () {
                        return this.get("enable")
                    },
                    isEffectiveGrain: function () {
                        return this._isEffectivePP() && !this.get("webVR") && this.get("grainEnable") && this.get("grainFactor") >= 5e-4
                    },
                    isEffectiveSharpen: function () {
                        return this._isEffectivePP() && !this.get("webVR") && this.get("sharpenEnable") && this.get("sharpenFactor") >= 5e-4
                    },
                    isEffectiveChromaticAberration: function () {
                        return this._isEffectivePP() && !this.get("webVR") && this.get("chromaticAberrationEnable") && this.get("chromaticAberrationFactor") >= .001
                    },
                    isEffectiveVignette: function () {
                        return this._isEffectivePP() && !this.get("webVR") && this.get("vignetteEnable") && this.get("vignetteHardness") - this.get("vignetteAmount") <= .5 * Math.sqrt(2)
                    },
                    isEffectiveBloom: function () {
                        return this._isEffectivePP() && (!this.get("webVR") || !jr.default.any) && this.get("bloomEnable") && this.get("bloomFactor") >= .01
                    },
                    isEffectiveToneMapping: function () {
                        return this._isEffectivePP() && this.get("toneMappingEnable")
                    },
                    isEffectiveColorBalance: function () {
                        return this._isEffectivePP() && this.get("colorBalanceEnable")
                    },
                    isEffectiveDof: function () {
                        return this._isEffectivePP() && !this.get("webVR") && this.get("dofEnable") && (this.get("dofBlurNear") >= .01 || this.get("dofBlurFar") >= .01)
                    },
                    isEffectiveSsao: function () {
                        return this._isEffectivePP() && !this.get("webVR") && this.get("ssaoEnable") && this.get("ssaoIntensity") >= .01
                    },
                    isEffectiveSsr: function () {
                        return this._isEffectivePP() && bi.Z.get("mask") & bi.Z.LIT && !this.get("webVR") && this.get("ssrEnable") && this.get("ssrFactor") > .01
                    },
                    hasAtLeastOneEffectiveEffect: function () {
                        return !!this.isEffectiveSsr() || (!!this.isEffectiveGrain() || (!!this.isEffectiveSharpen() || (!!this.isEffectiveChromaticAberration() || (!!this.isEffectiveVignette() || (!!this.isEffectiveBloom() || (!!this.isEffectiveToneMapping() || (!!this.isEffectiveColorBalance() || (!!this.isEffectiveDof() || !!this.isEffectiveSsao()))))))))
                    },
                    initAfterFirstFrame: function () {
                        this._makeValidSsaoRadius(), this._makeValidSsaoBias(), this.trigger("uiReady"), this.set("postProcessReady", !0)
                    },
                    init: function (e) {
                        this._viewer = e.getViewer();
                        var t = e.getModel().get("options");
                        if (t.scene && t.scene.sssProfiles && this.setProfilesJSON(t.scene.sssProfiles), t.scene && t.scene.postProcess) {
                            var i = t.scene.postProcess;
                            this.setJSON(i), void 0 !== (0, l.Z)().postProcess && this.set("enable", (0, l.Z)().postProcess), void 0 !== (0, l.Z)().ssr && this.set("ssrEnable", (0, l.Z)().ssr);
                            var n = i.taa,
                                r = (0, l.Z)().taa;
                            if (n) {
                                this.set("taaEnable", void 0 !== r ? r : n.enable);
                                var a = (0, l.Z)().taaTransparent;
                                this.set("taaTransparent", void 0 !== a ? a : n.transparent), void 0 === r && J.Z.getBoxReady().then(function () {
                                    J.Z.getMaxDistanceFromOrigin() > 1e6 && this.set("taaEnable", !1)
                                }.bind(this))
                            } else void 0 !== r && this.set("taaEnable", r)
                        } (0, vi.Z)() && L.Z.getMaterial().then(function () {
                            "Tilt Brush" === this._viewer.getRootUserData().authoringTool ? (this.set("bloomEnable", !0), this.set("bloomThreshold", .6), this.set("bloomFactor", 1.6), this.set("bloomRadius", .2), this.set("toneMappingEnable", !0), this.set("toneMappingMethod", "filmic")) : "minecraft" !== this._viewer.getRootUserData().source && "mineways" !== this._viewer.getRootUserData().source || (this.set("ssaoEnable", !0), this.set("ssaoRadius", .05), this.set("ssaoIntensity", 1), this.set("ssaoBias", .006))
                        }.bind(this))
                    },
                    fadeForTeleportVR: function (e) {
                        this.set("vrStartFade", !0), this.set("vrFadeCallback", e)
                    },
                    setProfilesJSON: function (e, t) {
                        if (t && t.validate) {
                            var i = this.validate(e, {
                                schema: this._sssSchema
                            });
                            if (i.length) return console.error("Failed to validate sss profile json", e, i), i.join("\n")
                        }
                        return this.set("sssProfiles", e), []
                    },
                    getProfilesJSON: function () {
                        return this.get("sssProfiles")
                    },
                    editorGetJSON: function () {
                        return this.getJSON()
                    },
                    editorSetJSON: function (e) {
                        return this.setJSON(e, {
                            validate: !0
                        })
                    }
                });
            const _l = vl;
            var Sl = i("C/2N"),
                xl = g.Z.osg,
                Cl = g.Z.osgShader.shaderProcessor,
                Tl = {
                    pascalCache: [
                        [1]
                    ],
                    getOrCreatePascalCoefficients: function (e) {
                        e = void 0 === e ? 5 : Math.min(e, 128);
                        var t = Tl.pascalCache;
                        if (t[e]) return t[e];
                        for (var i = t.length - 1; i < e; i++) {
                            var n = t[i],
                                r = n.length,
                                a = new Array(r);
                            a[0] = 1, a[r] = 1;
                            for (var o = i === t.length - 1 ? Math.pow(2, i) : 1, s = 0; s < r - 1; s++) a[s + 1] = (n[s] + n[s + 1]) * o;
                            o = Math.pow(2, i + 1);
                            for (var l = 0; l < r + 1; l++) a[l] /= o;
                            t.push(a)
                        }
                        return t[e]
                    }
                },
                Ml = function (e) {
                    var t = e.toString();
                    return -1 === t.indexOf(".") ? t + ".0" : t
                },
                bl = function (e, t) {
                    var i = .005 / e,
                        n = e,
                        r = Tl.getOrCreatePascalCoefficients(n),
                        a = Math.floor(n / 2),
                        o = [],
                        s = Ml(r[a]);
                    a + 1 >= e && (s = "1.0");
                    var l, u = 1;
                    for (o.push("vec3 pixel = " + s + " * %fetch(gTexCoord.xy).rgb;"), o.push("vec2 offset;"), o.push("vec2 blurDir = uPixelRatio.xy * uBlurDir.xy / uTextureOutputSize.xy;"), t && o.push("blurDir *= uGlobalTexSize.y * 0.00075;"), l = a + 1; l < e; l += 2) {
                        var c = r[l],
                            h = r[l + 1],
                            d = c + h;
                        if (d < i) break;
                        var g = (u * c + (u + 1) * h) / d;
                        o.push("offset = blurDir * " + Ml(g) + ";"), s = Ml(d), o.push("pixel += " + s + " * %fetch(gTexCoord.xy + offset.xy).rgb;"), o.push("pixel += " + s + " * %fetch(gTexCoord.xy - offset.xy).rgb;"), u += 2
                    }
                    o.push("return vec4(pixel, 1.0);");
                    for (l = 0; l < o.length; ++l) o[l] = "    " + o[l].replace("%fetch", "TEXTURE_2D_TextureBlurInput");
                    return ["uniform sampler2D TextureBlurInput;", "uniform vec2 uTextureOutputSize;", "uniform vec2 uPixelRatio;", "uniform vec2 uBlurDir;", t ? "uniform vec2 uGlobalTexSize;\n" : "", "vec4 gaussianBlur() {", o.join("\n"), "}"].join("\n")
                };
            const yl = function (e, t, i, n, r) {
                for (var a = 2, o = xl.Uniform.createFloat2(xl.vec2.fromValues(0, 1), "uBlurDir"), s = xl.Uniform.createFloat2(xl.vec2.fromValues(1, 0), "uBlurDir"), l = {}, u = t, c = 0; c < n.length; c++) {
                    var h = n[c] + 1,
                        d = "gaussianBlur" + c;
                    Cl.hasShader(d) || (l[d] = bl(h, r)), e.push({
                        func: {
                            name: "gaussianBlur",
                            file: d
                        },
                        uniforms: o,
                        textures: {
                            name: u,
                            uniformName: "TextureBlurInput"
                        },
                        out: {
                            name: "TextureBlurTemp" + c,
                            divisor: a,
                            filter: "linear"
                        }
                    }), u = i + (c + 1), e.push({
                        func: {
                            name: "gaussianBlur",
                            file: d
                        },
                        uniforms: s,
                        textures: {
                            name: "TextureBlurTemp" + c,
                            uniformName: "TextureBlurInput"
                        },
                        out: {
                            name: u,
                            divisor: a,
                            filter: "linear"
                        }
                    }), a *= 2
                }
                Cl.addShaders(l)
            };
            var Al = i("icLH");
            var Rl = g.Z.osg,
                wl = g.Z.osgUtil,
                El = g.Z.osgShader.shaderProcessor,
                Pl = function (e) {
                    Rl.Node.call(this), this.setName("PostProcess - node In"), this._view3d = e, this._camera = e._camera, this._effectiveConfig = e._effectiveConfig, this._viewer = e._viewer, this._viewerOSGJS = e._viewerOSGJS, this._model = e.model, this._hasTriangles = this._viewer.getOrCreateScene().getJSON().faceCount > 0, eo.Z.setHasTriangles(this._hasTriangles), this._viewer.getCamera().getRenderer().setRenderStage(new eo.Z), this._model.on("pingPongTexture0", this.onPingPongTexture0, this), L.Z.getMaterial().then(function () {
                        var e = this.getBackgroundModel();
                        e.bind("backgroundUpdated", this.onBackgroundUpdated, this), e.bind("change:color", this.onBackgroundColor, this)
                    }.bind(this)), this._composer = void 0, this._addShaders()
                };
            Rl.createPrototypeNode(Pl, Rl.objectInherit(Rl.Node.prototype, {
                _addShaders: function () {
                    var e = {
                        "passThrough.glsl": '#ifdef VR_DISTORTION\nuniform vec2 uDistortion;\nuniform vec4 uProjectionLeft;\nuniform vec4 uUnprojectionLeft;\n\n#pragma include "distortion.glsl"\n#endif\n\n#ifdef ASCII_FOOL\n#pragma include "ascii.glsl"\n#endif\n\nuniform sampler2D TextureInput;\n\nvec4 passThrough() {\n#ifdef VR_DISTORTION\n    gTexCoord = distortion(gTexCoord);\n#endif\n\n#ifdef ASCII_FOOL\n    return ascii(gTexCoord.xy);\n#else\n    return TEXTURE_2D_TextureInput(gTexCoord);\n#endif\n}\n',
                        "setDepthAlpha.glsl": '#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureInput;\nuniform sampler2D TextureDepth;\n\nuniform sampler2D TextureRefraction;\nuniform vec2 uTextureRefractionSize;\nuniform vec2 uTextureRefractionRatio;\n\n// no background scenario\nvec4 setDepthAlpha(const in vec4 color) {\n#ifdef REFRACTION_FORCE_ALPHA_ONE\n    // detect if we are on a refraction pixel\n    vec2 uvRef = min(gTexCoord, 1.0 - 1.0 / uTextureRefractionSize.xy);\n    if (texture2D(TextureRefraction, uvRef * uTextureRefractionRatio).a > 0.0) return vec4(color.rgb, 1.0);\n#endif\n\n    float alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));\n    return vec4(color.rgb, alpha);\n}',
                        "combineOpacity.glsl": "uniform sampler2D TextureTransparent;\n\nvec4 combineOpacity(const in vec4 color) {\n\t// should be replaced with TEXTURE_2D_TextureTransparent as is can make sense\n    vec4 transparent = TEXTURE_2D_TextureTransparent(gTexCoord);\n    return vec4(color.rgb * (1.0 - transparent.a) + transparent.rgb, 1.0);\n}",
                        "combineRefraction.glsl": "uniform sampler2D TextureInput;\nuniform sampler2D TextureRefraction;\n\nuniform vec2 uTextureRefractionSize;\nuniform vec2 uTextureRefractionRatio;\nuniform float uRGBMRange;\n\nvec4 combineRefraction() {\n    // manual fetch to check m value of rgba : we use m 0 (invalid of rgbm) as masking\n    vec2 uv = min(gTexCoord, 1.0 - 1.0 / uTextureRefractionSize.xy);\n    vec4 rgbmRefraction = texture2D(TextureRefraction, uv * uTextureRefractionRatio);\n\n    vec4 background = TEXTURE_2D_TextureInput(gTexCoord);\n    if (rgbmRefraction.a == 0.0) return background;\n    return vec4(decodeRGBM(rgbmRefraction, uRGBMRange), 1.0);\n}",
                        "packMipmapRefraction.glsl": "uniform sampler2D TextureRefractionBlur0;\nuniform sampler2D TextureRefractionBlur1;\nuniform sampler2D TextureRefractionBlur2;\nuniform sampler2D TextureRefractionBlur3;\nuniform sampler2D TextureRefractionBlur4;\nuniform sampler2D TextureRefractionBlur5;\nuniform sampler2D TextureRefractionBlur6;\nuniform sampler2D TextureRefractionBlur7;\nuniform vec2 uTextureOutputRatio;\n\nvec4 packMipmapRefraction() {\n    vec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // see _hookComposerResize in NodePostProcess.js (mipmap)\n    gTexCoord.y /= uTextureOutputRatio.y;\n\n    float levelLog = -log2(1.0 - gTexCoord.y) + 1.0;\n    float level = floor(levelLog) - 1.0;\n\n    float pLevel = pow(2.0, level + 1.0); // 2, 4, 8, 16...\n    gTexCoord.x = pLevel * gTexCoord.x * 0.5;\n    gTexCoord.y = pLevel * (1.0 - gTexCoord.y) - 1.0;\n\n    // unused part of the texture\n    if (gTexCoord.x > 1.0 || gTexCoord.y > 1.0) return result;\n\n    if (level < 0.1) result.rgb = TEXTURE_2D_TextureRefractionBlur0(gTexCoord).rgb;\n    else if (level < 1.1) result.rgb = TEXTURE_2D_TextureRefractionBlur1(gTexCoord).rgb;\n    else if (level < 2.1) result.rgb = TEXTURE_2D_TextureRefractionBlur2(gTexCoord).rgb;\n    else if (level < 3.1) result.rgb = TEXTURE_2D_TextureRefractionBlur3(gTexCoord).rgb;\n    else if (level < 4.1) result.rgb = TEXTURE_2D_TextureRefractionBlur4(gTexCoord).rgb;\n    else if (level < 5.1) result.rgb = TEXTURE_2D_TextureRefractionBlur5(gTexCoord).rgb;\n    else if (level < 6.1) result.rgb = TEXTURE_2D_TextureRefractionBlur6(gTexCoord).rgb;\n    else if (level < 7.1) result.rgb = TEXTURE_2D_TextureRefractionBlur7(gTexCoord).rgb;\n\n    return result;\n}\n",
                        "sssCommon.glsl": '#pragma include "utils/checkerboard.glsl"\n\n// blur jimenez\n// https://github.com/iryoku/separable-sss/blob/master/SeparableSSS.h#L454\n\n// blur UE4 (based on jimenez)\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/SeparableSSS.usf\n\n// UE 4 pre/post passes (down/upsample/checkerboard)\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/PostProcessSubsurface.usf\n\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Common.usf#L501\n// also solution 2 of http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\nfloat luminanceLinear(const in vec3 color) {\n    return dot(color, vec3(0.3, 0.59, 0.11));\n}\n\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/PostProcessSubsurface.usf#L247\nvoid uncheckerboard(out vec3 diffuse, out vec3 specular) {\n\n    vec2 coordCenter = floor(gTexCoord * uTextureSSSColorSize) + 0.5;\n    vec2 uvCenter = coordCenter / uTextureSSSColorSize;\n    // not precomputing offset as 1.0/uTextureSSSColorSize.xy\n    // to make sure we don\'t loose precision and end up with ABCD being same texel\n    // on low precision gpu\n    vec3 offset = vec3(1.0, 1.0, 0.0);\n\n    vec3 A = TEXTURE_2D_TextureSSSColor((coordCenter + offset.xz)/ uTextureSSSColorSize.xy).rgb;\n    vec3 B = TEXTURE_2D_TextureSSSColor((coordCenter - offset.xz)/ uTextureSSSColorSize.xy).rgb;\n    vec3 C = TEXTURE_2D_TextureSSSColor((coordCenter + offset.zy)/ uTextureSSSColorSize.xy).rgb;\n    vec3 D = TEXTURE_2D_TextureSSSColor((coordCenter - offset.zy)/ uTextureSSSColorSize.xy).rgb;\n\n    // Luminance could be green channel only\n    float a = luminanceLinear(A);\n    float b = luminanceLinear(B);\n    float c = luminanceLinear(C);\n    float d = luminanceLinear(D);\n\n    float ab = abs(a - b);\n    float cd = abs(c - d);\n\n    // take the average in the direction that avoids dither pattern\n    vec3 quant1 = 0.5 * mix(A + B, C + D, ab > cd ? 1.0 : 0.0);\n    vec3 quant0 = TEXTURE_2D_TextureSSSColor(uvCenter).rgb;\n\n    float checker = checkerboard(coordCenter, uHalton);\n    diffuse = mix(quant1, quant0, checker);\n    specular = mix(quant0, quant1, checker);\n}\n\n',
                        "sssExtract.glsl": '#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureSSSColor;\nuniform sampler2D TextureDepth;\nuniform vec2 uTextureSSSColorSize;\n\nuniform vec4 uHalton;\n\n#pragma include "sssCommon.glsl"\n\n// hacky line to force the composerPostprocess to\n// hook texture funciton in sssCommon because pragma defines\n// aren\'t handled directly\n\n// TEXTURE_2D_TextureSSSColor(whatever)\nvec4 sssExtract() {\n    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);\n    vec3 specular;\n    vec3 diffuse;\n    uncheckerboard(diffuse, specular);\n\n    // force depth "0.0" to tell sss blur to skip the pixel when blurring\n    // make sure to return float not bool cast to float implicitely\n    // not all glsl compiler support that\n    float bgOrNotSSS = (decodeProfile(pack) == 0 || pack.x == 1.0) ? 0.0 : 1.0;\n    return vec4(diffuse, bgOrNotSSS * decodeDepth(pack));\n}\n',
                        "sssBlur.glsl": '#pragma include "utils/functions.glsl"\n#pragma include "utils/decodeDepth.glsl"\n#pragma include "utils/rand.glsl"\n\nuniform sampler2D TextureSSSBlur;\nuniform sampler2D TextureDepth;\nuniform sampler2D TextureSSSKernel;\n\nuniform vec2 uNearFar;\n\nuniform vec2 uBlurDir;\nuniform float uProjFactor;\nuniform float uScatteringFactorPacker;\nuniform float uFrameModTaaSS;\n\n#ifndef SSS_JITTER\n#define SSS_JITTER 1.0\n#endif\n\n#ifndef SSS_HALF_KERNEL_SIZE\n#define SSS_HALF_KERNEL_SIZE 11\n#endif\n\n#ifndef SSS_PROFILE_COUNT\n#define SSS_PROFILE_COUNT 1\n#endif\n\n#define SSS_FOLLOW_SURFACE\n\n// if we want to do it branchless\nvec3 sssFetchColorBranchless(const in vec2 uv, const in vec4 colorM, const in float depthNormBias){\n    vec4 fetch = TEXTURE_2D_TextureSSSBlur(uv);\n\n#ifdef SSS_FOLLOW_SURFACE\n    float mixer = smoothstep(0.0, 0.05, abs(colorM.a - fetch.a) * depthNormBias);\n    mixer = mix(mixer, 1.0, step(fetch.a, 0.0)); // force to 1 if fetch.a is 0 (background)\n    fetch.rgb = mix(fetch.rgb, colorM.rgb, mixer);\n#endif\n\n    // uv inside box\n    // https://stackoverflow.com/questions/12751080/glsl-point-inside-box-test\n    vec2 s = step(vec2(0.0), uv) - step(vec2(1.0), uv);\n    return mix(colorM.rgb, fetch.rgb, s.x * s.y);\n}\n\nvec3 sssFetchColor(const in vec2 uv, const in vec4 colorM, const in float depthNormBias){\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0) {\n        return colorM.rgb;\n    }\n\n    // ignore sss with big depth difference, original jimenez is clamp(dDiff, 0.0, 1.0)\n    // we use a much more aggressive function\n    vec4 fetch = TEXTURE_2D_TextureSSSBlur(uv);\n\n#ifdef SSS_FOLLOW_SURFACE\n    if (fetch.a == 0.0) return colorM.rgb;\n    return mix(fetch.rgb, colorM.rgb, smoothstep(0.0, 0.05, abs(colorM.a - fetch.a) * depthNormBias));\n#else\n    return fetch.rgb;\n#endif\n}\n\nvec4 sssBlur() {\n    vec4 colorM = TEXTURE_2D_TextureSSSBlur(gTexCoord);\n\n    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);\n\n    // background or not sss stuffs\n    if (pack.x == 1.0) {\n        return colorM;\n    }\n\n    int profile = decodeProfile(pack);\n    float scatter = decodeScatter(pack);\n    if (scatter == 0.0) {\n        return colorM;\n    }\n\n    float scatterWorld = scatter / uScatteringFactorPacker;\n    float depthRange = (uNearFar.y - uNearFar.x);\n\n    // for follow surface\n    // factor to get a normalized depth difference depending of scatter but not of camera position\n    float depthNormBias = depthRange * 0.05 / scatterWorld;\n\n    float worldPos = uNearFar.x + depthRange * colorM.a;\n    // uScatteringFactorPacker is just a unpacking factor because subsurface factor \n    // is a world space value but written in 8 bit texture\n    vec2 finalStep = uBlurDir * uProjFactor * scatterWorld / worldPos;\n    finalStep *= 1.0 / 3.0;\n\n    float yProfile = 1.0 - (float(profile) - 0.5) / float(SSS_PROFILE_COUNT);\n    float xKernelSize = 1.0 / float(SSS_HALF_KERNEL_SIZE);\n\n    vec3 kernel0 = texture2D(TextureSSSKernel, vec2(xKernelSize * 0.5, yProfile)).rgb;\n    vec3 colorBlurred = colorM.rgb * kernel0;\n\n    // force nearest sample for sss texture kernel color\n    vec2 offKernelNearest = vec2(0.5 * xKernelSize, 0.0);\n\n    // randomize the sss texture alpha weight a bit\n    float rnd = interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS);\n    rnd = mix(0.5, rnd, SSS_JITTER);\n    vec2 offKernelJitter = vec2(rnd * xKernelSize, 0.0);\n\n    for (int i = 1; i < SSS_HALF_KERNEL_SIZE; i++) {\n        vec2 uvKernel = vec2(float(i) * xKernelSize, yProfile);\n\n        vec3 kernel = texture2D(TextureSSSKernel, uvKernel + offKernelNearest).rgb;\n        float kernelDither = texture2D(TextureSSSKernel, uvKernel + offKernelJitter).a;\n\n        vec2 offset = kernelDither * finalStep;\n\n        vec3 fetch = sssFetchColor(gTexCoord + offset, colorM, depthNormBias);\n        fetch += sssFetchColor(gTexCoord - offset, colorM, depthNormBias);\n\n        colorBlurred += kernel.rgb * fetch;\n    }\n\n    return vec4(colorBlurred, colorM.a);\n}\n',
                        "sssCombine.glsl": '#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureSSSColor;\nuniform vec2 uTextureSSSColorSize;\n\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uProjFactor;\nuniform float uScatteringFactorPacker;\n\n#pragma include "sssCommon.glsl"\n\nuniform sampler2D TextureSSSBlur;\nuniform sampler2D TextureDepth;\n\nvec4 sssCombine() {\n\n    // full res - not SSS\n    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);\n    int profile = decodeProfile(pack);\n    // black pixels for background or non sss surfaces\n    if (pack.x == 1.0 || profile == 0) {\n        return TEXTURE_2D_TextureSSSColor(gTexCoord);\n    }\n\n    vec3 specular;\n    vec3 diffuse;\n    uncheckerboard(diffuse, specular);\n\n    // try to retain high res detail as much as possible (same ad dof)\n    // make sure to use a factor that is independent from bounding box\n    float scatterWorld = decodeScatter(pack) / uScatteringFactorPacker;\n    float worldPos = uNearFar.x + (uNearFar.y - uNearFar.x) * decodeDepth(pack);\n    float factor = uProjFactor * scatterWorld / worldPos;\n\n    // magic factor 10 (can be tweaked, e.g: if sss effects disappears too fast when we are far away)\n    factor = smoothstep(0.05, 0.3, factor * 10.0);\n    // return vec4(vec3(factor), 1.0);\n\n    diffuse = mix(diffuse, TEXTURE_2D_TextureSSSBlur(gTexCoord).rgb, factor);\n\n    return vec4(diffuse + specular, 1.0);\n}\n',
                        "packMipmapDepth.glsl": '#pragma include "utils/encodeDecode.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureDepth0;\nuniform sampler2D TextureDepth1;\nuniform sampler2D TextureDepth2;\nuniform sampler2D TextureDepth3;\nuniform sampler2D TextureDepth4;\nuniform sampler2D TextureDepth5;\nuniform vec2 uTextureOutputRatio;\n\nvec4 packMipmapDepth() {\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // see _hookComposerResize in NodePostProcess.js (mipmap)\n    gTexCoord.y /= uTextureOutputRatio.y;\n\n    float levelLog = -log2(1.0 - gTexCoord.y) + 1.0;\n    float level = floor(levelLog) - 1.0;\n\n    float pLevel = pow(2.0, level + 1.0); // 2, 4, 8, 16...\n    gTexCoord.x = pLevel * gTexCoord.x * 0.5;\n    gTexCoord.y = pLevel * (1.0 - gTexCoord.y) - 1.0;\n\n    // unused part of the texture\n    if (gTexCoord.x > 1.0 || gTexCoord.y > 1.0) return result;\n\n    if (level < 0.1) result.rgba = vec4(encode24(decodeDepth(TEXTURE_2D_TextureDepth0(gTexCoord))), 1.0);\n    else if (level < 1.1) result.rgba = TEXTURE_2D_TextureDepth1(gTexCoord);\n    else if (level < 2.1) result.rgba = TEXTURE_2D_TextureDepth2(gTexCoord);\n    else if (level < 3.1) result.rgba = TEXTURE_2D_TextureDepth3(gTexCoord);\n    else if (level < 4.1) result.rgba = TEXTURE_2D_TextureDepth4(gTexCoord);\n    else if (level < 5.1) result.rgba = TEXTURE_2D_TextureDepth5(gTexCoord);\n\n    return result;\n}\n',
                        "depthMipmap.glsl": '#pragma include "utils/encodeDecode.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureDepth;\nuniform int uFirstDepth;\n\nuniform vec2 uTextureDepthSize;\nuniform vec2 uTextureOutputSize;\n\n// For some reasons it requires unpacking *and* repacking to avoid transition between mipmap\nvec4 depthMipmap() {\n    vec2 invSize = 1.0 / uTextureDepthSize;\n    vec4 depths;\n    vec2 offDepth = vec2(0.25, -0.25);\n    if (uFirstDepth == 1) {\n        depths.x = decodeDepth(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.yy * invSize));\n        depths.y = decodeDepth(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.xy * invSize));\n        depths.z = decodeDepth(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.yx * invSize));\n        depths.w = decodeDepth(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.xx * invSize));\n    } else {\n        depths.x = decode24(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.yy * invSize).xyz);\n        depths.y = decode24(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.xy * invSize).xyz);\n        depths.z = decode24(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.yx * invSize).xyz);\n        depths.w = decode24(TEXTURE_2D_TextureDepth(gTexCoord + offDepth.xx * invSize).xyz);\n    }\n\n    return vec4(encode24(min(min(depths.x, depths.y), min(depths.z, depths.w))), 1.0);\n}\n',
                        "ssaoExtract.glsl": '#pragma include "utils/functions.glsl"\n#pragma include "utils/encodeDecode.glsl"\n#pragma include "utils/rand.glsl"\n\nuniform sampler2D TextureMipmapDepth;\nuniform vec2 uTextureMipmapDepthSize;\nuniform vec2 uTextureMipmapDepthRatio;\n\nuniform float uQuality; // mipmap usage\n\nuniform vec2 uTextureOutputSize;\n\nuniform float uSsaoRadius;\nuniform float uSsaoIntensity;\nuniform float uSsaoBias;\nuniform vec4 uSsaoProjectionInfo;\nuniform float uSsaoProjectionScale;\n\nuniform vec2 uNearFar;\n\nuniform float uFrameModTaaSS;\n\n// Constant used to scale the depth view value that is given to the blur pass\n#define MIN_RADIUS 1.0\n#define NB_SPIRAL_TURNS 3.0\n\nvec4 fetchDepthPackLevel(const in vec2 uv, const in float level){\n    float maxLod = 5.0;\n    float powLevel = pow(2.0, min(maxLod, floor(level)) + 1.0);\n    vec2 pixelSize = 2.0 * powLevel / uTextureMipmapDepthSize;\n\n    vec2 uvFetch = max(pixelSize, min(1.0 - pixelSize, uv));\n    uvFetch = vec2(2.0 * uvFetch.x, powLevel - 1.0 - uvFetch.y) * uTextureMipmapDepthRatio.xy / powLevel;\n\n    return texture2D(TextureMipmapDepth, uvFetch);\n}\n\nfloat fetchDepthLevel(const in vec2 uv, const in float level){\n    return decode24(fetchDepthPackLevel(uv, level).xyz);\n}\n\nfloat zValueFromScreenSpacePosition(const in float depth) {\n    return uNearFar.x + (uNearFar.y - uNearFar.x) * depth;\n}\n\nvec3 reconstructCSPosition(const in vec2 ssP, const in float z) {\n    return vec3((ssP.xy * uSsaoProjectionInfo.xy + uSsaoProjectionInfo.zw) * z, z);\n}\n\nvec3 getPosition(const in vec2 uv) {\n    return reconstructCSPosition(uv * uTextureOutputSize, zValueFromScreenSpacePosition(fetchDepthLevel(uv, 0.0)));\n}\n\n#define MAX_MIP_LEVEL 5\n// Determines at which point we should switch mip level\n// if number is too small (~3) will lead to flashing (bad variance as many taps give same pixel)\n// if number is too high, mip level are not used well and the cache is not used efficiently\n#define LOG_MAX_OFFSET 3\n\nvec3 getOffsetedPixelPos(\n    const in vec2 uv,\n    const in vec2 unitOffset,\n    const in float screenSpaceRadius) {\n\n    float mipLevel = clamp(floor(log2(screenSpaceRadius)) - float(LOG_MAX_OFFSET), 0.0, float(MAX_MIP_LEVEL));\n    vec2 uvOff = uv + floor(screenSpaceRadius * unitOffset) / uTextureOutputSize;\n\n    float d = zValueFromScreenSpacePosition(fetchDepthLevel(uvOff, mipLevel));\n    return reconstructCSPosition(uvOff * uTextureOutputSize, d);\n}\n\n#define PIOVER8 0.39269908169\nvec3 unpackNormal1(const in float pack1) {\n    float pack8 = floor(pack1 * 255.0);\n    float th = PIOVER8 * float(pack8 / 16.0);\n    float len = sqrt(mod(float(pack8), 16.0) / 15.001);\n    vec2 nv = vec2(cos(th), sin(th)) * len;\n    return -vec3(nv.x, nv.y, sqrt(max(0.0, 1.0 - nv.x * nv.x - nv.y * nv.y)));\n}\n\nvec3 unpackNormal2(const in vec2 pack2) {\n    vec3 nv = pack2.rgg * 2.0 - 1.0;\n    return -vec3(nv.x, nv.y, sqrt(max(0.0, 1.0 - nv.x * nv.x - nv.y * nv.y)));\n}\n\n#define SSAO_TAP_EXTRACT(id) screenSpaceRadius = (float(id) + 0.5) * (1.0 / nbSamples); \\\n    angle = screenSpaceRadius * (NB_SPIRAL_TURNS * 6.28) + randomAngle; \\\n    screenSpaceRadius = max(0.75, screenSpaceRadius * ssRadius); \\\n    offsetUnitVec = vec2(cos(angle), sin(angle)); \\\n    occludingPoint = getOffsetedPixelPos(uv, offsetUnitVec, screenSpaceRadius); \\\n    occludingPoint -= cameraSpacePosition; \\\n    vv = dot(occludingPoint, occludingPoint); \\\n    vn = dot(occludingPoint, normal); \\\n    contrib += max(1.0 - vv * invRadius2, 0.0) * max((vn - uSsaoBias) * inversesqrt(vv), 0.0); \\\n\n#define SSAO_DO_TAPS(void) SSAO_TAP_EXTRACT(offset + 0); \\\n    SSAO_TAP_EXTRACT(offset + 1); \\\n    SSAO_TAP_EXTRACT(offset + 2); \\\n    SSAO_TAP_EXTRACT(offset + 3); \\\n    SSAO_TAP_EXTRACT(offset + 4); \\\n    SSAO_TAP_EXTRACT(offset + 5); \\\n    SSAO_TAP_EXTRACT(offset + 6); \\\n    SSAO_TAP_EXTRACT(offset + 7); \\\n    SSAO_TAP_EXTRACT(offset + 8); \\\n    SSAO_TAP_EXTRACT(offset + 9); \\\n    SSAO_TAP_EXTRACT(offset + 10); \\\n    offset += 11; \\\n\n\nvec4 ssaoExtract() {\n    vec2 uv = gTexCoord;\n\n    vec3 depthPacked = fetchDepthPackLevel(uv, 0.0).xyz;\n\n    vec3 cameraSpacePosition = getPosition(uv);\n    float ssRadius = -uSsaoProjectionScale * uSsaoRadius / cameraSpacePosition.z;\n\n#ifdef SSAO_NORMAL\n    vec3 normal = unpackNormal2(TEXTURE_2D_TextureDepth(uv).ba); // g buffer normal 2 component on ba\n#elif defined(GL_OES_standard_derivatives) && !defined(MOBILE)\n    vec3 normal = cross(dFdy(cameraSpacePosition), dFdx(cameraSpacePosition));\n#else\n    vec2 offDepth = vec2(1.0, 0.0);\n    vec3 depthLeft = getPosition(uv - offDepth.xy / uTextureMipmapDepthSize);\n    vec3 depthRight = getPosition(uv + offDepth.xy / uTextureMipmapDepthSize);\n    vec3 depthBottom = getPosition(uv - offDepth.yx / uTextureMipmapDepthSize);\n    vec3 depthTop = getPosition(uv + offDepth.yx / uTextureMipmapDepthSize);\n    vec3 normal = cross(depthLeft - depthRight, depthTop - depthBottom);\n#endif\n\n    // early returns should be done derivatives usage to avoid bad edges\n\n    // early return background\n    if (depthPacked.x == 1.0) {\n        return vec4(depthPacked, 1.0);\n    }\n\n    // early return radius too small (note: needs to be in separate conditional because of nvidia/osx bug)\n    if (ssRadius < MIN_RADIUS) {\n        return vec4(depthPacked, 1.0);\n    }\n\n    normal = normalize(normal);\n    float nFalloff = mix(1.0, max(0.0, 1.5 * normal.z), 0.35);\n\n     // needs to be > 2PI\n    float randomAngle = 6.28 * interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS);\n    float invRadius2 = 1.0 / (uSsaoRadius * uSsaoRadius);\n    float contrib = 0.0;\n\n    float vv;\n    float vn;\n    float screenSpaceRadius;\n    float angle;\n    vec3 occludingPoint;\n    vec2 offsetUnitVec;\n    int offset = 0;\n\n    float nbSamples = 11.0;\n\n    if (uQuality > 0.33) nbSamples += 11.0;\n#ifndef MOBILE\n    if (uQuality > 0.66) nbSamples += 11.0;\n#endif\n\n    SSAO_DO_TAPS();\n    if (uQuality > 0.33) { SSAO_DO_TAPS(); }\n#ifndef MOBILE\n    if (uQuality > 0.66) { SSAO_DO_TAPS(); }\n#endif\n\n    float aoValue = max(0.0, 1.0 - sqrt(contrib * nFalloff / nbSamples));\n    aoValue = pow(aoValue, 10.0 * uSsaoIntensity);\n\n    vec4 aoDepth;\n    aoDepth.rgb = depthPacked;\n    aoDepth.a = mix(1.0, aoValue, clamp(ssRadius - MIN_RADIUS, 0.0, 1.0));\n\n    return aoDepth;\n}\n',
                        "ssaoBlur.glsl": '#pragma include "utils/encodeDecode.glsl"\n\nuniform sampler2D TextureBlurInput;\nuniform vec2 uTextureBlurInputSize;\n\n#define SSAO_FILTER_RADIUS 3\n\n#define SSAO_TAP_BLUR(id, absid) sampleTex = TEXTURE_2D_TextureBlurInput(uv + axis * float(id) * 2.0); \\\n    z = decode24(sampleTex.xyz); \\\n    weight = max(0.0, 1.0 - sharpnessFactor * abs(z - initialZ)) * (0.3 + gaussian[absid]); \\\n    sum += weight * sampleTex.a; \\\n    totalWeight += weight;\n\nvec4 ssaoBlur(const in vec2 axis) {\n    vec2 uv = gTexCoord;\n\n    vec4 aoDepth = TEXTURE_2D_TextureBlurInput(uv);\n\n    // background\n    if(aoDepth.x == 1.0){\n        return aoDepth;\n    }\n\n    float initialZ = decode24(aoDepth.xyz);\n\n    float gaussian[SSAO_FILTER_RADIUS + 2]; // dummy because of intel off-by-one bug\n    gaussian[0] = 0.153170;\n    gaussian[1] = 0.144893;\n    gaussian[2] = 0.122649;\n    gaussian[3] = 0.092902;\n    gaussian[4] = 0.0;\n\n    float totalWeight = gaussian[0];\n    float sum = aoDepth.a * totalWeight;\n    float sharpnessFactor = 400.0;\n\n    // ---- UNROLL ----\n    vec2 ofs;\n    float z;\n    float weight;\n    vec4 sampleTex;\n\n    SSAO_TAP_BLUR(-3, 3);\n    SSAO_TAP_BLUR(-2, 2);\n    SSAO_TAP_BLUR(-1, 1);\n    SSAO_TAP_BLUR(1, 1);\n    SSAO_TAP_BLUR(2, 2);\n    SSAO_TAP_BLUR(3, 3);\n    // ---- UNROLL ----\n\n    aoDepth.a = sum / totalWeight;\n    return aoDepth;\n}\n\n#ifdef SSAO_BLUR_H\nvec4 ssaoBlurH() {\n    return ssaoBlur(vec2(1.0, 0.0) / uTextureBlurInputSize);\n}\n#else\nvec4 ssaoBlurV() {\n    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;\n    return vec4(color * ssaoBlur(vec2(0.0, 1.0) / uTextureBlurInputSize).aaa, 1.0);\n}\n#endif',
                        "dofCommon.glsl": '#pragma include "utils/decodeDepth.glsl"\n\nconst float MAX_BLUR = 16.0;\nconst float EPS_EARLY_OUT = 0.01; // early out (typically when we move the camera fast and the dof might be not effective)\n\nfloat texDepthToCoC(const in vec4 fetch) {\n    // background should be always max blurred so that the near blur can expand onto the background (because of special dilate background codepath below)\n    if(fetch.x == 1.0) return max(uDofBlurNearFarFocal.x, uDofBlurNearFarFocal.y);\n\n    float coc = decodeDepth(fetch);\n    coc = clamp((coc - uDofBlurNearFarFocal.z) / coc, -1.0, 1.0);\n    return (coc < 0.0 ? coc * uDofBlurNearFarFocal.x : coc * uDofBlurNearFarFocal.y);\n}',
                        "dofCoC.glsl": 'uniform vec3 uDofBlurNearFarFocal;\n\n#pragma include "dofCommon.glsl"\n\nuniform sampler2D TextureDepth;\n\nvec4 dofCoC() {\n    if(uDofBlurNearFarFocal.x < EPS_EARLY_OUT && uDofBlurNearFarFocal.y < EPS_EARLY_OUT){\n        return vec4(0.0);\n    }\n\n    return vec4(vec3(0.0), texDepthToCoC(TEXTURE_2D_TextureDepth(gTexCoord)) * 0.5 + 0.5);\n}',
                        "dofNearDilate.glsl": 'uniform vec3 uDofBlurNearFarFocal;\n\n#pragma include "dofCommon.glsl"\n\nuniform sampler2D TextureDofCoC;\nuniform vec2 uTextureDofCoCSize;\nuniform sampler2D TextureDepth;\n\nuniform float uDofScale;\n\nvec4 dilateNear(const in vec2 offset) {\n    if(uDofBlurNearFarFocal.x < EPS_EARLY_OUT && uDofBlurNearFarFocal.y < EPS_EARLY_OUT){\n        return vec4(0.0);\n    }\n\n    // TODO DOF both the weights and the formula can be tweaked, also we could add a bit of jitter or something\n    vec2 uv = gTexCoord;\n    bool isBG = TEXTURE_2D_TextureDepth(uv).x == 1.0;\n\n    float coc = 0.0;\n    vec2 ofs = MAX_BLUR * offset / 5.0;\n\n    float coc0 = TEXTURE_2D_TextureDofCoC(uv).a * 2.0 - 1.0;\n    float coc1 = TEXTURE_2D_TextureDofCoC(uv - 5.0 * ofs).a * 2.0 - 1.0;\n    float coc2 = TEXTURE_2D_TextureDofCoC(uv - 4.0 * ofs).a * 2.0 - 1.0;\n    float coc3 = TEXTURE_2D_TextureDofCoC(uv - 3.0 * ofs).a * 2.0 - 1.0;\n    float coc4 = TEXTURE_2D_TextureDofCoC(uv - 2.0 * ofs).a * 2.0 - 1.0;\n    float coc5 = TEXTURE_2D_TextureDofCoC(uv - 1.0 * ofs).a * 2.0 - 1.0;\n    float coc6 = TEXTURE_2D_TextureDofCoC(uv + 1.0 * ofs).a * 2.0 - 1.0;\n    float coc7 = TEXTURE_2D_TextureDofCoC(uv + 2.0 * ofs).a * 2.0 - 1.0;\n    float coc8 = TEXTURE_2D_TextureDofCoC(uv + 3.0 * ofs).a * 2.0 - 1.0;\n    float coc9 = TEXTURE_2D_TextureDofCoC(uv + 4.0 * ofs).a * 2.0 - 1.0;\n    float coc10 = TEXTURE_2D_TextureDofCoC(uv + 5.0 * ofs).a * 2.0 - 1.0;\n\n    if(isBG == true){\n        // avoid "shrink" effect on the out of focus far part on the model edges\n        // gaussian weights (sigma 10), (doesn\'t have to be gaussian though), but the sum must be 1.0\n        // http://dev.theomader.com/gaussian-kernel-calculator/\n        coc = abs(coc0) * 0.095474 +\n        (abs(coc1) + abs(coc10)) * 0.084264 +\n        (abs(coc2) + abs(coc9)) * 0.088139 +\n        (abs(coc3) + abs(coc8)) * 0.091276 +\n        (abs(coc4) + abs(coc7)) * 0.093585 +\n        (abs(coc5) + abs(coc6)) * 0.094998;\n    } else {\n        // blur only near field (expand)\n        coc = min(coc0, 0.0);\n        coc = min(coc1 * 0.3, coc);\n        coc = min(coc2 * 0.5, coc);\n        coc = min(coc3 * 0.75, coc);\n        coc = min(coc4 * 0.8, coc);\n        coc = min(coc5 * 0.95, coc);\n        coc = min(coc6 * 0.95, coc);\n        coc = min(coc7 * 0.8, coc);\n        coc = min(coc8 * 0.75, coc);\n        coc = min(coc9 * 0.5, coc);\n        coc = min(coc10 * 0.3, coc);\n        if(abs(coc0) > abs(coc)) coc = coc0;\n    }\n\n    return vec4(0.0, 0.0, 0.0, coc * 0.5 + 0.5);\n}\n\nvec4 dofNearDilateH() {\n    vec2 offset = vec2(uDofScale / uTextureDofCoCSize.x, 0.0);\n    return dilateNear(offset);\n}\n\nvec4 dofNearDilateV() {\n    vec2 offset = vec2(0.0, uDofScale / uTextureDofCoCSize.y);\n    return dilateNear(offset);\n}',
                        "dofDownsampleColor.glsl": "uniform sampler2D TextureInput;\n\n#ifdef COLOR_WITH_COC\nuniform sampler2D TextureDofCoC;\n#endif\n\nvec4 dofDownsampleColor() {\n    vec2 uv = gTexCoord;\n\n    vec4 color = TEXTURE_2D_NEAREST_TextureInput(uv);\n\n// premult with coc buffer\n#ifdef COLOR_WITH_COC\n    color.a = abs(TEXTURE_2D_TextureDofCoC(uv).a * 2.0 - 1.0);\n    color.a *= color.a * color.a;\n    color.rgb *= color.a;\n#endif\n\n    return color;\n}",
                        "dofBlurCircular.glsl": '#pragma include "utils/rand.glsl"\n\nuniform vec3 uDofBlurNearFarFocal;\n#pragma include "dofCommon.glsl"\n\nuniform sampler2D TextureDofColor;\nuniform vec2 uTextureDofColorSize;\n\n#ifndef COLOR_WITH_COC\nuniform sampler2D TextureDofCoC;\nuniform vec2 uTextureDofCoCSize;\n#endif\n\nuniform float uDofScale;\nuniform float uQuality;\n\nuniform float uFrameModTaaSS;\n\n#ifdef COLOR_WITH_COC\n#define DOF_TAP(id) ofs = fTaps_Poisson[id]; \\\n                    ofs = gTexCoord + blurDist * vec2(dot(ofs, basis.xy), dot(ofs, basis.zw) ); \\\n                    sumcol += TEXTURE_2D_TextureDofColor(ofs);\n#else\n#define DOF_TAP(id) ofs = fTaps_Poisson[id]; \\\n                    ofs = gTexCoord + blurDist * vec2(dot(ofs, basis.xy), dot(ofs, basis.zw) ); \\\n                    cocWeight = abs(TEXTURE_2D_TextureDofCoC(ofs).a * 2.0 - 1.0); \\\n                    cocWeight *= cocWeight * cocWeight; \\\n                    sumcol.rgb += TEXTURE_2D_TextureDofColor(ofs).rgb * cocWeight; \\\n                    sumcol.a += cocWeight;\n#endif\n\nvec4 dofBlur16(const in vec2 blurDist, const in float ntime) {\n    float rnd = 6.28 * ditheringNoise(gl_FragCoord.xy, uFrameModTaaSS + ntime);\n\n    float cosa = cos(rnd);\n    float sina = sin(rnd);\n    vec4 basis = vec4(cosa, -sina, sina, cosa);\n\n    vec4 sumcol = vec4(0.0);\n\n    float total = 0.0;\n\n    vec2 fTaps_Poisson[17];\n    // https://github.com/bartwronski/PoissonSamplingGenerator\n    fTaps_Poisson[0] = vec2(0.343280198355, 0.921191856785);\n    fTaps_Poisson[1] = vec2(-0.116859107262, 0.873056831344);\n    fTaps_Poisson[2] = vec2(-0.646421287853, 0.760425284853);\n    fTaps_Poisson[3] = vec2(-0.0437332058416, 0.47196719804);\n    fTaps_Poisson[4] = vec2(0.48240473891, 0.464894594736);\n    fTaps_Poisson[5] = vec2(-0.718897237297, 0.352191304304);\n    fTaps_Poisson[6] = vec2(-0.939061387886, -0.0387376698953);\n    fTaps_Poisson[7] = vec2(0.546569494557, -0.0169516524446);\n    fTaps_Poisson[8] = vec2(-0.182644095652, -0.0702667761349);\n    fTaps_Poisson[9] = vec2(-0.576191305396, -0.252368997099);\n    fTaps_Poisson[10] = vec2(0.921914032366, -0.366530187909);\n    fTaps_Poisson[11] = vec2(-0.0582053944545, -0.510617206206);\n    fTaps_Poisson[12] = vec2(-0.783101528934, -0.601411360136);\n    fTaps_Poisson[13] = vec2(0.430604354377, -0.729559481383);\n    fTaps_Poisson[14] = vec2(-0.350716524868, -0.809522919973);\n    fTaps_Poisson[15] = vec2(0.0600898835968, -0.952568587297);\n    fTaps_Poisson[16] = vec2(0.0, 0.0); // dummy because of intel off-by-one bug\n\n    vec2 ofs;\n    vec4 sampleTex;\n    float cocWeight;\n\n    DOF_TAP(0);\n    DOF_TAP(1);\n    DOF_TAP(2);\n    DOF_TAP(3);\n    DOF_TAP(4);\n    DOF_TAP(5);\n    DOF_TAP(6);\n    DOF_TAP(7);\n    DOF_TAP(8);\n    DOF_TAP(9);\n    DOF_TAP(10);\n    DOF_TAP(11);\n    DOF_TAP(12);\n    DOF_TAP(13);\n    DOF_TAP(14);\n    DOF_TAP(15);\n\n    return sumcol;\n}\n\nvec4 dofBlurCircular() {\n    if(uDofBlurNearFarFocal.x < EPS_EARLY_OUT && uDofBlurNearFarFocal.y < EPS_EARLY_OUT) {\n        return vec4(0.0);\n    }\n\n    float factor = MAX_BLUR * uDofScale;\n\n#ifdef COLOR_WITH_COC\n    vec2 blurDist = factor * pow(TEXTURE_2D_TextureDofColor(gTexCoord).a, 0.333) / uTextureDofColorSize;\n#else\n    vec2 blurDist = factor * abs(TEXTURE_2D_TextureDofCoC(gTexCoord).a * 2.0 - 1.0) / uTextureDofCoCSize;\n#endif\n\n    // TODO optimize dofBlur16 (unroll...)\n    vec4 sumcol = dofBlur16(blurDist, 0.0); // 16\n    if (uQuality > 0.33) sumcol += dofBlur16(blurDist, 3.0); // 32\n    if (uQuality > 0.66) sumcol += dofBlur16(blurDist, 5.0); // 48\n\n    return vec4(sumcol.rgb / sumcol.a, 1.0);\n}\n',
                        "dofCombine.glsl": 'uniform vec3 uDofBlurNearFarFocal;\n\n#pragma include "dofCommon.glsl"\n\nuniform sampler2D TextureInput;\nuniform sampler2D TextureDofBlurCircular;\nuniform sampler2D TextureDofNearDilateV;\nuniform sampler2D TextureDepth;\n\nuniform vec2 uTextureDofNearDilateVSize;\nuniform vec2 uTextureDofBlurCircularSize;\n\nuniform float uDofScale;\n\nvec4 dofCombine() {\n    vec2 uv = gTexCoord;\n    vec3 color = TEXTURE_2D_TextureInput(uv).rgb;\n\n    if(uDofBlurNearFarFocal.x < EPS_EARLY_OUT && uDofBlurNearFarFocal.y < EPS_EARLY_OUT){\n        return vec4(color, 1.0);\n    }\n\n    vec4 depthPacked = TEXTURE_2D_TextureDepth(uv);\n\n    // half res color\n    vec3 blur;\n    // no bilinear for background pixels because it can displays artefacts on low frequency due to rgbm bilinear fetching\n    if (depthPacked.x == 1.0) {\n        blur = TEXTURE_2D_NEAREST_TextureDofBlurCircular(uv).rgb;\n        vec2 off = vec2(1.0, -1.0) * uDofScale;\n        blur += TEXTURE_2D_NEAREST_TextureDofBlurCircular(uv + off.xx / uTextureDofBlurCircularSize).rgb;\n        blur += TEXTURE_2D_NEAREST_TextureDofBlurCircular(uv + off.yy / uTextureDofBlurCircularSize).rgb;\n        blur += TEXTURE_2D_NEAREST_TextureDofBlurCircular(uv + off.xy / uTextureDofBlurCircularSize).rgb;\n        blur += TEXTURE_2D_NEAREST_TextureDofBlurCircular(uv + off.yx / uTextureDofBlurCircularSize).rgb;\n        blur /= 5.0;\n    } else {\n        blur = TEXTURE_2D_TextureDofBlurCircular(uv).rgb;\n        vec2 off = vec2(1.0, -1.0) * uDofScale;\n        blur += TEXTURE_2D_TextureDofBlurCircular(uv + off.xx / uTextureDofBlurCircularSize).rgb;\n        blur += TEXTURE_2D_TextureDofBlurCircular(uv + off.yy / uTextureDofBlurCircularSize).rgb;\n        blur += TEXTURE_2D_TextureDofBlurCircular(uv + off.xy / uTextureDofBlurCircularSize).rgb;\n        blur += TEXTURE_2D_TextureDofBlurCircular(uv + off.yx / uTextureDofBlurCircularSize).rgb;\n        blur /= 5.0;\n    }\n\n    // merge full res and half res coc\n    vec2 uvNearest = (floor(uv * uTextureDofNearDilateVSize) + 0.5) / uTextureDofNearDilateVSize;\n    float coc = abs(min(TEXTURE_2D_TextureDofNearDilateV(uvNearest).a * 2.0 - 1.0, texDepthToCoC(depthPacked)));\n\n    // merge half res blurred color and full res pixels\n    float cocLower = 0.05;\n    float cocHigher = 0.3;\n\n    return vec4(mix(color, blur, smoothstep(cocLower, cocHigher, coc)), 1.0);\n}\n\n',
                        "bloomExtract.glsl": '#pragma include "utils/getLuminance.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureInput;\n\n#ifdef HAS_BACKGROUND\nuniform sampler2D TextureDepth;\n#endif\n\nuniform float uBloomThreshold;\n\nvec3 extractBright(const in vec3 color) {\n    // TODO manage hdr pixel with high frequency? (use derivative??), for now we clamp the extracted pixel :(\n    return clamp(color * clamp(getLuminance(color) - uBloomThreshold, 0.0, 1.0), 0.0, 1.0);\n}\n\nvec4 bloomExtract() {\n    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;\n\n#ifdef HAS_BACKGROUND\n\tfloat alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));\n\tif(alpha == 0.0) {\n\t\treturn vec4(vec3(0.0), 1.0);\n    }\n#else\n\tfloat alpha = 1.0;\n#endif\n\n\treturn vec4(extractBright(color * alpha), 1.0);\n}',
                        "bloomCombine.glsl": "uniform sampler2D TextureInput;\nuniform sampler2D TextureBloomBlur1;\nuniform sampler2D TextureBloomBlur2;\nuniform sampler2D TextureBloomBlur3;\nuniform sampler2D TextureBloomBlur4;\nuniform sampler2D TextureBloomBlur5;\n\nuniform float uBloomRadius;\nuniform float uBloomFactor;\n\nfloat getRadiusFactored(const float value, const float middle) {\n    return mix(value, middle * 2.0 - value, uBloomRadius);\n}\n\nvec4 bloomCombine() {\n    vec3 bloom = vec3(0.0);\n\n    const float midVal = 0.6;\n\n    const float factor1 = 1.1;\n    const float factor2 = 0.9;\n    const float factor3 = 0.6;\n    const float factor4 = 0.3;\n    const float factor5 = 0.1;\n\n    bloom += TEXTURE_2D_TextureBloomBlur1(gTexCoord).rgb * getRadiusFactored(factor1, midVal);\n    bloom += TEXTURE_2D_TextureBloomBlur2(gTexCoord).rgb * getRadiusFactored(factor2, midVal);\n    bloom += TEXTURE_2D_TextureBloomBlur3(gTexCoord).rgb * getRadiusFactored(factor3, midVal);\n    bloom += TEXTURE_2D_TextureBloomBlur4(gTexCoord).rgb * getRadiusFactored(factor4, midVal);\n    bloom += TEXTURE_2D_TextureBloomBlur5(gTexCoord).rgb * getRadiusFactored(factor5, midVal);\n\n    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;\n    return vec4(color + (bloom * uBloomFactor), 1.0);\n}",
                        "chromaticAberration.glsl": "uniform sampler2D TextureInput;\n\nuniform float uChromaFactor;\n\nvec4 chromaticAberration() {\n    vec2 uv = gTexCoord;\n\n    vec2 dist = uv - 0.5;\n    vec2 offset = uChromaFactor * dist * length(dist);\n    vec3 col;\n    col.r = TEXTURE_2D_TextureInput(uv - offset).r;\n    col.g = TEXTURE_2D_TextureInput(uv).g;\n    col.b = TEXTURE_2D_TextureInput(uv + offset).b;\n\n    return vec4(col, 1.0);\n}",
                        "vignette.glsl": '#pragma include "utils/decodeDepth.glsl"\n#pragma include "utils/rand.glsl"\n\nuniform vec2 uLensRadius;\nuniform float uFrameMod;\n\nfloat vignetteDithered() {\n    vec2 lens = uLensRadius;\n    // smoothesp is not realiable with edge0 == edge1\n    lens.y = min(lens.y, lens.x - 1e-4);\n\n    float jitter = interleavedGradientNoise(gl_FragCoord.xy, uFrameMod);\n\n    // jitter a bit the uv to remove the banding in some cases\n    // (lens.x - lens.y) reduce flickering when the vignette is harder (hardness)\n    // (lens.x + lens.y) reduce the flickering when the vignette has a strong radius\n    jitter = (lens.x - lens.y) * (lens.x + lens.y) * 0.07 * (jitter - 0.5);\n    return smoothstep(lens.x, lens.y, jitter + distance(gTexCoord, vec2(0.5)));\n}\n\nvec4 vignette(const in vec4 color) {\n    float factor = vignetteDithered();\n    return vec4(linearTosRGB(sRGBToLinear(color.rgb) * factor), clamp(color.a + (1.0 - factor), 0.0, 1.0));\n}',
                        "toneMapping.glsl": '#pragma include "utils/getLuminance.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\nuniform float uToneExposure;\nuniform float uToneBrightness;\nuniform float uToneContrast;\nuniform float uToneSaturation;\nuniform int uToneMethod;\n\n#ifdef HAS_FIXED_BACKGROUND\nuniform sampler2D TextureDepth;\n#endif\n\nvec3 toneMapping(const in vec3 color) {\n    vec3 col = color * uToneExposure;\n    float luminance = dot(col * (1.0 + uToneBrightness), vec3(0.2126, 0.7152, 0.0722));\n    col = mix(vec3(luminance), col * (1.0 + uToneBrightness), vec3(uToneSaturation));\n\n    // contrast is annoying and require special treatment in case of fixed background\n    // because it doesn\'t output black when the input is black\n    float toneContrast = uToneContrast;\n#ifdef HAS_FIXED_BACKGROUND\n    float alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));\n    if(alpha == 0.0) toneContrast *= luminance;\n#endif\n    col = max(vec3(0.0), col * (1.0 + toneContrast) - 0.5 * toneContrast);\n\n    // simple reinhard and filmic\n    // http://filmicgames.com/archives/190\n    if(uToneMethod == 1) { // reinhard (on luminance)\n        col /= 1.0 + getLuminance(col);\n    } else if( uToneMethod == 2) { // filmic\n        vec3 x = max(vec3(0.0), col - 0.004);\n        col = (x * (6.2 * x + 0.5) ) / ( x * (6.2 * x + 1.7) + 0.06);\n        col = pow(col, vec3(2.2)); // filmic curve already encode srgb to linear\n    }\n\n    return col;\n}\n\nvec4 toneMapping(const in vec4 color) {\n    return vec4(toneMapping(color.rgb), 1.0);\n}\n',
                        "colorBalance.glsl": "uniform vec3 uColorBalanceLow;\nuniform vec3 uColorBalanceMid;\nuniform vec3 uColorBalanceHigh;\n\nfloat RGBToL(const in vec3 color) {\n    float fmin = min(min(color.r, color.g), color.b);\n    float fmax = max(max(color.r, color.g), color.b);\n    return (fmax + fmin) / 2.0;\n}\n\nvec3 colorBalance(const in vec3 color) {\n    vec3 lrgb = uColorBalanceLow;\n    vec3 mrgb = uColorBalanceMid;\n    vec3 hrgb = uColorBalanceHigh;\n\n    float cLen = length(color);\n    if(cLen < 1e-5)\n        return color;\n\n    // TODO : I have no idea what I am doing, we should use a curve widge\n    float lightness = RGBToL(color);\n    // '  lightness=(lightness*0.9-1.0)/(lightness*2.0+1.0) +1.0;\n    lightness = (1.5 * lightness) / (lightness + 0.5);\n    // https://github.com/liovch/GPUImage/blob/master/framework/Source/GPUImageColorBalanceFilter\n    float a = 0.25;\n    float b = 0.333;\n    float scale = 0.7;\n    vec3 low = lrgb * clamp((lightness - b) / -a + 0.5, 0.0, 1.0);\n    vec3 mid = mrgb * clamp((lightness - b) / a + 0.5, 0.0, 1.0) * clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0);\n    vec3 high = hrgb * clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0);\n    vec3 newColor = max(color + (low + mid + high) * scale, vec3(0.0));\n    // newColor can be negative\n    float len = length(newColor);\n    return len < 1e-5 ? newColor * cLen : newColor * cLen / len;\n}\n\nvec4 colorBalance(const in vec4 color) {\n    return vec4(colorBalance(color.rgb), 1.0);\n}",
                        "supersample.glsl": "uniform vec4 uHalton;\n\nuniform float uSSAARestart;\nuniform sampler2D TexturePrevious;\nuniform vec2 uTexturePreviousSize;\n\n// static in place amortized supersampling\nvec4 supersample() {\n    vec4 currFragColor = TEXTURE_2D_TextureInput(gTexCoord).rgba;\n\n    float haltz = abs(uHalton.z);\n    if (haltz == 1.0) {\n        // just return the color.\n        return currFragColor;\n    }\n\n    // same pixel for same projected interpolated vertex on prev frame\n    vec4 accumColorN = TEXTURE_2D_NEAREST_TexturePrevious(gTexCoord).rgba;\n\n    // mix frames\n    float lerpFac = 1.0 / uHalton.w;\n\n    // if uTaaSSSRestart is 0.0, then we used the previous TAAed image to start supersampling\n    // we do that to avoid a sudden re-aliasing of the image (which is perceptible)\n    if (uHalton.w == 1.0) lerpFac = uSSAARestart;\n\n    if (haltz == 3.0) {\n        // No supersample, crude motion blur by accumulation\n        return mix(currFragColor, accumColorN, lerpFac);\n    }\n\n    // Supsersample, accumulation + jittering\n    // http://en.wikipedia.org/wiki/Moving_average#Cumulative_moving_average\n    // cumulative moving average over frameNum (which starts at 2)\n    // n is previous frame\n    // accumColorN = Accum(n)\n    // return value is accumColor( n +1 )\n    // Accum(n+1) = Accum(n) + ((x(n+1) - Accum(n)) / (n + 1)))\n    // formula above is equal to glsl  mix\n    return mix(accumColorN, currFragColor, lerpFac);\n}\n",
                        "supersampleTaa.glsl": '#pragma include "utils/getLuminance.glsl"\n#pragma include "utils/decodeDepth.glsl"\n#pragma include "supersample.glsl"\n\nuniform sampler2D TextureInput;\nuniform vec2 uTextureInputSize;\nuniform sampler2D TexturePrevious;\nuniform vec2 uTexturePreviousSize;\nuniform sampler2D TextureDepth;\n\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\n\nuniform float uTaaEnabled;\nuniform mat4 uTaaMotionMatrixLeft;\nuniform vec4 uTaaCornersCSLeft[2];\n\n#ifdef VR_ENABLED\nuniform mat4 uTaaMotionMatrixRight;\nuniform vec4 uTaaCornersCSRight[2];\n#endif\n\nvec3 reconstructVSPosition(const in vec2 uv, const in vec4 corners0, const in vec4 corners1, const in float depth) {\n    vec2 finalUv = uv;\n#ifdef VR_ENABLED\n    float xViewportOffset = uv.x >= 0.5 ? -0.5 : 0.0;\n    finalUv.x = ( uv.x + xViewportOffset ) * 2.0;\n#endif\n\n    // the corners are in view space, it means if we interpolate between them we can retrieve the view space direction of the fragment\n    vec4 AB = mix(corners0, corners1, vec4(finalUv.x));\n\n    // multiply this view space direction by the depth gives us the view space position\n    return vec3(mix(AB.xy, AB.zw, vec2(finalUv.y)), 1.0) * depth;\n}\n\n#define NEIGHBOUR_SET_IF_DMIN_Z_GREATER(d, x, y) if(d < dmin.z) dmin = vec3(x, y, d);\n#define NEIGHBOUR_CREATE_FROM_OFFSET(d, x, y) d = decodeDepth(TEXTURE_2D_TextureDepth(uv + vec2(x,y)));\n#define FIND_NEIGHBOUR_MIN(d, x, y) NEIGHBOUR_CREATE_FROM_OFFSET(d, x, y); NEIGHBOUR_SET_IF_DMIN_Z_GREATER(d, x, y)\n\n\n// Neighborhood clamping from Tiago Sousa\n// 4tap(decent) comment t, ml, mr, b\n// https://github.com/playdeadgames/temporal/blob/9e6a7704e69bb73f29fe393390e545b21ddfd42d/Assets/Shaders/IncDepth.cginc#L111\n// 9Tap(good) slower but nicer\n// https://github.com/playdeadgames/temporal/blob/9e6a7704e69bb73f29fe393390e545b21ddfd42d/Assets/Shaders/IncDepth.cginc#L37\n//#define CLOSEST_9TAP\nvec3 closestFragment(const in vec2 uv, const in vec2 texelSize) {\n\n    float d;\n    vec2 size = 2.0 * texelSize;\n    vec3 dmin = vec3(0.0, 0.0, 0.0);\n\n    // 5Tap\n    NEIGHBOUR_CREATE_FROM_OFFSET(dmin.z, 0.0, 0.0);\n    FIND_NEIGHBOUR_MIN(d, -size.x, size.y);\n    FIND_NEIGHBOUR_MIN(d, size.x, size.y);\n    FIND_NEIGHBOUR_MIN(d, -size.x, -size.y);\n    FIND_NEIGHBOUR_MIN(d, size.x, -size.y);\n\n#ifdef CLOSEST_9TAP\n    FIND_NEIGHBOUR_MIN(d, 0.0, size.y);\n    FIND_NEIGHBOUR_MIN(d, -size.x, 0.0);\n    FIND_NEIGHBOUR_MIN(d, size.x, 0.0);\n    FIND_NEIGHBOUR_MIN(d, 0.0, -size.y);\n#endif\n\n    return vec3(uv + dmin.xy, dmin.z);\n}\n\n// note: only clips towards aabb center (but fast!)\n// same as https://github.com/gokselgoktas/temporal-anti-aliasing/blob/master/Assets/Resources/Shaders/TemporalAntiAliasing.cginc#L199\n// which is adapted from https://github.com/playdeadgames/temporal\n// using the mathematical similar version of https://twitter.com/Stubbesaurus/status/890154773726580736\n// exhibits numerical issue (in a consistent way on intel/nvidia at least)\nvec4 clip_aabb_opti(const in vec4 minimum, const in vec4 maximum, const in vec4 color) {\n    const float eps = 0.00000001;\n\n    vec4 center = 0.5 * (maximum + minimum);\n    vec4 extents = 0.5 * (maximum - minimum) + eps;\n    vec4 offset = color - center;\n\n    vec4 ts = abs(offset / extents);\n    float t = max(max(ts.r, ts.g), max(ts.b, ts.a));\n    return center + offset / max(1.0, t);\n    // return t > 1.0 : center + offset / t : color;\n}\n\nvec4 taa(const in vec2 ssVel, const in vec2 texelSize) {\n    vec2 uv = gTexCoord;\n\n    vec4 tl = TEXTURE_2D_TextureInput(uv + vec2(-texelSize.x, texelSize.y));\n    vec4 t  = TEXTURE_2D_TextureInput(uv + vec2(0.0, texelSize.y));\n    vec4 tr = TEXTURE_2D_TextureInput(uv + vec2(texelSize.x, texelSize.y));\n\n    vec4 ml = TEXTURE_2D_TextureInput(uv + vec2(-texelSize.x, 0.0));\n    vec4 m  = TEXTURE_2D_TextureInput(uv);\n    vec4 mr = TEXTURE_2D_TextureInput(uv + vec2(texelSize.x, 0.0));\n\n    vec4 bl = TEXTURE_2D_TextureInput(uv + vec2(-texelSize.x, -texelSize.y));\n    vec4 b  = TEXTURE_2D_TextureInput(uv + vec2(0.0, -texelSize.y));\n    vec4 br = TEXTURE_2D_TextureInput(uv + vec2(texelSize.x, -texelSize.y));\n\n    // sharpen\n    // https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/TAA.cginc#L143\n    // reduces blurring, but increases flickering with dense geometry\n    vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * m;\n    m += (m - (corners * 0.166667)) * 2.718282 * 0.3;\n    m = max(vec4(0.0), m);\n\n    // Brian Karis neighbourhood rounding: http://advances.realtimerendering.com/s2014/epic/TemporalAA.pptx\n    // average of rounded pattern with cross pattern\n    vec4 cmin5 = min(mr, min(m, min(ml, min(t, b))));\n    vec4 cmin = min(cmin5, min(tl, min(tr, min(bl, br))));\n\n    vec4 cmax5 = max(mr, max(m, max(ml, max(t, b))));\n    vec4 cmax = max(cmax5, max(tl, max(tr, max(bl, br))));\n\n    cmin = 0.5 * (cmin + cmin5);\n    cmax = 0.5 * (cmax + cmax5);\n\n    vec4 previousColor = TEXTURE_2D_TexturePrevious(uv - ssVel);\n    previousColor = clip_aabb_opti(cmin, cmax, previousColor);\n\n    float lum0 = getLuminance(m.rgb);\n    float lum1 = getLuminance(previousColor.rgb);\n    float diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));\n    float unbiased_weight = 1.0 - diff;\n    float feedback = mix(FEEDBACK_MIN, FEEDBACK_MAX, unbiased_weight * unbiased_weight);\n\n    return mix(m, previousColor, feedback);\n}\n\nvec2 computeSSVelocity(const in vec2 pixelPos, const in vec3 vsPos, const in mat4 motionMatrix, const in bool rightEye) {\n    vec4 screenSpaceNDCPrevPosition = motionMatrix * vec4(vsPos, 1.0);\n    vec2 ndcPrev = screenSpaceNDCPrevPosition.xy / screenSpaceNDCPrevPosition.w;\n\n    if(ndcPrev.x >= 1.0 || ndcPrev.x <= -1.0 ||\n       ndcPrev.y >= 1.0 || ndcPrev.y <= -1.0)\n        return vec2(0.0);\n    \n    vec2 ndcCurrent = pixelPos * 2.0 - 1.0;\n    \n#ifdef VR_ENABLED\n    ndcCurrent.x /= 2.0;\n    ndcPrev.x /= 2.0;\n\n    if (rightEye) {\n        ndcCurrent.x += 0.5;\n        ndcPrev.x += 0.5;\n    }\n#endif\n\n    return 0.5 * (ndcCurrent - ndcPrev);\n}\n\n\nvec4 computeTaa(const in mat4 motionMatrix, const in vec4 corners0, const in vec4 corners1, const in bool rightVR) {\n    vec2 uv = gTexCoord;\n    float haltz = abs(uHalton.z);\n    if (haltz == 1.0) {\n        vec2 texelSize = vec2(1.0) / uTextureInputSize;\n        vec3 closest = closestFragment(uv, texelSize);\n\n        // discard background fragments to save fillrate\n        // make sure the mesh isn\'t transparent\n        if (closest.z >= 1.0\n#ifdef TAA_TRANSPARENT\n            && decodeAlpha(TEXTURE_2D_TextureDepth(closest.xy)) == 0.0\n#endif\n        ) {\n            // unjitter for fixed background with highres pattern or text\n            return TEXTURE_2D_TextureInput(uv - 0.5 * uHalton.xy * texelSize);\n        }\n\n        float depth = -(uNearFar.x + (uNearFar.y - uNearFar.x) * closest.z);\n        vec3 viewSpace = reconstructVSPosition(closest.xy, corners0, corners1, depth);\n        vec2 ssVel = computeSSVelocity(closest.xy, viewSpace, motionMatrix, rightVR);        \n        \n        return taa(ssVel, texelSize);\n    }\n\n    return supersample();\n}\n\n// temporal anti-aliasing from Playdead\'s Inside\n// slides: http://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in\n// sources: https://github.com/playdeadgames/temporal\nvec4 supersampleTaa() {\n    if (uTaaEnabled == 0.0) {\n        return supersample();\n    }\n\n#ifdef VR_ENABLED\n    // left and right eyes have different matrices\n    if (gTexCoord.x >= 0.5) {\n        return computeTaa(uTaaMotionMatrixRight, uTaaCornersCSRight[0], uTaaCornersCSRight[1], true);\n    }\n#endif\n\n    return computeTaa(uTaaMotionMatrixLeft, uTaaCornersCSLeft[0], uTaaCornersCSLeft[1], false);\n}\n',
                        "composeExtra.glsl": "uniform sampler2D TextureExtra;\r\n\r\n// LINEAR should be deduce from TEXTURE_2D_TextureExtra with user data\r\nvec4 composeExtra(const in vec4 color) {\r\n#ifdef LINEAR_EXTRA\r\n\tvec4 extra = sRGBToLinear(TEXTURE_2D_TextureExtra(gTexCoord));\r\n#else\r\n\tvec4 extra = TEXTURE_2D_TextureExtra(gTexCoord);\r\n#endif\r\n\treturn extra + vec4(color) * (1.0 - extra.a);\r\n}",
                        "composeFixedBackground.glsl": '#pragma include "utils/decodeDepth.glsl"\r\n\r\nuniform sampler2D TextureFixed;\r\nuniform vec2 uFixedScale;\r\n\r\nuniform sampler2D TextureDepth;\r\nuniform vec2 uTextureOutputSize;\r\n\r\nuniform vec4 uHalton;\r\nuniform float uSplitView;\r\n\r\nvec4 composeBackground(const in vec3 color, const in float alpha) {\r\n    vec2 jitter = uHalton.xy * 0.5 / uTextureOutputSize;\r\n    vec2 uv = (gTexCoord - 0.5 + jitter) * uFixedScale + 0.5;\r\n\r\n    // we recenter and unstretch the background\r\n    if (uSplitView == 1.0) uv.x = uv.x * 0.5 + 0.25;\r\n\r\n    // composer can\'t guess based on user data, so SRGBToLinear should be defined (or not) by TEXTURE_2D_XXXXXXX\r\n    vec3 backgroundColor = sRGBToLinear(texture2D(TextureFixed, uv).rgb);\r\n    return vec4(color.rgb + backgroundColor * (1.0 - alpha), 1.0);\r\n}\r\n\r\nuniform sampler2D TextureInput;\r\nuniform vec2 uTextureInputSize;\r\nuniform vec2 uTextureInputRatio;\r\n\r\nuniform sampler2D TextureRefraction;\r\nuniform vec2 uTextureRefractionSize;\r\nuniform vec2 uTextureRefractionRatio;\r\nuniform float uRGBMRange;\r\n\r\nvec4 composeFixedBackground(const in vec4 color) {\r\n#ifdef REFRACTION_COMPOSITING_EXCLUSION\r\n    // detect if we are on a refraction pixel\r\n    vec2 uvRef = min(gTexCoord, 1.0 - 1.0 / uTextureRefractionSize.xy);\r\n    if (texture2D(TextureRefraction, uvRef * uTextureRefractionRatio).a > 0.0) return color;\r\n#endif\r\n\r\n    float alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));\r\n    return composeBackground(color.rgb, alpha);\r\n}\r\n\r\nvec4 composeFixedBackgroundRefraction() {\r\n    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;\r\n    float alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));\r\n    return composeBackground(color.rgb, alpha);\r\n}',
                        "fxaa.glsl": '#ifdef VR_DISTORTION\nuniform vec2 uDistortion;\nuniform vec4 uProjectionLeft;\nuniform vec4 uUnprojectionLeft;\n\n#pragma include "distortion.glsl"\n#endif\n\n#ifdef ASCII_FOOL\n#pragma include "ascii.glsl"\n#endif\n\nuniform sampler2D TextureInput;\nuniform vec2 uTextureInputSize;\n\n// G3D version of FXAA\n// green (y) as luma\n// Quality 12\nvec4 fxaa() {\n#ifdef VR_DISTORTION\n    gTexCoord = distortion(gTexCoord);\n#endif\n\n    vec2 fxaaQualityRcpFrame = 1.0 / uTextureInputSize;\n    float fxaaQualitySubpix = 0.75;\n    float fxaaQualityEdgeThreshold = 0.125;\n    float fxaaQualityEdgeThresholdMin = 0.0625;\n\n    vec2 posM = gTexCoord;\n    vec4 rgbyM = TEXTURE_2D_TextureInput(posM);\n    float lumaM = rgbyM.y;\n\n    // Swizzler Offseter Util\n    vec4 sw = vec4(-1.0, 1.0, 1.0, -1.0) * fxaaQualityRcpFrame.xxyy;\n\n    float lumaS = TEXTURE_2D_TextureInput(posM + vec2(0.0, sw.z)).y;\n    float lumaE = TEXTURE_2D_TextureInput(posM + vec2(sw.y, 0.0)).y;\n    float lumaN = TEXTURE_2D_TextureInput(posM + vec2(0.0, sw.w)).y;\n    float lumaW = TEXTURE_2D_TextureInput(posM + vec2(sw.x, 0.0)).y;\n\n    float maxSM = max(lumaS, lumaM);\n    float minSM = min(lumaS, lumaM);\n\n    float maxESM = max(lumaE, maxSM);\n    float minESM = min(lumaE, minSM);\n\n    float maxWN = max(lumaN, lumaW);\n    float minWN = min(lumaN, lumaW);\n\n    float rangeMax = max(maxWN, maxESM);\n    float rangeMin = min(minWN, minESM);\n\n    float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    float range = rangeMax - rangeMin;\n    float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\n    bool earlyExit = range < rangeMaxClamped;\n\n    if (earlyExit) {\n#ifdef ASCII_FOOL\n    return ascii(posM);\n#else\n    return rgbyM;\n#endif\n    }\n\n    float lumaNW = TEXTURE_2D_TextureInput(posM + sw.xw).y;\n    float lumaSE = TEXTURE_2D_TextureInput(posM + sw.yz).y;\n    float lumaNE = TEXTURE_2D_TextureInput(posM + sw.yw).y;\n    float lumaSW = TEXTURE_2D_TextureInput(posM + sw.xy).y;\n\n    float lumaNS = lumaN + lumaS;\n    float lumaWE = lumaW + lumaE;\n    float subpixRcpRange = 1.0/range;\n    float subpixNSWE = lumaNS + lumaWE;\n    float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\n    float lumaNESE = lumaNE + lumaSE;\n    float lumaNWNE = lumaNW + lumaNE;\n    float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\n    float lumaNWSW = lumaNW + lumaSW;\n    float lumaSWSE = lumaSW + lumaSE;\n    float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    float edgeVert = abs(edgeVert3) + edgeVert4;\n\n    float subpixNWSWNESE = lumaNWSW + lumaNESE;\n    float lengthSign = fxaaQualityRcpFrame.x;\n    bool horzSpan = edgeHorz >= edgeVert;\n    float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\n    float gradientN = lumaN - lumaM;\n    float gradientS = lumaS - lumaM;\n    float lumaNN = lumaN + lumaM;\n    float lumaSS = lumaS + lumaM;\n    bool pairN = abs(gradientN) >= abs(gradientS);\n    float gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\n    vec2 posB = posM.xy;\n    vec2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n\n    vec2 posN;\n    posN.x = posB.x - offNP.x;\n    posN.y = posB.y - offNP.y;\n    vec2 posP;\n    posP.x = posB.x + offNP.x;\n    posP.y = posB.y + offNP.y;\n    float subpixD = ((-2.0)*subpixC) + 3.0;\n    float lumaEndN = TEXTURE_2D_TextureInput(posN).y;\n    float subpixE = subpixC * subpixC;\n    float lumaEndP = TEXTURE_2D_TextureInput(posP).y;\n\n    if(!pairN) lumaNN = lumaSS;\n    float gradientScaled = gradient * 1.0/4.0;\n    float lumaMM = lumaM - lumaNN * 0.5;\n    float subpixF = subpixD * subpixE;\n    bool lumaMLTZero = lumaMM < 0.0;\n\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    bool doneN = abs(lumaEndN) >= gradientScaled;\n    bool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * 1.5;\n    if(!doneN) posN.y -= offNP.y * 1.5;\n    bool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * 1.5;\n    if(!doneP) posP.y += offNP.y * 1.5;\n\n    if(doneNP) {\n        if(!doneN) lumaEndN = TEXTURE_2D_TextureInput(posN.xy).y;\n        if(!doneP) lumaEndP = TEXTURE_2D_TextureInput(posP.xy).y;\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * 2.0;\n        if(!doneN) posN.y -= offNP.y * 2.0;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * 2.0;\n        if(!doneP) posP.y += offNP.y * 2.0;\n\n        if(doneNP) {\n            if(!doneN) lumaEndN = TEXTURE_2D_TextureInput(posN.xy).y;\n            if(!doneP) lumaEndP = TEXTURE_2D_TextureInput(posP.xy).y;\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * 4.0;\n            if(!doneN) posN.y -= offNP.y * 4.0;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * 4.0;\n            if(!doneP) posP.y += offNP.y * 4.0;\n\n            if(doneNP) {\n                if(!doneN) lumaEndN = TEXTURE_2D_TextureInput(posN.xy).y;\n                if(!doneP) lumaEndP = TEXTURE_2D_TextureInput(posP.xy).y;\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * 12.0;\n                if(!doneN) posN.y -= offNP.y * 12.0;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * 12.0;\n                if(!doneP) posP.y += offNP.y * 12.0;\n\n            }\n\n        }\n\n    }\n\n    float dstN = posM.x - posN.x;\n    float dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n\n    bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    float spanLength = (dstP + dstN);\n    bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    float spanLengthRcp = 1.0/spanLength;\n\n    bool directionN = dstN < dstP;\n    float dst = min(dstN, dstP);\n    bool goodSpan = directionN ? goodSpanN : goodSpanP;\n    float subpixG = subpixF * subpixF;\n    float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    float subpixH = subpixG * fxaaQualitySubpix;\n\n    float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\n \n#ifdef ASCII_FOOL\n    return ascii(posM);\n#else\n    return TEXTURE_2D_TextureInput(posM);\n#endif\n}\n',
                        "grain.glsl": '#pragma include "utils/rand.glsl"\n\nuniform float uTimeGrain;\nuniform float uGrainFactor;\n\nfloat nrandTriangle() {\n    float nrnd0 = pseudoRandom(gl_FragCoord.xy + 1000.0 * fract(uTimeGrain));\n\n    // Convert uniform distribution into triangle-shaped distribution.\n    float orig = nrnd0 * 2.0 - 1.0;\n    nrnd0 = orig * inversesqrt(abs(orig));\n    nrnd0 = max(-1.0, nrnd0); // Nerf the NaN generated by 0 * rsqrt(0). Thanks @FioraAeterna!\n    nrnd0 = nrnd0 - sign(orig) + 0.5;\n\n    // Result is range [-0.5,1.5] which is useful for actual dithering. convert to [0,1] for histogram.\n    return (nrnd0 + 0.5) * 0.5;\n    // return nrnd0;\n}\n\nvec4 grain(const in vec4 color) {\n    float grainFactor = nrandTriangle();\n    return vec4(mix(color.rgb, color.rgb * (color.rgb + (1.0 - color.rgb) * 2.0 * grainFactor), uGrainFactor), color.a);\n}',
                        "sharpen.glsl": '#pragma include "utils/decodeDepth.glsl"\n\nuniform sampler2D TextureInput;\nuniform vec2 uTextureInputSize;\n\n#ifdef HAS_BACKGROUND\nuniform sampler2D TextureDepth;\n#endif\n\nuniform float uSharpFactor;\n\nuniform vec2 uPixelRatio;\n\nvec3 sharpColorFactor(const in vec3 color, const float sharp) {\n    vec2 off = uPixelRatio.xy / uTextureInputSize.xy;\n\n    // use useAA, 4 texFetch already in cache. perhaps we could cache ourself.\n    vec3 rgbNW = TEXTURE_2D_TextureInput(gTexCoord + off * vec2(-1.0, -1.0)).rgb; \n    vec3 rgbSE = TEXTURE_2D_TextureInput(gTexCoord + off * vec2(1.0, 1.0)).rgb;\n    vec3 rgbNE = TEXTURE_2D_TextureInput(gTexCoord + off * vec2(1.0, -1.0)).rgb;\n    vec3 rgbSW = TEXTURE_2D_TextureInput(gTexCoord + off * vec2(-1.0, 1.0)).rgb;\n\n    return color + sharp * (4.0 * color - rgbNW - rgbNE - rgbSW - rgbSE);\n}\n\nvec4 sharpen(const in vec4 color) {\n#ifdef HAS_BACKGROUND\n\tfloat alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));\n\tif( alpha == 0.0 ) {\n\t\treturn vec4(color.rgb,1.0);\n    }\n#else\n\tfloat alpha = 1.0;\n#endif\n\n    return vec4(sharpColorFactor(color.rgb, uSharpFactor * alpha), color.a);\n}\n\nvec4 sharpen() {\n    return sharpen(TEXTURE_2D_TextureInput(gTexCoord));\n}',
                        "dofCross.glsl": "uniform vec2 uTextureInputSize;\nuniform vec3 uDofCross;\n\nuniform vec2 uPixelRatio;\n\nvec4 dofCross(const in vec4 color) {\n    float ratio = uTextureInputSize.y / uTextureInputSize.x;\n    float dist = distance(vec2(uDofCross.x, uDofCross.y * ratio), gTexCoord * vec2(1.0, ratio));\n    float widthCircle = uPixelRatio.x / uTextureInputSize.x;\n    return vec4(mix(color.rgb, vec3(1.0), abs(dist - 60.0 * widthCircle) > widthCircle ? 0.0 : uDofCross.z), color.a);\n}",
                        "distortion.glsl": "// https://github.com/borismus/webvr-boilerplate/blob/master/src/distortion/barrel-distortion-fragment-v2.js\n\nvec2 barrel(const in vec2 v, const in vec4 projection, const in vec4 unprojection) {\n  vec2 w = (v + unprojection.zw) / unprojection.xy;\n  float val = dot(w, w);\n  // float poly = (showCenter == 1 && val < 0.00010) ? 10000.0 : 1.0 + (uDistortion.x + uDistortion.y * val) * val;\n  float poly = 1.0 + (uDistortion.x + uDistortion.y * val) * val;\n  return projection.xy * (poly * w) - projection.zw;\n}\n\nvec2 distortion(const in vec2 texCoord) {\n\n  if (abs(texCoord.x - 0.5) < .001) {\n    discard;\n  }\n\n  vec2 a;\n\n  if (texCoord.x < 0.5){\n    a = barrel(vec2(texCoord.x / 0.5, texCoord.y), uProjectionLeft, uUnprojectionLeft);\n  } else {\n    // right projections are shifted and vertically mirrored relative to left\n    const vec3 swi = vec3(1.0, -1.0, 0.0);\n    vec4 projectionRight = (uProjectionLeft + swi.zzxz) * swi.xxyx;\n    vec4 unprojectionRight = (uUnprojectionLeft + swi.zzxz) * swi.xxyx;\n    a = barrel(vec2((texCoord.x - 0.5) / 0.5, texCoord.y), projectionRight, unprojectionRight);\n  }\n\n  if (a.x < 0.0 || a.x > 1.0 || a.y < 0.0 || a.y > 1.0) {\n    discard;\n  }\n\n  return vec2(a.x * 0.5 + (texCoord.x < 0.5 ? 0.0 : 0.5), a.y);\n}",
                        "ascii.glsl": '//original shader : https://www.shadertoy.com/view/lssGDj by @movAX13h\n// Here\'s a little tool for new characters: thrill-project.com/archiv/coding/bitmap/\n\nfloat character(const in float n, vec2 p)\n{\n  p = floor(p*vec2(4.0, -4.0) + 2.5);\n  if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n  {\n      if (int(mod(n/exp2(p.x + 5.0 * p.y), 2.0)) == 1) return 1.5;\n  }\n  return 0.2;\n}\n\nuniform vec2 uTextureInputSize;\n\nvec4  ascii( const in vec2 coord )\n{\n  vec2 pix = coord*uTextureInputSize.xy;\n  vec3 col = TEXTURE_2D_TextureInput(floor(pix/16.0)*16.0/uTextureInputSize.xy).rgb;\n\n  float gray = 0.3 * col.r + 0.59 * col.g + 0.11 * col.b;\n\n  // 458144   fish\n  // 473536   square\n  // 33408895 empty round\n  // a 469450 33095217\n  // p 469448 33095184\n  // r 32078482\n  // i 14815374\n  // l 8659215\n\n/*\n  float n =  4096.0;               // .\n  if (gray > 0.2) n = 65600.0;    // :\n  if (gray > 0.3) n = 332772.0;   // *\n  if (gray > 0.4) n = 15255086.0; // o\n  if (gray > 0.5) n = 23385164.0; // &\n  if (gray > 0.6) n = 15252014.0; // 8\n  if (gray > 0.7) n = 13199452.0; // @\n  if (gray > 0.8) n = 11512810.0; // #\n*/\n\n  // letters are APRIL\n  // "emojii" are fish, square, hollow round\n  float n =  14815374.0;               // I\n  if (gray > 0.2) n = 473536.0;    // square\n  if (gray > 0.3) n = 15255086.0;   //  round o\n  if (gray > 0.4) n = 458144.0; // fish\n  if (gray > 0.5) n = 10955200.0; // A\n  if (gray > 0.6) n = 1113663.0; // P\n  if (gray > 0.7) n = 5356847.0; // R\n  if (gray > 0.8) n = 15762465.0; // L\n\n  vec2 p = mod(pix / 8.0, 2.0) - vec2(1.0);\n  col = col * vec3(character(n, p));\n  return vec4(col, 1.0);\n}\n',
                        "fadeVr.glsl": "uniform float uVrFadeFactor;\r\n\r\nvec4 fadeVr(const in vec4 color) {\r\n\treturn vec4(mix(color.rgb, vec3(0.0), clamp(uVrFadeFactor, 0.0, 1.0)), color.a);\r\n}",
                        "veilVr.glsl": "uniform float uVrVeilFactor;\r\n\r\nvec4 veilVr(const in vec4 color) {\r\n\treturn vec4(color.rgb * uVrVeilFactor, 1.0);\r\n}",
                        "outline.glsl": "uniform float uOutlineFactor;\nuniform vec2 uPixelRatio;\nuniform float uHighlightFactor;\nuniform float uLineWidth;\n\nuniform sampler2D TextureOutline;\nuniform vec2 uTextureOutlineSize;\n\nvec4 outline() {\n    float fac0 = 2.0;\n    float fac1 = 1.0;\n    float offsetx = uPixelRatio.x / uTextureOutlineSize[0] * uLineWidth;\n    float offsety = uPixelRatio.y / uTextureOutlineSize[1] * uLineWidth;\n\n    vec4 texel0 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(offsetx, offsety));\n    vec4 texel1 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(offsetx, 0.0));\n    vec4 texel2 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(offsetx, -offsety));\n    vec4 texel3 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(0.0, -offsety));\n    vec4 texel4 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(-offsetx, -offsety));\n    vec4 texel5 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(-offsetx, 0.0));\n    vec4 texel6 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(-offsetx, offsety));\n    vec4 texel7 = TEXTURE_2D_TextureOutline(gTexCoord + vec2(0.0, offsety));\n\n    vec4 rowx = -fac0 * texel5 + fac0 * texel1 + -fac1 * texel6 + fac1 * texel0 + -fac1 * texel4 + fac1 * texel2;\n    vec4 rowy = -fac0 * texel3 + fac0 * texel7 + -fac1 * texel4 + fac1 * texel6 + -fac1 * texel2 + fac1 * texel0;\n\n    float magSqr = sqrt(dot(rowy, rowy) + dot(rowx, rowx));\n    bool infMag = magSqr < 1.0 / 65025.0;\n\n    vec3 texelCenter = TEXTURE_2D_TextureOutline(gTexCoord).rgb;\n    if (texelCenter == vec3(0.0) || (uHighlightFactor == 0.0 && infMag)) {\n        discard;\n    }\n\n    float finalFactor = infMag ? uHighlightFactor : min(1.0, sqrt(magSqr) * uOutlineFactor);\n\n    return finalFactor * vec4(texelCenter, 1.0);\n}\n",
                        "finalPremultAlpha.glsl": '#pragma include "utils/functions.glsl"\n\nvec4 finalPremultAlpha(const in vec4 color) {\n    return vec4(linearTosRGB(sRGBToLinear(color.rgb) * color.a), color.a);\n}'
                    };
                    El.addShaders(e)
                },
                getNodeBackground: function () {
                    return this._viewer.getFeatures().environment.getNode().getBackground()
                },
                getBackgroundModel: function () {
                    return this._viewer.getFeatures().background.getModel()
                },
                getBackgroundType: function () {
                    return this.getBackgroundModel().getEnableType()
                },
                onPingPongTexture0: function (e) {
                    this._composer && this._composer.swapFeedbackLoopTextures(e)
                },
                _replaceTexture: function (e, t, i) {
                    var n = this._composer.getStateSetPass(t);
                    if (n) {
                        var r = n.getUniform(i);
                        r && n.setTextureAttributeAndModes(r.getInternalArray()[0], e)
                    }
                },
                onBackgroundUpdated: function (e) {
                    void 0 !== this._composer && "fixed" === this._effectiveConfig.bgType && (this._replaceTexture(e, "composeFixedBackground", "TextureFixed"), this._replaceTexture(e, "composeFixedBackgroundRefraction", "TextureFixed"))
                },
                onBackgroundColor: function () {
                    var e = eo.Z.getClearColor();
                    if ("color" === this.getBackgroundType()) {
                        Rl.vec3.copy(e, this.getBackgroundModel().getColor()), e[3] = 1, 1 === to.Z.uOutputLinear.getInternalArray()[0] && Sl.ZP.srgbToLinear(e, e);
                        var t = to.Z.uRGBMRange.getInternalArray()[0];
                        t > 0 && Sl.ZP.encodeRGBM(e, t, e)
                    } else Rl.vec4.set(e, 0, 0, 0, 0)
                },
                _getSupportedLinearFloatTexture: function () {
                    var e = Rl.WebGLCaps.instance();
                    return 0 === (0, l.Z)().floatRtt ? Rl.Texture.UNSIGNED_BYTE : e.hasLinearHalfFloatRTT() ? Rl.Texture.HALF_FLOAT : jr.default.any && this._model.get("webVR") && 2 === (0, l.Z)().floatRtt ? Rl.Texture.UNSIGNED_BYTE : e.hasLinearFloatRTT() ? Rl.Texture.FLOAT : Rl.Texture.UNSIGNED_BYTE
                },
                _getSupportedFloatTexture: function () {
                    var e = Rl.WebGLCaps.instance();
                    return 0 === (0, l.Z)().floatRtt ? Rl.Texture.UNSIGNED_BYTE : e.hasLinearHalfFloatRTT() || e.hasHalfFloatRTT() ? Rl.Texture.HALF_FLOAT : jr.default.any && this._model.get("webVR") && 2 === (0, l.Z)().floatRtt ? Rl.Texture.UNSIGNED_BYTE : e.hasLinearFloatRTT() || e.hasFloatRTT() ? Rl.Texture.FLOAT : Rl.Texture.UNSIGNED_BYTE
                },
                _updateEffectiveConfig: function () {
                    var e = this._effectiveConfig,
                        t = Kn.get("hasTransparency"),
                        i = Kn.get("hasExtra"),
                        n = Kn.get("hasRefraction"),
                        r = Kn.get("hasScattering");
                    e.webVR = this._model.get("webVR"), e.AR = this._model.get("AR");
                    var a = this._model.get("doDistortionVR") && (0, l.Z)().vrStereo;
                    e.useDistortionVR = e.webVR && a, e.useSss = r, e.useSsao = this._model.isEffectiveSsao(), e.useDof = this._model.isEffectiveDof(), e.useBloom = this._model.isEffectiveBloom(), e.useChromaticAberration = this._model.isEffectiveChromaticAberration(), e.useToneMapping = this._model.isEffectiveToneMapping(), e.useColorBalance = this._model.isEffectiveColorBalance(), e.bgType = this.getBackgroundType(), e.hasBG = "none" !== e.bgType, e.useTaa = !e.AR && this._model.get("taaEnable"), e.useTaaTransparent = e.useTaa && this._model.get("taaTransparent");
                    var s = (0, l.Z)().fxaa;
                    return e.useFxaa = void 0 === s ? this._hasTriangles : s, e.useGrain = this._model.isEffectiveGrain(), e.useSharpen = this._model.isEffectiveSharpen(), e.useVignette = this._model.isEffectiveVignette(), e.useTransparency = t || e.webVR || (0, o.Z)(), e.useSsr = this._model.isEffectiveSsr(), e.useRefraction = n, e.useDepth = this._needDepthTexture(), e.useExtra = i || e.webVR || e.AR, bi.Z.set("hasSsr", e.useSsr), this._effectiveConfig
                },
                _needDepthTexture: function () {
                    if ((0, o.Z)()) return !0;
                    var e = this._effectiveConfig;
                    if (e.useRefraction || e.useSsr || e.useDof || e.useBloom || e.useSharpen || e.useSsao || e.useSss || e.useTaa || !e.useFxaa) return !0;
                    if (this._viewer.getFeatures().hotspot.getModel().get("hotspots").length > 0) return !0;
                    var t = this.getBackgroundType();
                    return "none" === t || "fixed" === t || this._model.get("webVR")
                },
                _addInternalTextures: function (e, t, i) {
                    e.addInternalTexture({
                        name: "TextureOpaque",
                        immuable: !0,
                        srgb: i,
                        rgbm: !i
                    }), e.setInputTexture("TextureOpaque"), (t.useRefraction || t.useSsr) && e.addInternalTexture({
                        name: "TextureToBeRefracted",
                        divisor: (0, l.Z)().refractionRes,
                        immuable: !0,
                        reusable: !1,
                        srgb: !1,
                        rgbm: !0
                    }), t.useRefraction && e.addInternalTexture({
                        name: "TextureRefraction",
                        immuable: !0,
                        srgb: !1,
                        rgbm: !0
                    }), (t.useSsr || t.useSsao) && e.addInternalTexture({
                        name: "TextureMipmapDepth",
                        immuable: !0,
                        reusable: !1,
                        srgb: !1,
                        rgbm: !1
                    }), t.useDepth && e.addInternalTexture({
                        name: "TextureDepth",
                        filter: "nearest",
                        immuable: !0,
                        srgb: !1,
                        rgbm: !1
                    }), t.useTransparency && e.addInternalTexture({
                        name: "TextureTransparent",
                        filter: "nearest",
                        immuable: !0,
                        type: this._getSupportedFloatTexture(),
                        rgbm: !1,
                        srgb: !1
                    }), t.useExtra && e.addInternalTexture({
                        name: "TextureExtra",
                        filter: "nearest",
                        immuable: !0,
                        srgb: !t.webVR,
                        rgbm: !1
                    })
                },
                _addSss: function (e, t) {
                    var i = this._getSupportedLinearFloatTexture();
                    t.addExternalTexture("TextureSSSKernel", this._view3d._sssTexKernel), e.push({
                        func: "sssExtract",
                        textures: [{
                            name: "%last",
                            uniformName: "TextureSSSColor"
                        }, "TextureDepth"],
                        out: {
                            name: "TextureSSSExtract",
                            rgbm: !1,
                            divisor: 2,
                            type: i,
                            filter: "linear"
                        }
                    });
                    var n = [];
                    n.push("#define SSS_HALF_KERNEL_SIZE " + (0, l.Z)().sssHalfKernel), n.push("#define SSS_PROFILE_COUNT " + this._model.get("sssProfiles").length), n.push("#define SSS_JITTER " + (0, l.Z)().sssJitter.toExponential());
                    var r = this._model.useSSSLookupFloatLinear() ? "1.0" : this._model.getSSSWeightRange().toExponential();
                    n.push("#define SSS_BYTE_RANGE " + r);
                    var a = Rl.Uniform.createFloat2(Rl.vec2.fromValues(0, 1), "uBlurDir");
                    e.push({
                        func: "sssBlur",
                        header: n,
                        textures: [{
                            name: "TextureSSSExtract",
                            uniformName: "TextureSSSBlur"
                        }, "TextureDepth", "TextureSSSKernel"],
                        uniforms: a,
                        out: {
                            name: "TextureSSSBlur1",
                            divisor: 2,
                            type: i,
                            rgbm: !1,
                            filter: "linear"
                        }
                    });
                    var o = Rl.Uniform.createFloat2(Rl.vec2.fromValues(1, 0), "uBlurDir");
                    e.push({
                        func: "sssBlur",
                        header: n,
                        textures: [{
                            name: "TextureSSSBlur1",
                            uniformName: "TextureSSSBlur"
                        }, "TextureDepth", "TextureSSSKernel"],
                        uniforms: o,
                        out: {
                            name: "TextureSSSBlur2",
                            divisor: 2,
                            rgbm: !0,
                            filter: "linear"
                        }
                    }), e.push({
                        func: "sssCombine",
                        textures: [{
                            name: "TextureSSSBlur2",
                            uniformName: "TextureSSSBlur"
                        }, {
                            name: "%last",
                            uniformName: "TextureSSSColor"
                        }, "TextureDepth"],
                        out: {
                            name: "%next"
                        }
                    })
                },
                _packMipmapDepth: function (e) {
                    for (var t = Rl.Uniform.createInt(1, "uFirstDepth"), i = Rl.Uniform.createInt(0, "uFirstDepth"), n = 1; n <= 5; n++) {
                        var r = 1 << n + 1,
                            a = 1 === n ? "TextureDepth" : "TextureDepth" + (n - 1),
                            o = "TextureDepth" + n;
                        e.push({
                            func: "depthMipmap",
                            textures: [{
                                name: a,
                                uniformName: "TextureDepth"
                            }],
                            uniforms: 1 === n ? t : i,
                            out: {
                                name: o,
                                divisor: r,
                                filter: "linear"
                            }
                        })
                    }
                    e.push({
                        func: "packMipmapDepth",
                        textures: [{
                            name: "TextureDepth",
                            uniformName: "TextureDepth0"
                        }, "TextureDepth1", "TextureDepth2", "TextureDepth3", "TextureDepth4", "TextureDepth5"],
                        out: {
                            name: "TextureMipmapDepth",
                            filter: "linear"
                        }
                    })
                },
                _addSsao: function (e) {
                    var t = [
                        ["#extension GL_OES_standard_derivatives : enable"]
                    ];
                    (0, l.Z)().ssaoNormal && t.push("#define SSAO_NORMAL"), jr.default.any && t.push("#define MOBILE"), e.push({
                        func: "ssaoExtract",
                        header: t,
                        textures: "TextureMipmapDepth",
                        out: {
                            name: "TextureSsaoExtract",
                            filter: "linear"
                        }
                    }), e.push({
                        func: {
                            name: "ssaoBlurH",
                            file: "ssaoBlur.glsl"
                        },
                        header: "#define SSAO_BLUR_H",
                        textures: {
                            name: "TextureSsaoExtract",
                            uniformName: "TextureBlurInput"
                        },
                        out: {
                            name: "TextureSsaoBlurH",
                            filter: "nearest"
                        }
                    }), e.push({
                        func: {
                            name: "ssaoBlurV",
                            file: "ssaoBlur.glsl"
                        },
                        header: "#define SSAO_BLUR_V",
                        textures: [{
                            name: "%last",
                            filter: "linear"
                        }, {
                            name: "TextureSsaoBlurH",
                            uniformName: "TextureBlurInput"
                        }],
                        out: {
                            name: "%next"
                        }
                    })
                },
                _addCombineOpacity: function (e) {
                    e.push({
                        func: "combineOpacity",
                        textures: [{
                            name: "%last",
                            filter: "nearest"
                        }, "TextureTransparent"],
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    })
                },
                _packMipmapColor: function (e, t, i) {
                    var n = this._addFixedBackgroundRefraction(e, t, i);
                    return yl(e, n, "TextureRefractionBlur", [3, 5, 7, 9, 11, 13, 15], !0), e.push({
                        func: "packMipmapRefraction",
                        textures: [{
                            name: n,
                            uniformName: "TextureRefractionBlur0"
                        }, "TextureRefractionBlur1", "TextureRefractionBlur2", "TextureRefractionBlur3", "TextureRefractionBlur4", "TextureRefractionBlur5", "TextureRefractionBlur6", "TextureRefractionBlur7"],
                        out: {
                            name: "TextureToBeRefracted",
                            filter: "linear"
                        }
                    }), e.length
                },
                _addRefraction: function (e) {
                    e.push({
                        func: "combineRefraction",
                        textures: ["%last", "TextureRefraction"],
                        out: {
                            name: "%next"
                        }
                    })
                },
                _addDof: function (e) {
                    var t = (0, l.Z)().dofRes;
                    e.push({
                        func: "dofCoC",
                        textures: "TextureDepth",
                        out: {
                            name: "TextureDofCoC",
                            divisor: t,
                            filter: "nearest"
                        }
                    }), e.push({
                        func: {
                            name: "dofNearDilateH",
                            file: "dofNearDilate.glsl"
                        },
                        textures: ["TextureDofCoC", "TextureDepth"],
                        out: {
                            name: "TextureDofNearDilateH",
                            divisor: t,
                            filter: "linear"
                        }
                    }), e.push({
                        func: {
                            name: "dofNearDilateV",
                            file: "dofNearDilate.glsl"
                        },
                        textures: [{
                            name: "TextureDofNearDilateH",
                            uniformName: "TextureDofCoC"
                        }, "TextureDepth"],
                        out: {
                            name: "TextureDofNearDilateV",
                            divisor: t,
                            filter: "nearest"
                        }
                    });
                    var i = this._getSupportedFloatTexture() === Rl.Texture.HALF_FLOAT,
                        n = i ? "#define COLOR_WITH_COC" : "",
                        r = ["%last"];
                    i && r.push({
                        name: "TextureDofNearDilateV",
                        uniformName: "TextureDofCoC"
                    }), e.push({
                        func: "dofDownsampleColor",
                        header: n,
                        textures: r,
                        out: {
                            name: "TextureDofDownsampleColor",
                            divisor: t,
                            filter: "nearest",
                            type: i ? Rl.Texture.HALF_FLOAT : Rl.Texture.UNSIGNED_BYTE
                        }
                    });
                    var a = [{
                        name: "TextureDofDownsampleColor",
                        uniformName: "TextureDofColor",
                        rgbm: !i
                    }];
                    i || a.push({
                        name: "TextureDofNearDilateV",
                        uniformName: "TextureDofCoC"
                    }), e.push({
                        func: "dofBlurCircular",
                        header: n,
                        textures: a,
                        out: {
                            name: "TextureDofBlurCircular",
                            divisor: t,
                            filter: "linear",
                            rgbm: !0
                        }
                    }), e.push({
                        func: "dofCombine",
                        textures: [{
                            name: "%last",
                            filter: "linear"
                        }, "TextureDofBlurCircular", "TextureDofNearDilateV", "TextureDepth"],
                        out: {
                            name: "%next"
                        }
                    })
                },
                _addBloom: function (e, t) {
                    var i, n = ["%last"];
                    t.hasBG && (i = "#define HAS_BACKGROUND", n.push("TextureDepth")), e.push({
                        func: "bloomExtract",
                        textures: n,
                        header: i,
                        out: {
                            name: "TextureBloomExtract",
                            filter: "linear"
                        }
                    });
                    yl(e, "TextureBloomExtract", "TextureBloomBlur", [3, 5, 7, 9, 11]), e.push({
                        func: "bloomCombine",
                        textures: [{
                            name: "%last"
                        }, "TextureBloomBlur1", "TextureBloomBlur2", "TextureBloomBlur3", "TextureBloomBlur4", "TextureBloomBlur5"],
                        out: {
                            name: "%next"
                        }
                    })
                },
                _addMergeable: function (e, t) {
                    if (t.useChromaticAberration && e.push({
                        func: "chromaticAberration",
                        textures: [{
                            name: "%last",
                            filter: "nearest"
                        }],
                        out: {
                            name: "%next"
                        }
                    }), t.useColorBalance && e.push({
                        func: "colorBalance",
                        textures: [{
                            name: "%last",
                            filter: "nearest"
                        }],
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    }), t.useToneMapping) {
                        var i = [{
                            name: "%last",
                            filter: "nearest"
                        }],
                            n = "";
                        "fixed" !== t.bgType || t.useRefraction || t.useSsr || (n = "#define HAS_FIXED_BACKGROUND", i.push("TextureDepth")), e.push({
                            func: "toneMapping",
                            header: n,
                            textures: i,
                            out: {
                                name: "%next"
                            },
                            collapsible: !0
                        })
                    }
                    t.webVR && t.useExtra && (e.push({
                        func: "veilVr",
                        textures: "%last",
                        out: {
                            name: "%next",
                            filter: "nearest"
                        },
                        collapsible: !0
                    }), e.push({
                        func: "composeExtra",
                        header: "#define LINEAR_EXTRA",
                        textures: ["%last", "TextureExtra"],
                        out: {
                            name: "%next",
                            filter: "nearest"
                        },
                        collapsible: !0
                    }))
                },
                _addSuperSample: function (e, t) {
                    if (!t.hasBG) {
                        var i = ["%last", "TextureDepth"];
                        if (t.useRefraction && i.push("TextureRefraction"), e.push({
                            func: "setDepthAlpha",
                            header: t.useRefraction ? "#define REFRACTION_FORCE_ALPHA_ONE" : "",
                            textures: i,
                            out: {
                                name: "%next"
                            },
                            collapsible: !0
                        }), t.AR) return
                    }
                    if (t.useTaa) {
                        var n = [];
                        t.useTaaTransparent && n.push("#define TAA_TRANSPARENT"), n.push("#define FEEDBACK_MIN " + (0, l.Z)().taaFeedbackMin), n.push("#define FEEDBACK_MAX " + (0, l.Z)().taaFeedbackMax), Ao.Z.vrConfig.doVR && n.push("#define VR_ENABLED"), e.push({
                            func: "supersampleTaa",
                            textures: [{
                                name: "%last",
                                filter: "linear",
                                rgbm: !1,
                                srgb: !0
                            }, "%previous", "TextureDepth"],
                            header: n,
                            out: {
                                name: "%next",
                                filter: "linear"
                            }
                        })
                    } else e.push({
                        func: "supersample",
                        textures: [{
                            name: "%last",
                            filter: "linear",
                            rgbm: !1,
                            srgb: !0
                        }, "%previous"],
                        out: {
                            name: "%next",
                            filter: "linear"
                        }
                    })
                },
                _addFinalPass: function (e, t) {
                    var i = [],
                        n = [{
                            name: "%last",
                            filter: "linear",
                            srgb: !0,
                            rgbm: !1
                        }];
                    t.useDistortionVR && i.push("#define VR_DISTORTION"), (0, l.Z)().postProcessAscii && i.push("#define ASCII_FOOL"), t.useFxaa ? e.push({
                        func: "fxaa",
                        header: i,
                        textures: n,
                        out: {
                            name: "%next"
                        }
                    }) : e.push({
                        func: "passThrough",
                        header: i,
                        textures: n,
                        out: {
                            name: "%next"
                        }
                    }), t.useSharpen && (i = [], n = ["%last"], t.hasBG && (i.push("#define HAS_BACKGROUND"), n.push("TextureDepth")), e.push({
                        func: "sharpen",
                        header: i,
                        textures: n,
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    })), t.useVignette && e.push({
                        func: "vignette",
                        textures: [{
                            name: "%last",
                            filter: "nearest"
                        }],
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    }), t.useGrain && e.push({
                        func: "grain",
                        textures: "%last",
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    }), t.useDof && e.push({
                        func: "dofCross",
                        textures: "%last",
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    }), t.webVR ? e.push({
                        func: "fadeVr",
                        textures: "%last",
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    }) : t.useExtra && e.push({
                        func: "composeExtra",
                        textures: ["%last", "TextureExtra"],
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    }), t.hasBG || e.push({
                        func: "finalPremultAlpha",
                        textures: "%last",
                        out: {
                            name: "%next"
                        },
                        collapsible: !0
                    })
                },
                _addFixedBackground: function (e, t, i) {
                    if ("fixed" === t.bgType) {
                        var n = this.getNodeBackground().getBackground() || hr.Z.dummyTexture;
                        n.divisor = -1, i.addExternalTexture("TextureFixed", n);
                        var r = ["%last", "TextureFixed", "TextureDepth"],
                            a = [];
                        t.useRefraction && (r.push("TextureRefraction"), a.push("#define REFRACTION_COMPOSITING_EXCLUSION")), e.push({
                            func: "composeFixedBackground",
                            header: a,
                            textures: r,
                            uniforms: [vo.scale],
                            out: {
                                name: "%next"
                            },
                            collapsible: !0
                        })
                    }
                },
                _addFixedBackgroundRefraction: function (e, t, i) {
                    if (!t.useRefraction || "fixed" !== t.bgType) return "%last";
                    var n = this.getNodeBackground().getBackground() || hr.Z.dummyTexture;
                    return n.divisor = -1, i.addExternalTexture("TextureFixed", n), e.push({
                        func: {
                            name: "composeFixedBackgroundRefraction",
                            file: "composeFixedBackground.glsl"
                        },
                        textures: ["%last", "TextureFixed", "TextureDepth"],
                        uniforms: [vo.scale],
                        out: {
                            name: "TextureWithBackground"
                        }
                    }), "TextureWithBackground"
                },
                _addPassThrough: function (e) {
                    e.push({
                        func: "passThrough",
                        textures: "%last",
                        out: {
                            name: "%next"
                        }
                    })
                },
                _createComposer: function () {
                    var e = this._updateEffectiveConfig(),
                        t = this._composer || new wl.ComposerPostProcess;
                    void 0 === this._composer && this._initComposer(t), t.clear();
                    var i = [],
                        n = e.useSsr && (0, l.Z)().depthMipmap || e.useSsao,
                        r = e.useSsr || e.useRefraction,
                        a = 0;
                    n && this._packMipmapDepth(i), e.useSsao && this._addSsao(i), e.useSss && this._addSss(i, t), e.useTransparency && this._addCombineOpacity(i), r && (a = this._packMipmapColor(i, e, t)), e.useRefraction && this._addRefraction(i, e, t), e.useDof && this._addDof(i), e.useBloom && this._addBloom(i, e), this._addMergeable(i, e), this._addFixedBackground(i, e, t), a > 0 && i.length === a && this._addPassThrough(i);
                    var o = 0 === i.length;
                    if (this._addSuperSample(i, e), this._addFinalPass(i, e), this._addInternalTextures(t, e, o), t.build(i), this._assignInternalTextureToCamera(), to.Z.uOutputLinear.setInt(o ? 0 : 1), to.Z.uRGBMRange.setFloat(o ? -1 : this._model.get("rgbmDefault")), this.onBackgroundColor(), e.useRefraction || e.useSsr) {
                        var s = this.getOrCreateStateSet(),
                            u = t.getInternalTexture("TextureToBeRefracted");
                        s.setTextureAttributeAndModes(5, u), s.addUniform(Rl.Uniform.createInt(5, "uTextureToBeRefracted")), u = (0, l.Z)().depthMipmap ? t.getInternalTexture("TextureMipmapDepth") : t.getInternalTexture("TextureDepth"), s.setTextureAttributeAndModes(4, u), s.addUniform(Rl.Uniform.createInt(4, "uTextureMipmapDepth"))
                    }
                },
                _assignInternalTextureToCamera: function () {
                    var e = this._composer,
                        t = this._effectiveConfig,
                        i = this._camera;
                    i._textureOpaque = e.getInternalTexture("TextureOpaque"), t.useDepth && (i._textureDepth = e.getInternalTexture("TextureDepth")), t.useTransparency && (i._textureTransparent = e.getInternalTexture("TextureTransparent")), t.useRefraction && (i._textureRefraction = e.getInternalTexture("TextureRefraction")), t.useExtra && (i._textureExtra = e.getInternalTexture("TextureExtra"))
                },
                _resizeMipmapHeight: function (e, t, i) {
                    var n = e.getInternalTexture(t);
                    if (n) {
                        var r = e._screenWidth,
                            a = e._screenHeight,
                            o = e._getTextureSize(r, n.divisor),
                            s = e._getTextureSize(a, .5 * n.divisor);
                        n.setTextureSize(o, s);
                        var l = e.getStateSetPass(i);
                        if (l) {
                            l.getUniform("uTextureOutputSize").getInternalArray()[1] = s;
                            for (var u = e.getCameras(), c = 0; c < u.length; ++c) {
                                var h = u[c];
                                if (h.getName() === t) return void h.getViewport().setViewport(0, 0, o, s)
                            }
                        }
                    }
                },
                _hookComposerResize: function (e) {
                    var t = this,
                        i = wl.ComposerPostProcess.prototype;
                    e.resizeRatio = function (n, r, a, o) {
                        i.resizeRatio.call(e, n, r, a, o), t._resizeMipmapHeight(e, "TextureToBeRefracted", "packMipmapRefraction"), t._resizeMipmapHeight(e, "TextureMipmapDepth", "packMipmapDepth")
                    }
                },
                _initComposer: function (e) {
                    e.setScreenSize(this._viewerOSGJS.getCanvasWidth(), this._viewerOSGJS.getCanvasHeight()), e.setMethodWrapUV(1, 1), this._hookComposerResize(e), this._viewer.bind("resizeCanvas", e.resize, e), this._viewer.bind("resizeRatio", e.resizeRatio, e), e.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), e.setName("PostProcess - Composer"), this.addChild(e), this._composer = e;
                    var t = e.getOrCreateStateSet();
                    for (var i in Al.Z) t.addUniform(Al.Z[i])
                },
                resetCameraAttachments: function () {
                    var e = this._camera;
                    e.resetAttachments(), e.fboOpaque && (e.fboOpaque.reset(), e.fboOpaque = void 0), e.fboTransparent && (e.fboTransparent.reset(), e.fboTransparent = void 0), e.fboRefraction && (e.fboRefraction.reset(), e.fboRefraction = void 0), e.fboDepth && (e.fboDepth.reset(), e.fboDepth = void 0), e.fboExtra && (e.fboExtra.reset(), e.fboExtra = void 0), e.attachRenderBuffer(Rl.FrameBufferObject.DEPTH_ATTACHMENT, Rl.WebGLCaps.instance().isWebGL2() ? Rl.FrameBufferObject.DEPTH_COMPONENT24 : Rl.FrameBufferObject.DEPTH_COMPONENT16)
                },
                createPathStandard: function () {
                    if (this._createComposer(), this.resetCameraAttachments(), (0, l.Z)().stats) {
                        var e = this._composer.getCameras();
                        e[e.length - 1].setRenderOrder(Rl.Camera.POST_RENDER, 0);
                        var t, i = [];
                        for (t = 0; t < e.length; t++) {
                            var n = e[t].getName(); - 1 === n.indexOf("FeedbackTexture") && i.push(n)
                        }
                        this._viewer.setOptionStatsPostProcess(i);
                        var r = eo.Z.getTimerGPU();
                        for (t = 0; t < e.length; ++t) {
                            var a = e[t],
                                o = a.getName();
                            a.setInitialDrawCallback(r.start.bind(r, o)), a.setFinalDrawCallback(r.end.bind(r, o))
                        }
                        this._camera.setFinalDrawCallback((function () {
                            r.start("PostProcess")
                        }));
                        var s = this._viewerOSGJS.getCamera();
                        s.setInitialDrawCallback(r.start.bind(r, "Total GL")), s.setFinalDrawCallback((function () {
                            r.end("PostProcess"), r.end("Total GL")
                        }))
                    }
                }
            }), "osgtestdemo2024", "PostProcess");
            const Nl = Pl;
            var Ol, Dl, Il, Fl, Ll, Vl, Bl, Ul = g.Z.osg,
                kl = g.Z.osgUtil,
                Zl = !1,
                Hl = !1,
                Gl = !1,
                zl = function (e) {
                    this._dirty = !0, this._view3d = e, this._effectiveConfig = e._effectiveConfig, this._viewer = e._viewer, this._viewerOSGJS = e._viewerOSGJS, this._model = e.model;
                    var t = (0, l.Z)().dofTransition;
                    this._interpolatorDofFocusPoint = new kl.DelayInterpolator(3, t ? .15 : 1), this._interpolatorDofBlurNear = new kl.DelayInterpolator(1, t ? .15 : 1), this._interpolatorDofBlurFar = new kl.DelayInterpolator(1, t ? .15 : 1), this._interpolatorDofCross = new kl.DelayInterpolator(1, t ? .08 : 1), this._interpolatorDofCross._epsilon = -.01, this._dofInitialized = !1, this._dofAutoFocus = !1, this._currentEye = Ul.vec3.create(), this._lastEye = Ul.vec3.create(), this._currentRot = Ul.quat.create(), this._lastRot = Ul.quat.create(), this._dofLastPos = Ul.vec3.create(), this._dofLastFocal = 0, this._firstFrame = !0, this._cullConfig = Ao.Z.vrConfig, this._skipTaaFrames = 0, this._lastUpdateTime = this._viewerOSGJS.getFrameStamp().getSimulationTime();
                    var i = this.dirty.bind(this);
                    Kn.bind("change:hasTransparency", i), Kn.bind("change:hasExtra", i), Kn.on("change:hasScattering", i), Kn.on("change:hasRefraction", i), L.Z.getMaterial().then(function () {
                        this.getBackgroundModel().bind("change:enable", i)
                    }.bind(this)), this._hookViewerCheckNeedToDoFrame(), this._hookViewerFrame(), this._hookViewerComputeCanvasSize(), this._model.on("resetTaa", this.onResetTaa.bind(this)), (0, l.Z)().dofCircle || (this.showDofCross = function () { })
                };
            Ul.createPrototypeObject(zl, {
                dirty: function () {
                    this._dirty = !0, Gl = !0
                },
                onResetTaa: function () {
                    this._skipTaaFrames = 2
                },
                getMainCamera: function () {
                    return this._view3d._camera
                },
                getNodeIn: function () {
                    return this._view3d._nodeIn
                },
                getCurrentComposer: function () {
                    return this._view3d._nodeIn._composer
                },
                getBackgroundModel: function () {
                    return this._viewer.getFeatures().background.getModel()
                },
                updateTargetDofBlurNear: function () {
                    this._interpolatorDofBlurNear.setTarget(this._model.get("dofBlurNear"))
                },
                updateTargetDofBlurFar: function () {
                    this._interpolatorDofBlurFar.setTarget(this._model.get("dofBlurFar"))
                },
                getClampedProjectionMatrix: function () {
                    var e = this.getMainCamera();
                    return e.clampedProjectionMatrix || e.getProjectionMatrix()
                },
                onEffectChanged: function () {
                    return U.Z.draw(), this.getNodeIn().createPathStandard()
                },
                _toggleComposerCameras: function (e) {
                    this._viewer.getSuperSample().setSwitch(e);
                    var t = e ? -1 : 0;
                    this.getMainCamera().setNodeMask(t);
                    var i = this.getCurrentComposer(),
                        n = i ? i.getCameras() : void 0;
                    if (void 0 !== n)
                        for (var r = 0; r < n.length - 1; r++) n[r].setNodeMask(t)
                },
                _hookViewerCheckNeedToDoFrame: function () {
                    var e = this._viewerOSGJS,
                        t = e.checkNeedToDoFrame.bind(e),
                        i = this;
                    e.checkNeedToDoFrame = function () {
                        this._requestContinousUpdate && U.Z.draw();
                        var e = t(),
                            n = Zl;
                        return Zl = !1, e || !n ? (i._toggleComposerCameras(!0), e) : (i._toggleComposerCameras(!1), !0)
                    }
                },
                _hookViewerFrame: function () {
                    var e = this.getMainCamera(),
                        t = this._viewerOSGJS,
                        i = this._viewer.getSuperSample(),
                        n = (0, l.Z)().vrMirror,
                        r = this,
                        a = t.frame.bind(t);
                    t.frame = function (t, o) {
                        a(t, o), U.Z.setShadowForcedUpdate(!1), Hl && (Hl = !1, r._skipTaaFrames = 1, U.Z.draw(), a(t, o), Gl = !0), Gl && (Gl = !1, r._skipTaaFrames = 1, U.Z.draw(), a(t, o)), e.setNodeMask(-1), this._hmd && this._hmd.isPresenting && n && (i.setSwitch(!1), e.setNodeMask(0), this.getCamera().getRenderer().draw())
                    }
                },
                _hookViewerComputeCanvasSize: function () {
                    this._resizeCanvasTimeout = -1, this._doResizeCanvas = !1, this._overrideCanvasWidth = -1, this._overrideCanvasHeight = -1, this._viewer.bind("resizeViewer", this._onResizeCanvas, this), this._viewer.bind("resizeViewerOnNextFrame", this._onForceResizeCanvas, this), this._cbEnableResizeCanvas = this._enableResizeCanvas.bind(this);
                    var e = this._viewerOSGJS,
                        t = this._viewer.getCanvas();
                    this._originalCanvasResize = e.computeCanvasSize.bind(e, t), e.computeCanvasSize = this._computeCanvasSize.bind(e, t, this)
                },
                _onResizeCanvas: function (e, t) {
                    this._overrideCanvasWidth = e, this._overrideCanvasHeight = t, U.Z.draw()
                },
                _onForceResizeCanvas: function (e, t) {
                    this._enableResizeCanvas(), this._onResizeCanvas(e, t)
                },
                _enableResizeCanvas: function () {
                    this._doResizeCanvas = !0
                },
                _resetResizeCanvas: function () {
                    this._doResizeCanvas = !1, window.clearTimeout(this._resizeCanvasTimeout)
                },
                _computeCanvasSize: function (e, t) {
                    var i = t._overrideCanvasWidth,
                        n = t._overrideCanvasHeight;
                    if (i > 0) {
                        var r = !1;
                        return this._canvasWidth !== i && (e.width = i, this._canvasWidth = i, r = !0), this._canvasHeight !== n && (e.height = n, this._canvasHeight = n, r = !0), r
                    }
                    var a = t._viewer.getFeatures().inspector;
                    if (!a) return !1;
                    var o = a.getModel();
                    if (t._doResizeCanvas) return o.set("viewerToCanvasRatio", 1), t._resetResizeCanvas(), t._originalCanvasResize();
                    window.ResizeObserver ? Ll || ((Ll = new window.ResizeObserver((function () {
                        Bl = e.clientWidth, Vl = e.clientHeight
                    }))).observe(e), Bl = e.clientWidth, Vl = e.clientHeight) : (Bl = e.clientWidth, Vl = e.clientHeight);
                    var s = Math.max(1, Math.floor(Bl * this._devicePixelRatio)) / Math.max(1, Math.floor(Vl * this._devicePixelRatio)) / (this._canvasWidth / this._canvasHeight);
                    if (s === o.get("viewerToCanvasRatio")) return !1;
                    o.set("viewerToCanvasRatio", s), t._resetResizeCanvas();
                    var u = (0, l.Z)().resizeTimeout;
                    return t._resizeCanvasTimeout = window.setTimeout(t._cbEnableResizeCanvas, u), !1
                },
                showDofCross: function () {
                    this._interpolatorDofCross.getCurrent()[0] = 1, this._interpolatorDofCross.setTarget(0), Ul.vec3.copy(this._dofLastPos, this._model.get("dofFocusPoint")), this._dofLastFocal = this.computeFocalDistance(), U.Z.draw()
                },
                hideDofCross: function () {
                    this._interpolatorDofCross.getCurrent()[0] = 0, U.Z.draw()
                },
                computeFocalDistance: function () {
                    var e = Ul.vec4.create();
                    return function () {
                        Ul.vec3.copy(e, this._interpolatorDofFocusPoint.getCurrent())[3] = 1;
                        var t = this._viewer.getCamera();
                        Ul.vec4.transformMat4(e, e, t.getViewMatrix()), Ul.vec4.transformMat4(e, e, this.getClampedProjectionMatrix());
                        var i = to.Z.uNearFar.getInternalArray();
                        return (e[3] - i[0]) / (i[1] - i[0])
                    }
                }(),
                _updateInterpolatorDofFocusPoint: function () {
                    var e = this._model.get("dofFocusPoint");
                    this._interpolatorDofFocusPoint.setTarget(e[0], e[1], e[2])
                },
                updateDofFocusPoint: function () {
                    this._updateInterpolatorDofFocusPoint(), this.showDofCross(), this._dofAutoFocus = !1
                },
                updateGrain: function (e) {
                    if (this._effectiveConfig.useGrain && this._model.get("grainAnimated")) {
                        Zl = !0;
                        var t = e.getSimulationTime(),
                            i = (0, l.Z)().grainSpeed / 1e3;
                        i > 0 && t - this._lastUpdateTime >= i && (Al.Z.uTimeGrain.setFloat(t / 1e3), this._lastUpdateTime = t)
                    }
                },
                _callbackPicking: function (e, t, i, n) {
                    if (!(e < 0)) {
                        if (e >= 1) {
                            var r = this._viewer.getFeaturesManager().getViewport3d(),
                                a = Al.Z.uDofCross.getInternalArray();
                            t = a[0] * r.width(), i = a[1] * r.height(), e = Fe.Z.pickDepth(n, t, i)
                        }
                        if (e < 1) {
                            var o = this._model.get("dofFocusPoint");
                            Fe.Z.getWorldPositionFromDepthXY(e, t, i, o), this._updateInterpolatorDofFocusPoint()
                        }
                        this.dofUpdateShowCross()
                    }
                },
                dofPickFocusPoint: function () {
                    var e = this._viewer.getFeaturesManager().getViewport3d(),
                        t = this._callbackPicking.bind(this);
                    Fe.Z.getPixelDepth(.5 * e.width(), .5 * e.height(), t)
                },
                dofUpdateShowCross: function (e, t) {
                    if (this._dofAutoFocus) this._interpolatorDofCross.getCurrent()[0] = 0;
                    else {
                        var i = Ul.vec3.dist(this._dofLastPos, this._model.get("dofFocusPoint")),
                            n = this.computeFocalDistance();
                        i > .1 * e && Math.abs(n - this._dofLastFocal) > .075 && t > .1 && this.showDofCross()
                    }
                },
                dofUpdateInterpolators: function (e, t) {
                    this._interpolatorDofBlurNear.setTarget(this._model.get("dofBlurNear") * t), this._interpolatorDofBlurFar.setTarget(this._model.get("dofBlurFar") * t);
                    var i = this._viewer.getFeaturesManager().getViewport3d(),
                        n = Al.Z.uDofCross.getInternalArray();
                    Fe.Z.getScreenPositionFromWorldPoint(this._model.get("dofFocusPoint"), n), n[0] /= i.width(), n[1] /= i.height();
                    var r = e.getDeltaTime();
                    this._interpolatorDofBlurNear.update(r), this._interpolatorDofBlurFar.update(r), this._interpolatorDofFocusPoint.update(r), this._interpolatorDofCross.update(r);
                    var a = Al.Z.uDofBlurNearFarFocal.getInternalArray();
                    a[0] = this._interpolatorDofBlurNear.getCurrent()[0], a[1] = this._interpolatorDofBlurFar.getCurrent()[0], a[2] = this.computeFocalDistance(), Al.Z.uDofCross.getInternalArray()[2] = this._interpolatorDofCross.getCurrent()[0], this._interpolatorDofCross.isDone() || (Zl = !0)
                },
                _getAttenuationDof: function (e, t) {
                    var i = this._viewerOSGJS.getManipulator(),
                        n = i.getHomeBoundingSphere(),
                        r = t >= .01 && (0, l.Z)().dofAttenuateSpeed ? 0 : 1,
                        a = i.getHomeDistance(i.getHomeBoundingSphere());
                    if ((0, l.Z)().dofAttenuateDistance) {
                        var o = (Ul.vec3.dist(n.center(), this._currentEye) - e) / (a - e);
                        r *= Math.max(0, Math.min(1, 1 - o))
                    }
                    return r
                },
                _getCameraMoveFactorSinceLastFocus: function (e) {
                    var t = this._viewerOSGJS.getManipulator().getInverseMatrix();
                    Ul.mat4.getRotation(this._currentRot, t), Ul.quat.normalize(this._currentRot, this._currentRot);
                    var i = Ul.quat.dot(this._lastRot, this._currentRot);
                    i = Math.abs(1 - i * i), this._viewerOSGJS.getManipulator().getEyePosition(this._currentEye);
                    var n = Ul.vec3.dist(this._lastEye, this._currentEye);
                    return Math.max(n / e, .1 * i)
                },
                updateDof: function (e) {
                    if (this._model.isEffectiveDof()) {
                        var t = to.Z.uNearFar.getInternalArray();
                        if (!(t[0] > t[1])) {
                            this.updateDofScaleUniform();
                            var i = this._viewerOSGJS.getManipulator().getHomeBoundingSphere().radius(),
                                n = this._getCameraMoveFactorSinceLastFocus(i),
                                r = this._getAttenuationDof(i, n),
                                a = !0;
                            !this._dofInitialized || (0, l.Z)().dofSticky ? (this._updateInterpolatorDofFocusPoint(), L.Z.getFirstCameraAnimation().isFulfilled() && (this._dofInitialized = !0)) : this._dofAutoFocus || n > .01 ? (this._dofAutoFocus = n > 1e-5, this.dofPickFocusPoint(), this.dofUpdateShowCross(i, r)) : (this._updateInterpolatorDofFocusPoint(), a = !1), this.dofUpdateInterpolators(e, r), a && (Ul.vec3.copy(this._lastEye, this._currentEye), Ul.quat.copy(this._lastRot, this._currentRot))
                        }
                    }
                },
                updateDofScaleUniform: function () {
                    var e = this._viewer.getFeaturesManager().getViewport3d();
                    Al.Z.uDofScale.getInternalArray()[0] = .0015 * e.height() / (0, l.Z)().dofRes
                },
                updateDirtyEffect: function () {
                    var e = this._viewerOSGJS.getCanvasWidth(),
                        t = this._viewerOSGJS.getCanvasHeight();
                    this._width && this._height || (this._width = this._height = -1), this._dirty && (this.onEffectChanged(), this._dirty = !1), e === this._width && t === this._height || (this._viewer.trigger("resizeCanvas", e, t), this.getNodeIn().resetCameraAttachments(), this._width = e, this._height = t, Hl = !0, U.Z.draw())
                },
                updateFade: function (e) {
                    var t = this._model.get("vrFading");
                    if (this._model.get("vrStartFade") && !t && (this._model.set("vrStartFade", !1), t = !0, this._model.set("vrFading", !0), this._model.set("vrFadeStartTime", e.getSimulationTime())), t) {
                        var i = this._model.get("vrFadeStartTime"),
                            n = this._model.get("vrFadeLength"),
                            r = e.getSimulationTime(),
                            a = (r - i) / n,
                            o = this._model.get("vrFadeCallback");
                        r > i + n && (a = 1 - (a - 1), o && (o(), this._model.set("vrFadeCallback", void 0)));
                        var s = Al.Z.uVrFadeFactor.getInternalArray();
                        a >= 0 ? s[0] = a : (s[0] = 0, this._model.set("vrFading", !1))
                    }
                },
                updateVeil: function () {
                    Al.Z.uVrVeilFactor.getInternalArray()[0] = this._model.get("veilFactor")
                },
                _sssGaussian: function (e, t, i) {
                    var n = t / (.001 + i);
                    return Math.exp(-n * n / (2 * e)) / (2 * Math.PI * e)
                },
                _sssProfile: function (e, t) {
                    return .1 * this._sssGaussian(.0484, e, t) + .118 * this._sssGaussian(.187, e, t) + .113 * this._sssGaussian(.567, e, t) + .358 * this._sssGaussian(1.99, e, t) + .078 * this._sssGaussian(7.41, e, t)
                },
                _computeSSSKernel: function (e, t, i, n) {
                    var r = (0, l.Z)().sssHalfKernel,
                        a = 2 * r - 1,
                        o = 0,
                        s = e * r * 4,
                        u = s + 0,
                        c = s + 1,
                        h = s + 2,
                        d = s + 3,
                        g = this._model.getSSSWeightRange(),
                        f = Math.pow(g, 2),
                        m = 2 * g / (a - 1);
                    for (o = 0; o < r; o++) {
                        var p = g - o * m;
                        t[4 * o + d] = g * Math.pow(p, 2) / f
                    }
                    var v = 0;
                    for (o = 0; o < r; o++) {
                        var _ = t[4 * o + d],
                            S = ((o > 0 ? Math.abs(_ - t[4 * (o - 1) + d]) : 0) + (v = o < r - 1 ? Math.abs(_ - t[4 * (o + 1) + d]) : v)) / 2;
                        t[4 * o + u] = S * this._sssProfile(_, n[0]), t[4 * o + c] = S * this._sssProfile(_, n[1]), t[4 * o + h] = S * this._sssProfile(_, n[2])
                    }
                    for (var x = t[4 * (o = r - 1) + u], C = t[4 * o + c], T = t[4 * o + h], M = t[4 * o + d]; o > 0; o--) {
                        var b = 4 * o,
                            y = 4 * (o - 1);
                        t[b + u] = t[y + u], t[b + c] = t[y + c], t[b + h] = t[y + h], t[b + d] = t[y + d]
                    }
                    t[u] = x, t[c] = C, t[h] = T, t[d] = M;
                    var A = t[u],
                        R = t[c],
                        w = t[h];
                    for (o = 1; o < r; o++) A += 2 * t[4 * o + u], R += 2 * t[4 * o + c], w += 2 * t[4 * o + h];
                    for (o = 0; o < r; o++) t[4 * o + u] /= A, t[4 * o + c] /= R, t[4 * o + h] /= w;
                    for (t[u] = 1 * (1 - i[0]) + i[0] * t[u], t[c] = 1 * (1 - i[1]) + i[1] * t[c], t[h] = 1 * (1 - i[2]) + i[2] * t[h], o = 1; o < r; o++) t[4 * o + u] *= i[0], t[4 * o + c] *= i[1], t[4 * o + h] *= i[2]
                },
                updateSSS: function () {
                    Al.Z.uProjFactor.getInternalArray()[0] = this.getClampedProjectionMatrix()[0];
                    var e = J.Z.getModelBoxWithoutDisplacement();
                    if (e) {
                        var t = e.radius(),
                            i = to.Z.uScatteringFactorPacker.getInternalArray(),
                            n = t * Mi.Z.getBoxFactor("SubsurfaceScattering");
                        i[0] = 1 / n, to.Z.uNormalizeFactorThickness.getInternalArray()[0] = .2 * t * .25
                    }
                    if (!this._model.get("sssKernelDone")) {
                        this._model.set("sssKernelDone", !0);
                        for (var r = this._model.get("sssProfiles"), a = r.length, o = (0, l.Z)().sssHalfKernel, s = new Float32Array(4 * a * o), u = 0, c = r.length; u < c; u++) {
                            var h = r[u];
                            this._computeSSSKernel(u, s, h.strength, h.falloff)
                        }
                        var d = this._view3d._sssTexKernel;
                        if (d.setTextureSize(o, a), d.setMinFilter(Ul.Texture.LINEAR), d.setMagFilter(Ul.Texture.LINEAR), this._model.useSSSLookupFloatLinear()) return d.setImage(s, Ul.Texture.RGBA), void d.setInternalFormatType(Ul.Texture.FLOAT);
                        var g = new Uint8Array(4 * o * a),
                            f = this._model.getSSSWeightRange();
                        for (u = 0; u < o * a; ++u) {
                            var m = 4 * u;
                            g[m] = Math.floor(255 * s[m]), g[m + 1] = Math.floor(255 * s[m + 1]), g[m + 2] = Math.floor(255 * s[m + 2]), g[m + 3] = Math.floor(s[m + 3] / f * 255)
                        }
                        d.setImage(g, Ul.Texture.RGBA), d.setInternalFormatType(Ul.Texture.UNSIGNED_BYTE)
                    }
                },
                updateSsao: function () {
                    if (this._model.isEffectiveSsao()) {
                        var e = to.Z.uNearFar.getInternalArray();
                        if (!(e[0] > e[1])) {
                            var t = this._viewer.getFeaturesManager().getViewport3d(),
                                i = this.getClampedProjectionMatrix(),
                                n = 1 === i[15] ? 1 : 2 / i[5],
                                r = -2 * Math.tan(.5 * n);
                            Al.Z.uSsaoProjectionScale.setFloat(t.height() / r);
                            var a = Al.Z.uSsaoProjectionInfo.getInternalArray();
                            a[0] = -2 / (t.width() * i[0]), a[1] = -2 / (t.height() * i[5]), a[2] = (1 - i[8]) / i[0], a[3] = (1 - i[9]) / i[5]
                        }
                    }
                },
                updateViewSpaceCorners: (Dl = [Ul.vec4.fromValues(-1, -1, 0, 1), Ul.vec4.fromValues(-1, 1, 0, 1), Ul.vec4.fromValues(1, -1, 0, 1), Ul.vec4.fromValues(1, 1, 0, 1)], Il = Ul.mat4.create(), Fl = Ul.vec3.create(), function (e, t) {
                    Ul.mat4.invert(Il, e);
                    for (var i = 0; i < 4; i++) Ul.vec3.transformMat4(Fl, Dl[i], Il), t[2 * i] = Fl[0] / Fl[2], t[2 * i + 1] = Fl[1] / Fl[2]
                }),
                updateTaaMatrices: function (e, t, i) {
                    var n = i.invViewMatrix.getInternalArray();
                    Ul.mat4.invert(n, e);
                    var r = i.lastFrame.getInternalArray(),
                        a = i.currentFrame.getInternalArray();
                    Ul.mat4.copy(r, a), Ul.mat4.multiply(a, t, e), this._firstFrame && Ul.mat4.copy(r, a);
                    var o = i.motionMatrix.getInternalArray();
                    Ul.mat4.multiply(o, r, n), this.updateViewSpaceCorners(t, i.corners.getInternalArray())
                },
                updateTAA: (Ol = Ul.mat4.create(), function () {
                    var e = to.Z.uNearFar.getInternalArray();
                    if (e[0] > e[1] || !this._model.get("taaEnable")) Al.Z.uTaaEnabled.setFloat(0);
                    else {
                        var t, i = this._viewer.getCamera().getViewMatrix(),
                            n = this._cullConfig.doVR;
                        n ? (Ul.mat4.multiply(Ol, this._cullConfig.leftOffsetView, i), t = this._cullConfig.leftProjection) : (Ol = i, t = this.getClampedProjectionMatrix());
                        var r = Al.Z;
                        this.updateTaaMatrices(Ol, t, {
                            motionMatrix: r.uTaaMotionMatrixLeft,
                            invViewMatrix: r.uTaaInvViewMatrixLeft,
                            lastFrame: r.uTaaLastFramePVLeft,
                            currentFrame: r.uTaaCurrentFramePVLeft,
                            corners: r.uTaaCornersCSLeft
                        }), n && (Ul.mat4.multiply(Ol, this._cullConfig.rightOffsetView, i), this.updateTaaMatrices(Ol, this._cullConfig.rightProjection, {
                            motionMatrix: r.uTaaMotionMatrixRight,
                            invViewMatrix: r.uTaaInvViewMatrixRight,
                            lastFrame: r.uTaaLastFramePVRight,
                            currentFrame: r.uTaaCurrentFramePVRight,
                            corners: r.uTaaCornersCSRight
                        })), this._firstFrame && (this._firstFrame = !1);
                        var a = this._viewer.getFeatures().animation.getModel(),
                            o = 0 === this._skipTaaFrames && a.canActivateTAA();
                        Al.Z.uTaaEnabled.setFloat(o ? 1 : 0), this._skipTaaFrames > 0 && --this._skipTaaFrames
                    }
                }),
                updateNearFarRatio: function () {
                    var e, t = this._viewer.getFeatures();
                    if (this._model.get("webVR")) {
                        var i = J.Z.getModelBoxWithDisplacement(),
                            n = i ? i.radius() : 1,
                            r = t.webVR.getModel().get("worldFactor") / n;
                        e = r > 0 ? .005 * Math.max(.1, r) : .005
                    } else e = t.camera.getModel().get("nearFarRatio");
                    this.getMainCamera().setNearFarRatio(e)
                },
                updateGlobalTexUniforms: function () {
                    var e = this._viewer.getFeaturesManager(),
                        t = to.Z.uGlobalTexSize.getInternalArray(),
                        i = to.Z.uGlobalTexRatio.getInternalArray(),
                        n = to.Z.uHalton.getInternalArray();
                    to.Z.uPreviousGlobalTexSize.setFloat2(t), to.Z.uPreviousGlobalTexRatio.setFloat2(i), to.Z.uPreviousHalton.setFloat4(n);
                    var r = e.getViewport3d();
                    t[0] = r.width(), t[1] = r.height();
                    var a = this.getCurrentComposer();
                    i[0] = a.getGlobalXRatio(), i[1] = a.getGlobalYRatio();
                    var o = a.getInternalTexture("TextureToBeRefracted");
                    if (o || this._model.isEffectiveSsr()) {
                        var s = to.Z.uTextureToBeRefractedSize.getInternalArray();
                        if (s[0] = o.getWidth(), s[1] = o.getHeight(), !this._model.get("taaEnable")) {
                            var l = this.getClampedProjectionMatrix(),
                                u = Al.Z.uTaaCornersCSLeft.getInternalArray();
                            this.updateViewSpaceCorners(l, u)
                        }
                    }
                },
                _shadowJitterUpdate: function (e) {
                    if (bi.Z.get("mask") & bi.Z.LIT) {
                        var t = 1 + e;
                        to.Z.uStaticFrameNumShadow0.setFloat(t), to.Z.uStaticFrameNumShadow1.setFloat(t), to.Z.uStaticFrameNumShadow2.setFloat(t), to.Z.uStaticFrameNumShadow3.setFloat(t)
                    }
                },
                updateGlobalUniforms: function (e) {
                    this.updateNearFarRatio(), this.updateGlobalTexUniforms(), to.Z.uTimeViewer.setFloat(e.getSimulationTime() / 1e3);
                    var t = J.Z.getModelBoxWithDisplacement();
                    to.Z.uBoxRadius.setFloat(t ? t.radius() : 1), to.Z.uPixelRatio.setFloat2(Ie.Z.getPixelRatio());
                    var i = this._viewer.getSuperSample(),
                        n = (e.getFrameNumber() + i.getFrameNumber()) % 16;
                    this._shadowJitterUpdate(n), to.Z.uFrameMod.setFloat(n);
                    var r = i.isEnabled() || Al.Z.uTaaEnabled.getInternalArray()[0];
                    to.Z.uFrameModTaaSS.setFloat(r ? n : 0);
                    var a = to.Z.uReprojectViewProj.getInternalArray(),
                        o = to.Z.uPreviousProjection.getInternalArray(),
                        s = to.Z.uPreviousViewInvView.getInternalArray(),
                        l = this._viewer.getCamera().getViewMatrix(),
                        u = this._cullConfig.doVR ? this._cullConfig.leftProjection : this.getClampedProjectionMatrix();
                    this._tmpView ? (Ul.mat4.invert(s, l), Ul.mat4.mul(s, this._tmpView, s), Ul.mat4.mul(a, this._tmpProjection, s), Ul.mat4.copy(o, this._tmpProjection), Ul.mat4.copy(this._tmpView, l), Ul.mat4.copy(this._tmpProjection, u)) : (this._tmpView = Ul.mat4.clone(l), this._tmpProjection = Ul.mat4.clone(u), Ul.mat4.copy(a, u))
                },
                cull: function (e, t) {
                    if (t.traverse(e), !this._model.get("postProcessReady")) return !1;
                    var i = t.getFrameStamp();
                    return this.updateTAA(i), this.updateSSS(i), this.updateSsao(i), this.updateGrain(i), this.updateDof(i), this.updateFade(i), this.updateVeil(i), this.updateDirtyEffect(), this.updateGlobalUniforms(i), !1
                }
            });
            const Wl = zl;
            var jl = g.Z.osg,
                Xl = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.model;
                        e.bind("change:webVR", this.dirty, this), e.bind("change:distortVR", this.dirty, this), e.bind("change:enable", this.dirty, this), e.bind("change:grainEnable", this.checkGrainEnable, this), e.bind("change:sharpenEnable", this.checkSharpenEnable, this), e.bind("change:chromaticAberrationEnable", this.checkChromaticAberrationEnable, this), e.bind("change:vignetteEnable", this.checkVignetteEnable, this), e.bind("change:bloomEnable", this.checkBloomEnable, this), e.bind("change:dofEnable", this.checkDofEnable, this), e.bind("change:toneMappingEnable", this.dirty, this), e.bind("change:colorBalanceEnable", this.dirty, this), e.bind("change:ssaoEnable", this.checkSsaoEnable, this), e.bind("change:ssrEnable", this.checkSsrEnable, this), bi.Z.bind("change:mask", this.checkSsrEnable, this), e.bind("change:taaEnable", this.checkTaaEnable, this), e.bind("change:taaTransparent", this.checkTaaTransparentEnable, this), e.bind("change:distortion", this.onDistortionChanged, this), e.bind("change:projectionLeft", this.onProjectionLeftChanged, this), e.bind("change:unprojectionLeft", this.onUnprojectionLeftChanged, this), e.bind("change:grainFactor", this.onGrainFactor, this), e.bind("change:sharpenFactor", this.onSharpenFactor, this), e.bind("change:chromaticAberrationFactor", this.onChromaticAberrationFactor, this), e.bind("change:vignetteAmount", this.onVignetteLensChanged, this), e.bind("change:vignetteHardness", this.onVignetteLensChanged, this), e.bind("change:bloomFactor", this.onBloomFactorChanged, this), e.bind("change:bloomThreshold", this.onBloomThresholdChanged, this), e.bind("change:bloomRadius", this.onBloomRadiusChanged, this), e.bind("change:toneMappingExposure", this.onToneMappingExposureChanged, this), e.bind("change:toneMappingBrightness", this.onToneMappingBrightnessChanged, this), e.bind("change:toneMappingContrast", this.onToneMappingContrastChanged, this), e.bind("change:toneMappingSaturation", this.onToneMappingSaturationChanged, this), e.bind("change:toneMappingMethod", this.onToneMappingMethodChanged, this), e.bind("change:colorBalanceLow", this.onColorBalanceShiftChanged, this), e.bind("change:colorBalanceMid", this.onColorBalanceShiftChanged, this), e.bind("change:colorBalanceHigh", this.onColorBalanceShiftChanged, this), e.bind("change:dofFocusPoint", this.onDofFocusPoint, this), e.bind("change:dofBlurNear", this.onDofBlurNear, this), e.bind("change:dofBlurFar", this.onDofBlurFar, this), e.bind("change:ssaoIntensity", this.onSsaoIntensity, this), e.bind("change:ssaoRadius", this.onSsaoRadius, this), e.bind("change:ssaoBias", this.onSsaoBias, this), e.bind("change:ssrFactor", this.onSsrFactor, this), e.bind("change", U.Z.draw), this._effectiveConfig = {}, this._viewer = this.model._viewer, this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._sssTexKernel = new jl.Texture, this._sssTexKernel.divisor = -1, this._camera = this._createMainCamera(), this._nodeIn = new Nl(this), this._nodeOut = this._createNodeOut(), this._nodeIn.addChild(this._camera), this._camera.addChild(this._nodeOut), this._callbackPostProcess = new Wl(this), this._nodeIn.setCullCallback(this._callbackPostProcess), this._initUniforms()
                    },
                    dirty: function () {
                        this._callbackPostProcess.dirty()
                    },
                    _initUniforms: function () {
                        var e = this.model.attributes;
                        for (var t in e) this.model.trigger("change:" + t)
                    },
                    _createNodeOut: function () {
                        var e = new jl.Node;
                        return e.setName("PostProcess - node Out"), Ao.Z.nodePostProcessOut = e, e
                    },
                    _createMainCamera: function () {
                        var e = new jl.Camera,
                            t = this._viewerOSGJS.getCanvasWidth(),
                            i = this._viewerOSGJS.getCanvasHeight();
                        return e.setViewport(new jl.Viewport(0, 0, t, i)), e.setName("PostProcess - MainCamera"), e.setRenderOrder(jl.Camera.PRE_RENDER, 0), e.attachRenderBuffer(jl.FrameBufferObject.DEPTH_ATTACHMENT, jl.FrameBufferObject.DEPTH_COMPONENT16), Ao.Z.cameraMain = e, e
                    },
                    methodToInt: function (e) {
                        return "reinhard" === e ? 1 : "filmic" === e ? 2 : 0
                    },
                    checkGrainEnable: function () {
                        this._effectiveConfig.useGrain !== this.model.isEffectiveGrain() && this.dirty()
                    },
                    checkSharpenEnable: function () {
                        this._effectiveConfig.useSharpen !== this.model.isEffectiveSharpen() && this.dirty()
                    },
                    checkChromaticAberrationEnable: function () {
                        this._effectiveConfig.useChromaticAberration !== this.model.isEffectiveChromaticAberration() && this.dirty()
                    },
                    checkVignetteEnable: function () {
                        this._effectiveConfig.useVignette !== this.model.isEffectiveVignette() && this.dirty()
                    },
                    checkBloomEnable: function () {
                        this._effectiveConfig.useBloom !== this.model.isEffectiveBloom() && this.dirty()
                    },
                    checkDofEnable: function () {
                        this._effectiveConfig.useDof !== this.model.isEffectiveDof() && this.dirty()
                    },
                    checkSsaoEnable: function () {
                        this._effectiveConfig.useSsao !== this.model.isEffectiveSsao() && this.dirty()
                    },
                    checkSsrEnable: function () {
                        this._effectiveConfig.useSsr !== this.model.isEffectiveSsr() && this.dirty()
                    },
                    checkTaaEnable: function () {
                        this._effectiveConfig.useTaa !== this.model.get("taaEnable") && this.dirty()
                    },
                    checkTaaTransparentEnable: function () {
                        this._effectiveConfig.useTaaTransparent !== (this.model.get("taaEnable") && this.model.get("taaTransparent")) && this.dirty()
                    },
                    onDistortionChanged: function () {
                        Al.Z.uDistortion.setFloat2(this.model.get("distortion"))
                    },
                    onProjectionLeftChanged: function () {
                        Al.Z.uProjectionLeft.setFloat4(this.model.get("projectionLeft"))
                    },
                    onUnprojectionLeftChanged: function () {
                        Al.Z.uUnprojectionLeft.setFloat4(this.model.get("unprojectionLeft"))
                    },
                    onGrainFactor: function () {
                        Al.Z.uGrainFactor.setFloat(this.model.get("grainFactor")), this.checkGrainEnable()
                    },
                    onSharpenFactor: function () {
                        Al.Z.uSharpFactor.setFloat(this.model.get("sharpenFactor")), this.checkSharpenEnable()
                    },
                    onChromaticAberrationFactor: function () {
                        Al.Z.uChromaFactor.setFloat(this.model.get("chromaticAberrationFactor")), this.checkChromaticAberrationEnable()
                    },
                    onVignetteLensChanged: function () {
                        var e = Al.Z.uLensRadius.getInternalArray(),
                            t = this.model.get("vignetteAmount"),
                            i = this.model.get("vignetteHardness");
                        e[0] = 2 - t - i, e[1] = i - t, this.checkVignetteEnable()
                    },
                    onBloomFactorChanged: function () {
                        Al.Z.uBloomFactor.setFloat(this.model.get("bloomFactor")), this.checkBloomEnable()
                    },
                    onBloomThresholdChanged: function () {
                        Al.Z.uBloomThreshold.setFloat(this.model.get("bloomThreshold")), this.checkBloomEnable()
                    },
                    onBloomRadiusChanged: function () {
                        Al.Z.uBloomRadius.setFloat(this.model.get("bloomRadius")), this.checkBloomEnable()
                    },
                    onColorBalanceShiftChanged: function () {
                        Al.Z.uColorBalanceLow.setFloat3(this.model.get("colorBalanceLow")), Al.Z.uColorBalanceMid.setFloat3(this.model.get("colorBalanceMid")), Al.Z.uColorBalanceHigh.setFloat3(this.model.get("colorBalanceHigh"))
                    },
                    onToneMappingExposureChanged: function () {
                        Al.Z.uToneExposure.setFloat(this.model.get("toneMappingExposure"))
                    },
                    onToneMappingBrightnessChanged: function () {
                        Al.Z.uToneBrightness.setFloat(this.model.get("toneMappingBrightness"))
                    },
                    onToneMappingContrastChanged: function () {
                        Al.Z.uToneContrast.setFloat(this.model.get("toneMappingContrast"))
                    },
                    onToneMappingSaturationChanged: function () {
                        Al.Z.uToneSaturation.setFloat(this.model.get("toneMappingSaturation"))
                    },
                    onToneMappingMethodChanged: function () {
                        Al.Z.uToneMethod.setInt(this.methodToInt(this.model.get("toneMappingMethod")))
                    },
                    onDofFocusPoint: function () {
                        this._callbackPostProcess.updateDofFocusPoint()
                    },
                    onDofBlurNear: function () {
                        this._callbackPostProcess.updateTargetDofBlurNear(), this.checkDofEnable()
                    },
                    onDofBlurFar: function () {
                        this._callbackPostProcess.updateTargetDofBlurFar(), this.checkDofEnable()
                    },
                    hideDofCross: function () {
                        this._callbackPostProcess.hideDofCross()
                    },
                    onSsaoRadius: function () {
                        Al.Z.uSsaoRadius.setFloat(this.model.get("ssaoRadius")), this.checkSsaoEnable()
                    },
                    onSsaoIntensity: function () {
                        Al.Z.uSsaoIntensity.setFloat(this.model.get("ssaoIntensity")), this.checkSsaoEnable()
                    },
                    onSsaoBias: function () {
                        Al.Z.uSsaoBias.setFloat(this.model.get("ssaoBias"))
                    },
                    onSsrFactor: function () {
                        to.Z.uSsrFactor.setFloat(this.model.get("ssrFactor")), this.checkSsrEnable()
                    }
                });
            var Yl = {
                FeatureName: "postProcess",
                ModelType: _l,
                ViewListType: [Xl]
            },
                Jl = n.Z.create(Yl);
            Jl.prototype.getNodeIn = function () {
                return this._views[0]._nodeIn
            }, Jl.prototype.getNodeOut = function () {
                return this._views[0]._nodeOut
            }, Jl.prototype.getCamera = function () {
                return this._views[0]._camera
            }, Jl.prototype.getCurrentComposer = function () {
                return this._views[0]._nodeIn._composer
            }, Jl.prototype.prepareForScreenShot = function () {
                to.Z.uSSAARestart.setFloat(1), this._views[0].hideDofCross()
            }, Jl.prototype.resetAfterScreenShot = function () {
                to.Z.uSSAARestart.setFloat(0)
            };
            const ql = Jl;
            var Kl = g.Z.osg;
            const Ql = ir().Model.extend({
                defaults: {
                    colorSelection: Kl.vec3.fromValues(1, 1, 0),
                    colorHover: Kl.vec3.fromValues(1, .5, 0),
                    durationOutline: -1,
                    durationHighlight: -1,
                    outlineWidth: 1
                },
                getName: function () {
                    return "Outline"
                }
            });
            var $l, eu = i("jXe1"),
                tu = g.Z.osg,
                iu = g.Z.osgUtil,
                nu = tu.StateAttribute.OVERRIDE_ON,
                ru = function (e) {
                    tu.Node.call(this), this._viewerWebGL = e, this._viewerOSGJS = e.getViewerOSGJS(), this._durationOutline = 5e3, this._timerOutline = void 0, this._durationHighlight = 5e3, this._timerHighlight = void 0, this._nodeProxy = new tu.Node, this._outlineScene = new tu.Node, this._paths = void 0, this._cbHideHighlight = this.hideHighlight.bind(this), this._cbHideOutline = this.hideOutline.bind(this);
                    var t = Le.Z.DEPTH_DISABLE;
                    this._stateSetSelection = new tu.StateSet, this._uColorSelection = tu.Uniform.createFloat3("uOutlineColor"), this._stateSetSelection.addUniform(this._uColorSelection), this._stateSetSelection.setAttributeAndModes(t, nu), this._stateSetHover = new tu.StateSet, this._uColorHover = tu.Uniform.createFloat3("uOutlineColor"), this._stateSetHover.addUniform(this._uColorHover), this._stateSetHover.setAttributeAndModes(t, nu), this._uOutlineFactor = tu.Uniform.createFloat(.25, "uOutlineFactor"), this._uHighlightFactor = tu.Uniform.createFloat(0, "uHighlightFactor"), this._uLineWidth = tu.Uniform.createFloat(1, "uLineWidth"), this.init()
                };
            tu.createPrototypeNode(ru, tu.objectInherit(tu.Node.prototype, {
                getComposer: function () {
                    return this._composer
                },
                setColorSelection: function (e) {
                    tu.vec3.copy(this._uColorSelection.getInternalArray(), e)
                },
                setColorHover: function (e) {
                    tu.vec3.copy(this._uColorHover.getInternalArray(), e)
                },
                setDurationHighlight: function (e) {
                    this._durationHighlight = e
                },
                setDurationOutline: function (e) {
                    this._durationOutline = e
                },
                setOutlineWidth: function (e) {
                    this._uLineWidth.getInternalArray()[0] = e
                },
                showOutline: function () {
                    Kn.setOutline(!0), this._nodeProxy.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._clearTimeoutOutline(), this._durationOutline >= 0 && (this._timerOutline = setTimeout(this._cbHideOutline, this._durationOutline)), this._uHighlightFactor.setFloat(0 !== this._durationHighlight ? .15 : 0), this._clearTimeoutHighlight(), this._durationHighlight >= 0 && this._durationHighlight < this._durationOutline && (this._timerHighlight = setTimeout(this._cbHideHighlight, this._durationHighlight)), U.Z.draw()
                },
                hideOutline: function () {
                    this._nodeProxy.setNodeMask(0), this._clearTimeoutOutline(), this.hideHighlight(), U.Z.draw()
                },
                hideHighlight: function () {
                    this._uHighlightFactor.setFloat(0), this._clearTimeoutHighlight(), U.Z.draw()
                },
                _clearTimeoutOutline: function () {
                    void 0 !== this._timerOutline && (clearTimeout(this._timerOutline), this._timerOutline = void 0)
                },
                _clearTimeoutHighlight: function () {
                    void 0 !== this._timerHighlight && (clearTimeout(this._timerHighlight), this._timerHighlight = void 0)
                },
                clearOutlineScene: function () {
                    for (var e = this._outlineScene, t = e.getChildren(), i = 0, n = t.length; i < n; ++i) {
                        var r = t[i];
                        r.getChildren()[0].removeChildren(), r.removeChildren()
                    }
                    e.removeChildren()
                },
                _getMaterialNode: function (e) {
                    var t = e.getStateSet();
                    return t && t.getAttribute("testdemo2024Material") ? t : void 0
                },
                _getLastMaterialPath: function (e, t) {
                    for (var i = t || 0, n = e.length - 1; n >= i; --n) {
                        var r = this._getMaterialNode(e[n]);
                        if (r) return r
                    }
                },
                addPaths: ($l = function (e) {
                    this._path = e
                }, tu.createPrototypeObject($l, {
                    update: function (e) {
                        return e.setMatrix(tu.computeLocalToWorld(this._path)), $l
                    }
                }), function (e, t) {
                    for (var i = this._outlineScene, n = t ? this._stateSetHover : this._stateSetSelection, r = 0, a = e.length; r < a; ++r) {
                        var o = e[r],
                            s = new tu.MatrixTransform,
                            l = new tu.Node;
                        i.addChild(s), s.addChild(l);
                        var u = o[o.length - 1];
                        l.addChild(u), s.setStateSet(n), this._getMaterialNode(u) || l.setStateSet(this._getLastMaterialPath(o)), (0, eu.Z)(o) ? s.addUpdateCallback(new $l(o)) : s.setMatrix(tu.computeLocalToWorld(o))
                    }
                }),
                addPathsHover: function (e) {
                    this.addPaths(e, !0)
                },
                createSubSceneRtt: function (e) {
                    var t = new tu.Camera;
                    t.setName("Outline Camera"), t.setClearColor(tu.vec4.create()), t.setRenderOrder(tu.Camera.PRE_RENDER, 0), t.attachTexture(tu.FrameBufferObject.COLOR_ATTACHMENT0, e);
                    var i = t.getOrCreateStateSet();
                    return i.setShaderGeneratorName("outline", nu), i.setAttribute(new wr.Z), t
                },
                init: function () {
                    var e = Le.Z.CULL_DISABLE;
                    this._outlineScene.getOrCreateStateSet().setAttributeAndModes(e, nu);
                    var t = this._createComposer();
                    this._composer = t;
                    var i = t.getInternalTexture("TextureOutline"),
                        n = this.createSubSceneRtt(i);
                    this._cameraRtt = n, n.addChild(this._outlineScene), this._nodeProxy.addChild(n), this._nodeProxy.addChild(t), this.addChild(this._nodeProxy), this._nodeProxy.setNodeMask(0)
                },
                _createComposer: function () {
                    var e = new iu.ComposerPostProcess,
                        t = this._viewerOSGJS;
                    e.setMethodWrapUV(1, 1), e.setScreenSize(t.getCanvasWidth(), t.getCanvasHeight()), e.setFinalPassUpScaleToScreen(!1), e.addInternalTexture({
                        name: "TextureOutline",
                        immuable: !0,
                        srgb: !0,
                        rgbm: !1
                    }), e.build({
                        func: "outline",
                        textures: ["TextureOutline"],
                        uniforms: [this._uOutlineFactor, this._uHighlightFactor, this._uLineWidth],
                        out: {
                            name: "%next"
                        }
                    });
                    var i = e.getStateSetPass("outline"),
                        n = Le.Z.BLEND_SUBSTRACTIVE;
                    return i.setAttributeAndModes(n), i.setRenderBinDetails(Oe.Z.OUTLINE, "RenderBin"), this._viewerWebGL.bind("resizeCanvas", e.resize, e), this._viewerWebGL.bind("resizeRatio", e.resizeRatio, e), e
                }
            }), "osgtestdemo2024", "Outline");
            const au = ru;
            var ou, su = g.Z.osg,
                lu = g.Z.osgAnimation,
                uu = function (e) {
                    su.ComputeBoundsVisitor.call(this), this._paths = [], this.setStateSet(e)
                };
            su.createPrototypeObject(uu, su.objectInherit(su.ComputeBoundsVisitor.prototype, {
                reset: function () {
                    su.ComputeBoundsVisitor.prototype.reset.call(this), this._pushIfGeo = !1, this._paths.length = 0, this._bonesBoxMatrix = {}, this._usedBones = {}
                },
                setStateSet: function (e) {
                    this.reset(), this._stateSet = e
                },
                getBoundingBox: (ou = new su.BoundingBox, function () {
                    for (var e in this._usedBones) {
                        var t = this._bonesBoxMatrix[e];
                        t && (ou.copy(t.box), ou.transformMat4(ou, t.matrix), this._bb.expandByBoundingBox(ou))
                    }
                    return this._bb
                }),
                apply: function (e) {
                    var t = e.getStateSet(),
                        i = this._pushIfGeo;
                    if (t && void 0 !== t._materialID && (this._pushIfGeo = t === this._stateSet), this._pushIfGeo && e instanceof su.Geometry && (this._paths.push(this.nodePath.slice(0)), e instanceof lu.RigGeometry)) {
                        var n = e.getBoneNameID();
                        for (var r in n) this._usedBones[r] = 1
                    }
                    su.ComputeBoundsVisitor.prototype.apply.call(this, e), this._pushIfGeo = i
                },
                pushMatrix: function (e) {
                    var t = this.nodePath[this.nodePath.length - 1];
                    if (t instanceof lu.Bone) {
                        var i = t.getBoneBoundingBox();
                        i.valid() && (this._bonesBoxMatrix[t.getName()] = {
                            matrix: su.mat4.clone(e),
                            box: i
                        })
                    }
                    su.ComputeBoundsVisitor.prototype.pushMatrix.call(this, e)
                },
                applyBoundingBox: function (e) {
                    this._pushIfGeo && su.ComputeBoundsVisitor.prototype.applyBoundingBox.call(this, e)
                }
            }));
            const cu = uu;
            var hu, du = g.Z.osg,
                gu = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this._viewer = this.options.context.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS();
                        var e = this.model;
                        e.bind("change:colorSelection", this.onColorSelectionChanged, this), e.bind("change:colorHover", this.onColorHoverChanged, this), e.bind("change:outlineWidth", this.onOutlineWiddthChanged, this), e.bind("hideOutline", this.onHideOutline, this), e.bind("hideHighlight", this.onHideHighlight, this), e.bind("clearFocusTimeout", this.onClearFocusTimeout, this), this._nodeOutline = new au(this._viewer), this._nodeOutline.setName("Feature - Outline"), this.onColorSelectionChanged(), this.onColorHoverChanged(), this.onOutlineWiddthChanged(), this.model.bind("displayOutlineFocus", this._onMaterialChange.bind(this, !0)), this.model.bind("displayOutlineNoFocus", this._onMaterialChange.bind(this, !1))
                    },
                    getNodeOutline: function () {
                        return this._nodeOutline
                    },
                    onColorSelectionChanged: function () {
                        this._nodeOutline.setColorSelection(this.model.get("colorSelection"))
                    },
                    onColorHoverChanged: function () {
                        this._nodeOutline.setColorHover(this.model.get("colorHover"))
                    },
                    onOutlineWiddthChanged: function () {
                        this._nodeOutline.setOutlineWidth(this.model.get("outlineWidth"))
                    },
                    onHideOutline: function () {
                        this._nodeOutline.hideOutline()
                    },
                    onHideHighlight: function () {
                        this._nodeOutline.hideHighlight()
                    },
                    onClearFocusTimeout: function () {
                        void 0 !== this._timer && (window.clearTimeout(this._timer), this._timer = void 0)
                    },
                    _focusOnBound: function (e) {
                        var t = this._viewer.getFeaturesManager(),
                            i = e.getBoundingBox(),
                            n = this._nodeOutline;
                        this.onClearFocusTimeout(), this._timer = window.setTimeout((function () {
                            t.focusOnBound(i, 1) || t.focusOnHomePosition(1), n.showOutline()
                        }), 200)
                    },
                    _onMaterialChange: (hu = new cu, function (e, t, i) {
                        var n = this._viewer.getFeaturesManager();
                        if (n) {
                            hu.setStateSet(t || i), n.getWorldNode().accept(hu);
                            var r = hu._paths;
                            0 !== r.length ? (e && this._focusOnBound(hu), this._nodeOutline.clearOutlineScene(), t ? (this._nodeOutline.addPaths(r), i && (hu.setStateSet(i), n.getWorldNode().accept(hu), this._nodeOutline.addPathsHover(hu._paths))) : this._nodeOutline.addPathsHover(r), this._nodeOutline.setDurationOutline(1e3 * this.model.get("durationOutline")), this._nodeOutline.setDurationHighlight(1e3 * this.model.get("durationHighlight")), e || this._nodeOutline.showOutline()) : du.error("Cound not find nodes attached to the stateset.")
                        }
                    })
                });
            var fu = {
                FeatureName: "outline",
                ModelType: Ql,
                ViewListType: [gu]
            },
                mu = n.Z.create(fu);
            mu.prototype.getNode = function () {
                return this._views[0].getNodeOutline()
            }, mu.prototype.prepareForScreenShot = function () {
                return this.getNode().hideOutline(), !1
            };
            const pu = mu;
            var vu = function (e) {
                this.coefficients = e
            };
            vu.prototype.distortInverse = function (e) {
                for (var t = e / .9, i = .9 * e, n = e - this.distort(t); Math.abs(i - t) > 1e-4;) {
                    var r = e - this.distort(i),
                        a = i - r * ((i - t) / (r - n));
                    t = i, i = a, n = r
                }
                return i
            }, vu.prototype.distort = function (e) {
                return e * this.distortionFactor_(e)
            }, vu.prototype.distortionFactor_ = function (e) {
                for (var t = 1, i = 1, n = e * e, r = 0; r < this.coefficients.length; r++) {
                    t += this.coefficients[r] * (i *= n)
                }
                return t
            };
            const _u = vu;
            var Su = g.Z.osg,
                xu = {
                    base64: function (e, t) {
                        return "data:" + e + ";base64," + t
                    },
                    isMobile: function () {
                        var e, t = !1;
                        return e = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (t = !0), t
                    },
                    isFirefox: function () {
                        return /firefox/i.test(navigator.userAgent)
                    },
                    isIOS: function () {
                        return /(iPad|iPhone|iPod)/g.test(navigator.userAgent)
                    },
                    isIFrame: function () {
                        try {
                            return window.self !== window.top
                        } catch (e) {
                            return !0
                        }
                    },
                    appendQueryParameter: function (e, t, i) {
                        var n = e.indexOf("?") < 0 ? "?" : "&";
                        return e += n + t + "=" + i
                    },
                    getQueryParameter: function (e) {
                        e = e.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                        var t = new RegExp("[\\?&]" + e + "=([^&#]*)").exec(location.search);
                        return null === t ? "" : decodeURIComponent(t[1].replace(/\+/g, " "))
                    },
                    isLandscapeMode: function () {
                        return 90 === window.orientation || -90 === window.orientation
                    },
                    getScreenWidth: function () {
                        return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio
                    },
                    getScreenHeight: function () {
                        return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio
                    },
                    projectionMatrixToVector_: function (e, t) {
                        var i = t || {},
                            n = i.xScale || 1,
                            r = i.yScale || 1,
                            a = i.xTrans || 0,
                            o = i.yTrans || 0,
                            s = Su.vec4.create();
                        return s[0] = e[0] * n * .5, s[1] = e[5] * r * .5, s[2] = .5 * (e[8] - 1 - a), s[3] = .5 * (e[9] - 1 - o), s
                    },
                    leftProjectionVectorToRight_: function (e) {
                        return Su.vec4.fromValues(e[0], e[1], -e[2] - 1, e[3])
                    }
                };
            const Cu = xu;
            var Tu = g.Z.osg,
                Mu = 180 / Math.PI,
                bu = Math.PI / 180,
                yu = function (e) {
                    this.id = e.id, this.label = e.label, this.fov = e.fov, this.interLensDistance = e.interLensDistance, this.baselineLensDistance = e.baselineLensDistance, this.screenLensDistance = e.screenLensDistance, this.distortionCoefficients = e.distortionCoefficients, this.inverseCoefficients = e.inverseCoefficients
                },
                Au = function (e) {
                    this.width = e.width || Cu.getScreenWidth(), this.height = e.height || Cu.getScreenHeight(), this.widthMeters = e.widthMeters, this.heightMeters = e.heightMeters, this.bevelMeters = e.bevelMeters
                },
                Ru = new Au({
                    widthMeters: .11,
                    heightMeters: .062,
                    bevelMeters: .004
                }),
                wu = new Au({
                    widthMeters: .1038,
                    heightMeters: .0584,
                    bevelMeters: .004
                }),
                Eu = {
                    CardboardV1: new yu({
                        id: "CardboardV1",
                        label: "Cardboard I/O 2014",
                        fov: 40,
                        interLensDistance: .06,
                        baselineLensDistance: .035,
                        screenLensDistance: .042,
                        distortionCoefficients: [.441, .156],
                        inverseCoefficients: [-.4410035, .42756155, -.4804439, .5460139, -.58821183, .5733938, -.48303202, .33299083, -.17573841, .0651772, -.01488963, .001559834]
                    }),
                    CardboardV2: new yu({
                        id: "CardboardV2",
                        label: "Cardboard I/O 2015",
                        fov: 60,
                        interLensDistance: .064,
                        baselineLensDistance: .035,
                        screenLensDistance: .039,
                        distortionCoefficients: [.34, .55],
                        inverseCoefficients: [-.33836704, -.18162185, .862655, -1.2462051, 1.0560602, -.58208317, .21609078, -.05444823, .009177956, -.0009904169, 6183535e-11, -16981803e-13]
                    })
                };

            function Pu(e) {
                this.viewer = Eu.CardboardV1, this.updateDeviceParams(e)
            }
            Pu.prototype.updateDeviceParams = function (e) {
                this.device = this.determineDevice_(e) || this.device
            }, Pu.prototype.getDevice = function () {
                return this.device
            }, Pu.prototype.setViewer = function (e) {
                this.viewer = e
            }, Pu.prototype.determineDevice_ = function (e) {
                if (!e) return Cu.isIOS() ? wu : Ru;
                var t = .0254,
                    i = t / e.xdpi,
                    n = t / e.ydpi,
                    r = Cu.getScreenWidth(),
                    a = Cu.getScreenHeight();
                return new Au({
                    widthMeters: i * r,
                    heightMeters: n * a,
                    bevelMeters: .001 * e.bevelMm
                })
            }, Pu.prototype.getDistortedFieldOfViewLeftEye = function () {
                var e = this.viewer,
                    t = this.device,
                    i = new _u(e.distortionCoefficients),
                    n = e.screenLensDistance,
                    r = (t.widthMeters - e.interLensDistance) / 2,
                    a = e.interLensDistance / 2,
                    o = e.baselineLensDistance - t.bevelMeters,
                    s = t.heightMeters - o,
                    l = Mu * Math.atan(i.distort(r / n)),
                    u = Mu * Math.atan(i.distort(a / n)),
                    c = Mu * Math.atan(i.distort(o / n)),
                    h = Mu * Math.atan(i.distort(s / n));
                return {
                    leftDegrees: Math.min(l, e.fov),
                    rightDegrees: Math.min(u, e.fov),
                    downDegrees: Math.min(c, e.fov),
                    upDegrees: Math.min(h, e.fov)
                }
            }, Pu.prototype.getFieldOfViewLeftEye = function (e) {
                return e ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye()
            }, Pu.prototype.getFieldOfViewRightEye = function (e) {
                var t = this.getFieldOfViewLeftEye(e);
                return {
                    leftDegrees: t.rightDegrees,
                    rightDegrees: t.leftDegrees,
                    upDegrees: t.upDegrees,
                    downDegrees: t.downDegrees
                }
            }, Pu.prototype.getProjectionMatrixLeftEye = function (e) {
                var t = this.getFieldOfViewLeftEye(e),
                    i = Tu.mat4.create(),
                    n = .1,
                    r = Math.tan(bu * t.leftDegrees) * n,
                    a = Math.tan(bu * t.rightDegrees) * n,
                    o = Math.tan(bu * t.downDegrees) * n,
                    s = Math.tan(bu * t.upDegrees) * n;
                return Tu.mat4.frustum(i, -r, a, -o, s, n, 1e3), i
            }, Pu.prototype.getUndistortedViewportLeftEye = function () {
                var e = this.getUndistortedParams_(),
                    t = this.viewer,
                    i = this.device,
                    n = t.screenLensDistance,
                    r = i.widthMeters / n,
                    a = i.heightMeters / n,
                    o = i.width / r,
                    s = i.height / a,
                    l = Math.round((e.eyePosX - e.outerDist) * o),
                    u = Math.round((e.eyePosY - e.bottomDist) * s);
                return {
                    x: l,
                    y: u,
                    width: Math.round((e.eyePosX + e.innerDist) * o) - l,
                    height: Math.round((e.eyePosY + e.topDist) * s) - u
                }
            }, Pu.prototype.getUndistortedFieldOfViewLeftEye = function () {
                var e = this.getUndistortedParams_();
                return {
                    leftDegrees: Mu * Math.atan(e.outerDist),
                    rightDegrees: Mu * Math.atan(e.innerDist),
                    downDegrees: Mu * Math.atan(e.bottomDist),
                    upDegrees: Mu * Math.atan(e.topDist)
                }
            }, Pu.prototype.getUndistortedParams_ = function () {
                var e = this.viewer,
                    t = this.device,
                    i = new _u(e.distortionCoefficients),
                    n = e.screenLensDistance,
                    r = e.interLensDistance / 2 / n,
                    a = t.widthMeters / n,
                    o = t.heightMeters / n,
                    s = a / 2 - r,
                    l = (e.baselineLensDistance - t.bevelMeters) / n,
                    u = e.fov,
                    c = i.distortInverse(Math.tan(bu * u)),
                    h = Math.min(s, c),
                    d = Math.min(r, c),
                    g = Math.min(l, c);
                return {
                    outerDist: h,
                    innerDist: d,
                    topDist: Math.min(o - l, c),
                    bottomDist: g,
                    eyePosX: s,
                    eyePosY: l
                }
            }, Pu.Viewers = Eu;
            const Nu = Pu;
            const Ou = {
                format: 1,
                last_updated: "2019-02-19T20:27:12Z",
                devices: [{
                    type: "android",
                    rules: [{
                        mdmh: "asus/*/Nexus 7/*"
                    }, {
                        ua: "Nexus 7"
                    }],
                    dpi: [320.8, 323],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "asus/*/ASUS_Z00AD/*"
                    }, {
                        ua: "ASUS_Z00AD"
                    }],
                    dpi: [403, 404.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Google/*/Pixel 2 XL/*"
                    }, {
                        ua: "Pixel 2 XL"
                    }],
                    dpi: 537.9,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Google/*/Pixel 3 XL/*"
                    }, {
                        ua: "Pixel 3 XL"
                    }],
                    dpi: [558.5, 553.8],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Google/*/Pixel XL/*"
                    }, {
                        ua: "Pixel XL"
                    }],
                    dpi: [537.9, 533],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Google/*/Pixel 3/*"
                    }, {
                        ua: "Pixel 3"
                    }],
                    dpi: 442.4,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Google/*/Pixel 2/*"
                    }, {
                        ua: "Pixel 2"
                    }],
                    dpi: 441,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Google/*/Pixel/*"
                    }, {
                        ua: "Pixel"
                    }],
                    dpi: [432.6, 436.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "HTC/*/HTC6435LVW/*"
                    }, {
                        ua: "HTC6435LVW"
                    }],
                    dpi: [449.7, 443.3],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "HTC/*/HTC One XL/*"
                    }, {
                        ua: "HTC One XL"
                    }],
                    dpi: [315.3, 314.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "htc/*/Nexus 9/*"
                    }, {
                        ua: "Nexus 9"
                    }],
                    dpi: 289,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "HTC/*/HTC One M9/*"
                    }, {
                        ua: "HTC One M9"
                    }],
                    dpi: [442.5, 443.3],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "HTC/*/HTC One_M8/*"
                    }, {
                        ua: "HTC One_M8"
                    }],
                    dpi: [449.7, 447.4],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "HTC/*/HTC One/*"
                    }, {
                        ua: "HTC One"
                    }],
                    dpi: 472.8,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Huawei/*/Nexus 6P/*"
                    }, {
                        ua: "Nexus 6P"
                    }],
                    dpi: [515.1, 518],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Huawei/*/BLN-L24/*"
                    }, {
                        ua: "HONORBLN-L24"
                    }],
                    dpi: 480,
                    bw: 4,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Huawei/*/BKL-L09/*"
                    }, {
                        ua: "BKL-L09"
                    }],
                    dpi: 403,
                    bw: 3.47,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LENOVO/*/Lenovo PB2-690Y/*"
                    }, {
                        ua: "Lenovo PB2-690Y"
                    }],
                    dpi: [457.2, 454.713],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/Nexus 5X/*"
                    }, {
                        ua: "Nexus 5X"
                    }],
                    dpi: [422, 419.9],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/LGMS345/*"
                    }, {
                        ua: "LGMS345"
                    }],
                    dpi: [221.7, 219.1],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/LG-D800/*"
                    }, {
                        ua: "LG-D800"
                    }],
                    dpi: [422, 424.1],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/LG-D850/*"
                    }, {
                        ua: "LG-D850"
                    }],
                    dpi: [537.9, 541.9],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/VS985 4G/*"
                    }, {
                        ua: "VS985 4G"
                    }],
                    dpi: [537.9, 535.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/Nexus 5/*"
                    }, {
                        ua: "Nexus 5 B"
                    }],
                    dpi: [442.4, 444.8],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/Nexus 4/*"
                    }, {
                        ua: "Nexus 4"
                    }],
                    dpi: [319.8, 318.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/LG-P769/*"
                    }, {
                        ua: "LG-P769"
                    }],
                    dpi: [240.6, 247.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/LGMS323/*"
                    }, {
                        ua: "LGMS323"
                    }],
                    dpi: [206.6, 204.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "LGE/*/LGLS996/*"
                    }, {
                        ua: "LGLS996"
                    }],
                    dpi: [403.4, 401.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Micromax/*/4560MMX/*"
                    }, {
                        ua: "4560MMX"
                    }],
                    dpi: [240, 219.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Micromax/*/A250/*"
                    }, {
                        ua: "Micromax A250"
                    }],
                    dpi: [480, 446.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Micromax/*/Micromax AQ4501/*"
                    }, {
                        ua: "Micromax AQ4501"
                    }],
                    dpi: 240,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/G5/*"
                    }, {
                        ua: "Moto G (5) Plus"
                    }],
                    dpi: [403.4, 403],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/DROID RAZR/*"
                    }, {
                        ua: "DROID RAZR"
                    }],
                    dpi: [368.1, 256.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT830C/*"
                    }, {
                        ua: "XT830C"
                    }],
                    dpi: [254, 255.9],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1021/*"
                    }, {
                        ua: "XT1021"
                    }],
                    dpi: [254, 256.7],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1023/*"
                    }, {
                        ua: "XT1023"
                    }],
                    dpi: [254, 256.7],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1028/*"
                    }, {
                        ua: "XT1028"
                    }],
                    dpi: [326.6, 327.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1034/*"
                    }, {
                        ua: "XT1034"
                    }],
                    dpi: [326.6, 328.4],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1053/*"
                    }, {
                        ua: "XT1053"
                    }],
                    dpi: [315.3, 316.1],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1562/*"
                    }, {
                        ua: "XT1562"
                    }],
                    dpi: [403.4, 402.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/Nexus 6/*"
                    }, {
                        ua: "Nexus 6 B"
                    }],
                    dpi: [494.3, 489.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1063/*"
                    }, {
                        ua: "XT1063"
                    }],
                    dpi: [295, 296.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1064/*"
                    }, {
                        ua: "XT1064"
                    }],
                    dpi: [295, 295.6],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1092/*"
                    }, {
                        ua: "XT1092"
                    }],
                    dpi: [422, 424.1],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/XT1095/*"
                    }, {
                        ua: "XT1095"
                    }],
                    dpi: [422, 423.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "motorola/*/G4/*"
                    }, {
                        ua: "Moto G (4)"
                    }],
                    dpi: 401,
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "OnePlus/*/A0001/*"
                    }, {
                        ua: "A0001"
                    }],
                    dpi: [403.4, 401],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "OnePlus/*/ONE E1005/*"
                    }, {
                        ua: "ONE E1005"
                    }],
                    dpi: [442.4, 441.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "OnePlus/*/ONE A2005/*"
                    }, {
                        ua: "ONE A2005"
                    }],
                    dpi: [391.9, 405.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A5000/*"
                    }, {
                        ua: "ONEPLUS A5000 "
                    }],
                    dpi: [403.411, 399.737],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "OnePlus/*/ONE A5010/*"
                    }, {
                        ua: "ONEPLUS A5010"
                    }],
                    dpi: [403, 400],
                    bw: 2,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "OPPO/*/X909/*"
                    }, {
                        ua: "X909"
                    }],
                    dpi: [442.4, 444.1],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9082/*"
                    }, {
                        ua: "GT-I9082"
                    }],
                    dpi: [184.7, 185.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G360P/*"
                    }, {
                        ua: "SM-G360P"
                    }],
                    dpi: [196.7, 205.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/Nexus S/*"
                    }, {
                        ua: "Nexus S"
                    }],
                    dpi: [234.5, 229.8],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9300/*"
                    }, {
                        ua: "GT-I9300"
                    }],
                    dpi: [304.8, 303.9],
                    bw: 5,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-T230NU/*"
                    }, {
                        ua: "SM-T230NU"
                    }],
                    dpi: 216,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SGH-T399/*"
                    }, {
                        ua: "SGH-T399"
                    }],
                    dpi: [217.7, 231.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SGH-M919/*"
                    }, {
                        ua: "SGH-M919"
                    }],
                    dpi: [440.8, 437.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-N9005/*"
                    }, {
                        ua: "SM-N9005"
                    }],
                    dpi: [386.4, 387],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SAMSUNG-SM-N900A/*"
                    }, {
                        ua: "SAMSUNG-SM-N900A"
                    }],
                    dpi: [386.4, 387.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9500/*"
                    }, {
                        ua: "GT-I9500"
                    }],
                    dpi: [442.5, 443.3],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9505/*"
                    }, {
                        ua: "GT-I9505"
                    }],
                    dpi: 439.4,
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G900F/*"
                    }, {
                        ua: "SM-G900F"
                    }],
                    dpi: [415.6, 431.6],
                    bw: 5,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G900M/*"
                    }, {
                        ua: "SM-G900M"
                    }],
                    dpi: [415.6, 431.6],
                    bw: 5,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G800F/*"
                    }, {
                        ua: "SM-G800F"
                    }],
                    dpi: 326.8,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G906S/*"
                    }, {
                        ua: "SM-G906S"
                    }],
                    dpi: [562.7, 572.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9300/*"
                    }, {
                        ua: "GT-I9300"
                    }],
                    dpi: [306.7, 304.8],
                    bw: 5,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-T535/*"
                    }, {
                        ua: "SM-T535"
                    }],
                    dpi: [142.6, 136.4],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-N920C/*"
                    }, {
                        ua: "SM-N920C"
                    }],
                    dpi: [515.1, 518.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-N920P/*"
                    }, {
                        ua: "SM-N920P"
                    }],
                    dpi: [386.3655, 390.144],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-N920W8/*"
                    }, {
                        ua: "SM-N920W8"
                    }],
                    dpi: [515.1, 518.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9300I/*"
                    }, {
                        ua: "GT-I9300I"
                    }],
                    dpi: [304.8, 305.8],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-I9195/*"
                    }, {
                        ua: "GT-I9195"
                    }],
                    dpi: [249.4, 256.7],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SPH-L520/*"
                    }, {
                        ua: "SPH-L520"
                    }],
                    dpi: [249.4, 255.9],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SAMSUNG-SGH-I717/*"
                    }, {
                        ua: "SAMSUNG-SGH-I717"
                    }],
                    dpi: 285.8,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SPH-D710/*"
                    }, {
                        ua: "SPH-D710"
                    }],
                    dpi: [217.7, 204.2],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/GT-N7100/*"
                    }, {
                        ua: "GT-N7100"
                    }],
                    dpi: 265.1,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SCH-I605/*"
                    }, {
                        ua: "SCH-I605"
                    }],
                    dpi: 265.1,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/Galaxy Nexus/*"
                    }, {
                        ua: "Galaxy Nexus"
                    }],
                    dpi: [315.3, 314.2],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-N910H/*"
                    }, {
                        ua: "SM-N910H"
                    }],
                    dpi: [515.1, 518],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-N910C/*"
                    }, {
                        ua: "SM-N910C"
                    }],
                    dpi: [515.2, 520.2],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G130M/*"
                    }, {
                        ua: "SM-G130M"
                    }],
                    dpi: [165.9, 164.8],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G928I/*"
                    }, {
                        ua: "SM-G928I"
                    }],
                    dpi: [515.1, 518.4],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G920F/*"
                    }, {
                        ua: "SM-G920F"
                    }],
                    dpi: 580.6,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G920P/*"
                    }, {
                        ua: "SM-G920P"
                    }],
                    dpi: [522.5, 577],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G925F/*"
                    }, {
                        ua: "SM-G925F"
                    }],
                    dpi: 580.6,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G925V/*"
                    }, {
                        ua: "SM-G925V"
                    }],
                    dpi: [522.5, 576.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G930F/*"
                    }, {
                        ua: "SM-G930F"
                    }],
                    dpi: 576.6,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G935F/*"
                    }, {
                        ua: "SM-G935F"
                    }],
                    dpi: 533,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G950F/*"
                    }, {
                        ua: "SM-G950F"
                    }],
                    dpi: [562.707, 565.293],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G955U/*"
                    }, {
                        ua: "SM-G955U"
                    }],
                    dpi: [522.514, 525.762],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G955F/*"
                    }, {
                        ua: "SM-G955F"
                    }],
                    dpi: [522.514, 525.762],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G960F/*"
                    }, {
                        ua: "SM-G960F"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G9600/*"
                    }, {
                        ua: "SM-G9600"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G960T/*"
                    }, {
                        ua: "SM-G960T"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G960N/*"
                    }, {
                        ua: "SM-G960N"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G960U/*"
                    }, {
                        ua: "SM-G960U"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G9608/*"
                    }, {
                        ua: "SM-G9608"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G960FD/*"
                    }, {
                        ua: "SM-G960FD"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "samsung/*/SM-G960W/*"
                    }, {
                        ua: "SM-G960W"
                    }],
                    dpi: [569.575, 571.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Sony/*/C6903/*"
                    }, {
                        ua: "C6903"
                    }],
                    dpi: [442.5, 443.3],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Sony/*/D6653/*"
                    }, {
                        ua: "D6653"
                    }],
                    dpi: [428.6, 427.6],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Sony/*/E6653/*"
                    }, {
                        ua: "E6653"
                    }],
                    dpi: [428.6, 425.7],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Sony/*/E6853/*"
                    }, {
                        ua: "E6853"
                    }],
                    dpi: [403.4, 401.9],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Sony/*/SGP321/*"
                    }, {
                        ua: "SGP321"
                    }],
                    dpi: [224.7, 224.1],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*"
                    }, {
                        ua: "ALCATEL ONE TOUCH Fierce"
                    }],
                    dpi: [240, 247.5],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "THL/*/thl 5000/*"
                    }, {
                        ua: "thl 5000"
                    }],
                    dpi: [480, 443.3],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Fly/*/IQ4412/*"
                    }, {
                        ua: "IQ4412"
                    }],
                    dpi: 307.9,
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "ZTE/*/ZTE Blade L2/*"
                    }, {
                        ua: "ZTE Blade L2"
                    }],
                    dpi: 240,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "BENEVE/*/VR518/*"
                    }, {
                        ua: "VR518"
                    }],
                    dpi: 480,
                    bw: 3,
                    ac: 500
                }, {
                    type: "ios",
                    rules: [{
                        res: [640, 960]
                    }],
                    dpi: [325.1, 328.4],
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "ios",
                    rules: [{
                        res: [640, 1136]
                    }],
                    dpi: [317.1, 320.2],
                    bw: 3,
                    ac: 1e3
                }, {
                    type: "ios",
                    rules: [{
                        res: [750, 1334]
                    }],
                    dpi: 326.4,
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "ios",
                    rules: [{
                        res: [1242, 2208]
                    }],
                    dpi: [453.6, 458.4],
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "ios",
                    rules: [{
                        res: [1125, 2001]
                    }],
                    dpi: [410.9, 415.4],
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "ios",
                    rules: [{
                        res: [1125, 2436]
                    }],
                    dpi: 458,
                    bw: 4,
                    ac: 1e3
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Huawei/*/EML-L29/*"
                    }, {
                        ua: "EML-L29"
                    }],
                    dpi: 428,
                    bw: 3.45,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{
                        mdmh: "Nokia/*/Nokia 7.1/*"
                    }, {
                        ua: "Nokia 7.1"
                    }],
                    dpi: [432, 431.9],
                    bw: 3,
                    ac: 500
                }, {
                    type: "ios",
                    rules: [{
                        res: [1242, 2688]
                    }],
                    dpi: 458,
                    bw: 4,
                    ac: 1e3
                }]
            };
            var Du = function (e) {
                this.xdpi = e.xdpi, this.ydpi = e.ydpi, this.bevelMm = e.bevelMm
            },
                Iu = !1,
                Fu = function (e) {
                    Iu
                },
                Lu = function (e) {
                    Iu
                },
                Vu = function (e) {
                    Iu
                },
                Bu = function (e, t) {
                    if (this.dpdb = Ou, this.recalculateDeviceParams_(), e) {
                        this.onDeviceParamsUpdated = t, Fu();
                        var i = new XMLHttpRequest,
                            n = this;
                        i.open("GET", "https://dpdb.webvr.rocks/dpdb.json", !0), i.addEventListener("load", (function () {
                            n.loading = !1, i.status >= 200 && i.status <= 299 ? (Fu(), n.dpdb = JSON.parse(i.response), n.recalculateDeviceParams_()) : Lu()
                        })), i.send()
                    }
                };
            Bu.prototype.getDeviceParams = function () {
                return this.deviceParams
            }, Bu.prototype.recalculateDeviceParams_ = function () {
                Fu();
                var e = this.calcDeviceParams_();
                Fu(), Fu(), e ? (this.deviceParams = e, this.onDeviceParamsUpdated && this.onDeviceParamsUpdated(this.deviceParams)) : Lu()
            }, Bu.prototype.calcDeviceParams_ = function () {
                var e = this.dpdb;
                if (!e) return Lu(), null;
                if (1 !== e.format) return Lu(), null;
                if (!e.devices || !e.devices.length) return Lu(), null;
                var t = navigator.userAgent || navigator.vendor || window.opera,
                    i = Cu.getScreenWidth(),
                    n = Cu.getScreenHeight();
                if (Fu(), Fu(), Fu(), !e.devices) return Lu(), null;
                for (var r = 0; r < e.devices.length; r++) {
                    var a = e.devices[r];
                    if (a.rules)
                        if ("ios" === a.type || "android" === a.type) {
                            if (Cu.isIOS() === ("ios" === a.type)) {
                                for (var o = !1, s = 0; s < a.rules.length; s++) {
                                    var l = a.rules[s];
                                    if (this.matchRule_(l, t, i, n)) {
                                        Fu(), Fu(), o = !0;
                                        break
                                    }
                                }
                                if (o) {
                                    var u = a.dpi[0] || a.dpi,
                                        c = a.dpi[1] || a.dpi;
                                    return new Du({
                                        xdpi: u,
                                        ydpi: c,
                                        bevelMm: a.bw
                                    })
                                }
                            }
                        } else Vu();
                    else Vu()
                }
                return Vu(), null
            }, Bu.prototype.matchRule_ = function (e, t, i, n) {
                if (!e.ua && !e.res) return !1;
                if (e.ua && t.indexOf(e.ua) < 0) return !1;
                if (e.res) {
                    if (!e.res[0] || !e.res[1]) return !1;
                    var r = e.res[0],
                        a = e.res[1];
                    if (Math.min(i, n) !== Math.min(r, a) || Math.max(i, n) !== Math.max(r, a)) return !1
                }
                return !0
            };
            const Uu = Bu;
            var ku = g.Z.osg;
            (0, l.Z)().vrForceRaf && (g.Z.osgViewer.Viewer.prototype.setVRDisplay = function (e) {
                this._hmd = e, this._requestAnimationFrame = e.requestAnimationFrame.bind(e)
            });
            var Zu = a.Z.extend({
                getModelOptionPath: function () {
                    return "vr"
                },
                defaults: {
                    enable: !1,
                    deviceInfo: void 0,
                    hit: void 0,
                    hasNativeHMD: !1,
                    humanMatrix: ku.mat4.create(),
                    humanInAir: !1,
                    displayFloor: !0
                },
                init: function (e) {
                    if (this._context = e, this._scene = e.getScene(), this._viewer = e.getViewer(), window.matchMedia && window.matchMedia("(environment-blending: additive)").matches) {
                        var t = this._context.getFeatures().background.getModel();
                        t.set("color", [0, 0, 0]), t.set("enable", "color"), this.set("displayFloor", !1)
                    }
                },
                initAfterFirstFrame: function () {
                    this.set("deviceInfo", this._initDeviceInfo());
                    var e = this._context.getModel().get("options").vr;
                    e && e.worldFactor > 0 && this.setJSON(e), this.initBoundAndWorldFactor(), this.set("enable", (0, l.Z)().cardboard > 0)
                },
                onVrDisplayReady: function (e) {
                    L.Z.getVrDisplayReady().isFulfilled() ? e() : L.Z.getVrDisplayReady().then((function () {
                        e()
                    }))
                },
                _getBoundRadius: function () {
                    return J.Z.getModelBoxWithDisplacement().radius()
                },
                isDiorama: function () {
                    return this._getBoundRadius() < 2 * this.get("worldFactor")
                },
                getMinimumWorldFactor: function () {
                    return .001 * this._getBoundRadius()
                },
                getMaximumWorldFactor: function () {
                    return 100 * this._getBoundRadius()
                },
                getDefaultHumanHeight: function () {
                    return 1.65
                },
                _makeValidWorldFactor: function () {
                    var e = this.get("worldFactor"),
                        t = this.getMinimumWorldFactor(),
                        i = this.getMaximumWorldFactor();
                    if (e < t * J.Z.BIAS_MIN || e > i * J.Z.BIAS_MAX) {
                        var n = J.Z.getModelBoxWithDisplacement(),
                            r = n.getMin()[2],
                            a = n.radius();
                        this.set("worldFactor", .5 * a), this.set("floorHeight", r);
                        var o = n.center(ku.vec3.create());
                        o[1] -= 1.2 * a, o[2] = r, ku.mat4.fromTranslation(this.get("humanMatrix"), o)
                    } else this.set("worldFactor", Math.min(Math.max(e, t), i))
                },
                initBoundAndWorldFactor: function () {
                    this._makeValidWorldFactor(), this.trigger("uiReady")
                },
                _initDeviceInfo: function () {
                    var e = new Uu(!1),
                        t = new Nu(e.getDeviceParams());
                    return (0, l.Z)().cardboard > 1 && t.setViewer(Nu.Viewers.CardboardV2), t
                },
                getName: function () {
                    return "WebVR"
                },
                setJSON: function (e, t) {
                    var i = t || {};
                    i.ignore = ["initialCamera"];
                    var n = a.Z.prototype.setJSON.call(this, e, i),
                        r = this.get("humanMatrix"),
                        o = e.initialCamera;
                    return ku.mat4.fromQuat(r, o.rotation), ku.mat4.setTranslation(r, o.position), n
                },
                getJSON: function () {
                    var e = ku.mat4.copy(ku.mat4.create(), this.get("humanMatrix")),
                        t = ku.mat4.getScale(ku.vec3.create(), e);
                    ku.vec3.set(t, 1 / t[0], 1 / t[1], 1 / t[2]);
                    var i = ku.mat4.scale(e, e, t),
                        n = ku.quat.create();
                    ku.quat.normalize(n, ku.mat4.getRotation(n, i));
                    var r = a.Z.prototype.getJSON.call(this, {
                        ignore: "initialCamera"
                    });
                    return r.initialCamera = {
                        position: ku.mat4.getTranslation(ku.vec3.create(), i),
                        rotation: n
                    }, r
                }
            });
            const Hu = Zu;
            var Gu = i("BvLe");
            const zu = "attribute vec3 Vertex;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying float vHeight;\n\nvoid main(void) {\n  vHeight = Vertex.z;\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex.xyz, 1.0));\n}\n",
                Wu = 'uniform vec3 uColor;\nuniform float uAlpha;\nuniform int uOutputLinear;\n\nvarying float vHeight;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n  vec4 color = vec4(uColor, 1.0) * uAlpha * smoothstep(1.0, 0.0, pow(vHeight, 0.3));\n\n  gl_FragColor = uOutputLinear == 0 ? linearTosRGB(color) : color;\n}\n';
            var ju, Xu, Yu = g.Z.osg,
                Ju = g.Z.osgUtil,
                qu = Yu.vec3.fromValues(.1, .4, .8),
                Ku = Yu.vec3.fromValues(1, .7, .1),
                Qu = Yu.vec3.fromValues(1, 0, 0),
                $u = Yu.vec3.fromValues(0, 0, .9),
                ec = function (e) {
                    Yu.MatrixTransform.call(this), this._model = e, this.setMatrix(e.get("humanMatrix")), this.setName("WebVR - Human"), this.setNodeMask(0), this.editMask = Ju.NodeGizmo.NO_FULL_CIRCLE | Ju.NodeGizmo.PICK_PLANE_Z | Ju.NodeGizmo.PICK_ARROW | Ju.NodeGizmo.PICK_ARC_Z, this._humanMT = new Yu.MatrixTransform, Yu.mat4.fromZRotation(this._humanMT.getMatrix(), Math.PI), this._geoHuman = new Yu.Geometry, this._humanMT.addChild(this._geoHuman), this._uColorCylinder = Yu.Uniform.createFloat3(Yu.vec3.copy(Yu.vec3.create(), qu), "uColor"), this._uColorHint = Yu.Uniform.createFloat3(Yu.vec3.copy(Yu.vec3.create(), Ku), "uColor"), this._hintToFloorMT = new Yu.MatrixTransform, this._geoHintToFloor = Yu.createTexturedBoxGeometry(0, 0, -.5, .02, .02, 1), this._hintToFloorMT.addChild(this._geoHintToFloor), this._hintToFloorMT.setNodeMask(Pe.Z.NO_PICK), this._geoCylinder = Ju.GizmoGeometry.createCylinderGeometry(1, 1, 1, 50, 1, !1, !1), this._geoCylinder.setNodeMask(Pe.Z.NO_PICK);
                    for (var t = 0, i = this._geoCylinder.getAttributes().Vertex.getElements(), n = i.length / 3; t < n; ++t) i[3 * t + 2] += .5;
                    this._cylinderMT = new Yu.MatrixTransform, Yu.mat4.fromScaling(this._cylinderMT.getMatrix(), Yu.vec3.fromValues(1, 1, .5)), this._cylinderMT.addChild(this._geoCylinder), this.addChild(this._humanMT), this.addChild(this._cylinderMT), this.addChild(this._hintToFloorMT), this._boundingBoxComputed = !0, this._boundingSphereComputed = !0, this.init()
                };
            Yu.createPrototypeNode(ec, Yu.objectInherit(Yu.MatrixTransform.prototype, {
                init: function () {
                    this.getOrCreateStateSet().setAttributeAndModes(Le.Z.CULL_BACK);
                    var e = this._humanMT.getOrCreateStateSet();
                    e.setShaderGeneratorName("shadeless-pbr"), e.setName("vrHuman");
                    var t = Fr.createMaterialModel(e);
                    t.set("name", "NodeHuman"), t.set("hasVertexColor", !0), t.set("vertexColorEnable", !0), t.set("vertexColorColorSpace", "linear"), t.trigger("apply"), e.setAttributeAndModes(e.getAttribute("testdemo2024Material")), (0, o.Z)() && cs(this.initHumanMesh.bind(this));
                    var i = this._geoHintToFloor.getOrCreateStateSet();
                    i.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec3 Vertex;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying float vHeight;\n\nvoid main(void) {\n  vHeight = Vertex.z;\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex.xyz, 1.0));\n}\n", 'uniform vec3 uColor;\nuniform int uOutputLinear;\n\nvarying float vHeight;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n  vec4 color = vec4(uColor, 1.0) * smoothstep(1.0, 0.0, vHeight + 1.0);\n\n  gl_FragColor = uOutputLinear == 0 ? linearTosRGB(color) : color;\n}\n', "webVR-hintToFloor", "VRHintToFloor")), i.addUniform(this._uColorHint), i.setRenderBinDetails(Oe.Z.TRANSPARENT_NO_EARLYZ_POST, "RenderBin");
                    var n = this._geoCylinder.getOrCreateStateSet();
                    n.setAttributeAndModes(Ne.Z.getOrCreateShader(zu, Wu, "webVR-humanCylinder", "VRHumanCylinder")), n.addUniform(this._uColorCylinder), n.addUniform(Yu.Uniform.createFloat(1, "uAlpha")), n.setRenderBinDetails(Oe.Z.TRANSPARENT_NO_EARLYZ_POST, "RenderBin")
                },
                initHumanMesh: function (e) {
                    var t = this._geoHuman;
                    t.getAttributes().Vertex = new Yu.BufferArray(Yu.BufferArray.ARRAY_BUFFER, e.VERTEX, 3), t.getAttributes().Color = new Yu.BufferArray(Yu.BufferArray.ARRAY_BUFFER, e.COLOR, 4), t.getPrimitives().push(new Yu.DrawElements(Yu.primitiveSet.TRIANGLES, new Yu.BufferArray(Yu.BufferArray.ELEMENT_ARRAY_BUFFER, e.TRIANGLES, 1))), t.getPrimitives().push(new Yu.DrawElements(Yu.primitiveSet.TRIANGLE_STRIP, new Yu.BufferArray(Yu.BufferArray.ELEMENT_ARRAY_BUFFER, e.STRIP, 1)))
                },
                setVisible: function (e) {
                    if (this._visible !== e) {
                        this._visible = e, this.setNodeMask(e ? -1 : 0);
                        var t = this._model._viewer.getFeaturesManager().getNodeGizmo();
                        e ? (t.attachToNode(this), this._initView()) : this._restoreView()
                    }
                },
                _initView: function () {
                    var e = Yu.vec3.create(),
                        t = Yu.vec3.create(),
                        i = Yu.vec3.create(),
                        n = Yu.quat.create(),
                        r = Yu.vec3.create(),
                        a = Yu.vec3.create(),
                        o = Yu.vec3.fromValues(0, 0, -1);
                    return function () {
                        var s = this._model._viewer.getFeaturesManager(),
                            l = this._model.get("worldFactor"),
                            u = this._model._viewer.getViewerOSGJS().getManipulator();
                        this._eyePos || (this._eyePos = Yu.vec3.create(), this._eyeTarget = Yu.vec3.create()), u.getEyePosition(this._eyePos), u.getTarget(this._eyeTarget), Yu.mat4.getTranslation(e, this.getMatrix()), Yu.mat4.getRotation(n, this.getMatrix()), Yu.vec3.set(t, 0, 1, 0), Yu.vec3.transformQuat(t, t, n), Yu.vec3.copy(r, $u), Yu.vec3.scale(r, r, l), Yu.vec3.add(e, e, r), Yu.vec3.scale(r, t, -1), Yu.vec3.normalize(r, r), Yu.vec3.cross(a, r, o), Yu.vec3.copy(i, e), Yu.vec3.scale(r, r, 3 * l), Yu.vec3.scale(a, a, .5 * l), Yu.vec3.add(r, r, a), Yu.vec3.add(i, i, r), s.focusOnTargetAndEye(e, i, 1)
                    }
                }(),
                _restoreView: function () {
                    this._eyePos && this._model._viewer.getFeaturesManager().focusOnTargetAndEye(this._eyeTarget, this._eyePos)
                },
                computeDistanceToFloor: (ju = Yu.vec3.create(), Xu = Yu.vec3.create(), function () {
                    var e = this.getMatrix(),
                        t = this._model,
                        i = t.get("worldFactor"),
                        n = t.get("floorHeight");
                    Yu.mat4.getTranslation(ju, e), Yu.vec3.copy(Xu, ju);
                    var r = .1 * i;
                    ju[2] += r, Xu[2] -= 100 * i, this.setNodeMask(Pe.Z.NO_PICK);
                    var a = Fe.Z.computeNearestIntersection3D(ju, Xu, Pe.Z.PICK_GEOMETRY_SLOW);
                    if (this.setNodeMask(-1), a) r = Yu.vec3.dist(Fe.Z.getWorldPositionFromHit(a, Xu), ju);
                    else {
                        if (!t.get("displayFloor")) return 0;
                        r = ju[2] - n
                    }
                    return Math.max(0, r - .1 * i)
                }),
                updateNodeVR: function () {
                    var e = Yu.vec3.create();
                    return function (t, i) {
                        if (0 !== this.getNodeMask()) {
                            var n = this.getMatrix(),
                                r = this._model,
                                a = r._viewer.getFeaturesManager(),
                                o = r.get("worldFactor"),
                                s = r.get("floorHeight");
                            Yu.vec3.lerp(this._uColorHint.getInternalArray(), Ku, Qu, .5 * Math.sin(10 * i) + .5), Yu.mat4.getScale(e, n), Yu.vec3.set(e, o / e[0], o / e[1], o / e[2]), Yu.mat4.scale(n, n, e), r.get("displayFloor") && (n[14] = Math.max(n[14], s));
                            var l = a.getNodeGizmo().getAttachedNode() === this || t && -1 !== t._nodePath.indexOf(this._humanMT);
                            Yu.vec3.copy(this._uColorCylinder.getInternalArray(), l ? Ku : qu);
                            var u = this.computeDistanceToFloor() / o,
                                c = u > .05;
                            Yu.mat4.fromScaling(this._hintToFloorMT.getMatrix(), Yu.vec3.set(e, 1, 1, c ? u : 1e-7)), this._model.set("humanInAir", c), this.dirtyBound()
                        }
                    }
                }()
            }), "osgtestdemo2024", "Human");
            const tc = ec;
            var ic = g.Z.osg,
                nc = g.Z.osgUtil,
                rc = function () {
                    ic.Node.call(this), this.setName("WebVR - Teleport"), this.setVisible(!0), this._interpolatorNormal = new nc.DelayInterpolator(3), this._interpolatorNormal.setDelay(.08), this._geoCircle1 = ic.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0), this._geoCircle2 = ic.createTexturedQuadGeometry(-.5, -.5, .15, 1, 0, 0, 0, 1, 0), this._geoCircle3 = ic.createTexturedQuadGeometry(-.5, -.5, .15, 1, 0, 0, 0, 1, 0), this._uAlpha1 = ic.Uniform.createFloat(1, "uAlpha"), this._uAlpha2 = ic.Uniform.createFloat(1, "uAlpha"), this._uAlpha3 = ic.Uniform.createFloat(1, "uAlpha"), this._uScale1 = ic.Uniform.createFloat(1, "uScale"), this._uScale2 = ic.Uniform.createFloat(.99, "uScale"), this._uScale3 = ic.Uniform.createFloat(.99, "uScale"), this._geoCylinder = nc.GizmoGeometry.createCylinderGeometry(1, 1, 1, 50, 1, !1, !1);
                    for (var e = 0, t = this._geoCylinder.getAttributes().Vertex.getElements(), i = t.length / 3; e < i; ++e) t[3 * e + 2] += .5;
                    this._cylinderMT = new ic.MatrixTransform, ic.mat4.fromScaling(this._cylinderMT.getMatrix(), ic.vec3.fromValues(.38, .38, .125)), this._cylinderMT.addChild(this._geoCylinder), this._hotspotHintMT = new ic.MatrixTransform, this._hotspotHintMT.addChild(this._geoCylinder), this._hotspotHintMT.setNodeMask(0), this._teleportMT = new ic.MatrixTransform, this._teleportMT.addChild(this._geoCircle1), this._teleportMT.addChild(this._geoCircle2), this._teleportMT.addChild(this._geoCircle3), this._teleportMT.addChild(this._cylinderMT), this.addChild(this._teleportMT), this.addChild(this._hotspotHintMT), this.init()
                };
            ic.createPrototypeNode(rc, ic.objectInherit(ic.Node.prototype, {
                init: function () {
                    var e = this.getOrCreateStateSet();
                    e.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec2 TexCoord0;\nattribute vec3 Vertex;\n\nvarying vec2 vTexCoord0;\nuniform float uScale;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  vTexCoord0 = TexCoord0;\n\n  vec3 posLocal = Vertex.xyz * vec3(uScale, uScale, 1.0 - uScale);\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(posLocal, 1.0));\n}\n", 'varying vec2 vTexCoord0;\n\nuniform sampler2D uTextureTeleportCircle;\nuniform float uScale;\nuniform float uAlpha;\nuniform int uOutputLinear;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n  vec3 tex = sRGBToLinear(texture2D(uTextureTeleportCircle, vTexCoord0).rgb);\n  vec4 color = uScale == 1.0 ? vec4(tex.rrr, 1.0) * uAlpha * tex.g : vec4(uAlpha * tex.b);\n\n  gl_FragColor = uOutputLinear == 0 ? linearTosRGB(color) : color;\n}\n', "webVR-teleportCircle", "VRTeleportCircle")), e.addUniform(ic.Uniform.createInt(0, "uTextureTeleportCircle")), e.setTextureAttributeAndModes(0, hr.Z.dummyTexture), this._geoCircle1.getOrCreateStateSet().addUniform(this._uScale1), this._geoCircle2.getOrCreateStateSet().addUniform(this._uScale2), this._geoCircle3.getOrCreateStateSet().addUniform(this._uScale3), this._geoCircle1.getOrCreateStateSet().addUniform(this._uAlpha1), this._geoCircle2.getOrCreateStateSet().addUniform(this._uAlpha2), this._geoCircle3.getOrCreateStateSet().addUniform(this._uAlpha3);
                    var t = this._cylinderMT.getOrCreateStateSet();
                    t.addUniform(ic.Uniform.createFloat3(ic.vec3.fromValues(.7, .7, .3), "uColor")), t.addUniform(this._uAlpha1);
                    var i = this._hotspotHintMT.getOrCreateStateSet();
                    i.addUniform(ic.Uniform.createFloat3(ic.vec3.fromValues(.1, .66, .85), "uColor")), i.addUniform(this._uAlpha1), this._geoCylinder.getOrCreateStateSet().setAttributeAndModes(Ne.Z.getOrCreateShader(zu, Wu, "webVR-teleportCylinder", "VRTeleportCylinder"))
                },
                initTextureTeleport: function () {
                    rs(this.replaceTextureTeleport.bind(this))
                },
                replaceTextureTeleport: function (e) {
                    this.getOrCreateStateSet().setTextureAttributeAndModes(0, s.Z.instance.getOrCreateTexture(e.TELEPORT_CIRCLE, {
                        internalFormat: ic.Texture.RGBA
                    }).texture)
                },
                setVisible: function (e) {
                    this.setNodeMask(e ? Pe.Z.NO_PICK : 0)
                },
                setHotspotHint: function () {
                    var e = ic.vec3.create(),
                        t = ic.vec3.fromValues(0, 0, 1),
                        i = ic.quat.create();
                    return function (n, r, a, o) {
                        if (this._hotspotHintMT.setNodeMask(n ? -1 : 0), r) {
                            ic.vec3.sub(e, a, r);
                            var s = ic.vec3.len(e);
                            ic.vec3.normalize(e, e), ic.quat.rotationTo(i, t, e);
                            var l = this._hotspotHintMT.getMatrix();
                            ic.mat4.fromQuat(l, i);
                            ic.mat4.scale(l, l, ic.vec3.set(e, .02 * o, .02 * o, s)), ic.mat4.setTranslation(l, r)
                        }
                    }
                }(),
                updateWorldNormal: function (e, t) {
                    this._interpolatorNormal.setTarget(t[0], t[1], t[2]), this._interpolatorNormal.update(e.getDeltaTime()), ic.vec3.normalize(t, this._interpolatorNormal.getCurrent())
                },
                updateNodeVR: function () {
                    var e = ic.vec3.fromValues(0, 0, 1),
                        t = ic.vec3.create();
                    return function (i, n, r, a, o, s, l) {
                        var u = this._teleportMT.getMatrix();
                        if (this.getNodeMask()) {
                            var c = Math.acos(ic.vec3.dot(e, l));
                            ic.vec3.cross(t, l, e), ic.mat4.fromRotation(u, -c, t);
                            var h = Math.min(Math.max(o, s), 50 * s);
                            ic.mat4.scale(u, u, ic.vec3.set(t, h, h, h)), ic.vec3.set(t, a[0], a[1], a[2] + .05 * o), ic.mat4.setTranslation(u, t), this.setNodeMask(Pe.Z.NO_PICK)
                        }
                        var d = r.getSimulationTime(),
                            g = d % .99,
                            f = (d + .2) % .99;
                        this._uScale2.setFloat(g), this._uScale3.setFloat(f), this._uAlpha1.setFloat(i), this._uAlpha2.setFloat(i * (1 - g * g)), this._uAlpha3.setFloat(i * (1 - f * f)), this._teleportMT.dirtyBound()
                    }
                }()
            }), "osgtestdemo2024", "Teleport");
            const ac = rc;
            var oc = g.Z.osg,
                sc = function () {
                    oc.MatrixTransform.call(this), this.setName("WebVR - Cursor"), this.setVisible(!0), this._geom = oc.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0), this._uAlpha = oc.Uniform.createFloat(1, "uAlpha"), this._uColor = oc.Uniform.createFloat3(oc.vec3.fromValues(.7, .7, .7), "uCursorColor"), this.addChild(this._geom), this.init()
                };
            oc.createPrototypeNode(sc, oc.objectInherit(oc.MatrixTransform.prototype, {
                init: function () {
                    var e = oc.StateAttribute.OVERRIDE_ON,
                        t = this.getOrCreateStateSet();
                    t.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec2 TexCoord0;\nattribute vec3 Vertex;\n\nvarying vec2 vLocalVertex;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  vLocalVertex = Vertex.xy;\n\n  vec3 posLocal = Vertex.xyz * 0.5;\n  posLocal += vec3(0.0, 0.0, 0.1);\n\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(posLocal, 1.0));\n}\n", 'varying vec2 vLocalVertex;\n\nuniform float uAlpha;\nuniform int uOutputLinear;\nuniform vec3 uCursorColor;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n  vec4 color = vec4(uCursorColor, 1.0) * uAlpha * smoothstep(0.0, 1.0, 1.0 - 2.0 * length(vLocalVertex));\n\n  gl_FragColor = linearTosRGB(color);\n}\n', "webVR-cursor", "VRCursor"), e), t.setRenderBinDetails(Oe.Z.VR_CURSOR, "RenderBin"), t.setAttributeAndModes(Le.Z.BLEND_SUBSTRACTIVE), t.addUniform(this._uColor), t.addUniform(this._uAlpha)
                },
                setVisible: function (e) {
                    this.setNodeMask(e ? Pe.Z.NO_PICK : 0)
                },
                setColor: function (e) {
                    oc.vec3.copy(this._uColor.getInternalArray(), e)
                },
                updateNodeVR: function () {
                    var e = oc.vec3.create(),
                        t = oc.quat.create();
                    return function (i, n, r, a) {
                        var o = this.getMatrix();
                        oc.mat4.invert(o, n.getViewMatrix()), oc.mat4.fromQuat(o, oc.mat4.getRotation(t, o)), oc.mat4.scale(o, o, oc.vec3.set(e, a, a, a)), oc.mat4.setTranslation(o, r), this._uAlpha.setFloat(i), this.dirtyBound()
                    }
                }()
            }), "osgtestdemo2024", "Cursor");
            const lc = sc;
            var uc, cc, hc = g.Z.osg,
                dc = function (e) {
                    hc.MatrixTransform.call(this), this._model = e, this._postMultRotate = e._viewer.getViewerOSGJS().getManipulator().getFirstPersonManipulator().getPostMultRotate(), this.setName("WebVR - Floor"), this.setNodeMask(-1), this._cam = new hc.Camera, this._cam.setNearFarRatio(5e-5), this._geom = hc.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0), this._uScaleToMeter = hc.Uniform.createFloat(1, "uScaleToMeter"), this._cam.addChild(this._geom), this.addChild(this._cam), this.init()
                };
            hc.createPrototypeNode(dc, hc.objectInherit(hc.MatrixTransform.prototype, {
                init: function () {
                    var e = this.getOrCreateStateSet(),
                        t = (this._model.get("displayFloor") ? "#define DISPLAY_FLOOR\n" : "") + '#pragma include "utils/functions.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\nvarying vec2 vTexCoord0;\n\nuniform sampler2D uTextureFloor;\nuniform float uScaleToMeter;\nuniform int uOutputLinear;\n\nvarying vec4 vViewPos;\nuniform vec2 uNearFar;\nuniform sampler2D uTextureDepth;\nuniform vec2 uGlobalTexSize;\nuniform vec2 uGlobalTexRatio;\n\nvoid main(void) {\n\n#ifndef DISPLAY_FLOOR\n  discard;\n#else\n\n  float distDepth = distanceToDepth(uTextureDepth, uGlobalTexRatio * gl_FragCoord.xy / uGlobalTexSize, vViewPos, uNearFar);\n  if (distDepth >= 0.0) discard;\n\n  float x = length(vTexCoord0 * 2.0 - 1.0);\n  x *= x;\n  float fade = smoothstep(0.0, 1.0, 1.0 - x * x);\n\n  float value = sRGBToLinear(texture2D(uTextureFloor, (vTexCoord0 * 1.0 - 0.5) * uScaleToMeter).r);\n  vec4 color = vec4(vec3(value), fade * max(0.8, value));\n  color.rgb *= color.a;\n\n  gl_FragColor = uOutputLinear == 0 ? linearTosRGB(color) : color;\n#endif\n}\n';
                    e.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec2 TexCoord0;\nattribute vec3 Vertex;\n\nvarying vec2 vTexCoord0;\nvarying vec4 vViewPos;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  vTexCoord0 = TexCoord0;\n  vViewPos = uModelViewMatrix * vec4(Vertex.xyz, 1.0);\n  gl_Position = (uProjectionMatrix * vViewPos).xyww;\n}\n", t, "webVR-floor", "VRFloor")), e.addUniform(hc.Uniform.createInt(0, "uTextureFloor")), e.setTextureAttributeAndModes(0, hr.Z.dummyTexture), e.addUniform(this._uScaleToMeter), e.addUniform(hc.Uniform.createInt(1, "uTextureDepth")), e.setTextureAttributeAndModes(1, hr.Z.dummyTexture), e.setRenderBinDetails(Oe.Z.TRANSPARENT_NO_EARLYZ_PRE, "RenderBin"), e.setAttributeAndModes(Le.Z.DEPTH_DISABLE), e.setAttributeAndModes(Le.Z.CULL_BACK), (0, o.Z)() && this.initTextureFloor()
                },
                initTextureFloor: function () {
                    rs(this.replaceTextureFloor.bind(this))
                },
                replaceTextureFloor: function (e) {
                    this.getOrCreateStateSet().setTextureAttributeAndModes(0, s.Z.instance.getOrCreateTexture(e.FLOOR, {
                        internalFormat: hc.Texture.RGBA
                    }).texture)
                },
                setVisible: function (e) {
                    if (this.setNodeMask(e ? -1 : 0), e && !this._depthInitialized) {
                        var t = this._model._viewer.getFeaturesManager().getTextureDepth();
                        t && (this.getOrCreateStateSet().setTextureAttributeAndModes(1, t), this._depthInitialized = !0)
                    }
                },
                updateNodeVR: (uc = hc.vec3.create(), cc = hc.vec3.create(), function () {
                    var e = this.getMatrix(),
                        t = J.Z.getModelBoxWithDisplacement();
                    t.center(cc);
                    var i = t.radius(),
                        n = Math.max(15 * this._model.get("worldFactor"), 5 * i);
                    hc.mat4.fromQuat(e, this._postMultRotate), hc.mat4.scale(e, e, hc.vec3.set(uc, n, n, n)), e[12] = cc[0], e[13] = cc[1], this._uScaleToMeter.setFloat(n / this._model.get("worldFactor")), e[14] = this._model.get("floorHeight") - 1e-4 * i, this.dirtyBound()
                })
            }), "osgtestdemo2024", "Floor");
            const gc = dc,
                fc = "attribute vec3 Vertex;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vLocalVertex;\n\nvoid main(void) {\n  vLocalVertex = Vertex;\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex.xyz, 1.0));\n}\n",
                mc = 'varying vec3 vLocalVertex;\n\nuniform int uOutputLinear;\nuniform float uAlpha;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n  vec4 color = linearTosRGB(vec4(0.1, 0.66, 0.85, 1.0)) * (smoothstep(1.0, 0.0, vLocalVertex.y) * smoothstep(1.0, 0.0, abs(vLocalVertex.x * 4.0))) * uAlpha;\n\n  gl_FragColor = color;\n}\n';
            var pc, vc, _c, Sc, xc, Cc, Tc = g.Z.osg,
                Mc = g.Z.InputGroups,
                bc = Tc.vec3.create(),
                yc = {
                    TELEPORT: 0,
                    MENU: 1,
                    NAME: "DEFAULT"
                },
                Ac = {
                    SCALE_THRESHOLD: .3,
                    TELEPORT: 0,
                    MENU: 1,
                    SCALE_DIR_AXIS: 0,
                    NAME: "VIVE"
                },
                Rc = {
                    SCALE_THRESHOLD: .7,
                    TELEPORT: 0,
                    MENU: 1,
                    SCALE_DIR_AXIS: 2,
                    NAME: "Oculus touch"
                },
                wc = {
                    SCALE_THRESHOLD: .3,
                    TELEPORT: 0,
                    MENU: 2,
                    SCALE_DIR_AXIS: 0,
                    NAME: "Oculus go"
                },
                Ec = {
                    SCALE_THRESHOLD: .3,
                    TELEPORT: 0,
                    MENU: 2,
                    SCALE_DIR_AXIS: 0,
                    NAME: "Oculus remote"
                },
                Pc = {
                    SCALE_THRESHOLD: .3,
                    TELEPORT: 0,
                    MENU: 1,
                    SCALE_DIR_AXIS: 2,
                    NAME: "Windows mixed reality"
                },
                Nc = {
                    SCALE_THRESHOLD: .3,
                    TELEPORT: 0,
                    MENU: 1,
                    SCALE_DIR_AXIS: 0,
                    NAME: "Magic leap"
                },
                Oc = Tc.vec3.fromValues(.8481, .8481, .8481),
                Dc = Tc.vec3.fromValues(.00237, .30699, .57048),
                Ic = function (e, t) {
                    Tc.MatrixTransform.call(this), this.setName("VR - Controller"), this.setNodeMask(Pe.Z.NO_PICK), this._pointerMT = new Tc.MatrixTransform, this._pointerMTScale = new Tc.MatrixTransform, this._proxyControllerMT = new Tc.MatrixTransform, this._geomPointer = Tc.createTexturedQuadGeometry(-.5, 0, 0, 1, 0, 0, 0, 1, 0), this.addChild(this._proxyControllerMT), this.addChild(this._pointerMT), this._pointerMT.addChild(this._pointerMTScale), this._pointerMTScale.addChild(this._geomPointer);
                    var i = new Tc.createTexturedBoxGeometry(0, -.1, 0, .1, .2, .1);
                    this._proxyControllerMT.addChild(i), this._uNormalSign = Tc.Uniform.createFloat(1, "uNormalSign"), this._activeController = void 0, this._model = e, this._viewerOSGJS = e._viewer.getViewerOSGJS(), this._postMultRotate = e._viewer.getViewerOSGJS().getManipulator().getFirstPersonManipulator().getPostMultRotate(), this._uPointerAlpha = Tc.Uniform.createFloat1(1, "uAlpha"), this._hitScaleOffset = 20, this._inputManager = t, this._controllerMeshDisplay = void 0, this._pressedButtons = [], this._gamepadType = void 0, this._pointerClicked = !1, this._timeSinceLastPointerClick = 0, this._menuPressed = !1, this._clickPressed = !1, this._teleportPressed = !1, this._menuPressedFrame = !1, this._clickPressedFrame = !1, this._teleportPressedFrame = !1, this._scaleValueChange = 0, this._cbClick = this.onClick.bind(this), this._canvasX = 0, this._canvasY = 0, this._preferLeftHand = !1, this.init()
                };
            Tc.createPrototypeNode(Ic, Tc.objectInherit(Tc.MatrixTransform.prototype, {
                init: function () {
                    var e = this._proxyControllerMT.getOrCreateStateSet();
                    e.addUniform(Tc.Uniform.createFloat3(Oc, "uAlbedo")), e.addUniform(this._uNormalSign), e.addUniform(Tc.Uniform.createFloat(.4, "uRoughness")), e.addUniform(Tc.Uniform.createFloat(0, "uMetalness")), e.setShaderGeneratorName("controller"), Fr.createMaterialModel(e).trigger("apply");
                    var t = this._geomPointer.getOrCreateStateSet();
                    t.addUniform(this._uPointerAlpha), t.setRenderBinDetails(Oe.Z.VR_CURSOR, "RenderBin"), t.setAttributeAndModes(Le.Z.BLEND_SUBSTRACTIVE), t.setAttributeAndModes(Ne.Z.getOrCreateShader(fc, mc, "webVR-laser", "VRLaser")), Ve.Z.initWebVRNavigation(this), this._ctrlLeft = .32, this._ctrlFwrd = .55
                },
                setEventListeners: function () {
                    this._model.get("hasNativeHMD") ? window.addEventListener("click", this._cbClick) : this._inputManager.setEnable(Mc.WEBVR_NAVIGATION, !0)
                },
                removeEventListeners: function () {
                    this._model.get("hasNativeHMD") ? window.addEventListener("click", this._cbClick) : this._inputManager.setEnable(Mc.WEBVR_NAVIGATION, !1)
                },
                onClick: function () {
                    this._teleportPressed = !0, this._clickPressed = !0
                },
                setListenToEvents: function (e) {
                    e ? this.setEventListeners() : this.removeEventListeners()
                },
                isPosedController: function () {
                    var e = this._activeController;
                    return !(!e || !e.targetRayMode || "tracked-pointer" !== e.targetRayMode)
                },
                _createGeometryFromJSON: function (e) {
                    var t = new Tc.Geometry,
                        i = t.getAttributes();
                    i.Vertex = new Tc.BufferArray(Tc.BufferArray.ARRAY_BUFFER, e.VERTEX, 3), i.Normal = new Tc.BufferArray(Tc.BufferArray.ARRAY_BUFFER, e.NORMAL, 3), e.COLOR && (i.Color = new Tc.BufferArray(Tc.BufferArray.ARRAY_BUFFER, e.COLOR, 1));
                    var n = t.getPrimitives(),
                        r = new Tc.BufferArray(Tc.BufferArray.ELEMENT_ARRAY_BUFFER, e.TRIANGLES, 1);
                    n.push(new Tc.DrawElements(Tc.primitiveSet.TRIANGLES, r));
                    var a = new Tc.BufferArray(Tc.BufferArray.ELEMENT_ARRAY_BUFFER, e.STRIP, 1);
                    return n.push(new Tc.DrawElements(Tc.primitiveSet.TRIANGLE_STRIP, a)), t
                },
                replaceControllerMesh: function (e) {
                    this._proxyControllerMT.removeChildren();
                    var t = this._createGeometryFromJSON(e.BODY),
                        i = this._createGeometryFromJSON(e.BUTTON);
                    this._proxyControllerMT.addChild(t), this._proxyControllerMT.addChild(i), i.getOrCreateStateSet().addUniform(Tc.Uniform.createFloat3(Dc, "uAlbedo")), this._updateCorrectionMatrix()
                },
                _checkControllerHand: function (e) {
                    this._activeController && "left" === this._activeController.handedness ? (Tc.mat4.scale(e, e, Tc.vec3.set(bc, -1, 1, 1)), this._uNormalSign.setFloat(-1)) : this._uNormalSign.setFloat(1)
                },
                _updateCorrectionMatrix: function () {
                    var e = this._proxyControllerMT.getMatrix();
                    if (this._gamepadType === Rc) Tc.mat4.fromTranslation(e, Tc.vec3.set(bc, 0, .03262643, .031930979)), Tc.mat4.rotateX(e, e, .22 * Math.PI), this._checkControllerHand(e);
                    else if (this._gamepadType === Pc) {
                        var t = (0, l.Z)().forceControllerOrientation;
                        Tc.mat4.fromXRotation(e, Math.PI * t), t = (0, l.Z)().forceControllerRayOrientation, Tc.mat4.rotateX(this._pointerMT.getMatrix(), this._pointerMT.getMatrix(), Math.PI * t), this._checkControllerHand(e)
                    } else this._gamepadType === Nc ? (Tc.mat4.identity(e), Tc.mat4.scale(e, e, [.01, .01, .01]), this._checkControllerHand(e)) : Tc.mat4.identity(e)
                },
                onPointerDown: function () {
                    jr.default.any && !this._activeController && (this._pointerClicked = !0)
                },
                onPointerUp: function (e) {
                    this._pointerClicked = !1, jr.default.any || Math.abs(e.canvasX - this._canvasX) < 5 && Math.abs(e.canvasY - this._canvasY) < 5 && (this._clickPressed = !0, this._teleportPressed = !0)
                },
                displayMenu: function () {
                    this._menuPressed = !0
                },
                onMouseDown: function (e) {
                    jr.default.any && !this._activeController && this._model.get("hasNativeHMD") && (this._teleportPressed = !0), jr.default.any || (this._canvasX = e.canvasX, this._canvasY = e.canvasY)
                },
                updateButtonsPressed: function () {
                    if (this._activeController)
                        for (var e = this._pressedButtons.length, t = 0; t < e; ++t) {
                            var i = this._activeController.gamepad.buttons[t].pressed;
                            i !== this._pressedButtons[t] && (this._pressedButtons[t] = i, i ? this.onButtonDown(t) : this.onButtonUp(t))
                        }
                },
                updateHoverAxes: function () {
                    this._activeController && (this._scaleValueChange = 0, this.updateScaleChangeFromXAxis(this._gamepadType))
                },
                updateScaleChangeFromXAxis: function (e) {
                    if (this._activeController.gamepad) {
                        var t = this._activeController.gamepad.axes[e.SCALE_DIR_AXIS];
                        t > e.SCALE_THRESHOLD ? this._scaleValueChange = 1 : t < -e.SCALE_THRESHOLD && (this._scaleValueChange = -1)
                    }
                },
                updatePointerClick: function (e) {
                    if (this._pointerClicked) {
                        if (this._timeSinceLastPointerClick > 1.2) return this._menuPressed = !0, this._pointerClicked = !1, void (this._timeSinceLastPointerClick = 0);
                        this._timeSinceLastPointerClick += e
                    } else this._timeSinceLastPointerClick > 0 && this._timeSinceLastPointerClick < 1.2 && (jr.default.any && (this._clickPressed = !0, this._teleportPressed = !0), this._timeSinceLastPointerClick = 0)
                },
                onButtonUp: function (e) {
                    switch (e) {
                        case this._gamepadType.TELEPORT:
                            this._clickPressed = !0, this._teleportPressed = !0;
                            break;
                        case this._gamepadType.MENU:
                            this._menuPressed = !0
                    }
                },
                onButtonDown: function (e) { },
                getAndSetActiveController: function (e) {
                    if (e.length) {
                        var t = this._activeController;
                        if (this._activeController = this._getControllerWithPressedButtons(e), this._activeController || (this._isLastActiveControllerStillWorking(e, t) ? this._activeController = t : this._activeController = this._getControllerWithOrientationAndPreferredHand(e)), !this._activeController) return this._pressedButtons.length = 0, void (this._gamepadType = void 0);
                        var i = this._activeController.profiles.length && this._activeController.profiles[0];
                        if (i !== this._lastProfile) {
                            this._lastProfile = i;
                            for (var n = this._pressedButtons.length = this._activeController.gamepad && this._activeController.gamepad.buttons.length, r = 0; r < n; ++r) this._pressedButtons[r] = !1;
                            this._gamepadType = this._getGamepadType(this._activeController), console.log("Found a controller:", this._gamepadType.NAME), this._updateCorrectionMatrix()
                        }
                    }
                },
                _isLastActiveControllerStillWorking: function (e, t) {
                    if (!t) return !1;
                    for (var i = 0; i < e.profiles; i++)
                        if (e[i].profiles.length == t.profiles.length && e[i].profiles[0] == t.profiles[0]) return !0;
                    return !1
                },
                _getControllerWithPressedButtons: function (e) {
                    for (var t = 0, i = e.length; t < i; ++t) {
                        var n = e[t];
                        if (n.gamepad)
                            for (var r = n.gamepad.buttons.length, a = 0; a < r; ++a)
                                if (n.gamepad.buttons[a].pressed) return n
                    }
                },
                setPreferLeftHand: function (e) {
                    this._preferLeftHand !== e && (this._preferLeftHand = e, this.getAndSetActiveController(), this._updateCorrectionMatrix())
                },
                _getControllerWithOrientationAndPreferredHand: function (e) {
                    for (var t, i = this._preferLeftHand ? "left" : "right", n = 0, r = e.length; n < r; ++n) {
                        var a = e[n];
                        if (a) {
                            var o = "tracked-pointer" === a.targetRayMode;
                            if (o && a.handedness === i) return a;
                            !o && t || (t = a)
                        }
                    }
                    return t
                },
                _getGamepadType: function (e) {
                    for (var t = 0; t < e.profiles.length; t++) {
                        var i = e.profiles[t];
                        if (-1 !== i.indexOf("oculus")) {
                            if (-1 !== i.indexOf("touch") || -1 !== i.indexOf("rift")) return Rc;
                            if (-1 !== i.indexOf("go")) return wc
                        }
                        if (-1 !== i.indexOf("windows-mixed-reality")) return Pc;
                        if (-1 !== i.indexOf("vive")) return Ac;
                        if (-1 !== i.indexOf("magicleap-one")) return Nc;
                        if (i.indexOf("generic-trigger-squeeze-touchpad")) return Ac;
                        if (i.indexOf("generic-trigger-squeeze-thumbstick")) return Rc;
                        if (i.indexOf("generic-trigger-squeeze-touchpad-thumbstick")) return Rc;
                        if (i.indexOf("generic-trigger-touchpad-thumbstick")) return Rc;
                        if (i.indexOf("generic-trigger-squeeze")) return Rc;
                        if (i.indexOf("generic-trigger-thumbstick")) return Rc;
                        if (i.indexOf("generic-trigger-touchpad")) return wc;
                        if (i.indexOf("generic-trigger")) return wc;
                        if (i.indexOf("generic-touchpad")) return wc;
                        if (i.indexOf("generic-button")) return Ec
                    }
                    return yc
                },
                applyPoseMatrix: (Sc = Tc.quat.create(), xc = Tc.vec3.create(), Cc = Tc.mat4.create(), function (e, t) {
                    var i = this._viewerOSGJS.getXRPose(this._activeController.targetRaySpace);
                    if (i) {
                        var n = i.transform,
                            r = n.orientation;
                        r && (r = Tc.quat.set(Sc, r.x, -r.z, r.y, r.w), Tc.quat.multiply(r, this._postMultRotate, r), Tc.mat4.multiply(e, e, Tc.mat4.fromQuat(Cc, r)));
                        var a = this._model.get("worldFactor"),
                            o = n.position;
                        o && (o = Tc.vec3.set(xc, o.x * a, -o.z * a, o.y * a), Tc.vec3.transformQuat(o, o, this._postMultRotate), Tc.vec3.add(o, o, t), Tc.mat4.setTranslation(e, o))
                    }
                }),
                updatePointerScaleFromHit: function (e) {
                    var t = Tc.mat4.getTranslation(Tc.vec3.create(), this.getMatrix()),
                        i = Tc.vec3.dist(t, e);
                    this._hitScaleOffset = i / this._model.get("worldFactor")
                },
                resetPointerScale: function () {
                    this._hitScaleOffset = 20
                },
                isMenuPressed: function () {
                    return this._menuPressedFrame
                },
                isTeleportPressed: function () {
                    return this._teleportPressedFrame
                },
                isClickPressed: function () {
                    return this._clickPressedFrame
                },
                checkScaleChangeValue: function () {
                    return this._scaleValueChange
                },
                checkDownloadController: function () {
                    var e = (0, l.Z)().forceController,
                        t = this._gamepadType;
                    if (e) {
                        switch (e) {
                            case "oculus":
                                t = Rc;
                                break;
                            case "go":
                                t = wc;
                                break;
                            case "windows":
                                t = Pc;
                                break;
                            case "magicleap":
                                t = Nc;
                                break;
                            default:
                                t = Ac
                        }
                        this._gamepadType = t
                    } else if (!this.isPosedController()) return;
                    t === Rc ? this._controllerMeshDisplay !== Rc && (this._controllerMeshDisplay = Rc, os(this.replaceControllerMesh.bind(this))) : t === wc ? this._controllerMeshDisplay !== wc && (this._controllerMeshDisplay = wc, ss(this.replaceControllerMesh.bind(this))) : t === Pc ? this._controllerMeshDisplay !== Pc && (this._controllerMeshDisplay = Pc, ls(this.replaceControllerMesh.bind(this))) : t === Nc ? this._controllerMeshDisplay !== Nc && (this._controllerMeshDisplay = Nc, us(this.replaceControllerMesh.bind(this))) : this._controllerMeshDisplay !== Ac && (this._controllerMeshDisplay = Ac, as(this.replaceControllerMesh.bind(this)))
                },
                updateNodeVR: (_c = Tc.vec3.create(), function (e, t, i) {
                    var n = this._model.get("worldFactor");
                    e && (this.getAndSetActiveController(e), this.checkDownloadController()), this.updatePointerClick(t), this.updateButtonsPressed(), this.updateHoverAxes();
                    var r = this.getMatrix();
                    Tc.mat4.fromScaling(this._pointerMTScale.getMatrix(), Tc.vec3.set(_c, .05, this._hitScaleOffset, 1)), Tc.mat4.fromScaling(r, Tc.vec3.set(_c, n, n, n)), (0, l.Z)().forceController ? (this.setNodeMask(Pe.Z.NO_PICK), Tc.mat4.copy(r, this._model.get("humanMatrix")), r[14] += 2 * n) : this.isPosedController() ? (this.setNodeMask(Pe.Z.NO_PICK), this.applyPoseMatrix(r, i)) : this.setNodeMask(0), this._menuPressedFrame = this._menuPressed, this._clickPressedFrame = this._clickPressed, this._teleportPressedFrame = this._teleportPressed, this._clickPressed = !1, this._menuPressed = !1, this._teleportPressed = !1, this.dirtyBound()
                }),
                raycastFromController: (pc = Tc.vec3.fromValues(0, 20, 0), vc = Tc.mat4.create(), function (e, t, i, n, r) {
                    var a = this.getMatrix();
                    if (this._gamepadType === Pc) {
                        var o = 2 * (0, l.Z)().forceControllerRayOrientation;
                        a = vc, Tc.mat4.rotateX(a, this.getMatrix(), Math.PI * o)
                    }
                    Tc.mat4.getTranslation(n, a), Tc.vec3.set(r, 0, i / this._model.get("worldFactor"), 0), Tc.vec3.transformMat4(r, r, a);
                    var s = Fe.Z.computeNearestIntersection3DHotspotFirst(n, r, Pe.Z.PICK_GEOMETRY_FAST, e);
                    return s || Tc.vec3.transformMat4(r, pc, a), s
                })
            }), "osgtestdemo2024", "Controller");
            const Fc = Ic;
            var Lc = g.Z.osg,
                Vc = function (e, t, i, n, r) {
                    this._startPosOffset = e, this._startPos = Lc.vec3.create(), this._targetPos = Lc.vec3.create(), this._duration = t, this._easingFunc = i, this._result = Lc.vec3.create(), this._hasStarted = !1, this._reverse = !1, this._finished = !0, this._node = n, this._model = r
                };
            Vc.prototype = {
                isFinished: function () {
                    return this._finished
                },
                _reverseAnim: function () {
                    this._reverse = !this._reverse
                },
                start: function () {
                    var e = Lc.vec3.create();
                    return function (t) {
                        this._started = .05 * -t, this._hasStarted = !1, this._finished = !1, Lc.vec3.scale(e, this._startPosOffset, this._model.get("worldFactor")), this._reverse ? (Lc.mat4.getTranslation(this._startPos, this._node.getMatrix()), Lc.vec3.add(this._targetPos, this._startPos, e), this._node.setOpacity(1)) : (Lc.mat4.getTranslation(this._targetPos, this._node.getMatrix()), Lc.vec3.add(this._startPos, this._targetPos, e), this._node.setOpacity(0)), Lc.mat4.setTranslation(this._node.getMatrix(), this._startPos)
                    }
                }(),
                update: function (e, t) {
                    if (!this._finished) {
                        var i = t.getFrameStamp().getSimulationTime();
                        if (this._started < 0) return this._started += t.getFrameStamp().getDeltaTime(), !0;
                        this._hasStarted || (this._started = i, this._hasStarted = !0);
                        var n = (i - this._started) / this._duration;
                        return n > 1 && (this._finished = !0, n = 1), this._easingFunc && (n = this._easingFunc(n)), this.interpolate(n, e), this._finished && (this._reverseAnim(), this._onFinishCallback && this._onFinishCallback(), this._node.dirtyBound()), !0
                    }
                },
                interpolate: function (e, t) {
                    Lc.vec3.lerp(this._result, this._startPos, this._targetPos, e), Lc.mat4.setTranslation(t.getMatrix(), this._result), this._reverse ? this._node.setOpacity(1 - e) : this._node.setOpacity(e)
                },
                setOnFinishCallback: function (e) {
                    this._onFinishCallback = e
                }
            };
            const Bc = Vc;
            i("G/Kp");
            var Uc = g.Z.osgAnimation,
                kc = g.Z.osg,
                Zc = Uc.easeOutCubic,
                Hc = function (e) {
                    kc.Node.call(this), this._menuPanel = new Fs(.9, 2.5, Ms.AXIS_BOTH, .2, 10, 10), this._menuPanel.setUseCache(!0), this._menuPanel.setClickAction("vrHelpButton", this.displayHelp.bind(this)), this._menuPanel.setClickAction("vrExitButton", this.hide.bind(this)), this._menuPanel.setVisible(!1);
                    var t = new Bc(kc.vec3.fromValues(0, 0, -.05), .15, Zc, this._menuPanel, e);
                    this._menuPanel.setAnimation(t), this.addChild(this._menuPanel), this._helpPanel = new Ms(2, 2, Ms.AXIS_BOTH, .2, 10, 10), this._helpPanel.setPanelClickAction(this.hideHelp.bind(this)), this._helpPanel.setVisible(!1);
                    var i = new Bc(kc.vec3.fromValues(0, 0, 0), .3, Zc, this._helpPanel, e);
                    this._helpPanel.setAnimation(i), this.addChild(this._helpPanel), this._model = e
                };
            kc.createPrototypeNode(Hc, kc.objectInherit(kc.Node.prototype, {
                initialize: function (e) {
                    var t = e.hotspot._views[0]._hotspots;
                    this._menuPanel.initialize("front/macros/vr/vr-menu", {
                        hasHotspotsNavigation: t.length && t.length > 1
                    }), rs(function (e) {
                        var t = s.Z.instance.getOrCreateTexture(e.MENU_HELP, {
                            internalFormat: kc.Texture.RGBA
                        }).texture;
                        this._helpPanel.initialize(t, {
                            width: 1e3,
                            height: 500
                        })
                    }.bind(this))
                },
                display: function (e, t) {
                    this._menuPanel.displayInView(e, t, this._model.get("worldFactor"))
                },
                hide: function () {
                    this._menuPanel.setVisible(!1), this._helpPanel.isVisible() && this._helpPanel.setVisible(!1)
                },
                setHomeAction: function (e) {
                    this._menuPanel.setClickAction("vrHomeButton", e)
                },
                setNextAction: function (e) {
                    this._menuPanel.setClickAction("vrNextButton", e)
                },
                setPrevAction: function (e) {
                    this._menuPanel.setClickAction("vrPrevButton", e)
                },
                displayHelp: function () {
                    kc.mat4.copy(this._helpPanel.getMatrix(), kc.mat4.create()), kc.mat4.setTranslation(this._helpPanel.getMatrix(), kc.vec3.fromValues(0, 0, .2)), kc.mat4.multiply(this._helpPanel.getMatrix(), this._menuPanel.getMatrix(), this._helpPanel.getMatrix()), this._helpPanel.setVisible(!0)
                },
                hideHelp: function () {
                    this._helpPanel.isVisible() && this._helpPanel.setVisible(!1)
                },
                isVisible: function () {
                    return this._menuPanel.isVisible()
                },
                isHelpVisible: function () {
                    return this._helpPanel.isVisible()
                },
                updateHit: function (e) {
                    return this._helpPanel.isVisible() ? this._helpPanel.updateHit(e) : this._menuPanel.isVisible() ? this._menuPanel.updateHit(e) : void 0
                },
                click: function () {
                    this._helpPanel.isVisible() ? this._helpPanel.click() : this._menuPanel.isVisible() && this._menuPanel.click()
                }
            }), "osgtestdemo2024", "Menu");
            const Gc = Hc;
            var zc, Wc, jc, Xc, Yc, Jc, qc, Kc, Qc, $c = i("JueD"),
                eh = g.Z.osg,
                th = g.Z.osgUtil,
                ih = g.Z.InputGroups,
                nh = (new (ys())({
                    device: "VWR",
                    listen: !0
                }), V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.model;
                        e.bind("change:enable", this.onEnable, this), e.bind("change:worldFactor", this.onWorldFactor, this), e.bind("change:floorHeight", this.onFloorHeight, this), e.bind("doubleTap", this.onDoubleTap, this), e.bind("snapHumanOnFloor", this.snapHumanOnFloor, this), this._viewer = this.options.context.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._manipulator = this._viewerOSGJS.getManipulator(), this._cullConfig = Ao.Z.vrConfig, this._lastSelectedHotspot = void 0, this._lastHoveredHotspot = void 0, this._lastFloorHeight = 0, this._lastTime = 0, this._lastWorldFactor = -1, this._lastMouse = eh.vec2.create(), this._interpolatorAlpha = new th.DelayInterpolator(1), this._interpolatorAlpha.setDelay(.1), this._webvrMaxHeight = this.getWebVRMaxHeight(), this._nodeWebVR = new eh.Node, this._nodeWebVR.setName("Feature - WebVR"), this._proxyVR = new eh.Node, this._proxyVR.setName("WebVR - Proxy"), this._proxyVR.setNodeMask(0), this._floorMT = new gc(e), this._humanMT = new tc(e), this._teleportNode = new ac, this._cursorMT = new lc, this._controllerMT = new Fc(e, this._viewer.getInputManager()), this._nodeMenu = new Gc(e), this._nodeMenu.setHomeAction(this._onVrSessionEnd.bind(this)), this._nodeMenu.setNextAction(this.goToNextHotspot.bind(this)), this._nodeMenu.setPrevAction(this.goToPrevHotspot.bind(this)), this._dataDownloaded = !1, this._scaleControlEnabled = !0, this.onFloorHeight(), this.initGraphNodes(), this.hookComputeCanvasSize(), Ve.Z.initWebVR(this), this._onVrSessionEndBinded = this._onVrSessionEnd.bind(this), this._viewerOSGJS.getInputManager().getInputSource("WebVR").pollHeadset().catch((function () { })), L.Z.getModelDisplayed().then(this.initWebVR.bind(this))
                    },
                    getNodeWebVR: function () {
                        return this._nodeWebVR
                    },
                    getProxyWebVR: function () {
                        return this._proxyVR
                    },
                    getWebVRMaxHeight: function () {
                        return -1 === (0, l.Z)().maxDevicePixelRatio ? -1 : jr.default.any ? Math.min(window.screen.width, window.screen.height) * (0, $c.Z)() : -1
                    },
                    _onVrDisplayPointerRestricted: function () {
                        this._viewer.getCanvas().requestPointerLock()
                    },
                    _onVrDisplayPointerUnrestricted: function () {
                        document.exitPointerLock()
                    },
                    initWebVR: function () {
                        this._nodeWebVR.addUpdateCallback(this)
                    },
                    setProxyVisible: function (e) {
                        this._proxyVR.setNodeMask(e ? Pe.Z.NO_SHADOW : 0)
                    },
                    onDoubleTap: function (e) {
                        if (!this.model.get("enable") && -1 === e._nodePath.indexOf(this._humanMT)) {
                            var t = eh.vec3.create();
                            Fe.Z.getWorldPositionFromHit(e, t), eh.mat4.setTranslation(this._humanMT.getMatrix(), t), U.Z.draw()
                        }
                    },
                    scaleUp: function () {
                        var e = this.model.get("worldFactor");
                        e <= 0 || this.model.set("worldFactor", 1.2 * e)
                    },
                    scaleDown: function () {
                        var e = this.model.get("worldFactor");
                        e <= 0 || this.model.set("worldFactor", e * (1 / 1.2))
                    },
                    savePosition: function (e) {
                        this._lastMouse[0] = e.canvasX, this._lastMouse[1] = e.canvasX
                    },
                    onFloorHeight: function () {
                        var e = this.model.get("floorHeight"),
                            t = .05 * this.model.get("worldFactor");
                        Math.abs(this._humanMT.getMatrix()[14] - this._lastFloorHeight) <= t && (this._humanMT.getMatrix()[14] = e), this._floorMT.getMatrix()[14] = e, this._lastFloorHeight = e
                    },
                    initGraphNodes: function () {
                        this._nodeWebVR.addChild(this._proxyVR), this._proxyVR.addChild(this._floorMT), this._proxyVR.addChild(this._humanMT), this._proxyVR.addChild(this._teleportNode), this._proxyVR.addChild(this._cursorMT), this._proxyVR.addChild(this._controllerMT), this._proxyVR.addChild(this._nodeMenu);
                        var e = this._proxyVR.getOrCreateStateSet();
                        e.setRenderBinDetails(Oe.Z.TRANSPARENT_NO_EARLYZ_POST, "RenderBin"), e.setAttributeAndModes(Le.Z.DEPTH_LESS_NO_WRITE), e.setAttributeAndModes(Le.Z.CULL_DISABLE)
                    },
                    resetCameraToHuman: function () {
                        var e = eh.vec3.create(),
                            t = eh.vec3.create(),
                            i = eh.mat4.create(),
                            n = eh.vec3.create();
                        return function () {
                            var r = eh.mat4.copy(i, this._humanMT.getMatrix());
                            eh.mat4.getScale(e, r), eh.vec3.set(e, 1 / e[0], 1 / e[1], 1 / e[2]), eh.mat4.scale(r, r, e);
                            var a = this._manipulator.getFirstPersonManipulator(),
                                o = a.getPostMultRotate();
                            eh.quat.normalize(o, eh.mat4.getRotation(o, r)), a.setResetInitialRotationVR(!0), eh.mat4.getTranslation(t, r), t[2] += this.getEyeLevel(), eh.vec3.set(n, 0, 1, 0), eh.vec3.transformQuat(n, n, o), eh.vec3.add(n, t, n), this._viewer.getFeaturesManager().focusOnTargetAndEye(n, t)
                        }
                    }(),
                    requestData: function (e, t) {
                        e && !this._dataDownloaded && (this._dataDownloaded = !0, this._teleportNode.initTextureTeleport(), this._floorMT.initTextureFloor(), this._nodeMenu.initialize(t))
                    },
                    startEnable: function (e) {
                        var t = this._viewer.getFeatures();
                        this.setProxyVisible(e), this.requestData(e, t), this.updateDistortion(), t.background.getModel().set("webVR", e && !(0, l.Z)().vrAr), t.camera.getModel().set("webVR", e), t.hotspot.getModel().set("webVR", e), t.shadingStyle.getModel().set("webVR", e), t.lighting.getModel().set("webVR", e), t.postProcess.getModel().set("webVR", e), (0, l.Z)().vrStereo ? (this._cullConfig.doVR = e, to.Z.uIsVr.setFloat(e)) : (this._cullConfig.doVR = !1, to.Z.uIsVr.setFloat(0)), this._controllerMT.setListenToEvents(e), e ? this._floorMT.updateNodeVR() : this._viewer.getFeaturesManager().focusOnSavedCamera(2);
                        var i = e && !(0, l.Z)().vrAr ? 1 : 0;
                        this._viewer.getCamera().getClearColor()[3] = i, this._resetOnNextFrame = !0, eh.log("Viewer StartEnable: enabled:" + e)
                    },
                    onEnable: function () {
                        var e = this.model.get("enable");
                        if ((0, l.Z)().cardboard || this.model.get("cardboard")) return this.model.set("hasNativeHMD", !1), this._viewer.getInputManager().setEnable(ih.WEBVR, e), this.startEnable(e), void (this._framePose = void 0);
                        e ? (this._viewer.getInputManager().setEnable(ih.WEBVR, e), this._viewerOSGJS.setPresentVR(!0).then(function (t) {
                            console.log("starting VR"), this.model.set("hasNativeHMD", !0), this._registerVRCallbacks(e, t), this.startEnable(e)
                        }.bind(this)).catch(function () {
                            this.model.set({
                                enable: !1
                            }, {
                                silent: !0
                            }), this.model.trigger("presentVrFailed")
                        }.bind(this))) : (console.log("Shutting down VR"), this._registerVRCallbacks(!1, this._viewerOSGJS.getVRSession()), this._viewerOSGJS.setPresentVR(!1), this._viewer.getInputManager().setEnable(ih.WEBVR, e), this.startEnable(e), this._nodeMenu.hide()), this._framePose = void 0
                    },
                    onPoseChange: function (e) {
                        this._framePose = e.pose
                    },
                    _registerVRCallbacks: function (e, t) {
                        e ? t.addEventListener("end", this._onVrSessionEndBinded) : t && (t.onend = void 0)
                    },
                    _onVrSessionEnd: function () {
                        this.model.get("enable") && this.model.set("enable", !1)
                    },
                    updateDistortion: function () {
                        var e = this._viewer.getFeatures().postProcess.getModel(),
                            t = !this.model.get("hasNativeHMD") && !(0, l.Z)().vrAr;
                        if (e.set("doDistortionVR", t), t) {
                            var i = this.model.get("deviceInfo"),
                                n = i.getProjectionMatrixLeftEye(),
                                r = i.getProjectionMatrixLeftEye(!0),
                                a = i.getUndistortedViewportLeftEye(),
                                o = i.device,
                                s = {
                                    xScale: a.width / (o.width / 2),
                                    yScale: a.height / o.height,
                                    xTrans: 2 * (a.x + a.width / 2) / (o.width / 2) - 1,
                                    yTrans: 2 * (a.y + a.height / 2) / o.height - 1
                                };
                            e.set("distortion", i.viewer.distortionCoefficients), e.set("projectionLeft", Cu.projectionMatrixToVector_(n)), e.set("unprojectionLeft", Cu.projectionMatrixToVector_(r, s))
                        }
                    },
                    snapHumanOnFloor: function () {
                        this._humanMT.getMatrix()[14] -= this._humanMT.computeDistanceToFloor()
                    },
                    getEyeLevel: function () {
                        var e = this.getPosVR()[2];
                        return this._framePose && e || (e = 0), this.model.get("worldFactor") * this.model.getDefaultHumanHeight() + e
                    },
                    snapOnClosestSurface: function () {
                        var e = this._manipulator.getEyePosition(eh.vec3.create()),
                            t = eh.vec3.copy(eh.vec3.create(), e);
                        t[2] -= 5 * this.model.get("worldFactor");
                        var i = this._viewer.getFeaturesManager(),
                            n = Fe.Z.computeNearestIntersection3D(e, t, Pe.Z.PICK_GEOMETRY_FAST, this._nodeWebVR);
                        if (n) {
                            var r = eh.vec3.create();
                            Fe.Z.getWorldPositionFromHit(n, r), r[2] += this.getEyeLevel(), i.focusOnTargetAndEye(void 0, r)
                        }
                    },
                    scaleMatrixTranslate: function (e, t) {
                        e[12] *= t, e[13] *= t, e[14] *= t
                    },
                    transformMatrixYuptoZup: (qc = eh.vec3.create(), Kc = eh.vec3.create(), Qc = 1e-7, function (e) {
                        var t = eh.mat4.getScale(qc, e),
                            i = Math.abs(t[0] - 1) > Qc || Math.abs(t[1] - 1) > Qc || Math.abs(t[2] - 1) > Qc;
                        i && (Kc[0] = 1 / t[0], Kc[1] = 1 / t[1], Kc[2] = 1 / t[2], eh.mat4.scale(e, e, Kc));
                        var n = e,
                            r = n[4],
                            a = n[5],
                            o = n[6],
                            s = n[7];
                        n[4] = -n[8], n[5] = n[9], n[6] = n[10], n[7] = n[11], n[8] = r, n[9] = a, n[10] = o, n[11] = s;
                        var l = n[1];
                        n[1] = -n[2], n[2] = l, l = n[5], n[5] = n[6], n[6] = -l, l = n[10], n[10] = n[9], n[9] = -l, l = n[13], n[13] = -n[14], n[14] = l, i && eh.mat4.scale(e, e, t)
                    }),
                    computeEyesOffsetViewMatrices: (Jc = eh.mat4.create(), function (e, t, i) {
                        var n = this._framePose;
                        eh.mat4.identity(Jc), n.transform.matrix && (Jc = n.transform.inverse.matrix), eh.mat4.multiply(e, Jc, e), eh.mat4.multiply(t, Jc, t), eh.mat4.invert(e, e), eh.mat4.invert(t, t), this.transformMatrixYuptoZup(e), this.transformMatrixYuptoZup(t), this.scaleMatrixTranslate(e, i), this.scaleMatrixTranslate(t, i)
                    }),
                    _getCorrectionPixel: function (e) {
                        return this._webvrMaxHeight > 0 ? Math.min(1, this._webvrMaxHeight / (e.renderHeight || 512)) : 1
                    },
                    onWorldFactor: function () {
                        var e = this.model.get("worldFactor");
                        if (this._lastWorldFactor > 0 && this._lastWorldFactor !== e && this.model.get("enable") && this.snapOnClosestSurface(), this._lastWorldFactor = e, this._framePose) {
                            var t = this._viewerOSGJS.getVRSession().renderState.baseLayer;
                            (l = this._cullConfig).framebufferWidth = t.framebufferWidth, l.framebufferHeight = t.framebufferHeight;
                            for (var i = 0; i < this._framePose.views.length; i++) {
                                var n = this._framePose.views[i],
                                    r = t.getViewport(n),
                                    a = r.height - r.y,
                                    o = Math.floor(r.width - r.x) || 512,
                                    s = Math.floor(a) || 512;
                                e = this.model.get("worldFactor");
                                "left" === n.eye && (l.leftRenderWidth = o, l.leftRenderHeight = s, eh.mat4.copy(l.leftProjection, n.projectionMatrix), eh.mat4.copy(l.leftOffsetView, n.transform.matrix)), "right" === n.eye && (l.rightRenderWidth = o, l.rightRenderHeight = s, eh.mat4.copy(l.rightProjection, n.projectionMatrix), eh.mat4.copy(l.rightOffsetView, n.transform.matrix))
                            }
                            this.computeEyesOffsetViewMatrices(l.leftOffsetView, l.rightOffsetView, e), this._viewer.getInputManager().setParam("worldFactor", e), U.Z.draw()
                        } else if (!this.model.get("hasNativeHMD")) {
                            var l, u = this.getConfigCardboard(),
                                c = u.getEyeParameters("left"),
                                h = u.getEyeParameters("right"),
                                d = this._getCorrectionPixel(c);
                            (l = this._cullConfig).leftRenderWidth = Math.floor(c.renderWidth * d) || 512, l.leftRenderHeight = Math.floor(c.renderHeight * d) || 512, l.rightRenderWidth = Math.floor(h.renderWidth * d) || 512, l.rightRenderHeight = Math.floor(h.renderHeight * d) || 512;
                            var g = u.getFrameData(this._frameData);
                            this._updateCullConfig(g, c, h), U.Z.draw(), l.framebufferWidth = 2 * l.leftRenderWidth, l.framebufferHeight = l.leftRenderHeight, this._viewer.getInputManager().setParam("worldFactor", e)
                        }
                    },
                    perspectiveMatrixFromVRFieldOfView: function (e, t, i, n) {
                        var r = n || eh.mat4.create(),
                            a = Math.PI / 180,
                            o = Math.tan(e.upDegrees * a) * t,
                            s = Math.tan(e.downDegrees * a) * t,
                            l = Math.tan(e.leftDegrees * a) * t,
                            u = Math.tan(e.rightDegrees * a) * t;
                        return eh.mat4.frustum(r, -l, u, -s, o, t, i), r
                    },
                    hookComputeCanvasSize: function () {
                        var e = this._viewerOSGJS,
                            t = e.computeCanvasSize,
                            i = this;
                        this._cullConfig;
                        e.computeCanvasSize = function (n) {
                            if (!(i.model.get("enable") && (i._framePose || !i.model.get("HasNativeHMD")))) return t.call(e, n);
                            i.onWorldFactor();
                            var r = Math.min(jr.default.any ? 4096 : 16384, Gu.Z.instance().getWebGLParameter("MAX_RENDERBUFFER_SIZE")),
                                a = (0, l.Z)().vrMaxRttSize;
                            a && (r = a);
                            var o = i._cullConfig.framebufferWidth,
                                s = i._cullConfig.framebufferHeight;
                            if (o > r) {
                                var u = r / o;
                                o = Math.floor(o * u)
                            }
                            if (s > r) {
                                var c = r / s;
                                s = Math.floor(s * c)
                            }
                            var h = !1;
                            return this._canvasWidth !== o && (n.width = o, this._canvasWidth = o, h = !0), this._canvasHeight !== s && (n.height = s, this._canvasHeight = s, h = !0), h
                        }
                    },
                    _updateCullConfig: function () {
                        var e = eh.vec3.create();
                        return function (t, i, n) {
                            var r = this.model.get("worldFactor"),
                                a = this._cullConfig;
                            t && this._frameData.leftViewMatrix || (eh.mat4.copy(a.leftProjection, this._frameData.leftProjectionMatrix), eh.mat4.copy(a.rightProjection, this._frameData.rightProjectionMatrix), eh.vec3.set(e, -r * i.offset[0], 0, 0), eh.mat4.fromTranslation(a.leftOffsetView, e), eh.vec3.set(e, -r * n.offset[0], 0, 0), eh.mat4.fromTranslation(a.rightOffsetView, e))
                        }
                    }(),
                    getConfigCardboard: function () {
                        if (this._cardboardHMD) return this._cardboardHMD;
                        var e = this.model.get("deviceInfo"),
                            t = .5 * e.viewer.interLensDistance,
                            i = e.getUndistortedViewportLeftEye();
                        this._frameData = {
                            leftProjectionMatrix: this.perspectiveMatrixFromVRFieldOfView(e.getFieldOfViewLeftEye(!1), .1, 1e3, eh.mat4.create()),
                            rightProjectionMatrix: this.perspectiveMatrixFromVRFieldOfView(e.getFieldOfViewRightEye(!1), .1, 1e3, eh.mat4.create())
                        };
                        var n = {
                            left: {
                                offset: eh.vec3.fromValues(-t, 0, 0),
                                renderWidth: i.width,
                                renderHeight: i.height
                            },
                            right: {
                                offset: eh.vec3.fromValues(t, 0, 0),
                                renderWidth: i.width,
                                renderHeight: i.height
                            }
                        };
                        return this._cardboardHMD = {
                            displayName: "fake-cardboard",
                            isPresenting: !1,
                            getFrameData: function (e) {
                                return e
                            },
                            getEyeParameters: function (e) {
                                return n[e]
                            },
                            capabilities: {
                                hasPosition: !1,
                                hasRotation: !1,
                                hasExternalDisplay: !1
                            }
                        }, this._cardboardHMD
                    },
                    getPosVR: (Yc = eh.vec3.create(), function () {
                        return this._manipulator.getCurrentManipulator()._vrPos || eh.vec3.set(Yc, 0, 0, 0)
                    }),
                    getTeleportPosFromHotspot: function () {
                        var e = eh.vec3.create(),
                            t = eh.vec3.create(),
                            i = eh.vec3.create(),
                            n = eh.vec3.create();
                        return function (r, a, o, s) {
                            var l = this.model.get("worldFactor");
                            Fe.Z.getWorldPositionFromScenePoint(eh.mat4.getTranslation(e, r.getHotspotMatrix()), t);
                            var u = 2.5 * l;
                            eh.vec3.sub(e, t, a);
                            var c = eh.vec3.length(e);
                            e[2] = 0, eh.vec3.normalize(e, e), eh.vec3.scale(e, e, u), eh.vec3.sub(i, t, e), i[2] = t[2] + l, c < u + .1 * u && eh.vec3.copy(i, a), eh.vec3.copy(n, i), n[2] -= 3.5 * l;
                            var h = Fe.Z.computeNearestIntersection3D(i, n, Pe.Z.PICK_GEOMETRY_FAST, this._nodeWebVR);
                            h ? (Fe.Z.getWorldPositionFromHit(h, o, s), h.backface && eh.vec3.negate(s, s)) : (eh.vec3.copy(o, i), o[2] -= this.getEyeLevel(), eh.vec3.set(s, 0, 0, 1)), this._teleportNode.setHotspotHint(r.canTeleport(), o, t, l), r.setWorldTeleportPosition(t, o, l)
                        }
                    }(),
                    updateHitHotspot: (Xc = function (e) {
                        return e instanceof Ws
                    }, function (e, t, i, n, r) {
                        var a = this._viewer.getFeatures().hotspot.getWidgetNode(),
                            o = e && -1 !== e._nodePath.indexOf(a);
                        if (this._lastHoveredHotspot && this._lastHoveredHotspot.setHovered(!1), !o) return this._lastHoveredHotspot && this._lastHoveredHotspot.updateCardHit(), this._lastHoveredHotspot = void 0, void this._teleportNode.setHotspotHint(!1);
                        var s = this._lastHoveredHotspot = (0, nr.Z)(e._nodePath, Xc);
                        return s.updateCardHit(e), s.setHovered(!0), s.isFullyVisibleCard() || (this.getTeleportPosFromHotspot(s, t, n, r), this._viewer.getFeatures().hotspot.getModel().set("currentHotspotIndex", s.getIndex())), s
                    }),
                    handleHitPicking: function (e, t, i, n, r, a, o) {
                        var s, l = this._viewer.getFeaturesManager(),
                            u = this.model.get("worldFactor"),
                            c = this._floorMT.getBoundingSphere(),
                            h = eh.vec3.dist(c.center(), t) + c.radius();
                        return e ? s = Fe.Z.computeNearestIntersection2D(this._lastMouse[0], this._lastMouse[1], Pe.Z.PICK_GEOMETRY_FAST) : this._controllerMT.isPosedController() ? (s = this._controllerMT.raycastFromController(this._nodeWebVR, l, h, a, o)) ? (Fe.Z.getWorldPositionFromHit(s, n, r), s._backface && eh.vec3.negate(r, r), this._controllerMT.updatePointerScaleFromHit(n), this._cursorMT.setColor(eh.vec3.fromValues(.1, .66, .85))) : (this._controllerMT.resetPointerScale(), eh.vec3.copy(n, o)) : (eh.vec3.copy(a, t), eh.vec3.copy(o, i), eh.vec3.scale(o, i, h), eh.vec3.add(o, a, o), (s = Fe.Z.computeNearestIntersection3DHotspotFirst(a, o, Pe.Z.PICK_GEOMETRY_FAST, this._nodeWebVR)) ? (Fe.Z.getWorldPositionFromHit(s, n, r), s._backface && eh.vec3.negate(r, r)) : (eh.vec3.scale(n, i, 3 * u), eh.vec3.add(n, t, n))), s
                    },
                    goToNextHotspot: function () {
                        this._viewer.getFeatures().postProcess.getModel().fadeForTeleportVR(this.doTeleportToHotspot.bind(this, 1))
                    },
                    doTeleportToHotspot: function (e) {
                        this._nodeMenu && this._nodeMenu.isVisible() && this._nodeMenu.hide();
                        var t = this.computeHotspotIndex(e); - 1 !== t && (this.moveToHotspotWithIndex(t), this.displayHotspotCardForIndex(t))
                    },
                    goToPrevHotspot: function () {
                        this._viewer.getFeatures().postProcess.getModel().fadeForTeleportVR(this.doTeleportToHotspot.bind(this, -1))
                    },
                    displayHotspotCardForIndex: function (e) {
                        var t = this._viewer.getFeatures().hotspot.getWidgetNode().children[e];
                        this.toggleHotspotCard(t)
                    },
                    computeHotspotIndex: function (e) {
                        var t = this._viewer.getFeatures().hotspot.getModel(),
                            i = t.get("hotspots");
                        if (0 === i.length) return -1;
                        if (1 !== e && -1 !== e) return console.log("computeHotspotIndex was called with an invalid direction argument. Valid values are 1 for foward -1 for backward."), 0;
                        var n = t.get("currentHotspotIndex"),
                            r = i.length;
                        return (n += e) < 0 && (n = -1), n = (n % r + r) % r, t.set("currentHotspotIndex", n), n
                    },
                    moveToHotspotWithIndex: (zc = eh.vec3.create(), Wc = eh.vec3.create(), jc = eh.vec3.create(), function (e) {
                        var t = this._viewer.getFeatures().hotspot.getWidgetNode().children[e],
                            i = this._viewer.getFeatures().hotspot.getModel().get("hotspots").at(e);
                        Fe.Z.getWorldPositionFromScenePoint(i.get("eye"), Wc), Fe.Z.getWorldPositionFromScenePoint(i.get("position"), zc), this.getTeleportPosFromHotspot(t, Wc, Wc, jc), Wc[2] += this.getEyeLevel(), this._manipulator.getFirstPersonManipulator().setInitialPoseVR(Wc, zc)
                    }),
                    doTeleport: function (e, t, i) {
                        var n = this._viewer.getFeaturesManager();
                        e[2] += this.getEyeLevel(), t[2] += this.getEyeLevel(), n.focusOnTargetAndEye(t, e), this.toggleHotspotCard(i)
                    },
                    toggleHotspotCard: function (e) {
                        e && (e.isFullyVisibleCard() ? e.onCardHit(this) : (this._lastSelectedHotspot && this._lastSelectedHotspot.setVisibleCard(!1), this._lastSelectedHotspot = e, e && e.setVisibleCard(!0)))
                    },
                    setPauseUpdate: function (e) {
                        this._pauseUpdate = e
                    },
                    update: function () {
                        var e = eh.vec3.create(),
                            t = eh.vec3.create(),
                            i = eh.vec3.create(),
                            n = eh.vec3.create(),
                            r = eh.vec3.create(),
                            a = eh.vec3.create(),
                            o = eh.vec3.create(),
                            s = eh.vec3.create(),
                            u = eh.vec3.create(),
                            c = eh.vec3.create();
                        return function (h, d) {
                            var g = this._viewer.getFeatures(),
                                f = this.model.get("enable"),
                                m = this._viewer.getOptions().widgetAPI,
                                p = !!m && "virtual reality and augmented reality" === m.getTabbedWidget().get() && !this._pauseUpdate,
                                v = f || p;
                            this.setProxyVisible(v);
                            var _ = g.background.getModel();
                            _.get("webVR") !== v && _.set("webVR", v);
                            var S = g.postProcess.getModel();
                            if (S.get("webVR") !== v && S.set("webVR", v), this._humanMT.setVisible(p), !f && !p) return !0;
                            var x = this.model.get("worldFactor"),
                                C = d.getFrameStamp(),
                                T = C.getSimulationTime(),
                                M = C.getDeltaTime();
                            this._resetOnNextFrame && this._framePose && (this._resetOnNextFrame = !1, this.resetCameraToHuman()), this._manipulator.getEyePosition(i), this._manipulator.getTarget(n), eh.vec3.sub(n, n, i), eh.vec3.normalize(n, n);
                            var b = this._viewer.getCamera(),
                                y = this._viewerOSGJS.getVRSession();
                            if (y) {
                                this._controllerMT.setNodeMask(Pe.Z.NO_SHADOW);
                                var A = y.inputSources;
                                this._controllerMT.updateNodeVR(A, M, eh.vec3.sub(s, i, this.getPosVR()))
                            } else this._controllerMT.updateNodeVR(null, M, eh.vec3.sub(s, i, this.getPosVR())), this._controllerMT.setNodeMask(0);
                            var R = this.handleHitPicking(!f && p, i, n, t, e, r, a);
                            eh.vec3.copy(o, t);
                            var w, E, P = f && this._controllerMT.isTeleportPressed(),
                                N = this._controllerMT.isClickPressed(),
                                O = this._nodeMenu && this._controllerMT.isMenuPressed(this._nodeMenu.isVisible()),
                                D = R && -1 === R._nodePath.indexOf(this._nodeMenu) && (P || N) && this._nodeMenu.isVisible(),
                                I = f && (O || D);
                            if (I && (this._manipulator.getTarget(s), this._nodeMenu.isVisible() ? this._nodeMenu.hide() : this._nodeMenu.display(i, s)), f) {
                                E = this._nodeMenu.updateHit(R), w = this.updateHitHotspot(R, r, a, o, e), this._teleportNode.updateWorldNormal(C, e);
                                var F = R && e[2] > .5,
                                    L = w ? w.canTeleport() : F,
                                    V = R && -1 !== R._nodePath.indexOf(this._floorMT),
                                    B = w ? w.canTeleport() : F && (!this.model.isDiorama() || V);
                                if (P && T - this._lastTime > .5) {
                                    if (L) eh.vec3.add(c, o, n), eh.vec3.copy(u, o), this._viewer.getFeatures().postProcess.getModel().fadeForTeleportVR(this.doTeleport.bind(this, u, c, w)), this._lastTime = T;
                                    L || this.toggleHotspotCard(w), E && E.click()
                                }
                                this._interpolatorAlpha.setTarget(B ? 1 : 0), this._interpolatorAlpha.update(C.getDeltaTime())
                            }
                            var k = this._viewer.getFeaturesManager().getIconScaleFov(this._cullConfig.leftProjection),
                                Z = eh.vec3.dist(t, i) / k,
                                H = I ? 0 : this._interpolatorAlpha.getCurrent()[0];
                            this._cursorMT.setVisible(f), this._teleportNode.setVisible(R && f && !O);
                            var G = !(0, l.Z)().vrAr && this.model.get("displayFloor");
                            this._floorMT.setVisible(G), this._floorMT.updateNodeVR(), this._humanMT.updateNodeVR(R, T), this._teleportNode.updateNodeVR(H, R, C, o, x, Z, e), this._cursorMT.updateNodeVR(w ? 1 : 1 - H, b, t, Z), this._nodeMenu && this._lastSelectedHotspot && this._nodeMenu.isVisible() && this._lastSelectedHotspot.isFullyVisibleCard() && this._lastSelectedHotspot.setVisibleCard(!1);
                            var z = this._controllerMT.checkScaleChangeValue();
                            return this._scaleControlEnabled && 0 !== z && (z = x * Math.abs(z) * (z > 0 ? 1.02 : 1 / 1.02), this.model.set("worldFactor", z, {
                                silent: !!this._framePose
                            })), U.Z.draw(), !0
                        }
                    }()
                }));
            var rh = {
                FeatureName: "webVR",
                ModelType: Hu,
                ViewListType: [nh]
            },
                ah = n.Z.create(rh);
            ah.prototype.getNode = function () {
                return this._views[0].getNodeWebVR()
            }, ah.prototype.getWidgetNode = function () {
                return this._views[0].getProxyWebVR()
            }, ah.prototype.prepareForScreenShot = function () {
                var e = n.Z.prototype.prepareForScreenShot.call(this);
                return e && this._views[0].setPauseUpdate(!0), e
            }, ah.prototype.resetAfterScreenShot = function () {
                n.Z.prototype.resetAfterScreenShot.call(this), this._views[0].setPauseUpdate(!1)
            };
            const oh = ah;
            var sh = i("Zj2R"),
                lh = i("vcih");
            const uh = a.Z.extend({
                getModelOptionPath: function () {
                    return "sound"
                },
                defaults: function () {
                    return {
                        currentSoundIndex: -1,
                        visible: (0, l.Z)().uiSound,
                        autoplay: !0,
                        playing: !1,
                        volume: void 0,
                        select: void 0,
                        enable: !0
                    }
                },
                getName: function () {
                    return "Sound"
                },
                init: function (e) {
                    this._viewer = e.getViewer(), this.set("volume", lh.Z.getVolume());
                    var t = e.getModel().get("options").sound;
                    this.set("soundtracks", s.Z.instance.getSoundCollection()), this.setJSON(t)
                },
                setJSON: function (e, t) {
                    var i = e && e.soundtracks;
                    if (i && i.length)
                        for (var n = this.get("soundtracks"), r = 0; r < i.length; ++r) {
                            var a = i[r],
                                o = n.findWhere({
                                    uid: a.uid
                                }),
                                s = !0;
                            o ? o.get("isInit") ? o = o.duplicate() : s = !1 : o = new sh.Z, o.setJSON(a, t), o.set("isInit", !0), s && n.add(o)
                        }
                },
                getJSON: function () {
                    var e = [];
                    return this.get("soundtracks").each((function (t) {
                        e.push(t.getJSON())
                    })), {
                        soundtracks: e
                    }
                }
            });
            var ch, hh, dh, gh, fh, mh, ph = i("OUQ+"),
                vh = g.Z.osg,
                _h = g.Z.osgUtil,
                Sh = g.Z.InputGroups,
                xh = Le.Z.BLEND_SUBSTRACTIVE,
                Ch = Le.Z.DEPTH_DISABLE,
                Th = vh.StateAttribute.ON,
                Mh = vh.vec4.fromValues(.109375, .6640625, .84765625, 1),
                bh = vh.vec4.fromValues(1, 1, 0, 1),
                yh = vh.vec4.fromValues(.8, .8, .8, 1),
                Ah = vh.vec4.fromValues(1, 1, 0, 1),
                Rh = .5,
                wh = function () {
                    return hh || (hh = vh.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0)), hh
                },
                Eh = {
                    init: function (e, t, i) {
                        this.model = e, this._context = t, this._viewer = this._context.getViewer(), this._nodeFeature = i, this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._manipulator = this._viewerOSGJS.getManipulator(), this._icons = [], this._nodeCamera = new vh.Camera, this._nodeCamera.setNearFarRatio(5e-4), this._nodeCamera.setName("Sound - Camera"), this._nodeCamera.getOrCreateStateSet().setRenderBinDetails(Oe.Z.EDITOR_GIZMO, "RenderBin"), this._nodeCamera.setNodeMask(0), this._nodeIcons = new vh.MatrixTransform, this._nodeFeature.addChild(this._nodeCamera), this._nodeCamera.addChild(this._nodeIcons), this._nodeGizmos = new vh.MatrixTransform, this._nodeGizmos.setNodeMask(0), this._nodeGizmos._forceEnterIntersection = !0, this._nodeCamera.addChild(this._nodeGizmos), this._prepareGeometriesGizmo(), this._gizmoRefDistance = this._makeGizmo(this._geomHandleDistance), this._nodeGizmos.addChild(this._gizmoRefDistance._nodeGizmo), this._gizmoFalloff = this._makeGizmo(this._geomHandleFalloff), this._nodeGizmos.addChild(this._gizmoFalloff._nodeGizmo), Ve.Z.initSound(this), this.initStateset()
                    },
                    _prepareGeometriesGizmo: function () {
                        this._geomHandleFalloff = new vh.createTexturedBoxGeometry(0, 0, 0, Rh, Rh, Rh), this._geomHandleDistance = new vh.createTexturedBoxGeometry(0, 0, 0, Rh, Rh, Rh), this._arc = _h.GizmoGeometry.createCircleGeometry(64, 1, 3.2 * Math.PI), this.setGizmoStateset(this._arc, Mh), this.setGizmoStateset(this._geomHandleDistance, Mh), this.setGizmoStateset(this._geomHandleFalloff, Mh)
                    },
                    _makeGizmo: function (e) {
                        var t = {};
                        return t._nodeGizmo = new vh.MatrixTransform, t._arcScale = new vh.MatrixTransform, this._arcScale = new vh.MatrixTransform, t._arcX = this._makeArc(t._arcScale, "arcX"), t._arcY = this._makeArc(t._arcScale, "arcY", .5 * -Math.PI, vh.vec3.fromValues(1, 0, 0)), t._arcZ = this._makeArc(t._arcScale, "arcZ", .5 * Math.PI, vh.vec3.fromValues(0, 1, 0)), t._handleX = this._makeHandle(t._nodeGizmo, "handleX", vh.vec3.fromValues(1, 0, 0), e), t._handleY = this._makeHandle(t._nodeGizmo, "handleY", vh.vec3.fromValues(0, 1, 0), e), t._handleZ = this._makeHandle(t._nodeGizmo, "handleZ", vh.vec3.fromValues(0, 0, 1), e), t._handleXNeg = this._makeHandle(t._nodeGizmo, "handleXNeg", vh.vec3.fromValues(-1, 0, 0), e), t._handleYNeg = this._makeHandle(t._nodeGizmo, "handleYNeg", vh.vec3.fromValues(0, -1, 0), e), t._handleZNeg = this._makeHandle(t._nodeGizmo, "handleZNeg", vh.vec3.fromValues(0, 0, -1), e), t._nodeGizmo.editMask = _h.NodeGizmo.PICK_ARROW | _h.NodeGizmo.PICK_PLANE, t._nodeGizmo.setCullingActive(!1), t._nodeGizmo.addChild(t._arcScale), t
                    },
                    _makeHandle: function (e, t, i, n) {
                        var r = new vh.MatrixTransform;
                        return r.setName(t), e.addChild(r), r.addChild(n), vh.mat4.fromTranslation(r.getMatrix(), i), r
                    },
                    _makeArc: function (e, t, i, n) {
                        var r = new vh.MatrixTransform;
                        return r.setName(t), e.addChild(r), r.addChild(this._arc), i && n && vh.mat4.fromRotation(r.getMatrix(), i, n), r
                    },
                    initStateset: function () {
                        this._nodeCamera.getOrCreateStateSet().setTextureAttributeAndModes(0, hr.Z.dummyTexture, Th), this._nodeCamera.getOrCreateStateSet().addUniform(vh.Uniform.createInt(0, "uTextureDepth"))
                    },
                    setGizmoStateset: function (e, t) {
                        var i = e.getOrCreateStateSet();
                        i.setAttributeAndModes(Ne.Z.getOrCreateShader(Ha, Ga, "line", "Handle3D", "LINE"), Th), i.setAttributeAndModes(xh, Th), i.setAttributeAndModes(Ch, Th), i.addUniform(vh.Uniform.createFloat4(t, "uColor"))
                    },
                    updateDragHandle: function (e, t) {
                        var i = e.getMatrix();
                        vh.mat4.fromTranslation(i, t);
                        var n = e.getWorldMatrices()[0];
                        vh.mat4.getTranslation(t, n);
                        var r = this.getIconSize(t);
                        vh.mat4.scale(i, i, r), e.dirtyBound()
                    },
                    updateArcScale: (mh = vh.vec3.create(), function (e, t) {
                        var i = e._arcScale.getMatrix();
                        vh.mat4.scale(i, vh.mat4.IDENTITY, vh.vec3.set(mh, t, t, t)), e._arcScale.dirtyBound(), this.updateDragHandle(e._handleX, vh.vec3.set(mh, t, 0, 0)), this.updateDragHandle(e._handleY, vh.vec3.set(mh, 0, t, 0)), this.updateDragHandle(e._handleZ, vh.vec3.set(mh, 0, 0, t)), this.updateDragHandle(e._handleXNeg, vh.vec3.set(mh, -t, 0, 0)), this.updateDragHandle(e._handleYNeg, vh.vec3.set(mh, 0, -t, 0)), this.updateDragHandle(e._handleZNeg, vh.vec3.set(mh, 0, 0, -t))
                    }),
                    _checkSelectNodeChanged: function () {
                        var e = this.model.get("select");
                        if (e !== this._select) {
                            this._select = e;
                            var t = this.getGizmo();
                            if (!e || e.get("ambient")) return t.attachToNode(null), void this.hideIcon(e);
                            this.addIcon(e), (0, Jo.kR)(e), this._setGizmoPositionFromSound()
                        }
                    },
                    _updateFalloffGizmo: function () {
                        var e = this.model.get("select");
                        this.updateArcScale(this._gizmoRefDistance, e.get("distance")), "linear" === e.get("distanceModel") ? (this._gizmoFalloff._nodeGizmo.setNodeMask(Pe.Z.NO_SHADOW), this.updateArcScale(this._gizmoFalloff, e.get("distanceMax"))) : this._gizmoFalloff._nodeGizmo.setNodeMask(0)
                    },
                    _setGizmoPositionFromSound: function () {
                        var e = this.model.get("select").get("lastComputedWorldPosition");
                        vh.mat4.setTranslation(this._nodeGizmos.getMatrix(), e)
                    },
                    _setSoundPositionFromGizmo: function () {
                        var e = this.model.get("select"),
                            t = e.get("lastComputedWorldPosition");
                        vh.mat4.getTranslation(t, this._nodeGizmos.getMatrix()), (0, Jo.D1)(e, t)
                    },
                    updateGizmo: function () {
                        var e = this.getGizmo();
                        if (e) {
                            this._checkSelectNodeChanged();
                            var t = this.model.get("select");
                            if (!t || t.get("ambient")) return this._nodeGizmos.setNodeMask(0), void e.setNodeMask(0);
                            e.attachToNode(this._nodeGizmos), this._nodeGizmos.setNodeMask(-1), e.setNodeMask(-1);
                            var i = t.get("snap");
                            i ? this._nodeGizmos.editMask = _h.NodeGizmo.NO_PICK : (this._nodeGizmos.editMask = _h.NodeGizmo.PICK_ARROW | _h.NodeGizmo.PICK_PLANE, t.set("geometryUid", -1)), this._dragging && U.Z.draw(), this._updateFalloffGizmo(), this._nodeGizmos.dirtyBound();
                            var n = t.get("lastComputedWorldPosition"),
                                r = t.get("snapChanged");
                            r && t.set("snapChanged", !1), e.isEditing() || r ? i ? (this.snapCheck(t, n), this._displaySnapHelp()) : this._setSoundPositionFromGizmo() : this._setGizmoPositionFromSound()
                        }
                    },
                    _updateSoundObjectPosition: function (e) {
                        (0, Jo.kR)(e), e.get("soundObject").setPositionNormalized(e.get("lastComputedWorldPosition"))
                    },
                    getNodeCamera: function () {
                        return this._nodeCamera
                    },
                    getGizmo: function () {
                        var e = this._viewer.getFeaturesManager();
                        return e ? e.getNodeGizmo() : null
                    },
                    _displaySnapHelp: function () {
                        new ph.Z({
                            content: "Double-click to snap the sound on the object surface.",
                            class: "info",
                            delay: 2e3
                        })
                    },
                    initDepthTexture: function () {
                        var e = this._viewer.getFeaturesManager().getTextureDepth();
                        this._nodeCamera.getStateSet().setTextureAttributeAndModes(0, e, Th);
                        for (var t = 0, i = this._icons.length; t < i; t++) this._icons[t].getStateSet().setTextureAttributeAndModes(0, e, Th)
                    },
                    getIconSize: function () {
                        var e = vh.vec3.create(),
                            t = vh.vec3.create();
                        return function (i) {
                            var n = this._viewer.getFeaturesManager(),
                                r = n ? n.getIconScaleFov() : 1;
                            this._manipulator.getEyePosition(e);
                            var a = vh.vec3.dist(e, i || vh.vec3.ZERO) / r;
                            return vh.vec3.set(t, a, a, a)
                        }
                    }(),
                    updateIcons: function () {
                        var e = vh.quat.create(),
                            t = vh.mat4.create(),
                            i = vh.vec3.create(),
                            n = vh.vec3.create();
                        return function () {
                            var r = this.model.get("select"),
                                a = this._viewer.getCamera(),
                                o = vh.mat4.getScale(i, a.getProjectionMatrix())[0],
                                s = .02 * this._viewerOSGJS.getCanvasClientWidth() * o;
                            this._manipulator.getEyePosition(n), vh.mat4.invert(t, a.getViewMatrix()), vh.mat4.getRotation(e, t);
                            for (var l = 0, u = this._icons.length; l < u; l++) {
                                var c = this._icons[l],
                                    h = c.getUserData();
                                c !== this._hovered && this.setIconSelected(c, r === h);
                                var d = c.getMatrix();
                                this._updateSoundObjectPosition(h);
                                var g = h.get("lastComputedWorldPosition"),
                                    f = vh.vec3.dist(n, g) / s;
                                vh.vec3.set(i, f, f, f), vh.mat4.fromRotationTranslationScale(d, e, g, i), c.dirtyBound()
                            }
                        }
                    }(),
                    addIcon: function (e) {
                        var t, i;
                        if (i = this._findIcon(e)) return i.setNodeMask(-1), i;
                        t = wh(), (i = new vh.MatrixTransform).addChild(t);
                        var n = s.Z.instance.getOrCreateTexture(De.iconSound, {
                            internalFormat: vh.Texture.RGBA
                        });
                        this.setGizmoStateset(i, yh);
                        var r = i.getOrCreateStateSet();
                        r.setTextureAttributeAndModes(1, n.texture, Th), r.addUniform(vh.Uniform.createInt(1, "uTextureIcon")), r.addUniform(vh.Uniform.createInt(0, "uAttachedToCamera")), r.addUniform(vh.Uniform.createInt(1, "uEnable")), ch || (ch = Ne.Z.getOrCreateShader(Ha, Ga, "icon", "LightingIcon", "ICON")), r.setAttributeAndModes(ch);
                        var a = this._icons.length;
                        i.setName("SOUNDIconMT_" + a);
                        var o = i.getMatrix();
                        vh.mat4.fromTranslation(o, e.get("lastComputedWorldPosition")), vh.mat4.scale(o, o, this.getIconSize()), this._icons.push(i), this._nodeIcons.addChild(i), i.setUserData(e), i.dirtyBound()
                    },
                    hideIcon: function (e) {
                        var t = this._findIcon(e);
                        t && t.setNodeMask(0)
                    },
                    _findIcon: function (e) {
                        for (var t = 0; t < this._icons.length; t++)
                            if (this._icons[t].getUserData() === e) return this._icons[t];
                        return null
                    },
                    snapCheck: (dh = new _h.SphereIntersector, gh = new _h.IntersectionVisitor, fh = vh.vec3.create(), function (e, t) {
                        gh.setTraversalMask(Pe.Z.PICK_GEOMETRY_SLOW);
                        var i = 10 * J.Z.getModelBoxWithDisplacement().radius();
                        Fe.Z.getScenePositionFromWorldPoint(t, fh), dh.set(fh, i), gh.setIntersector(dh), this._viewer.getRootModel().accept(gh);
                        var n = dh.getIntersections(),
                            r = n.length;
                        if (r) {
                            for (var a = n[0], o = 1; o < r; ++o) {
                                var s = n[o];
                                s._ratio < a._ratio && (a = s)
                            } (0, Jo.hP)(e, a)
                        }
                    }),
                    onDragStart: function (e) {
                        if (this.isSoundTabOpen() && Fe.Z.isInitialized()) {
                            var t = Fe.Z.computeNearestIntersection2D(e.canvasX, e.canvasY, Pe.Z.PICK_GEOMETRY, this._nodeCamera);
                            if (this._dragging = !1, t) {
                                var i = t._nodePath[t._nodePath.length - 1];
                                if (i === wh()) {
                                    var n = t._nodePath[t._nodePath.length - 2].getUserData();
                                    n && this.model.get("soundtracks").trigger("select", n)
                                } else if (i === this._geomHandleDistance || i === this._geomHandleFalloff) {
                                    var r = this.model.get("select");
                                    if (void 0 === r) return;
                                    var a = this.getGizmo();
                                    if (!a || a.isEditing()) return;
                                    this._manipulator.getInputManager().setEnable(Sh.MANIPULATORS, !1), this._dragging = !0, this.model.set("dragging", !0);
                                    var o = a.getWorldMatrices()[0],
                                        s = vh.vec3.create();
                                    vh.vec3.transformMat4(s, s, o), a.getCanvasPositionFromWorldPoint(s, s), this._draggingStartGizmoCenterX = s[0], this._draggingStartGizmoCenterY = s[1], this._draggingStartX = e.canvasX, this._draggingStartY = e.canvasY;
                                    var l = (this._draggingStartX - this._draggingStartGizmoCenterX) / this._viewer.getWidth(),
                                        u = (this._draggingStartY - this._draggingStartGizmoCenterY) / this._viewer.getHeight();
                                    this._draggingStartScreenDistance = Math.sqrt(l * l + u * u), t._nodePath[t._nodePath.length - 3] === this._gizmoFalloff._nodeGizmo ? (this.draggingFallofGizmo = !0, this._draggingStartDistance = r.get("distanceMax")) : (this.draggingRefDistanceGizmo = !0, this._draggingStartDistance = r.get("distance"))
                                }
                            }
                        }
                    },
                    onHover: function (e, t, i) {
                        if (Fe.Z.isInitialized()) {
                            var n, r = Fe.Z.computeNearestIntersection2D(e, t, Pe.Z.PICK_GEOMETRY, this._nodeCamera);
                            if (r) {
                                var a = r._nodePath[r._nodePath.length - 1];
                                if (a === this._hovered || r._nodePath.length > 2 && r._nodePath[r._nodePath.length - 2] === this._hovered) return;
                                a === wh() ? (this._hovered = r._nodePath[r._nodePath.length - 2], this.setIconSelected(this._hovered, !0), U.Z.draw()) : a !== this._geomHandleDistance && a !== this._geomHandleFalloff || (this._hovered = a, n = a.getStateSet().getUniform("uColor").getInternalArray(), vh.vec4.copy(n, bh), U.Z.draw())
                            } else this._hovered && (this._hovered === this._geomHandleDistance || this._hovered === this._geomHandleFalloff ? (n = this._hovered.getStateSet().getUniform("uColor").getInternalArray(), vh.vec4.copy(n, Mh)) : this._hovered.getUserData() !== i && this.setIconSelected(this._hovered, !1), U.Z.draw(), this._hovered = !1)
                        }
                    },
                    setIconSelected: function (e, t) {
                        var i = e.getStateSet().getUniformList().uColor.getAttribute().getInternalArray();
                        t ? vh.vec4.copy(i, Ah) : vh.vec4.copy(i, yh)
                    },
                    onDragMove: function (e) {
                        if (this.isSoundTabOpen()) {
                            var t = this.model.get("select");
                            if (this._dragging) {
                                if (void 0 !== t) {
                                    var i = this.getGizmo();
                                    if (i)
                                        if (i.isEditing()) this.onDragEnd();
                                        else {
                                            var n = (e.canvasX - this._draggingStartGizmoCenterX) / this._viewer.getWidth(),
                                                r = (e.canvasY - this._draggingStartGizmoCenterY) / this._viewer.getHeight(),
                                                a = Math.sqrt(n * n + r * r);
                                            a = a * this._draggingStartDistance / this._draggingStartScreenDistance, this.draggingRefDistanceGizmo ? (t.set("distance", a), a > t.get("distanceMax") && t.set("distanceMax", a)) : (t.set("distanceMax", a), a < t.get("distance") && t.set("distance", a)), U.Z.draw()
                                        }
                                }
                            } else this.onHover(e.canvasX, e.canvasY, t)
                        }
                    },
                    onDragEnd: function () {
                        this._dragging && this.isSoundTabOpen() && (void 0 !== this.model.get("select") && (this._manipulator.getInputManager().setEnable(Sh.MANIPULATORS, !0), this.draggingFallofGizmo = !1, this.draggingRefDistanceGizmo = !1, this._dragging = !1, this.model.set("dragging", !1), U.Z.draw()))
                    },
                    onDoubleClick: function (e) {
                        if (this.isSoundTabOpen()) {
                            var t = this.model.get("select");
                            if (void 0 !== t && !t.get("ambient"))
                                if (this._viewer.getFeaturesManager()) {
                                    var i = Fe.Z.pickNearestSurface(e);
                                    i && ((0, Jo.hP)(t, i), (0, Jo.kR)(t), t.get("snap") || t.set("geometryUid", -1), this._updateSoundObjectPosition(t))
                                }
                        }
                    },
                    isSoundTabOpen: function () {
                        var e = this._viewer.getOptions().widgetAPI;
                        return e && "sound" === e.getTabbedWidget().get()
                    },
                    removeIcon: function (e) {
                        for (var t = 0, i = this._icons.length; t < i; t++) {
                            var n = this._icons[t];
                            if (n.getUserData() === e) {
                                n.getParents()[0].removeChild(n);
                                break
                            }
                        }
                    },
                    updateVisibility: function () {
                        this.isSoundTabOpen() ? (0 === this._nodeCamera.getNodeMask() && this._manipulator.getInputManager().setEnable(Sh.SOUND_GIZMO, !0), this._nodeCamera.setNodeMask(Pe.Z.NO_SHADOW), this.updateGizmo(), this.updateIcons()) : (0 !== this._nodeCamera.getNodeMask() && this._manipulator.getInputManager().setEnable(Sh.SOUND_GIZMO, !0), this._nodeCamera.setNodeMask(0))
                    }
                };
            const Ph = Eh;
            var Nh = i("HXjs"),
                Oh = g.Z.osg;
            const Dh = V.Z.extend({
                initialize: function (e) {
                    V.Z.prototype.initialize.apply(this, arguments), this._currentFrame = 0, this._currentSimulationTime = 0, this._soundPromises = [], this._soundObjects = [], this._context = e.context, this._viewer = this._context.getViewer();
                    var t = (0, l.Z)().soundEnable;
                    this.model.set("enable", t), (0, l.Z)().soundMute && (this.model.set("mute", !0), this.model.set("volume", 0), lh.Z.setMute(!0)), this._nodeFeature = new Oh.Node, this._nodeFeature.setName("Feature - Sound"), (0, o.Z)() && Ph.init(this.model, this._context, this._nodeFeature), this.listenTo(this.model, "change:playing", this.onPlayingChange.bind(this)), this.listenTo(this.model, "change:enable", this.onEnableChange.bind(this)), this.listenTo(this.model, "change:volume", this.updateVolume.bind(this)), this.listenTo(this.model, "change:mute", this.updateMute.bind(this));
                    var i = this.model.get("soundtracks");
                    (0, ut.Z)() || t && lh.Z.checkWillHaveSounds(this._viewer.model) || i.reset();
                    var n = i.length > 0;
                    if (n || (L.Z.resolveHasSound(n), (0, o.Z)())) {
                        if (this._nodeFeature.setCullCallback(this), (0, o.Z)() || n) {
                            var r = (0, Nh.X2)();
                            r && document.addEventListener(r, this.tabChange.bind(this))
                        }
                        if (jr.default.apple.device) {
                            var a, s, u = !1,
                                c = [];
                            for (a = 0, s = i.length; a < s; a++) {
                                var h = i.at(a);
                                !u && h.get("ambient") ? u = h : c.push(h)
                            }
                            for (a = 0, s = c.length; a < s; a++) i.remove(c[a]);
                            if (!u) return void L.Z.resolveHasSound(!1)
                        }
                        this.listenTo(i, "add", this.onAdd.bind(this)), this.listenTo(i, "remove", this.onRemove.bind(this)), this.listenTo(i, "select", this.onSelectChanged.bind(this)), lh.Z.setWaiting(!(0, o.Z)()), i.each(this.onAdd.bind(this)), L.Z.resolveHasSound(n);
                        var g = [];
                        g.push(L.Z.getHasAnimation()), (0, l.Z)().soundPreload && g.push(d().all(this._soundPromises).then((function () {
                            L.Z.resolveSoundsCanPlayTrough(!0)
                        }))), d().all(g).then(function (e) {
                            this._hasAnim = e[0], lh.Z.setHasAnim(this._hasAnim), L.Z.resolveSoundsCanPlayTrough(!0), this._hasAnim || (lh.Z.setWaiting(!1), this.play()), L.Z.getFirstAnimation().then(function () {
                                (0, o.Z)() && Ph.initDepthTexture(), this.updatePositionAndTime(this.model.get("playing"));
                                var e = this._viewer.getFeatures().animation.getModel();
                                this._featureAnimationModel = e, this._hasAnim && (lh.Z.setWaiting(!1), e.bind("change:playing", this.onAnimationPlaying, this), e.bind("change:speed", this.onAnimationSpeedChange, this), e.bind("seek", this.onAnimationTimeSeek, this), e.bind("change:currentUID", this.onUidChange, this), this.onAnimationPlaying(e))
                            }.bind(this))
                        }.bind(this))
                    } else this.model.set("enable", !1)
                },
                isTabHidden: function () {
                    return document[this._hidden]
                },
                tabChange: function () {
                    this.model.get("enable") && ((0, Nh.BG)() ? lh.Z.hide() : (lh.Z.show(), this._hasAnim && this._featureAnimationModel ? this.onAnimationPlaying(this._featureAnimationModel) : lh.Z.forcePlay(!0), this.updatePositionAndTime(this.model.get("playing")), lh.Z.update()))
                },
                animationTimeSync: function () {
                    if (lh.Z.canPlay() && this._featureAnimationModel) {
                        var e = this.getTimeFromAnimationProgress();
                        e !== this._currentSimulationTime && (this._currentSimulationTime = e, this.updatePositionAndTime(this._featureAnimationModel.get("playing")))
                    }
                },
                updatePositionAndTime: function (e) {
                    if (lh.Z.canPlay())
                        for (var t = this._viewer.getFeaturesManager && this._viewer.getFeaturesManager(), i = 0, n = this._soundObjects.length; i < n; i++) {
                            var r = this._soundObjects[i];
                            t && this.onSoundPositionChange(r.getModel()), r.setTime(this._currentSimulationTime, e)
                        }
                },
                onAnimationPlaying: function (e) {
                    if (1 === this._featureAnimationModel.get("speed")) {
                        var t = e.get("playing");
                        this.model.set("playing", t), t ? this.play() : this.pause()
                    } else lh.Z.setWaiting(!0)
                },
                onUidChange: function (e) {
                    "-1" === e.get("currentUID") ? this.pause() : e.get("playing") && this.play()
                },
                getTimeFromAnimationProgress: function () {
                    var e = this._featureAnimationModel.getCurrentAnimation();
                    if (!e) return 0;
                    var t = e.get("duration");
                    return this._featureAnimationModel.get("progress") * t / 100
                },
                onAnimationTimeSeek: function () {
                    this._currentSimulationTime = this.getTimeFromAnimationProgress()
                },
                onAnimationSpeedChange: function (e) {
                    1 !== e.get("speed") ? (this.pause(), lh.Z.setWaiting(!0)) : (lh.Z.setWaiting(!1), this.play())
                },
                onSoundChange: function (e) {
                    e.get("soundObject").updateFromModel(e), U.Z.draw()
                },
                onSoundPositionChange: function (e) {
                    e.get("soundObject").setPositionNormalized((0, Jo.kR)(e))
                },
                onSoundDistanceChange: function (e) {
                    e.get("soundObject").setRefDistanceNormalized(e.get("distance"))
                },
                onSoundDistanceMaxPositionChange: function (e) {
                    e.get("soundObject").setMaxDistanceNormalized(e.get("distanceMax"))
                },
                onSoundTimeChange: function (e) {
                    var t = e.get("soundObject"),
                        i = this.getTimeFromAnimationProgress();
                    t.setTime(i, !1)
                },
                onSoundVolumeChange: function (e) {
                    e.get("soundObject").updateVolume()
                },
                onSoundSnapChange: function (e) {
                    e.set("snapChanged", !0)
                },
                cull: function () {
                    return this._hasAnim && this._featureAnimationModel && this.animationTimeSync(), (0, o.Z)() && !this._pauseUpdate && Ph.updateVisibility(), !0
                },
                setPauseUpdate: function (e) {
                    this._pauseUpdate = e
                },
                getNode: function () {
                    return this._nodeFeature
                },
                getNodeEditor: function () {
                    return Ph.getNodeCamera()
                },
                onSelectChanged: function (e) {
                    this.model.get("select") !== e && (this.model.set("select", e), this.model.get("soundtracks").trigger("select", e), U.Z.draw())
                },
                onAdd: function (e) {
                    var t = lh.Z.createSound(e, this.model.get("playing")),
                        i = e.get("distance") < 0,
                        n = e.get("distanceMax") < 0;
                    (i || n) && (i && e.set("distance", 0), n && e.set("distanceMax", 0), J.Z.getBoxReady().then((function () {
                        var t = J.Z.getModelBoxWithDisplacement();
                        i && e.set("distance", t.radius()), n && e.set("distanceMax", 2 * t.radius()), t.center(e.get("position"))
                    })), (0, o.Z)() && (this.onSelectChanged(e), this._hasAnim && e.set("sync", !0))), e.set("soundObject", t), e.on("change:enable change:ambient change:distanceModel", this.onSoundChange.bind(this)), e.on("change:position ", this.onSoundPositionChange.bind(this)), e.on("change:distance", this.onSoundDistanceChange.bind(this)), e.on("change:distanceMax", this.onSoundDistanceMaxPositionChange.bind(this)), e.on("change:startTime change:loop change:sync", this.onSoundTimeChange.bind(this)), e.on("change:volume", this.onSoundVolumeChange.bind(this)), e.on("change:snap", this.onSoundSnapChange.bind(this)), this._soundObjects.push(t);
                    var r = new (d())((function (e) {
                        (0, l.Z)().soundPreload ? t.whenReady().then((function () {
                            e(t)
                        })) : e(t)
                    }));
                    if (this._soundPromises.push(r), (0, o.Z)()) {
                        e.get("ambient") || Ph.addIcon(e);
                        var a = this._viewer.getFeatures().animation;
                        if (a) {
                            var s = a.getModel();
                            if (s && 1 !== s.get("speed")) {
                                lh.Z.setWaiting(!0);
                                lh.Z.getProxyModel().trigger("sound-show", "Warning. The animation speed is not x1 but sound will play at normal speed. This can lead to unexpected sound playback issues.", {
                                    position: "top",
                                    duration: 5e3
                                })
                            }
                        }
                    }
                },
                onRemove: function (e) {
                    e === this.model.get("select") && this.onSelectChanged(), o.Z && Ph.removeIcon(e);
                    var t = e.get("soundObject");
                    lh.Z.removeSound(t), this._soundObjects.splice(this._soundObjects.indexOf(t), 1)
                },
                onEnableChange: function () {
                    this.model.set("playing", this.model.get("enable"))
                },
                onPlayingChange: function () {
                    this.model.get("enable") && (this.model.get("playing") ? this.onPlay() : this.onPause())
                },
                onPlay: function () {
                    if (!(0, Nh.BG)()) {
                        if (!this.model.get("enable")) return this.model.set("playing", !1), void this.pause();
                        lh.Z.setPlaying(!0), lh.Z.canPlay() ? lh.Z.forcePlay(!0) : lh.Z.featureDetectSoundAuthGestureNeeded() ? lh.Z.enableTapRequestPopup() : lh.Z.forcePlay(!0), this.updatePositionAndTime(!0)
                    }
                },
                onPause: function () {
                    lh.Z.pause(), this.updatePositionAndTime()
                },
                play: function () {
                    this.model.get("enable") && (this.model.set("playing", !0), this.onPlay())
                },
                pause: function () {
                    this.model.get("enable") && (this.model.set("playing", !1), this.onPause())
                },
                updateMute: function (e) {
                    var t = e.get("mute");
                    lh.Z.setMute(t)
                },
                updateVolume: function (e) {
                    var t = e.get("volume");
                    t >= 0 && (e.set("mute", !1), lh.Z.setMute(!1)), lh.Z.setVolume(t)
                }
            });
            var Ih = {
                FeatureName: "sound",
                ModelType: uh,
                ViewListType: [Dh]
            },
                Fh = n.Z.create(Ih);
            Fh.prototype.getNode = function () {
                return this._views[0].getNode()
            }, Fh.prototype.getWidgetNode = function () {
                return this._views[0].getNodeEditor()
            }, Fh.prototype.prepareForScreenShot = function () {
                var e = n.Z.prototype.prepareForScreenShot.call(this);
                return e && this._views[0].setPauseUpdate(!0), e
            }, Fh.prototype.resetAfterScreenShot = function () {
                n.Z.prototype.resetAfterScreenShot.call(this), this._views[0].setPauseUpdate(!1)
            };
            const Lh = Fh;
            var Vh = ir().Model.extend({
                defaults: {
                    availableDisplayView: ["Default"],
                    forceSingleSided: !1,
                    materialList: [],
                    materialByUid: {},
                    displayView: "Default",
                    material: void 0,
                    hoverMaterial: void 0,
                    splitType: "3d",
                    texCoord: 0,
                    focusMaterial: !(0, o.Z)(),
                    highlightOnHover: !(0, o.Z)(),
                    autoSelectHoverMaterial: (0, l.Z)().autoMaterial,
                    viewerToCanvasRatio: 1,
                    referenceShadingType: "lit",
                    uiVisible: !1
                },
                init: function (e) {
                    this._viewer = e.getViewer(), L.Z.getMaterial().then(this.initAvailableView.bind(this))
                },
                getMaterialModel: function () {
                    return this._viewer.getFeatures().material.getModel()
                },
                getShadingStyleModel: function () {
                    return this._viewer.getFeatures().shadingStyle.getModel()
                },
                getPostProcessModel: function () {
                    return this._viewer.getFeatures().postProcess.getModel()
                },
                getGroundModel: function () {
                    return this._viewer.getFeatures().ground.getModel()
                },
                getCurrentMaterial: function () {
                    return this.getMaterialByUid(this.get("material"))
                },
                getCurrentUVs: function () {
                    return this.get("materialList").find(function (e) {
                        return e.uid === this.get("material")
                    }.bind(this)).texCoordUnitList
                },
                getMaterialByUid: function (e) {
                    var t = this.getMaterialModel().getMaterials(),
                        i = t[e],
                        n = i.get("uidUniqueMerged");
                    return n ? t[n] : i
                },
                initAvailableView: function () {
                    var e = this.get("displayView"),
                        t = this.get("availableDisplayView"),
                        i = this.get("materialList"),
                        n = this.get("materialByUid");
                    this.set("displayView", "Default"), t.length = 0, t.push("Default"), i.length = 0;
                    var r = Mi.Z.length,
                        a = {},
                        o = !1,
                        s = this.getMaterialModel().attributes;
                    for (var l in s) {
                        var u = s[l];
                        if (!u.get("uidUniqueMerged")) {
                            for (var c = {}, h = u.getChannels(), d = 0; d < r; ++d) {
                                var g = Mi.Z[d],
                                    m = h[g],
                                    p = m.isEffective();
                                m.set("backupJSON", void 0), c[g] = p, a[g] || m.isEnableEffective() && ("DiffuseIntensity" !== g || p) && (a[g] = !0)
                            }
                            var v = u.get("texCoordUnitList");
                            o = o || v.length > 0, void 0 === this.get("material") && this.set("material", l);
                            var _ = !1;
                            h.MetalnessPBR.isEnableEffective() ? _ = h.GlossinessPBR.isEnableEffective() : h.SpecularPBR.isEnableEffective() && (_ = h.RoughnessPBR.isEnableEffective());
                            var S = {
                                uid: l,
                                name: u.get("name"),
                                texCoordUnitList: v,
                                uidUniqueMerged: u.get("uidUniqueMerged"),
                                uidListUnusedDuplicates: u.get("uidListUnusedDuplicates"),
                                effectiveChannels: c,
                                swapMicrosurface: _
                            };
                            i.push(S), n[l] = S
                        }
                    }
                    a.MetalnessPBR ? (delete a.GlossinessPBR, a.RoughnessPBR = !0) : a.SpecularPBR && (delete a.RoughnessPBR, a.GlossinessPBR = !0);
                    for (var x = 0; x < r; ++x) {
                        var C = Mi.Z[x];
                        a[C] && t.push(C)
                    }
                    t.push("MatcapFlat"), -1 === t.indexOf("NormalMap") && -1 === t.indexOf("BumpMap") || t.push("MatcapDetail");
                    var T = this.getShadingStyleModel();
                    T.get("hasWireframe") && t.push("Wireframe"), T.get("hasVertexColor") && T.get("vertexColorEnable") && (t.push("VertexColor"), T.get("hasVertexAlpha") && T.get("vertexColorUseAlpha") && -1 !== t.indexOf("Opacity") && t.push("VertexAlpha")), f.Z.hasVertexNormals && t.push("VertexNormal"), o && t.push("UVChecker"), this.getPostProcessModel().hasAtLeastOneEffectiveEffect() && t.push("DefaultNoPostProcess"), this.getGroundModel().get("enable") && t.push("DefaultNoGround"), f.Z.hasBones && (t.push("Bones"), t.push("BoneWeights")), this.set("referenceShadingType", T.get("type")), this.trigger("change:availableDisplayView"), this.set("displayView", e)
                },
                _getCorrectedDisplayView: function (e) {
                    var t = this.get("displayView");
                    return !this.get("materialByUid")[e].swapMicrosurface || "RoughnessPBR" !== t && "GlossinessPBR" !== t ? t : "RoughnessPBR" === t ? "GlossinessPBR" : "RoughnessPBR"
                },
                materialHasContentInView2d: function (e) {
                    var t = this.getMaterialByUid(e),
                        i = this._getCorrectedDisplayView(e);
                    return t.getChannels()[i] ? this.get("materialByUid")[e].effectiveChannels[i] : "Wireframe" === i ? t.get("geometryList").length > 0 : "VertexColor" === i ? t.get("hasVertexColor") : "VertexAlpha" === i ? t.get("hasVertexAlpha") : !("UVChecker" !== i || !t.get("texCoordUnitList").length)
                },
                materialHasTextureInView2d: function (e) {
                    var t = this.getMaterialByUid(e),
                        i = this._getCorrectedDisplayView(e),
                        n = t.getChannels()[i];
                    return n ? this.get("materialByUid")[e].effectiveChannels[i] && !!n.getTextureModel() : "Wireframe" === i ? t.get("geometryList").length > 0 : "VertexColor" === i ? t.get("hasVertexColor") : "VertexAlpha" === i && t.get("hasVertexAlpha")
                },
                hasContentInView2d: function () {
                    return this.materialHasContentInView2d(this.get("material"))
                },
                getName: function () {
                    return "Inspector"
                }
            });
            const Bh = Vh;
            var Uh = i("ypNz");
            var kh = g.Z.osg,
                Zh = g.Z.osgUtil,
                Hh = function (e, t) {
                    kh.Camera.call(this), this._model = t, this._viewer = e, this._viewerOSGJS = e.getViewerOSGJS(), this.setNodeMask(0), this.setName("Camera 2D"), this.setReferenceFrame(kh.Transform.ABSOLUTE_RF), this.setViewport(new kh.Viewport), kh.vec4.set(this.getClearColor(), .5, .5, 1, 1), this._manipulatorEnable = !1, this._scale = 1, this._zoomCoord = kh.vec2.create();
                    var i = this.getCameraEasing();
                    this._panInterpolator = new Zh.DelayInterpolator(2, i), this._zoomInterpolator = new Zh.DelayInterpolator(1, i), this.addUpdateCallback(this), this.initGraph()
                };
            Hh.prototype = kh.objectInherit(kh.Camera.prototype, {
                initGraph: function () {
                    var e = kh.StateAttribute.OVERRIDE_ON,
                        t = this.getOrCreateStateSet();
                    t.addUniform(kh.Uniform.createFloat(1, "uDisplay2D")), t.addUniform(kh.Uniform.createInt(0, "uOutputLinear"), e), t.setAttributeAndModes(Le.Z.DEPTH_DISABLE, e), t.setRenderBinDetails(Oe.Z.OPAQUE_NO_EARLYZ, "RenderBin"), this._projectedGeometry = new kh.Node, this._projectedGeometry.setName("Projected Geometry");
                    var i = this._projectedGeometry.getOrCreateStateSet();
                    i.addUniform(kh.Uniform.createFloat4(kh.vec4.ONE, "uColor")), i.addUniform(kh.Uniform.createInt(0, "uProjectedWireframe")), this._projectedWireframe = new kh.Node, this._projectedWireframe.setName("Projected Wireframe"), this._projectedWireframe.getOrCreateStateSet().addUniform(kh.Uniform.createInt(1, "uProjectedWireframe")), this._projectedPolygon = new kh.Node, this._projectedPolygon.setName("Projected Polygon"), this._projectedGeometry.addChild(this._projectedPolygon), this._projectedGeometry.addChild(this._projectedWireframe), this._displayTexture = new kh.Node, this._displayTexture.setName("Display Texture"), this._displayTexture.getOrCreateStateSet().setShaderGeneratorName("inspector", e), this._quadTexture = kh.createTexturedQuadGeometry(-.5, -.5, 0, 1, 0, 0, 0, 1, 0), this._quadTexture.setName("Texture display 2D"), this._displayTexture.addChild(this._quadTexture), this.addChild(this._displayTexture), this.addChild(this._projectedGeometry), L.Z.getModelDisplayed().then(function () {
                        var e = this._viewer.getFeatures(),
                            t = e.environment.getNode();
                        this._quadTexture.setStateSet(t.getStateSet()), e.postProcess.getNodeIn().addChild(this)
                    }.bind(this))
                },
                getCameraEasing: function () {
                    return void 0 === (0, l.Z)().cameraEasing ? .8 : 1 - (0, l.Z)().cameraEasing
                },
                getViewportWidth: function () {
                    return this.getViewport().width()
                },
                getViewportHeight: function () {
                    return this.getViewport().height()
                },
                _replaceProjectedGeometry: function (e, t, i) {
                    e.removeChildren();
                    for (var n = 0; n < t.length; ++n) {
                        var r = t[n],
                            a = new kh.Geometry;
                        a._attributes = r.getAttributes(), a._primitives = r.getPrimitives(), a._QVT = r._QVT, a._QVS = r._QVS, a._listQuantUV = r._listQuantUV, a.setBound(this._quadTexture.getBoundingBox()), a.setStateSet(i), e.addChild(a)
                    }
                },
                _updateProjectedGeometry: function (e, t, i, n) {
                    if (n.isFulfilled()) return this._replaceProjectedGeometry(e, t, i, n);
                    var r = this,
                        a = this._material;
                    n.then((function () {
                        a === r._material && r._replaceProjectedGeometry(e, t, i, n)
                    }))
                },
                _updateProjectedPolygon: function (e) {
                    this._updateProjectedGeometry(this._projectedPolygon, e.get("geometryList"), e.get("stateSet"), L.Z.getModelDisplayed())
                },
                _updateProjectedWireframe: function (e) {
                    this._updateProjectedGeometry(this._projectedWireframe, e.get("wireframeList"), e.get("stateSetWireframe"), L.Z.getWireframeOptimizedSplitCompressed())
                },
                setMaterial: function (e, t) {
                    this._material = e;
                    var i = e.get("stateSet");
                    this._displayTexture.setStateSet(i);
                    var n = "TexCoord" + t,
                        r = n,
                        a = "attribute vec2 %UV%;\nattribute vec4 Color;\n\nuniform float uArrayColorEnabled;\nuniform float uPointSize;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec4 vColor;\n\nvoid main() {\n    vec2 uv = %UV_UNPACK%;\n    gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(uv - 0.5, 1.0, 1.0));\n    gl_PointSize = 1.0;\n    vColor = uArrayColorEnabled == 1.0 ? Color : vec4(1.0, 1.0, 1.0, 1.0);\n}\n";
                    if ((0, l.Z)().zz) {
                        var o = "uQUV" + t;
                        r = n + ".xy * " + o + ".zw + " + o + ".xy", a = "uniform vec4 " + o + ";\n" + a
                    }
                    a = a.replace(/%UV%/g, n).replace(/%UV_UNPACK%/g, r);
                    var s = Ne.Z.getOrCreateShader(a, "uniform int uProjectedWireframe;\nuniform int uInspectorView; // see globalUniforms\nuniform vec4 uColor;\n\nvarying vec4 vColor;\n\nvoid main() {\n    gl_FragColor = uProjectedWireframe == 1 ? vec4(uColor.rgb * uColor.a, uColor.a) : vec4(uInspectorView == 1 ? vColor.aaa : vColor.rgb, 1.0);\n}\n", "inspector-projectedTexCoord" + t, "projectedTexCoord" + t);
                    if (this._projectedGeometry.getOrCreateStateSet().setAttributeAndModes(s), !e.get("texCoordUnitList").length) return this._projectedPolygon.removeChildren(), void this._projectedWireframe.removeChildren();
                    var u = this._quadTexture.getVertexAttributeList(),
                        c = "TexCoord" + t;
                    u[c] || (u[c] = u.TexCoord0), this._updateProjectedWireframe(e), this._updateProjectedPolygon(e)
                },
                setManipulatorEnable: function (e) {
                    this._manipulatorEnable = e
                },
                setVisible: function (e) {
                    this.setNodeMask(e ? Pe.Z.NO_PICK_NO_SHADOW_CAST : 0)
                },
                updateOrtho: function () {
                    var e = .5 * this._scale,
                        t = e * this.getViewportHeight() / this.getViewportWidth();
                    kh.mat4.ortho(this.getProjectionMatrix(), -e, e, -t, t, -10, 10)
                },
                onEventStart: function (e) {
                    this._lastScale = e.scale || 1, this._zoomInterpolator.reset(), this._panInterpolator.reset(), this._isPanning = !0
                },
                onEventEnd: function () {
                    this._zoomInterpolator.reset(), this._panInterpolator.reset(), this._isPanning = !1
                },
                _registerHoverUV: function () {
                    var e = kh.mat4.create();
                    return function (t) {
                        var i = to.Z.uHoverUV.getInternalArray();
                        kh.mat4.identity(e), this.getViewport().computeWindowMatrix(e), kh.mat4.multiply(e, e, this.getProjectionMatrix()), kh.mat4.multiply(e, e, this.getViewMatrix()), kh.mat4.invert(e, e), i[0] = t.glX, i[1] = t.glY, kh.vec2.transformMat4(i, i, e), i[0] += .5, i[1] += .5, U.Z.draw()
                    }
                }(),
                onEventUpdate: function (e) {
                    if (this._registerHoverUV(e), this._isPanning) {
                        if (this._panInterpolator.setTarget(e.glX, -e.glY), e.scale) {
                            var t = e.scale > this._lastScale ? 5 : 10,
                                i = (e.scale - this._lastScale) * t,
                                n = this._zoomInterpolator.getTarget()[0] - i;
                            this._zoomInterpolator.setTarget(n), this._lastScale = e.scale
                        }
                        this.registerFocusZoom(e), U.Z.draw()
                    }
                },
                onMouseWheel: function (e) {
                    this._zoomInterpolator.setTarget(this._zoomInterpolator.getTarget()[0] - Math.sign(e.deltaY)), this.registerFocusZoom(e), U.Z.draw()
                },
                registerFocusZoom: function (e) {
                    var t = this._viewerOSGJS.getCanvasPixelRatio(),
                        i = this.getViewportWidth(),
                        n = this.getViewportHeight(),
                        r = kh.vec2.set(this._zoomCoord, e.canvasX, e.canvasY),
                        a = "2d" === this._model.get("splitType") ? .5 : -.5;
                    r[0] = a + (r[0] * t - i) / i, r[1] = r[1] * t / n - .5
                },
                _updateWireframeNodeMask: function () {
                    var e = this._viewer.getOrCreateScene().getWireframeNodes();
                    e.length && this._projectedWireframe.setNodeMask(e[0].getNodeMask())
                },
                update: function (e, t) {
                    var i = t.getFrameStamp().getDeltaTime(),
                        n = this.getViewMatrix(),
                        r = this.getViewportWidth(),
                        a = this.getViewportHeight(),
                        o = this._panInterpolator.update(i),
                        s = .1 * this._zoomInterpolator.update(i)[0],
                        l = this._scale * (1 + s),
                        u = l * this._viewerOSGJS.getCanvasPixelRatio() / r,
                        c = l - this._scale;
                    n[12] += o[0] * u + this._zoomCoord[0] * c, n[13] -= o[1] * u + this._zoomCoord[1] * c * a / r, this._scale = l, this.updateOrtho(), this._updateWireframeNodeMask();
                    var h = this._model.get("displayView"),
                        d = "VertexColor" === h || "VertexAlpha" === h ? -1 : 0;
                    return this._projectedPolygon.setNodeMask(d), !0
                }
            });
            const Gh = Hh;
            var zh = i("GoyH");
            var Wh, jh, Xh = g.Z.osg,
                Yh = g.Z.osgAnimation,
                Jh = Xh.vec3.create(),
                qh = function () { };
            zh.Z.createPrototypeObject(qh, {
                enable: !0,
                linkGeoms: [],
                cull: function () {
                    var e = Xh.vec3.create();
                    return function () {
                        if (!this.enable) return !0;
                        for (var t = 0; t < this.linkGeoms.length; t++) {
                            var i = this.linkGeoms[t];
                            Xh.mat4.getTranslation(e, i.userDataMap.startBoneMatrix);
                            var n = i.userDataMap.startUniform.getInternalArray();
                            Xh.vec3.copy(n, e), Xh.mat4.getTranslation(e, i.userDataMap.endBoneMatrix), n = i.userDataMap.endUniform.getInternalArray(), Xh.vec3.copy(n, e)
                        }
                        return !0
                    }
                }()
            }, "osgShadow", "LinkCullCallback");
            var Kh, Qh, $h = function () {
                Xh.NodeVisitor.call(this), this._visitedNodes = {}, this._geoStateSet = new Xh.StateSet, this._geoStateSet.setAttributeAndModes(Wh || (Wh = Ne.Z.getOrCreateShader('uniform vec2 uNearFar;\n\n#define NO_JITTER\n#define HAS_VIEW_NORMAL\n#define INJECT_VERT gl_Position.z = -uNearFar.x;\n\n#pragma include "base.vert"\n', "uniform vec3 uBoneColor;\n\nvarying vec3 vViewNormal;\n\nvoid main(void) {\n    vec3 boneColor = uBoneColor * 0.95; // slightingly darker than influence color\n    vec3 boneLinkColor = vec3(max(0.25, abs(dot(normalize(vViewNormal), vec3(0.15, 0.3, 0.9)))));\n    gl_FragColor = vec4(uBoneColor.r < 0.0 ? boneLinkColor : boneColor, 1.0);\n}\n", "debug/skeleton", "debugSkeleton"))), this._geoStateSet.setRenderBinDetails(Oe.Z.DEBUG_2, "RenderBin"), this._linkCullCallback = new qh
            };
            Xh.createPrototypeObject($h, Xh.objectInherit(Xh.NodeVisitor.prototype, {
                setEnable: function (e, t) {
                    e ? (this._geoStateSet.setAttributeAndModes(Le.Z.DEPTH_LESS_WRITE, Xh.StateAttribute.OVERRIDE_ON), this._alreadyRun || (this._alreadyRun = !0, this.apply(t)), this._linkCullCallback.enable = e) : this._geoStateSet.setAttributeAndModes(Le.Z.DEPTH_NEVER, Xh.StateAttribute.OVERRIDE_ON)
                },
                _setBoneStateSet: function (e) {
                    e.setStateSet(this._geoStateSet), e._isSkeleton = !0
                },
                _getOrCreateBoneGeometry: function () {
                    return this._geomBone || (this._geomBone = Xh.createTexturedSphere(), this._setBoneStateSet(this._geomBone), this._geomBone.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW)), this._geomBone
                },
                _getOrCreateBoneBodyGeometry: function () {
                    if (this._geomBoneBody) return this._geomBoneBody;
                    for (var e = .3, t = .05, i = new Float32Array(72), n = new Float32Array(72), r = 0; r < 4; ++r) {
                        var a = 3 * r * 3 * 2,
                            o = 0 === r || 1 === r ? t : -.05,
                            s = 0 === r || 3 === r ? t : -.05,
                            l = 0 === r || 3 === r ? t : -.05,
                            u = 2 === r || 3 === r ? t : -.05;
                        i[a + 3 + 0] = o, i[a + 3 + 1] = s, i[a + 3 + 2] = e, i[a + 6 + 0] = l, i[a + 6 + 1] = u, i[a + 6 + 2] = e;
                        var c = e;
                        n[a + 0] = n[a + 3 + 0] = n[a + 6 + 0] = s * c - c * u, n[a + 1] = n[a + 3 + 1] = n[a + 6 + 1] = c * l - o * c, n[a + 2] = n[a + 3 + 2] = n[a + 6 + 2] = o * u - s * l, i[a + 9 + 0] = 0, i[a + 9 + 1] = 0, i[a + 9 + 2] = 1, i[a + 12 + 0] = l, i[a + 12 + 1] = u, i[a + 12 + 2] = e, i[a + 15 + 0] = o, i[a + 15 + 1] = s, i[a + 15 + 2] = e, c = -.7, n[a + 9 + 0] = n[a + 12 + 0] = n[a + 15 + 0] = s * c - c * u, n[a + 9 + 1] = n[a + 12 + 1] = n[a + 15 + 1] = c * l - o * c, n[a + 9 + 2] = n[a + 12 + 2] = n[a + 15 + 2] = o * u - s * l
                    }
                    this._geomBoneBody = new Xh.Geometry;
                    var h = this._geomBoneBody.getAttributes();
                    h.Vertex = new Xh.BufferArray(Xh.BufferArray.ARRAY_BUFFER, i, 3), h.Normal = new Xh.BufferArray(Xh.BufferArray.ARRAY_BUFFER, n, 3);
                    var d = new Xh.DrawArrays(Xh.primitiveSet.TRIANGLES, 0, i.length / 3);
                    return this._geomBoneBody.getPrimitives().push(d), this._setBoneStateSet(this._geomBoneBody), this._geomBoneBody.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._geomBoneBody
                },
                _createBoneLinkGeometry: (Kh = Xh.vec3.create(), Qh = Xh.vec3.create(), function (e, t) {
                    Xh.mat4.getTranslation(Kh, e.getMatrixInSkeletonSpace()), Xh.mat4.getTranslation(Qh, t.getMatrixInSkeletonSpace());
                    var i = new Float32Array(6);
                    i[0] = 1;
                    var n = new Float32Array(2);
                    n[0] = 0, n[1] = 1;
                    var r = new Xh.Geometry,
                        a = r.getAttributes();
                    a.Vertex = new Xh.BufferArray(Xh.BufferArray.ARRAY_BUFFER, i, 3), a.BoneIndex = new Xh.BufferArray(Xh.BufferArray.ARRAY_BUFFER, n, 1);
                    var o = new Xh.DrawArrays(Xh.primitiveSet.LINES, 0, i.length / 3);
                    r.getPrimitives().push(o);
                    var s = r.getOrCreateStateSet(),
                        l = Xh.Uniform.createFloat3("uStartPos"),
                        u = Xh.Uniform.createFloat3("uEndPos");
                    return s.addUniform(l), s.addUniform(u), r.userDataMap = {}, r.userDataMap.startBoneMatrix = e.getMatrixInSkeletonSpace(), r.userDataMap.endBoneMatrix = t.getMatrixInSkeletonSpace(), r.userDataMap.startUniform = l, r.userDataMap.endUniform = u, this._linkCullCallback.linkGeoms.push(r), r
                }),
                _addBone: function (e, t) {
                    var i = new Xh.MatrixTransform,
                        n = e.getMinimumBound().radius() / 40;
                    Xh.vec3.set(Jh, n, n, n), Xh.mat4.fromScaling(i.getMatrix(), Jh), i.getOrCreateStateSet().addUniform(Xh.Uniform.createFloat3(e.getOrCreateDebugColor(), "uBoneColor")), i.setName("Debug joint (" + e.getName() + ")"), e.addChild(i), i._isControlBone = t, i.addChild(this._getOrCreateBoneGeometry())
                },
                _addBoneBody: function () {
                    var e = Xh.vec3.create(),
                        t = Xh.vec3.fromValues(0, 0, 1),
                        i = Xh.quat.create(),
                        n = Xh.Uniform.createFloat3(Xh.vec3.fromValues(-1, -1, -1), "uBoneColor");
                    return function (r, a, o) {
                        var s = new Xh.MatrixTransform,
                            l = Xh.vec3.len(a);
                        Xh.quat.rotationTo(i, t, Xh.vec3.normalize(e, a));
                        var u = s.getMatrix();
                        Xh.vec3.set(e, l, l, l), Xh.mat4.fromRotationTranslationScale(u, i, Xh.vec3.ZERO, e), s.getOrCreateStateSet().addUniform(n);
                        var c = "Debug bone (" + r.getName() + ", " + o + ")";
                        s.setName(c), r.addChild(s), s.addChild(this._getOrCreateBoneBodyGeometry())
                    }
                }(),
                _addBoneLink: function (e, t) {
                    if (!this._boneLinksNode) {
                        this._boneLinksNode = new Xh.MatrixTransform, Xh.mat4.invert(this._boneLinksNode, this._rootBone.getMatrix()), this._rootBone._parents[0].addChild(this._boneLinksNode);
                        var i = this._boneLinksNode.getOrCreateStateSet();
                        i.setAttributeAndModes(jh || (jh = Ne.Z.getOrCreateShader("uniform vec2 uNearFar;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uModelViewMatrix;\n\nuniform vec3 uStartPos;\nuniform vec3 uEndPos;\n\n#ifdef NEED_INVARIANT\ninvariant gl_Position;\n#endif\nattribute float BoneIndex;\n\nvoid main() {\n\n    vec3 localVertex = uStartPos * (1.0 - BoneIndex) + uEndPos * BoneIndex;\n    vec4 viewVertex = uModelViewMatrix * vec4(localVertex, 1.0);\n    gl_Position = uProjectionMatrix * viewVertex;\n    gl_Position.z = -uNearFar.x;\n\n}\n", "\nvoid main(void) {\n    gl_FragColor =  vec4(0.2, 0.2, 0.2, 1.0);\n}\n", "debug/skeletonWire", "debugSkeletonWire"))), i.setRenderBinDetails(Oe.Z.DEBUG_2, "RenderBin"), this._boneLinksNode.setCullCallback(this._linkCullCallback), this._boneLinksNode._isControlBone = !0
                    }
                    this._boneLinksNode.addChild(this._createBoneLinkGeometry(e, t))
                },
                _extractBoneData: function (e) {
                    for (var t, i = [], n = e.getChildren(), r = 0; r < n.length; ++r)
                        if (n[r] instanceof Yh.Bone) {
                            var a = n[r],
                                o = a.isSkinning();
                            a.getName().indexOf("_correct") >= 0 && (o = a.getChildren()[0].isSkinning()), o ? i.push(a) : t || (t = a)
                        }
                    return 0 === i.length && t && i.push(a), i
                },
                _epsEqual: function (e, t, i) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            a = t[n];
                        if (Math.abs(r - a) > i) return !1
                    }
                    return !0
                },
                _approximateTail: function () {
                    var e = Xh.vec3.create(),
                        t = Xh.vec3.create(),
                        i = Xh.vec3.create(),
                        n = Xh.vec3.create(),
                        r = Xh.vec3.create(),
                        a = Xh.vec3.create();
                    return function (o, s) {
                        if (1 === s.length) return Xh.mat4.getTranslation(o.userDataMap.tail, s[0].getMatrix()), void (o.userDataMap.tailChild = s[0]);
                        if (s.length > 1) {
                            var l = .001 * o.getMinimumBound().radius();
                            Xh.mat4.getTranslation(o.userDataMap.tail, s[0].getMatrix());
                            for (var u = !0, c = 1; c < s.length; c++) {
                                var h = s[c];
                                if (Xh.mat4.getTranslation(e, h.getMatrix()), !this._epsEqual(e, o.userDataMap.tail, l)) {
                                    u = !1;
                                    break
                                }
                            }
                            if (u) return void (o.userDataMap.tailChild = s[0])
                        }
                        for (var d, g = o.userDataMap.apexes, f = 0, m = 0; m < g.length; m++) {
                            var p = Xh.vec3.sqrLen(g[m]);
                            p > f && (d = m, f = p)
                        }
                        if (s.length) {
                            var v = o.getBoneParent(),
                                _ = o.getMatrixInSkeletonSpace();
                            if (v && v.userDataMap.tail) {
                                var S = v.getMatrixInSkeletonSpace();
                                Xh.vec3.transformMat4(a, v.userDataMap.tail, S), Xh.mat4.getTranslation(e, S), Xh.vec3.sub(a, a, e), Xh.vec3.normalize(a, a)
                            }
                            if (s.length >= 1) {
                                Xh.vec3.normalize(i, g[d]);
                                for (var x = .95, C = .95, T = void 0, M = void 0, b = 0; b < s.length; b++) {
                                    var y = s[b];
                                    Xh.mat4.getTranslation(t, y.getMatrix()), Xh.vec3.normalize(r, t);
                                    var A = Xh.vec3.dot(r, i);
                                    if (A > x && (T = y, x = A), v && v.userDataMap.tail) {
                                        Xh.vec3.transformMat4(n, t, _), Xh.mat4.getTranslation(e, _), Xh.vec3.sub(n, n, e), Xh.vec3.normalize(n, n);
                                        var R = Xh.vec3.dot(n, a);
                                        R > C && (M = y, C = R)
                                    }
                                }
                                T ? (Xh.mat4.getTranslation(t, T.getMatrix()), Xh.vec3.copy(o.userDataMap.tail, t), o.userDataMap.tailChild = T) : M ? (Xh.mat4.getTranslation(t, M.getMatrix()), Xh.vec3.copy(o.userDataMap.tail, t), o.userDataMap.tailChild = M) : Xh.vec3.copy(o.userDataMap.tail, g[d])
                            }
                        } else Xh.vec3.copy(o.userDataMap.tail, g[d])
                    }
                }(),
                _drawBone: function (e) {
                    this._addBone(e, !e.isSkinning());
                    var t = e.getChildren();
                    if (t.length) {
                        var i = this._extractBoneData(e);
                        e.isSkinning() && e.userDataMap.apexes && (e.userDataMap.tail = Xh.vec3.create(), this._approximateTail(e, i), e.userDataMap.tail && this._addBoneBody(e, e.userDataMap.tail, e.getName() + "_tail"));
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r !== e.userDataMap.tailChild && t[n] instanceof Yh.Bone && this._addBoneLink(e, r)
                        }
                    }
                },
                apply: function (e) {
                    var t = e.getInstanceID();
                    if (!this._visitedNodes[t]) {
                        if (this._visitedNodes[t] = !0, e instanceof Yh.Bone) {
                            this._rootBone || (this._rootBone = e);
                            var i = e.getName();
                            i && -1 !== i.indexOf("_correct") || this._drawBone(e)
                        }
                        this.traverse(e)
                    }
                }
            }), "osgtestdemo2024", "DrawBoneVisitor");
            const ed = $h;
            var td = g.Z.osg,
                id = function () {
                    td.NodeVisitor.call(this), this._visible = !0
                };
            td.createPrototypeObject(id, td.objectInherit(td.NodeVisitor.prototype, {
                setEnable: function (e, t) {
                    this._visible = e, this._visitedNodes = {}, this._alreadyRun = !0, this.apply(t)
                },
                validNodeMask: function () {
                    return !0
                },
                apply: function (e) {
                    var t = e.getInstanceID();
                    this._visitedNodes[t] || (this._visitedNodes[t] = !0, e._isControlBone && e.setNodeMask(this._visible ? Pe.Z.NO_PICK_NO_SHADOW : 0), this.traverse(e))
                }
            }), "osgtestdemo2024", "ShowControlBonesVisitor");
            const nd = id;
            var rd = g.Z.osg,
                ad = g.Z.osgUtil,
                od = g.Z.InputGroups,
                sd = .25,
                ld = rd.vec3.fromValues(.7, .75, .75),
                ud = {
                    Opacity: !0,
                    AOPBR: !0,
                    CavityPBR: !0
                },
                cd = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments);
                        var e = this.model;
                        e.bind("change:displayView", this.onDisplayView, this), e.bind("change:material", this.onMaterial, this), e.bind("change:texCoord", this.onTexCoord, this), e.bind("change:splitType", this.onSplitType, this), e.bind("change:viewerToCanvasRatio", this._onViewerToCanvasRatio, this), e.bind("change:forceSingleSided", this.onForceSingleSided, this), e.bind("change:uiVisible", this.onToggle, this), this._viewer = this.options.context.getViewer(), this._viewerOSGJS = this._viewer.getViewerOSGJS(), this._inputManager = this._viewer.getInputManager(), this._viewer.bind("resizeCanvas", this._updateSplitView, this), this._nodeInspector = new rd.Node, this._nodeInspector.setName("Feature - Inspector"), this._normalVisitor = new ad.DisplayNormalVisitor, this._geoColorVisitor = new ad.DisplayGeometryVisitor, this._drawBonesVisitor = new ed, this._showControlBonesVisitor = new nd, this._camera2D = new Gh(this._viewer, this.model);
                        var t = (0, l.Z)();
                        t.uiInspector && t.uiGeneralControls && (Ve.Z.initInspector(this), Ve.Z.initInspectorCamera2D(this._camera2D)), Ve.Z.setInspectorInputsEnable(!1), this._matcapJSON = {
                            factor: 1,
                            color: rd.vec3.ONE,
                            texture: {
                                uid: "43a40dd3e9c34fc0b7da9cbf07b82ac8"
                            }
                        }, L.Z.getMaterial().then(this.initAfterMaterials.bind(this)), J.Z.getBoxReady().then(this.initNormalVisitor.bind(this))
                    },
                    onToggle: function () {
                        Ve.Z.setInspectorInputsEnable(this.model.get("uiVisible"))
                    },
                    onForceSingleSided: function () {
                        for (var e = this.model.get("forceSingleSided"), t = this.model.get("materialList"), i = this.getMaterialModel().getMaterials(), n = 0; n < t.length; ++n) {
                            var r = i[t[n].uid],
                                a = r.get("backupCullFace");
                            (void 0 !== a || (r.set("backupCullFace", r.get("cullFace")), e)) && (e ? r.set("cullFace", rd.CullFace.BACK) : r.set("cullFace", a))
                        }
                    },
                    initAfterMaterials: function () {
                        this._viewer.getFeatures().quality.getModel().bind("updateDynamicResolutionScaling", this._updateSplitView, this)
                    },
                    initNormalVisitor: function () {
                        this._normalVisitor.setScale(.01 * J.Z.getModelBoxWithDisplacement().radius())
                    },
                    hasDisplayView: function (e) {
                        return -1 !== this.model.get("availableDisplayView").indexOf(e)
                    },
                    getMaterialModel: function () {
                        return this._viewer.getFeatures().material.getModel()
                    },
                    getOutlineModel: function () {
                        return this._viewer.getFeatures().outline.getModel()
                    },
                    getQualityModel: function () {
                        return this._viewer.getFeatures().quality.getModel()
                    },
                    getShadingStyleModel: function () {
                        return this._viewer.getFeatures().shadingStyle.getModel()
                    },
                    getPostProcessModel: function () {
                        return this._viewer.getFeatures().postProcess.getModel()
                    },
                    getGroundModel: function () {
                        return this._viewer.getFeatures().ground.getModel()
                    },
                    getImageCollection: function () {
                        return this.getMaterialModel().getImageCollection()
                    },
                    getCurrentMaterial: function () {
                        return this.model.getCurrentMaterial()
                    },
                    isOnView2D: function (e) {
                        var t = this.model.get("splitType");
                        return "3d" !== t && ("2d" === t || "split" === t && e.canvasX > .5 * this._viewerOSGJS.getCanvasClientWidth())
                    },
                    isTabMaterial: function () {
                        var e = this._viewer.getFeaturesManager();
                        return e && "materials" === e.getCurrentTabName()
                    },
                    canDisplayOutline: function () {
                        return this.isTabMaterial() || "split" === this.model.get("splitType")
                    },
                    focusCheck: function (e) {
                        var t = (0, l.Z)();
                        if (t.uiInspector && t.uiGeneralControls) {
                            var i = this.isOnView2D(e);
                            i === this._isView2DEnabled || this._cursorPressed || (this._inputManager.setEnable(od.UI_INSPECTOR, i), (0, l.Z)().scrollwheel && (this._inputManager.setEnable(od.UI_INSPECTOR_ZOOM, i), this._inputManager.setEnable(od.SCENE_INSPECTOR_ZOOM, !i)), this._inputManager.setEnable(od.SCENE, !i), this._isView2DEnabled = i)
                        }
                    },
                    onMouseMove: function (e) {
                        var t, i = "split" === this.model.get("splitType") && this.hitMaterial(e);
                        this._cursorPressed ? this.getOutlineModel().trigger("hideOutline") : this.model.get("highlightOnHover") && this.canDisplayOutline() && !this._freezeHoverOutline && (this.isOnView2D(e) || (t = i), this.model.set("hoverMaterial", t), t ? this.displayOutline("displayOutlineNoFocus", t) : this.getOutlineModel().trigger("hideOutline"))
                    },
                    _freezeOutline: function (e) {
                        void 0 !== this._timerFreezer && (window.clearTimeout(this._timerFreezer), this._timerFreezer = void 0), this._freezeHoverOutline = !0;
                        var t = 1e3 * e,
                            i = this._enableOutline.bind(this);
                        this._timerFreezer = window.setTimeout(i, t)
                    },
                    _enableOutline: function () {
                        this._freezeHoverOutline = !1
                    },
                    _registerHoverUV: function (e, t) {
                        var i = to.Z.uHoverUV.getInternalArray();
                        if ("split" === this.model.get("splitType"))
                            if (U.Z.draw(), e && void 0 !== e._i3 && t === this.getCurrentMaterial()) {
                                var n = e._nodePath[e._nodePath.length - 1].getVertexAttributeList()["TexCoord" + this.model.get("texCoord")];
                                if (n) {
                                    var r = n.getElements(),
                                        a = 2 * e._i1,
                                        o = 2 * e._i2,
                                        s = 2 * e._i3;
                                    i[0] = r[a] * e._r1 + r[o] * e._r2 + r[s] * e._r3, i[1] = r[a + 1] * e._r1 + r[o + 1] * e._r2 + r[s + 1] * e._r3
                                } else i[0] = i[1] = 1e6
                            } else i[0] = i[1] = 1e6;
                        else i[0] = i[1] = 1e6
                    },
                    hitMaterial: function (e) {
                        if (Fe.Z.isInitialized()) {
                            var t = Pe.Z.PICK_GEOMETRY_SLOW,
                                i = Fe.Z.computeNearestIntersection2D(e.canvasX, e.canvasY, t),
                                n = i && Fe.Z.getMaterialFromHit(i);
                            return this._registerHoverUV(i, n), n && this.model.get("autoSelectHoverMaterial") && this.model.set("material", n.get("id")), n
                        }
                    },
                    displayOutline: function (e, t) {
                        this.isTabMaterial();
                        var i = this.getOutlineModel();
                        i.set("durationOutline", 2), i.set("durationHighlight", 2), i.trigger(e, t.get("stateSet"))
                    },
                    onMouseWheel: function () {
                        this.getOutlineModel().trigger("hideOutline"), this._freezeOutline(sd)
                    },
                    onCursorDown: function () {
                        this._cursorPressed = !0
                    },
                    onCursorUp: function () {
                        this._cursorPressed = !1, this._freezeOutline(sd)
                    },
                    autoSelectUV: function () {
                        var e = this.getCurrentMaterial(),
                            t = e.getChannels(),
                            i = this.model.get("displayView");
                        if (t[i]) {
                            var n = t[i].getTextureModel();
                            n && this.model.set("texCoord", n.get("texCoordUnit"))
                        } else {
                            var r = e.get("texCoordUnitList");
                            r.length && -1 === r.indexOf(this.model.get("texCoord")) && this.model.set("texCoord", r[0])
                        }
                    },
                    onTexCoord: function () {
                        this.updateMaterial(), this.getCurrentMaterial().getChannels().Inspector.set("selectUV", this.model.get("texCoord"))
                    },
                    onMaterial: function () {
                        var e = this.model.previous("material");
                        if (e && this.model.getMaterialByUid(e).getChannels().Inspector.set("isSelected", !1), this.getCurrentMaterial().getChannels().Inspector.set("isSelected", !0), this.autoSelectUV(), this.updateMaterial(), this.updateVisible2D(), this.canDisplayOutline()) {
                            var t = this.model.get("focusMaterial") && !this.model.get("autoSelectHoverMaterial") ? "Focus" : "NoFocus";
                            this.displayOutline("displayOutline" + t, this.getCurrentMaterial()), this._freezeOutline(sd)
                        }
                    },
                    updateVisible2D: function () {
                        var e = this.model.get("splitType");
                        this._camera2D.setVisible("3d" !== e && this.model.hasContentInView2d())
                    },
                    updateMaterial: function () {
                        var e = this.getCurrentMaterial(),
                            t = this.model.get("texCoord");
                        this._camera2D.setMaterial(e, t), "UVChecker" === this.model.get("displayView") && e.getChannels().Inspector.setTexCoordUnit(t), U.Z.draw()
                    },
                    onSplitType: function () {
                        var e = this.model.get("splitType");
                        to.Z.uSplitView.setFloat("split" === e ? 1 : 0), "split" !== e && this.getOutlineModel().trigger("hideOutline"), this._updateSplitView(), this.updateVisible2D(), U.Z.draw()
                    },
                    setupCheckerTexture: function (e) {
                        if (!this._checkerImageProxy) {
                            var t = this.getImageCollection();
                            this._checkerImageProxy = t.addNewImage({
                                url: i("2HFw"),
                                width: 1024,
                                height: 1024,
                                id: "skfbUVChecker",
                                name: "UVChecker",
                                internal: !0
                            })
                        }
                        var n = e.setupTextureModel({
                            image: this._checkerImageProxy
                        });
                        return n.updateMultiresTexture(), n
                    },
                    _getDisplayedChannel: function (e, t, i) {
                        return !i.swapMicrosurface || "RoughnessPBR" !== t && "GlossinessPBR" !== t ? ("Opacity" === t && e.Opacity.get("invert") && e.Inspector.set("invert", !0), e[t]) : (e.Inspector.set("invert", !0), "RoughnessPBR" === t ? e.GlossinessPBR : e.RoughnessPBR)
                    },
                    _getColorProfile: function (e) {
                        var t = this.getPostProcessModel().get("sssProfiles")[e.get("profile") - 1],
                            i = rd.vec3.create();
                        return rd.vec3.add(i, t.strength, t.falloff), rd.vec3.scale(i, i, .5), i
                    },
                    _updateTextureTransform: function () {
                        this.inspect.set("UVTransforms", this.channel.get("UVTransforms"))
                    },
                    _setDisplayChannel: function (e, t) {
                        e.setInspectorSRGB(t.getSRGB());
                        var i = t.getName();
                        if (t.isEffective()) {
                            var n = t.getTextureModel();
                            if (!n) {
                                var r = 1;
                                if ("SubsurfaceScattering" === i) r = 1 / (Mi.Z.getBoxFactor("SubsurfaceScattering") * J.Z.getModelBoxWithoutDisplacement().radius());
                                "Opacity" === i && "additive" === t.get("type") && (r = .5), e.setFactor(t.getFactor() * r)
                            }
                            if ("SubsurfaceScattering" === i) e.setColor(this._getColorProfile(t));
                            else if ("ClearCoat" === i) e.setColor(t.get("tint"));
                            else {
                                var a = t.getColor && t.getColor();
                                e.setColor(a || rd.vec3.ONE)
                            }
                            n && (e.setTextureModel(t.getTextureModel()), "Opacity" === i && "alphaMask" === t.get("type") && e.set("maskThreshold", t.get("factor"))), this._prevChannel && this._prevChannel.off(null, this._updateTextureTransform), e.set("UVTransforms", t.get("UVTransforms")), t.on("change:UVTransforms", this._updateTextureTransform, {
                                inspect: e,
                                channel: t
                            }), t.on("change:UVOffset", this._updateTextureTransform, {
                                inspect: e,
                                channel: t
                            }), this._prevChannel = t
                        } else ud[i] || e.setFactor(0)
                    },
                    _setUVChecker: function (e, t) {
                        this.setupCheckerTexture(e);
                        var i = this.getCurrentMaterial() === t ? this.model.get("texCoord") : t.get("texCoordUnitList")[0];
                        e.setTexCoordUnit(i || 0)
                    },
                    _resetChannel: function (e) {
                        return e.get("backupJSON") ? e.setChannelJSON(e.get("backupJSON"), this.getImageCollection()) : e.set("backupJSON", (0, Uh.Z)(e.getJSON())), e
                    },
                    _resetState: function () {
                        var e = this.getShadingStyleModel();
                        e.set("type", this.model.get("referenceShadingType")), this.hasDisplayView("VertexColor") && e.set("vertexColorEnable", !0), this.hasDisplayView("VertexAlpha") && e.set("vertexColorUseAlpha", !0);
                        for (var t = this.model.get("materialList"), i = this.getMaterialModel().getMaterials(), n = 0; n < t.length; ++n) {
                            var r = i[t[n].uid].getChannels();
                            this._resetChannel(r.Inspector), this._resetChannel(r.Displacement), this._resetChannel(r.Opacity), this._resetChannel(r.Matcap), this._resetChannel(r.BumpMap), this._resetChannel(r.NormalMap), r.Opacity.isEffective() || r.Opacity.set("enable", !1)
                        }
                    },
                    onDisplayView: function () {
                        var e = this.model.get("displayView");
                        if (-1 !== this.model.get("availableDisplayView").indexOf(e)) {
                            this._resetState();
                            for (var t = this.getShadingStyleModel(), i = "Default" === e || "DefaultNoPostProcess" === e, n = "UVChecker" === e, r = "Wireframe" === e, a = "VertexColor" === e, o = "VertexAlpha" === e, s = "VertexNormal" === e, l = "Opacity" === e, u = "MatcapFlat" === e, c = "MatcapDetail" === e, h = "Bones" === e, d = "BoneWeights" === e, g = this.getMaterialModel().getMaterials(), f = this.model.get("materialList"), m = 0; m < f.length; ++m)
                                if (!i && !s) {
                                    var p = f[m],
                                        v = g[p.uid],
                                        _ = v.getChannels(),
                                        S = _.Inspector;
                                    S.setTextureModel(void 0);
                                    var x = _.Opacity;
                                    if (x.isEffective() && "refraction" === x.get("type") && x.set("type", "alphaBlend"), n) this._setUVChecker(S, v);
                                    else if (r) S.setColor(ld);
                                    else if (o) x.set("enable", !1);
                                    else if (!a)
                                        if (u || c || h || d) u && (_.BumpMap.set("enable", !1), _.NormalMap.set("enable", !1)), (h || d) && (_.Opacity.set("enable", !0), _.Opacity.set("factor", .1), _.Opacity.set("type", "additive")), _.Matcap.setChannelJSON(this._matcapJSON);
                                        else {
                                            var C = this._getDisplayedChannel(_, e, p);
                                            this._setDisplayChannel(S, C), C === _.Displacement ? _.Displacement.set("enable", !1) : C === x && x.set("enable", !1)
                                        }
                                }
                            o ? to.Z.uInspectorView.setInt(1) : h || d ? to.Z.uInspectorView.setInt(2) : to.Z.uInspectorView.setInt(0), this.updateVisible2D(), this.autoSelectUV();
                            var T = this._viewer.getRootModel();
                            this._normalVisitor.setNormalVisibility(s, T), Kn.setDebugNormal(s), this._drawBonesVisitor.setEnable(h || d, T), this._showControlBonesVisitor.setEnable(h && !d, T), Kn.setDebugSkeleton(h || d), d ? this._geoColorVisitor.setSkinningDebug(T) : this._geoColorVisitor.disableDebug(T), this.hasDisplayView("VertexColor") && t.set("vertexColorEnable", a || o || i), this.hasDisplayView("VertexAlpha") && t.set("vertexColorUseAlpha", !o && !l), r ? (this._backupWireframeEnable = t.get("wireframeEnable"), this._backupWireframeColor = t.get("wireframeColor"), t.set("wireframeColor", "000000FF"), t.set("wireframeEnable", !0)) : this._backupWireframeColor && (t.set("wireframeColor", this._backupWireframeColor), t.set("wireframeEnable", this._backupWireframeEnable), this._backupWireframeColor = void 0), u || c || h || d ? t.set("type", "matcap") : i || s || t.set("type", "inspector"), this.hasDisplayView("DefaultNoPostProcess") && this.getPostProcessModel().set("enable", "Default" === e), this.hasDisplayView("DefaultNoGround") && this.getGroundModel().set("enable", "Default" === e), U.Z.draw()
                        } else console.error("Unknown display view : " + e)
                    },
                    _onViewerToCanvasRatio: function () {
                        this._updateViewports(), U.Z.draw()
                    },
                    _updateViewports: function () {
                        var e = this._viewer.getFeatures(),
                            t = this._viewer.getCamera(),
                            i = e.postProcess.getCamera().getViewport(),
                            n = this._camera2D.getViewport(),
                            r = t.getViewport(),
                            a = r.width(),
                            o = r.height(),
                            s = this.getQualityModel().get("dynamicResolutionScaling"),
                            l = Math.round(a * s[0]),
                            u = Math.round(o * s[1]),
                            c = this.model.get("splitType"),
                            h = "split" === c;
                        h ? (i.setViewport(0, 0, l >> 1, u), n.setViewport(a >> 1, 0, a >> 1, o)) : "2d" === c ? (i.setViewport(0, 0, 1, 1), n.setViewport(0, 0, a, o)) : (i.setViewport(0, 0, l, u), n.setViewport(0, 0, 0, 0));
                        var d = h ? .5 : 1;
                        d *= this.model.get("viewerToCanvasRatio");
                        var g = t.getProjectionMatrix();
                        g[0] = g[5] * u / (l * d)
                    },
                    _updateSplitView: function () {
                        var e = this.getQualityModel(),
                            t = this.model.get("splitType"),
                            i = 1,
                            n = 1;
                        "split" === t ? i = .5 : "2d" === t && (i = 0, n = 0);
                        var r = e.get("dynamicResolutionScaling");
                        this._updateViewports(), this._viewer.trigger("resizeRatio", i, n, r[0], r[1])
                    }
                });
            var hd = {
                FeatureName: "inspector",
                ModelType: Bh,
                ViewListType: [cd]
            },
                dd = n.Z.create(hd);
            dd.prototype.getNode = function () {
                return this._views[0]._nodeInspector
            };
            const gd = dd;
            const fd = ir().Model.extend({
                defaults: {
                    enable: (0, l.Z)().arkit
                }
            });
            var md, pd, vd = g.Z.osg,
                _d = vd.mat4.fromRotation(vd.mat4.create(), .5 * Math.PI, vd.vec3.fromValues(1, 0, 0)),
                Sd = vd.mat4.fromRotation(vd.mat4.create(), .5 * -Math.PI, vd.vec3.fromValues(1, 0, 0)),
                xd = function () {
                    window.updateARKit = this._onARKitEvent.bind(this), this._cameraListeners = [], this._planeListeners = []
                };
            xd.prototype = {
                update: function () {
                    if (!this._lastARKitData) return !0;
                    for (var e = 0; e < this._cameraListeners.length; e++) this._cameraListeners[e].onCameraChange(this._lastARKitData.camera, this._lastARKitData.projection);
                    if (this._lastARKitData.planes.length)
                        for (var t = 0; t < this._planeListeners.length; t++) this._planeListeners[t].onPlanesChange(this._lastARKitData.planes);
                    return !0
                },
                _onARKitEvent: function (e) {
                    this._lastARKitData = e
                },
                getCameraMatrix: function (e, t) {
                    vd.mat4.multiply(e, t, Sd)
                },
                getMatrixTransformFromARPlane: (md = vd.vec3.create(), pd = vd.mat4.create(), function (e, t) {
                    vd.vec3.set(md, t.center[0], t.center[1], t.center[2]), vd.mat4.fromTranslation(e, md), vd.mat4.multiply(e, t.transform, e);
                    var i = vd.vec3.set(md, t.extent[0], 1, t.extent[2]);
                    vd.mat4.multiply(e, e, vd.mat4.fromScaling(pd, i)), vd.mat4.multiply(e, _d, e)
                }),
                addCameraListener: function (e) {
                    this._cameraListeners.push(e)
                },
                addPlaneListener: function (e) {
                    this._planeListeners.push(e)
                }
            };
            const Cd = new xd;
            var Td = g.Z.osg,
                Md = function (e) {
                    this._camera = e, this._prevFrame = {
                        valid: !1,
                        position: Td.mat4.create(),
                        direction: Td.mat4.create(),
                        speed: -1,
                        at: -1
                    }
                };
            Md.prototype = {
                onCameraChange: function (e, t) {
                    return !e || !t || (Cd.getCameraMatrix(this._camera.getViewMatrix(), e), Td.mat4.copy(this._camera.getProjectionMatrix(), t), !0)
                }
            };
            const bd = Md,
                yd = function (e) {
                    i.e(3991).then(i.bind(i, "BHVO")).then((function (t) {
                        e(t.default)
                    }))
                };
            var Ad = g.Z.osg,
                Rd = Ad.createTexturedQuadGeometry(-.5, 0, 0, 1, 0, 0, 0, 1, 0),
                wd = Ad.vec3.fromValues(0, 0, 1),
                Ed = Ad.vec3.create(),
                Pd = Ad.vec3.create(),
                Nd = Ad.mat4.create(),
                Od = function (e) {
                    Ad.MatrixTransform.call(this), this._camera = e;
                    var t = Ad.Uniform.createFloat1(.7, "uAlpha");
                    this._uAlpha = t.getInternalArray();
                    var i = Rd.getOrCreateStateSet();
                    i.setRenderBinDetails(Oe.Z.EDITOR_GIZMO, "RenderBin"), i.setAttributeAndModes(Le.Z.DEPTH_LESS_NO_WRITE), i.addUniform(t), i.setAttributeAndModes(Ne.Z.getOrCreateShader(fc, mc, "AR-Elevation-Widget", "ARElevation")), this.addChild(Rd), this.addUpdateCallback(this), this.setNodeMask(0)
                };
            Ad.createPrototypeNode(Od, Ad.objectInherit(Ad.MatrixTransform.prototype, {
                setVisible: function (e, t) {
                    e !== this._visible && (t || (t = .01), this._delay = t, this._visible = e, e && this.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._isFading = !0)
                },
                update: function (e, t) {
                    var i = t.getFrameStamp();
                    if (this._time = i.getSimulationTime(), this._updateTransforms(), this._isFading) return this._updateFading(), !0
                },
                _updateTransforms: function () {
                    if (this._anchorPoint) {
                        var e = this.getMatrix();
                        Ad.mat4.invert(Nd, this._camera.getViewMatrix()), Ad.mat4.getTranslation(Ed, Nd), Ed[2] = this._anchorPoint[2], Ad.mat4.lookAt(e, this._anchorPoint, Ed, wd), Ad.mat4.invert(e, e), Ad.mat4.setTranslation(e, this._anchorPoint);
                        var t = Ad.vec3.length(Ad.vec3.subtract(Ed, Ed, this._anchorPoint));
                        Ad.mat4.scale(e, e, Ad.vec3.set(Pd, .01 * t, this._elevation, 1))
                    }
                },
                _updateFading: function () {
                    this._startTime || (this._startTime = this._time);
                    var e = this._time - this._startTime;
                    e < this._delay ? this._visible ? this._uAlpha[0] = e / this._delay * .7 : this._uAlpha[0] = .7 * (1 - e / this._delay) : (this._visible || this.setNodeMask(0), this._startTime = 0, this._isFading = !1)
                },
                setAnchorAndElevation: function (e, t) {
                    this._anchorPoint = e, this._elevation = t
                }
            }), "osgtestdemo2024", "ElevationWidget");
            const Dd = Od;
            var Id = i("Lz+S");
            var Fd = new (ys())({
                device: "VWR",
                listen: !0
            }),
                Ld = g.Z.osg,
                Vd = .35,
                Bd = 1.5,
                Ud = .5,
                kd = Bd + Ud;
            (0, l.Z)().arkitDebug && (Bd = 200);
            var Zd = Ld.vec3.create(),
                Hd = Ld.vec3.create(),
                Gd = Ld.vec3.create(),
                zd = Ld.vec3.create(),
                Wd = Ld.vec3.create(),
                jd = Ld.vec3.create(),
                Xd = Ld.vec3.create(),
                Yd = V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this._viewer = this.options.context.getViewer(), this._featureNode = new Ld.MatrixTransform, this._featureNode.setName("Feature - ARKit"), this._arSceneNode = new Ld.MatrixTransform, this._arSceneNode.setName("ARKit - Scene"), this._featureNode.addChild(this._arSceneNode), L.Z.getModelDisplayed().then(this.onEnable.bind(this))
                    },
                    initGraphNode: function () {
                        this._elevationWidget = new Dd(this._viewer.getCamera()), this._proxyNode = new Ld.Node, this._proxyNode.setName("ARKit - Widget-Shadows"), this._proxyNode.setNodeMask(Pe.Z.NO_SHADOW), this._widgetNode = new Ld.Node, this._widgetNode.setName("ARKit - Widget");
                        var e = this._widgetNode.getOrCreateStateSet();
                        this._createWidgetStateSet(e);
                        var t = Ld.Uniform.createFloat(Vd, "uAlpha");
                        e.addUniform(t), this._uAlpha = t.getInternalArray(), e.setTextureAttributeAndModes(0, hr.Z.dummyTexture, Ld.StateAttribute.OVERRIDE), this._featureNode.addChild(this._proxyNode), this._proxyNode.addChild(this._widgetNode), this._shadowPlaneNode = new Ld.MatrixTransform, this._shadowPlaneNode.setName("ARKit - ShadowPlane"), (e = this._proxyNode.getOrCreateStateSet()).setShaderGeneratorName("shadow-ar"), this._setCommonStateSet(e)
                    },
                    _setCommonStateSet: function (e) {
                        e.setRenderBinDetails(Oe.Z.EXTRA, "RenderBin"), e.setAttributeAndModes(Le.Z.CULL_DISABLE), e.setAttributeAndModes(Le.Z.BLEND_SUBSTRACTIVE), e.setAttributeAndModes(Le.Z.DEPTH_LESS_NO_WRITE)
                    },
                    _createWidgetStateSet: function (e) {
                        var t = Ne.Z.getOrCreateShader("attribute vec3 Vertex;\n\nattribute vec2 TexCoord0;\nvarying vec2 vTexCoord0;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main(void) {\n  vTexCoord0 = TexCoord0;\n  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex.xyz, 1.0));\n}\n", 'varying vec2 vTexCoord0;\n\nuniform sampler2D uTextureIcon;\nuniform float uAlpha;\nuniform vec2 uScale;\n\n#pragma include "utils/functions.glsl"\n\nvoid main() {\n    vec2 uvCenter = vTexCoord0 * 2.0 - 1.0;\n\n    vec4 icon = texture2D(uTextureIcon, vTexCoord0 * uScale * 10.0);\n\n    float alpha = uAlpha * icon.a * clamp(1.0 - dot(uvCenter, uvCenter), 0.0, 1.0);\n\n    icon.rgb *= alpha;\n    icon.rgb = linearTosRGB(icon.rgb);\n    gl_FragColor = vec4(icon.rgb, alpha);\n}\n', "plane", "ArPlane");
                        return e.setAttributeAndModes(t), this._setCommonStateSet(e), e.addUniform(Ld.Uniform.createInt(0, "uTextureIcon")), e.addUniform(Ld.Uniform.createFloat(0, "uDisplay2D")), e.addUniform(Ld.Uniform.createFloat2(Ld.vec2.fromValues(1, 1), "uScale")), e
                    },
                    enableARShadows: function (e) {
                        e ? (this._proxyNode.addChild(this._shadowPlaneNode), this._proxyNode.dirtyBound()) : (this._proxyNode.removeChild(this._shadowPlaneNode), this._proxyNode.dirtyBound())
                    },
                    _setPlaneTexture: function (e) {
                        var t = s.Z.instance.getOrCreateTexture(e.SKFB_LOGO, {
                            internalFormat: Ld.Texture.RGBA
                        });
                        this._widgetNode.getOrCreateStateSet().setTextureAttributeAndModes(0, t.texture)
                    },
                    _getOrCreatePlaneGeometry: function () {
                        return this._planeGeom || (this._planeGeom = Ld.createTexturedQuadGeometry(-.5, 0, -.5, 1, 0, 0, 0, 0, 1), this._planeGeom.setName("PlaneGeometry")), this._planeGeom
                    },
                    initEvents: function () {
                        this.model.bind("change:enable", this.onEnable, this), this.model.bind("pick", this.onPick, this), Ve.Z.initAR(this)
                    },
                    onEnable: function () {
                        if (this.model.get("enable")) {
                            this._planeNodes = {}, this._globalTranslation = Ld.vec3.create(), this._globalScale = Ld.vec3.fromValues(1, 1, 1), this._globalRotation = Ld.mat4.create(), this._startMat = Ld.mat4.create(), this._startPos = Ld.vec2.create(), this._curPos = Ld.vec2.create(), this._elevation = 0, this.initGraphNode(), Fd.on("message:arShadows", function (e) {
                                this.enableARShadows(parseInt(e.data.arShadows, 10)), e.removeFromHash()
                            }.bind(this)), L.Z.getFirstAnimation().then(function () {
                                var e = this._viewer.getFeatures(),
                                    t = e.lighting;
                                t.getModel().setPreset("LightFromAbove"), t.getModel().set("enable", !0);
                                var i = e.environment;
                                if (i.getModel().get("enable")) i.getModel().set("shadowEnable", !1);
                                else {
                                    var n = s.Z.instance.getEnvironmentCollection();
                                    if (n.length) {
                                        var r = n.at(0).get("uid");
                                        i.getModel().set("uid", r)
                                    } else i.getModel().set("uid", "2fa15e0b1cee45a5b02605a288934e1b");
                                    i.getModel().set("shadowEnable", !1), i.getModel().set("enable", !0)
                                }
                                e.ground.getModel().set("enable", !1), this.enableARShadows(!0)
                            }.bind(this)), Ve.Z.setInspectorInputsEnable(!0), this.initEvents(), this._viewer.getViewerOSGJS().requestContinuousUpdate(!0), yd(this._setPlaneTexture.bind(this));
                            var e = this._viewer.getFeatures();
                            e.background.getModel().set("enable", "none"), e.postProcess.getModel().set("enable", !1), e.postProcess.getModel().set("AR", !0), e.hotspot.getWidgetNode().setNodeMask(0), e.autospin.getModel().set("enable", !1), this._featureNode.addUpdateCallback(Cd), this._widgetNode.addUpdateCallback(this), this._widgetNode.addChild(this._elevationWidget), Cd.addPlaneListener(this), Cd.addCameraListener(new bd(this._viewer.getCamera())), this._viewer.getViewerOSGJS().requestContinuousUpdate(!0), this._inputManager = this._viewer.getInputManager(), (0, l.Z)().arkitDebug ? (Rs()(".viewer").css("background", "rgba(125,125,125,255)"), e.camera.getModel().set("indexManipulator", Ee.FPS)) : (Rs()(".viewer").css("background", "rgba(0,0,0,0)"), this._inputManager.setEnable(Id.Z.SCENE, !1)), this._arSceneNode.setNodeMask(0), this._viewer.getCamera().getClearColor()[3] = 0, J.Z.getBoxReady().then(function () {
                                var e = J.Z.getModelBoxWithDisplacement(),
                                    t = e.getMin()[2];
                                this._bBoxHeight = e.getMax()[2] - t;
                                var i = 1 / this._bBoxHeight;
                                Ld.vec3.set(this._globalScale, i, i, i), this._invAnchorPoint = e.center(Ld.vec3.create()), this._invAnchorPoint[2] = t, Ld.vec3.negate(this._invAnchorPoint, this._invAnchorPoint), (0, l.Z)().arkitDebug && (this._viewer.getFeaturesManager().focusOnTargetAndEye(Ld.vec3.fromValues(0, 0, 0), Ld.vec3.fromValues(5, 5, 2), .1), this.onPlanesChange([{
                                    uid: "123",
                                    transform: Ld.mat4.IDENTITY,
                                    center: Ld.vec3.ZERO,
                                    extent: Ld.vec3.fromValues(10, 1, 10)
                                }]));
                                var n = e.radius() * i;
                                this._shadowPlaneGeom = Ld.createTexturedQuadGeometry(-n, -n, 0, 2 * n, 0, 0, 0, 2 * n, 0), this._shadowPlaneNode.addChild(this._shadowPlaneGeom), this._shadowPlaneNode.dirtyBound()
                            }.bind(this))
                        }
                    },
                    getFeatureNode: function () {
                        return this._featureNode
                    },
                    getWidgetNode: function () {
                        return this._widgetNode
                    },
                    getArSceneNode: function () {
                        return this._arSceneNode
                    },
                    update: function (e, t) {
                        var i = t.getFrameStamp();
                        if (this._time = i.getSimulationTime(), this._modelPlaced) {
                            var n = this._time - this._hitTime;
                            return n < Ud && (this._uAlpha[0] = n / Ud * Vd), n > Bd && n < kd && (this._uAlpha[0] = (1 - (n - Bd) / Ud) * Vd), !0
                        }
                    },
                    onPick: function (e) {
                        var t = Fe.Z.computeNearestIntersection2D(e[0], e[1], Pe.Z.PICK_GEOMETRY_FAST, this._widgetNode);
                        this._hitTime = this._time, t && (this._modelPlaced = !0, Ld.vec3.transformMat4(this._globalTranslation, t._localIntersectionPoint, Ld.computeLocalToWorld(t._nodePath.slice(1))), this._arSceneNode.setNodeMask(-1), this._updateSceneTransforms(), window.location.hash = "buzz", window.setTimeout((function () {
                            window.location.hash = ""
                        }), 200))
                    },
                    _updateSceneTransforms: function () {
                        var e = this._arSceneNode.getMatrix();
                        Ld.mat4.fromTranslation(e, this._globalTranslation), Ld.mat4.multiply(e, e, this._globalRotation), Ld.mat4.scale(e, e, this._globalScale), Ld.mat4.translate(e, e, this._invAnchorPoint), Ld.mat4.translate(e, e, Ld.vec3.set(Zd, 0, 0, this._elevation));
                        var t = this._elevation >= 0 ? this._bBoxHeight : 0;
                        this._elevationWidget.setAnchorAndElevation(this._globalTranslation, (this._elevation + t) * this._globalScale[0]);
                        var i = this._shadowPlaneNode.getMatrix();
                        Ld.mat4.fromTranslation(i, this._globalTranslation);
                        for (var n = this._viewer.getFeatures().lighting.getModel().get("lights"), r = 0; r < n.length; r++) {
                            var a = n[r];
                            a.isCastingShadows() && a.dirty()
                        }
                        this._arSceneNode.dirtyBound(), this._shadowPlaneNode.dirtyBound()
                    },
                    _getPlaneNode: function (e) {
                        var t = this._planeNodes[e];
                        if (!t) {
                            this._hitTime = this._time, (t = new Ld.MatrixTransform).addChild(this._getOrCreatePlaneGeometry());
                            var i = t.getOrCreateStateSet(),
                                n = Ld.Uniform.createFloat2(Ld.vec2.fromValues(1, 1), "uScale");
                            i.addUniform(n), t._uScale = n.getInternalArray(), this._planeNodes[e] = t
                        }
                        return t
                    },
                    onPlanesChange: function (e) {
                        for (var t in this._planeNodes) {
                            var i = this._planeNodes[t];
                            i.updated = !1
                        }
                        for (var n, r = 0; r < e.length; r++) {
                            var a = e[r];
                            n = this._getPlaneNode(a.uid), Cd.getMatrixTransformFromARPlane(n.getMatrix(), a), n._uScale[0] = a.extent[0], n._uScale[1] = a.extent[2], 0 === n.getParents().length && this._widgetNode.addChild(n), n.updated = !0, n.dirtyBound()
                        }
                        for (t in this._planeNodes) !(i = this._planeNodes[t]).updated && n.getParents().length && this._widgetNode.removeChild(i);
                        this._widgetNode.dirtyBound()
                    },
                    startMotion: function (e) {
                        this._inputManager.setEnable(Id.Z.MANIPULATORS, !1), Ld.vec2.set(this._startPos, e.canvasX, e.canvasY)
                    },
                    endMotion: function () {
                        this._inputManager.setEnable(Id.Z.MANIPULATORS, !0), this.endElevate(), this.endRotate(), this.endScale()
                    },
                    motion: function (e) {
                        if (this._rotating) this.rotate(e);
                        else if (this._scaling) {
                            Ld.vec2.set(this._curPos, e.canvasX, e.canvasY);
                            var t = this._viewer.getCanvas().height,
                                i = 1 - (this._curPos[1] - this._startPos[1]) / t;
                            e.scale = i, this.scale(e)
                        } else this._elevating && this.elevate(e)
                    },
                    startRotate: function (e) {
                        this._rotating = !0, Ld.vec2.set(this._startPos, e.canvasX, e.canvasY), Ld.mat4.copy(this._startMat, this._globalRotation)
                    },
                    endRotate: function () {
                        this._rotating = !1
                    },
                    rotate: function (e) {
                        this._rotating || this.startRotate(e), Ld.vec2.set(this._curPos, e.canvasX, e.canvasY);
                        var t = this._viewer.getCanvas().width,
                            i = (this._curPos[0] - this._startPos[0]) / t * Math.PI * 2;
                        Ld.mat4.rotateZ(this._globalRotation, this._startMat, i), this._updateSceneTransforms()
                    },
                    startScale: function () {
                        this._scaling = !0, this._initScale = this._globalScale[0]
                    },
                    endScale: function () {
                        this._scaling = !1
                    },
                    scale: function (e) {
                        var t = Math.max(e.scale * this._initScale, 1e-8);
                        Ld.vec3.set(this._globalScale, t, t, t), this._updateSceneTransforms()
                    },
                    startElevate: function (e) {
                        this._elevating = !0, this._initElevation = this._elevation, Ld.vec2.set(this._startPos, e.glX, e.glY), this._startWorldElevation = this._getElevationFromScreenCoord(this._startPos), this._elevationWidget.setVisible(!0, Ud), this._hitTime = this._time
                    },
                    endElevate: function () {
                        this._elevating = !1, this._elevationWidget.setVisible(!1, Ud)
                    },
                    elevate: function (e) {
                        this._elevating || this.startElevate(e), Ld.vec2.set(this._curPos, e.glX, e.glY);
                        var t = this._getElevationFromScreenCoord(this._curPos) - this._startWorldElevation;
                        this._elevation = this._initElevation + t, this._elevation < 0 && (this._elevation = 0), this._updateSceneTransforms()
                    },
                    _getElevationFromScreenCoord: function (e) {
                        Ld.vec2.copy(Gd, e), Gd[2] = 0, Fe.Z.getWorldPositionFromScreenPoint(Gd, zd), Gd[2] = 1, Fe.Z.getWorldPositionFromScreenPoint(Gd, Wd), Ld.vec3.sub(Xd, Wd, zd), Ld.vec3.normalize(Xd, Xd), Ld.mat4.getLookAt(jd, Zd, Hd, this._viewer.getCamera().getViewMatrix()), Ld.vec3.subtract(jd, jd, Zd), jd[2] = 0, Ld.vec3.normalize(jd, jd), Ld.mat4.getTranslation(Zd, this._featureNode.getMatrix());
                        var t = Ld.vec3.length(this._globalTranslation),
                            i = Ld.vec3.dot(jd, Xd),
                            n = -(Ld.vec3.dot(jd, zd) + t) / i;
                        return 0 === i && (n = 0), Ld.vec3.scaleAndAdd(Zd, zd, Xd, n), Zd[2] / this._globalScale[0]
                    }
                });
            var Jd = {
                FeatureName: "ARKit",
                ModelType: fd,
                ViewListType: [Yd]
            },
                qd = n.Z.create(Jd);
            qd.prototype.getNodeIn = function () {
                return this._views[0].getFeatureNode()
            }, qd.prototype.getNodeOut = function () {
                return this._views[0].getArSceneNode()
            }, qd.prototype.getWidgetNode = function () {
                return this._views[0].getWidgetNode()
            };
            const Kd = qd;
            var Qd = i("/c5M"),
                $d = a.Z.extend({
                    _trashbin: [],
                    defaults: {
                        progress: 0
                    },
                    getModelOptionPath: function () {
                        return "ground"
                    },
                    getName: function () {
                        return "Ground"
                    },
                    init: function (e) {
                        var t = e.getModel().get("options");
                        this._globalModel = e.getModel(), this.setJSON(t.ground);
                        var i = this.get("aoTextureUid"),
                            n = !1;
                        if (i) {
                            var r = s.Z.instance.getTextureCollection().get(i);
                            r && (r.set("internal", !0), n = !0)
                        }
                        "BakedAO" !== this.get("shadowMode") || n || (this.set("enable", !1), i ? (console.log("Ground: Couldn't load texture " + i + " for model " + e._model.id), Qd.Z.client.captureMessage("Ground: Couldn't load texture " + i + " for model " + e._model.id)) : Qd.Z.client.captureMessage("Ground: Model " + e._model.id + " is in BakedAO mode but doesn't have an aoTextureUid"))
                    },
                    _adaptJSON: function (e) {
                        if (void 0 === e.scale) {
                            e.scale = 0, e.position = [0, 0, 0];
                            var t = 1.5,
                                i = 0;
                            void 0 !== e.size && (t = e.size, i = e.height), J.Z.getBoxReady().then(this._updateTransforms.bind(this, i, t, !0))
                        }
                    },
                    _updateTransforms: function (e, t, i) {
                        var n = J.Z.getModelBoxWithDisplacement();
                        "BakedAO" === this.get("shadowMode") && (t = 1.5);
                        var r = n.radius() * t;
                        this.set("scale", r), 0 === e && (e = 1e-4);
                        var a = this.get("position");
                        n.center(a);
                        var o = n.getMax()[2] - n.getMin()[2];
                        a[2] = n.getMin()[2] + o * e, i ? this.trigger("transformInit") : this.trigger("transformChanged")
                    },
                    startRender: function () {
                        this._globalModel.trigger("status:pending")
                    },
                    stopRender: function () {
                        this._globalModel.trigger("status:loaded")
                    }
                });
            const eg = $d;
            var tg = i("hySD");
            var ig = g.Z.osgShader.shaderProcessor,
                ng = g.Z.osgUtil,
                rg = g.Z.osg,
                ag = function (e, t, i, n, r) {
                    this._textureSize = e, this._nodeFeature = t, this._viewer = i, this._nbFrames = 0, this._targetNode = n, this._nbSamples = r || 300, this._progress = 0, this._samplingRange = 1, this._validRender = !1, this._renderedCanvas = document.createElement("canvas"), this._init()
                };
            ag.prototype = {
                _init: function () {
                    this.initComposer(), this.initShadowCamera(), this.initLightMapCamera(), this._nodeFeature.addChild(this._shadowCamera), this._nodeFeature.addChild(this._lightMapCamera), this._nodeFeature.addChild(this._composer), this._nodeFeature.addUpdateCallback(this)
                },
                getFinalTexture: function () {
                    return this._render ? this._currentlightMap : this._composer.getInternalTexture("FinalTexture1")
                },
                requestRender: function () {
                    this._render && this.stopRender(), this._shadowCamera.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._lightMapCamera.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._render = !0, U.Z.draw()
                },
                onFrameRendered: function (e) {
                    this._frameCallback = e
                },
                stopRender: function () {
                    this._render && (this._nbFrames = 0, this._render = !1, this._progress = 0, this._shadowCamera.setNodeMask(0), this._lightMapCamera.setNodeMask(0), this._composer.setNodeMask(0))
                },
                update: function (e, t) {
                    if (!this._render || !L.Z.getModelDisplayed().isFulfilled()) return !0;
                    var i = t.getFrameStamp();
                    return this._estimatedTime = i.getDeltaTime() * this._nbSamples, this._nbFrames > this._nbSamples && (this._shadowCamera.setNodeMask(0), this._lightMapCamera.setNodeMask(0), this._composer.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._getLastComposerCamera().setFinalDrawCallback(function (e) {
                        this._renderedCanvas = (0, tg.i)(e, this._textureSize, this._textureSize, this._renderedCanvas)
                    }.bind(this))), this._nbFrames > this._nbSamples + 1 ? (this._validRender = !0, this.stopRender(), this._progress = 100, this._frameCallback && this._frameCallback(!0), this._getLastComposerCamera().setFinalDrawCallback(void 0), !0) : (this._nbFrames++, this._uNumFrames.getInternalArray()[0] = this._nbFrames, this.updateCameras(), U.Z.draw(), this.swapLightMaps(), this._frameCallback && this._frameCallback(), this._progress = this._nbFrames / this._nbSamples * 100, !0)
                },
                getRenderedCanvas: function () {
                    return this._renderedCanvas
                },
                isValidRender: function () {
                    return this._validRender
                },
                getProgress: function () {
                    return this._progress
                },
                getEstimatedTime: function () {
                    return this._estimatedTime
                },
                setNbSamples: function (e) {
                    this._nbSamples = e
                },
                initComposer: function () {
                    this._composer = new ng.ComposerPostProcess, this._composer.setOffscreen(!0), this._composer.setScreenSize(this._textureSize, this._textureSize), this._composer.setNodeMask(0), this._composer.addInternalTexture({
                        name: "LightMap1",
                        immuable: !0,
                        srgb: !1,
                        reusable: !1
                    }), this._composer.addInternalTexture({
                        name: "FinalTexture1",
                        immuable: !0,
                        srgb: !1,
                        reusable: !1
                    }), this._composer.setInputTexture("LightMap1"), ig.addShaders({
                        "blurBakedAo.glsl": '#pragma include "utils/encodeDecode.glsl"\n\nuniform float uInvTextureSize;\n\nvec4 adaptativeBoxBlur(){\n    float ao = decode24(TEXTURE_2D_TextureBlur(gTexCoord).rgb);\n    float kernel = 3.0;\n\n    if (ao < 0.2 ){\n        float o = 0.2;\n        ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(-o, o) * uInvTextureSize).rgb);\n        ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(o, o) * uInvTextureSize).rgb);\n        ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(o, -o) * uInvTextureSize).rgb);\n        ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(-o, -o) * uInvTextureSize).rgb);\n        ao *= 0.2;\n        return vec4(ao, ao, ao, 1.0);\n    }\n\n    ao = 0.0;\n\n    // webgl 1.0 goodness, only constant bounds for for loops iteration.\n    if (ao < 0.4 ){\n        kernel = 3.0;\n        for (float i = -1.0; i <= 1.0; i++){\n            for (float j = -1.0; j <= 1.0; j++){\n                ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(i, j) * uInvTextureSize).rgb);\n            }\n        }\n    } else if (ao < 0.6 ){\n        kernel = 7.0;\n        for (float i = -3.0; i <= 3.0; i++){\n            for (float j = -3.0; j <= 3.0; j++){\n                ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(i, j) * uInvTextureSize).rgb);\n            }\n        }\n    } else if (ao < 0.8 ){\n        kernel = 9.0;\n        for (float i = -4.0; i <= 4.0; i++){\n            for (float j = -4.0; j <= 4.0; j++){\n                ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(i, j) * uInvTextureSize).rgb);\n            }\n        }\n    } else if(ao < 1.0 ){\n        kernel = 11.0;\n        for (float i = -5.0; i <= 5.0; i++){\n            for (float j = -5.0; j <= 5.0; j++){\n                ao += decode24(TEXTURE_2D_TextureBlur(gTexCoord + vec2(i, j) * uInvTextureSize).rgb);\n            }\n        }\n    }\n\n    ao /= kernel * kernel;\n\n    return vec4(ao, ao, ao, 1.0);\n}\n'
                    });
                    var e = [],
                        t = rg.Uniform.createFloat(1 / this._textureSize, "uInvTextureSize");
                    e.push({
                        func: {
                            name: "adaptativeBoxBlur",
                            file: "blurBakedAo.glsl"
                        },
                        uniforms: [t],
                        textures: {
                            name: "LightMap1",
                            uniformName: "TextureBlur"
                        },
                        out: {
                            name: "FinalTexture1",
                            filter: "linear"
                        }
                    }), this._composer.build(e);
                    for (var i = 0; i < this._composer.getCameras().length; i++) {
                        this._composer.getCameras()[i].setRenderOrder(rg.Camera.PRE_RENDER, 1)
                    }
                },
                _getLastComposerCamera: function () {
                    var e = this._composer.getCameras();
                    return e[e.length - 1]
                },
                initShadowCamera: function () {
                    this._shadowCamera = new rg.Camera, this._shadowCamera.setName("ShadowCam"), this._shadowCamera.setClearColor(rg.vec4.fromValues(1, 1, 1, 1)), this._shadowCamera.setRenderOrder(rg.Camera.PRE_RENDER, 0), this._shadowCamera.setReferenceFrame(rg.Transform.ABSOLUTE_RF), this._shadowCamera.setViewport(new rg.Viewport(0, 0, this._textureSize, this._textureSize)), this._shadowCamera.setNodeMask(0), this._shadowCamera.setComputeNearFar(!1);
                    var e = new rg.Texture;
                    e.setTextureSize(this._textureSize, this._textureSize), e.setMinFilter("LINEAR"), e.setMagFilter("LINEAR"), this._shadowCamera.attachTexture(rg.FrameBufferObject.COLOR_ATTACHMENT0, e), this._shadowCamera.attachRenderBuffer(rg.FrameBufferObject.DEPTH_ATTACHMENT, rg.FrameBufferObject.DEPTH_COMPONENT16);
                    var t = new rg.MatrixTransform;
                    t.setMatrix(this._viewer.getFeatures().orientation.getModel().get("matrix")), t.addChild(this._viewer.getRootModel()), this._shadowCamera.addChild(t);
                    var i = this._shadowCamera.getOrCreateStateSet();
                    i.setTextureAttributeAndModes(0, e, rg.StateAttribute.ON), i.setShaderGeneratorName("shadow-ao-bake"), i.setAttributeAndModes(Le.Z.DEPTH_LESS_WRITE, rg.StateAttribute.ON | rg.StateAttribute.OVERRIDE | rg.StateAttribute.PROTECTED), this._shadowMap = e
                },
                initLightMapCamera: function () {
                    this._lightMapCamera = new rg.Camera, this._lightMapCamera.setName("LightMapCam"), this._lightMapCamera.setClearColor(rg.vec4.fromValues(1, 1, 1, 1)), this._lightMapCamera.setRenderOrder(rg.Camera.PRE_RENDER, 1), this._lightMapCamera.setReferenceFrame(rg.Transform.ABSOLUTE_RF), this._lightMapCamera.setViewport(new rg.Viewport(0, 0, this._textureSize, this._textureSize)), this._lightMapCamera.setNodeMask(0), this._lightMapCamera.setComputeNearFar(!1), this._lightMap1 = this._composer.getInternalTexture("LightMap1"), this._lightMap1.setMinFilter("LINEAR"), this._lightMap1.setMagFilter("LINEAR"), this._lightMapCamera.attachTexture(rg.FrameBufferObject.COLOR_ATTACHMENT0, this._lightMap1), this._lightMap2 = new rg.Texture, this._lightMap2.setTextureSize(this._textureSize, this._textureSize), this._lightMap2.setMinFilter("LINEAR"), this._lightMap2.setMagFilter("LINEAR"), this._lightMapCamera.addChild(this._targetNode);
                    var e = this._lightMapCamera.getOrCreateStateSet();
                    e.setAttributeAndModes(Ne.Z.getOrCreateShader("attribute vec2 TexCoord0;\nattribute vec3 Vertex;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec4 vProjCoord;\n\nvoid main(void) {\n  gl_Position = vec4(TexCoord0 * 2.0 - 1.0, 0.0, 1.0);\n  vProjCoord = uModelViewMatrix * vec4(Vertex.xyz, 1.0);\n  vProjCoord = uProjectionMatrix * vProjCoord;\n  vProjCoord = vProjCoord / vProjCoord.w * 0.5 + 0.5;\n}\n", "#pragma include \"utils/encodeDecode.glsl\"\n\nuniform sampler2D uShadowMap;\nuniform sampler2D uPrevLightMap;\nuniform float uNumFrames;\nuniform float uTextureSize;\n\nvarying vec4 vProjCoord;\n\nvec4 accumulateShadow(const in vec4 projCoord, const in sampler2D shadowMap, const in sampler2D prevLightMap, const in float numFrames, const in float textureSize ){\n    float depth = decode24(texture2D(shadowMap, projCoord.xy).rgb);\n    float prevShadow = decode24(texture2D(prevLightMap, gl_FragCoord.xy / textureSize).rgb);\n\n\n    // here should be step (projCoord.z, depth) for proper comparison.\n    // but I still have some precision issue I can't sort out for now\n    // step (1.0, depth) is actually putting shadows everywhere the depth has been written, even when behind the ground\n    // It's only a problem for scenes that already have a ground geometry that has been made transparent,\n    // has the shader doesnt take opacity into account.\n    float currentShadow = step (1.0, depth);\n\n    // limits of light frustum\n    if (any(bvec4 ( projCoord.x > 1., projCoord.x < 0., projCoord.y > 1., projCoord.y < 0.))) {\n       currentShadow = 1.0;\n    }\n\n    float s = mix(prevShadow , currentShadow, 1.0 / numFrames);\n    return vec4(encode24(s),1.0);\n}\n\n\nvoid main(void) {\n    gl_FragColor = accumulateShadow(vProjCoord, uShadowMap, uPrevLightMap, uNumFrames, uTextureSize);\n}\n", "ground-bakeao", "GroundBakeAo"), rg.StateAttribute.ON | rg.StateAttribute.OVERRIDE | rg.StateAttribute.PROTECTED), e.setTextureAttributeAndModes(1, this._shadowMap, rg.StateAttribute.ON), e.addUniform(rg.Uniform.createInt(1, "uShadowMap")), e.setTextureAttributeAndModes(2, hr.Z.dummyTexture, rg.StateAttribute.ON), e.addUniform(rg.Uniform.createInt(2, "uPrevLightMap")), this._uNumFrames = rg.Uniform.createFloat(0, "uNumFrames"), e.addUniform(this._uNumFrames), this._uTextureSize = rg.Uniform.createFloat(this._textureSize, "uTextureSize"), e.addUniform(this._uTextureSize), this._currentlightMap = this._lightMap2
                },
                swapLightMaps: function () {
                    var e = this._lightMapCamera.getOrCreateStateSet();
                    this._currentlightMap && e.setTextureAttributeAndModes(2, this._currentlightMap, rg.StateAttribute.ON), this._currentlightMap === this._lightMap1 ? this._currentlightMap = this._lightMap2 : this._currentlightMap = this._lightMap1, e.setTextureAttributeAndModes(0, this._currentlightMap, rg.StateAttribute.ON), this._lightMapCamera.attachTexture(rg.FrameBufferObject.COLOR_ATTACHMENT0, this._currentlightMap)
                },
                setSceneData: function (e, t) {
                    this._bounds = e, this._transform = t
                },
                updateCameras: function () {
                    var e = rg.mat4.create(),
                        t = rg.vec3.create(),
                        i = rg.vec3.create();
                    return function () {
                        var n = this._bounds.radius();
                        rg.mat4.getTranslation(t, this._transform.getMatrix()), rg.mat4.copy(e, rg.mat4.IDENTITY), this.getRandomPoint(i), rg.vec3.scale(i, i, n), rg.vec3.add(i, t, i), rg.mat4.lookAt(e, i, t, [0, 0, 1]);
                        var r = 2 * n,
                            a = r / 1e3;
                        rg.mat4.ortho(this._shadowCamera.getProjectionMatrix(), -n, n, -n, n, a, r), rg.mat4.copy(this._shadowCamera.getViewMatrix(), e), rg.mat4.copy(this._lightMapCamera.getViewMatrix(), this._shadowCamera.getViewMatrix()), rg.mat4.copy(this._lightMapCamera.getProjectionMatrix(), this._shadowCamera.getProjectionMatrix())
                    }
                }(),
                getRandomPoint: function (e) {
                    var t = qr.Z.hemisphereSampleUniform(this._nbFrames, this._nbSamples * (1 / this._samplingRange));
                    rg.vec3.set(e, t[0], t[1], t[2])
                }
            };
            const og = ag;
            var sg = g.Z.osg,
                lg = "BakedAO",
                ug = function (e, t) {
                    sg.StateAttribute.call(this), this._enable = t || !1, this._useBakedAo = e === lg, this._displayPlane = !1
                };
            ug.prototype = sg.objectLibraryClass(sg.objectInherit(sg.StateAttribute.prototype, {
                attributeType: "GroundStateAttribute",
                cloneType: function () {
                    return new ug(!0)
                },
                setEnabled: function (e) {
                    this._enable = e
                },
                isEnabled: function () {
                    return this._enable
                },
                isUseBakedAo: function () {
                    return this._useBakedAo
                },
                setDisplayPlane: function (e) {
                    this._displayPlane = e
                },
                isDisplayPlane: function () {
                    return this._displayPlane
                },
                getHash: function () {
                    return "Ground" + this._useBakedAo + this._displayPlane
                }
            }), "osgtestdemo2024", "GroundStateAttribute"), sg.setTypeID(ug);
            var cg = V.Z.extend({
                initialize: function () {
                    V.Z.prototype.initialize.apply(this, arguments);
                    var e = this.model;
                    this.listenTo(e, "change:enable", this.onEnableChanged), this._resourceDefer = new bt.Z, this.options.context.getScene().addResourcePromise(this._resourceDefer.promise), this._nodeFeature = new sg.Node, this._nodeFeature.setName("Feature - Ground"), this._transform = new sg.MatrixTransform, this._transform.setName("Ground - Transform"), this._transform.setNodeMask(Pe.Z.NO_PICK_NO_SHADOW), this._geometry = sg.createTexturedQuadGeometry(-1, -1, 0, 2, 0, 0, 0, 2, 0), this._geometry.setName("Ground - Geometry"), this._geometry.setNodeMask(0), this._transform.addChild(this._geometry), this._viewer = this.options.context.getViewer(), this._needBake = !1;
                    var t = this._transform.getOrCreateStateSet();
                    this._uFade = sg.Uniform.createFloat("uGroundFade"), this._uOpacity = sg.Uniform.createFloat("uGroundOpacity");
                    var i = sg.Uniform.createFloat(1, "uWidgetFade");
                    t.addUniform(this._uFade), t.addUniform(this._uOpacity), t.addUniform(i), this._uWidgetFade = i.getInternalArray(), this._widgetFadeDirection = 1, e.get("enable") && this.onEnableChanged(), this.model.set("lastRenderHeight", this.model.get("height")), this.model.set("lastRenderSamplingRange", this.model.get("samplingRange")), this._nodeFeature.addUpdateCallback(this), e.get("enable") && e.get("shadowMode") === lg || this._resourceDefer.resolve()
                },
                registerEvents: function () {
                    this.listenTo(this.model, "change:opacity", this.onOpacityChanged), this.listenTo(this.model, "change:fade", this.onFadeChanged), this.listenTo(this.model, "transformChanged", this._onTransformChanged), this.listenTo(this.model, "transformInit", this._onPositionOrScaleChange), this.listenTo(this.model, "change:shadowMode", this.onShadowModeChanged), this.listenTo(this.model, "change:samplingRange", this.onSamplingRangeChanged), this.listenTo(this.model, "cancelRequested", this.cancelRender)
                },
                unRegisterEvents: function () {
                    this.stopListening(this.model), this.listenTo(this.model, "change:enable", this.onEnableChanged)
                },
                initStateSet: function () {
                    var e = this._geometry.getOrCreateStateSet();
                    e.setName("Ground"), e.setShaderGeneratorName("ground"), e.setRenderBinDetails(Oe.Z.TRANSPARENT_CUSTOM_EARLYZ, "RenderBin"), e.setAttribute(Le.Z.CULL_BACK), this._initialized = !0
                },
                onShadowModeChanged: function () {
                    var e = this._geometry.getOrCreateStateSet(),
                        t = this.model.get("shadowMode"),
                        i = t === lg;
                    if (this._geometry.setNodeMask(0), this._groundStateAttrib = new ug(t, !0), e.setAttributeAndModes(this._groundStateAttrib), this.cleanUpTexture(this._lightMapper, e), i) {
                        var n = this.model.get("aoTextureUid");
                        n && !this._needBake ? this._setupBakedAoTexture(n) : this._setupLightMapper()
                    } else this._geometry.setNodeMask(-1), U.Z.draw();
                    this._onPositionOrScaleChange()
                },
                _setupBakedAoTexture: function (e) {
                    var t = s.Z.instance.getOrCreateMultiresTexture(e, {
                        minFilter: sg.Texture.LINEAR,
                        magFilter: sg.Texture.LINEAR,
                        wrapS: sg.Texture.CLAMP_TO_EDGE,
                        wrapT: sg.Texture.CLAMP_TO_EDGE,
                        internalFormat: sg.Texture.RGBA
                    }).resource;
                    t.setForceUpload(!0), t.isTextureNull() && (t.setTextureSize(1, 1), t.setImage(new Uint8Array([255, 255, 255, 255])));
                    var i = this._geometry.getOrCreateStateSet();
                    i.setTextureAttributeAndModes(0, t, sg.StateAttribute.ON | sg.StateAttribute.OVERRIDE | sg.StateAttribute.PROTECTED), i.addUniform(sg.Uniform.createInt(0, "uTexture")), this._geometry.setNodeMask(-1), (0, l.Z)().preload ? t.getImageMaxSupported().promise.then(function () {
                        t.setImageMaxSupported(), this._resourceDefer.resolve()
                    }.bind(this)) : t.setImageSmallest().promise.then(function () {
                        this._resourceDefer.resolve(), t.setImageMaxSupported()
                    }.bind(this)), this.model.set("lastRenderHeight", this.model.get("height")), this.model.set("lastRenderSamplingRange", this.model.get("samplingRange"))
                },
                _setupLightMapper: function () {
                    var e = this._geometry.getOrCreateStateSet();
                    if (this._lightMapper) return this._lightMapper.isValidRender() ? this._restoreTexture() : this._needBake = !0, void (this._needBake && this._bake());
                    this._lightMapper = new og(512, this._nodeFeature, this._viewer, this._transform, 600), e.addUniform(sg.Uniform.createInt(0, "uTexture")), this._lightMapper.onFrameRendered(function (t) {
                        if (e.setTextureAttributeAndModes(0, this._lightMapper.getFinalTexture(), sg.StateAttribute.ON), this._geometry.setNodeMask(-1), this.model.set("progress", this._lightMapper.getProgress()), this.model.set("estimatedTime", this._lightMapper.getEstimatedTime()), t) {
                            if (this.model.stopRender(), !this.model.get("dirty")) {
                                this.model.set("dirty", !0);
                                var i = this.model.get("aoTextureUid");
                                i && this.model._trashbin.push(new Oo.Z({
                                    uid: i
                                })), this.model.set("aoTextureUid", void 0)
                            }
                            this.model.set("imageCanvas", this._lightMapper.getRenderedCanvas()), this.model.set("lastRenderHeight", this.model.get("height")), this.model.set("lastRenderSamplingRange", this.model.get("samplingRange"))
                        }
                    }.bind(this)), J.Z.getBoxReady().then(function () {
                        var e = J.Z.getModelBoxWithDisplacement();
                        this._lightMapper.setSceneData(e, this._transform), this._lightMapper._samplingRange = this.model.get("samplingRange"), this._bake(100)
                    }.bind(this))
                },
                _restoreTexture: function () {
                    var e = new sg.Texture;
                    e.setImage(this.model.get("imageCanvas")), this._geometry.getOrCreateStateSet().setTextureAttributeAndModes(0, e, sg.StateAttribute.ON), this._geometry.setNodeMask(-1), U.Z.draw()
                },
                cancelRender: function () {
                    if (this._lightMapper)
                        if (this._lightMapper.stopRender(), this.model.stopRender(), this._holdBake = !0, this.model.set("height", this.model.get("lastRenderHeight")), this.model.set("samplingRange", this.model.get("lastRenderSamplingRange")), this._holdBake = !1, this.model.set("progress", 100), this.model.set("estimatedTime", 0), this._lightMapper.isValidRender()) this._restoreTexture();
                        else {
                            var e = this.model.get("aoTextureUid");
                            e ? (this._setupBakedAoTexture(e), this.model.set("dirty", !1), this.model._trashbin.length = 0) : bi.Z.get("mask") & bi.Z.LIT ? this.model.set("shadowMode", "ShadowCatcher") : this.model.set("enable", !1)
                        }
                },
                onSamplingRangeChanged: function () {
                    this._lightMapper || this._setupLightMapper(), this._lightMapper._samplingRange = this.model.get("samplingRange"), this._bake()
                },
                cleanUpTexture: function (e, t) {
                    e && t.setTextureAttributeAndModes(0, e.getFinalTexture(), sg.StateAttribute.OFF)
                },
                getNodeGround: function () {
                    return this._nodeFeature
                },
                onOpacityChanged: function () {
                    this._uOpacity.setFloat(Math.max(0, this.model.get("opacity"))), U.Z.draw()
                },
                onFadeChanged: function () {
                    this._uFade.setFloat(this.model.get("fade")), U.Z.draw()
                },
                onEnableChanged: function () {
                    var e = this._geometry.getOrCreateStateSet();
                    this._nodeFeature.removeChild(this._transform), Kn.registerStateSetIsTransparent(e, !1), this.model.get("enable") ? (this.registerEvents(), this._onPositionOrScaleChange(), this._nodeFeature.addChild(this._transform), this._initialized || this.initStateSet(), this.onShadowModeChanged(), this.onFadeChanged(), this.onOpacityChanged(), Kn.registerStateSetIsTransparent(e, !0), this._lightMapper && !this._lightMapper.isValidRender() && this._bake(1)) : this.unRegisterEvents(), U.Z.draw()
                },
                _onTransformChanged: function () {
                    this._lightMapper || this.model.get("shadowMode") !== lg || this._setupLightMapper(), this._onPositionOrScaleChange(), this._needBake = !0, this.model.get("shadowMode") === lg && this._bake(), this._displayPlane(), U.Z.draw()
                },
                _displayPlane: function () {
                    this.model.get("enable") && (0, o.Z)() && (this._groundStateAttrib.setDisplayPlane(!0), this._geometry.getOrCreateStateSet().setAttribute(Le.Z.CULL_DISABLE), this._widgetFadeDirection = -1, this._schedulePlane && clearTimeout(this._schedulePlane), this._schedulePlane = setTimeout(function () {
                        this._widgetFadeDirection = 1, U.Z.draw()
                    }.bind(this), 1e3))
                },
                update: function (e, t) {
                    if (!this._groundStateAttrib || !this._groundStateAttrib.isDisplayPlane()) return !0;
                    var i = t.getFrameStamp();
                    (this._uWidgetFade[0] += i.getDeltaTime() * this._widgetFadeDirection, this._uWidgetFade[0] > 1) && (this._uWidgetFade[0] = 1, this._groundStateAttrib.setDisplayPlane(!1), this._geometry.getOrCreateStateSet().setAttribute(Le.Z.CULL_BACK));
                    return this._uWidgetFade[0] < .8 && (this._uWidgetFade[0] = .8), U.Z.draw(), !0
                },
                _onPositionOrScaleChange: function () {
                    var e = sg.vec3.create();
                    return function () {
                        var t = this.model,
                            i = this._transform.getMatrix(),
                            n = t.get("scale");
                        sg.vec3.set(e, n, n, n), sg.mat4.fromScaling(i, e);
                        var r = this.model.get("position");
                        i[12] = r[0], i[13] = r[1], i[14] = r[2], this._transform.dirtyBound()
                    }
                }(),
                _bake: function (e) {
                    e = e || 1e3, this._holdBake || (this.model.startRender(), this._schedule && clearTimeout(this._schedule), this._schedule = setTimeout(this._lightMapper.requestRender.bind(this._lightMapper), e), this._needBake = !1)
                }
            });
            var hg = {
                FeatureName: "ground",
                ModelType: eg,
                ViewListType: [cg]
            },
                dg = n.Z.create(hg);
            dg.prototype.getNode = function () {
                return this._views[0].getNodeGround()
            };
            const gg = dg;
            const fg = ir().Model.extend({
                defaults: {
                    enable: (0, l.Z)().decals,
                    defaultScale: [1, 1, 1],
                    decals: {},
                    decalGeometries: {}
                }
            });
            var mg = i("o2b8"),
                pg = i("WWMP"),
                vg = function (e) {
                    pg.Z.call(this), this._enable = !e, this._discardOutOfTextureBoundsPixels = !0, this._polygonOffset = !0, this._computeFragmentTangents = !1, this._dirtyHash = !0, this._hash = ""
                };
            zh.Z.createPrototypeStateAttribute(vg, zh.Z.objectInherit(pg.Z.prototype, {
                attributeType: "Decals",
                cloneType: function () {
                    return new vg(!0)
                },
                setEnabled: function (e) {
                    this._enable = e, this._dirtyHash = !0
                },
                isEnabled: function () {
                    return this._enable
                },
                getHash: function () {
                    return this._dirtyHash ? (this._hash = this._computeInternalHash(), this._dirtyHash = !1, this._hash) : this._hash
                },
                _computeInternalHash: function () {
                    return this.getTypeMember() + (this.isEnabled() ? "1" : "0") + (this._discardOutOfTextureBoundsPixels ? "1" : "0")
                },
                isDiscardOutOfTextureBoundPixels: function () {
                    return this._discardOutOfTextureBoundsPixels
                },
                setComputeFragmentTangents: function (e) {
                    this._computeFragmentTangents = e
                },
                isComputeFragmentTangents: function () {
                    return this._computeFragmentTangents
                },
                hasPolygonOffset() {
                    return this._polygonOffset
                },
                apply: function () {
                    this._enable
                }
            }), "osg", "DecalsAttribute");
            const _g = vg;
            var Sg, xg, Cg, Tg, Mg, bg, yg = g.Z.osg,
                Ag = (g.Z.osgUtil, g.Z.InputGroups, V.Z.extend({
                    initialize: function () {
                        V.Z.prototype.initialize.apply(this, arguments), this._viewer = this.options.context.getViewer(), this._model = this.options.model, L.Z.getModelDisplayed().then(this.onEnable.bind(this))
                    },
                    onEnable: function () {
                        (0, l.Z)().debugDecals && (Ve.Z.initDecals(this), console.log("decals debug enabled"))
                    },
                    onClick: function (e) {
                        this.createDecalFromPick(Fe.Z.pickNearestSurface(e))
                    },
                    createDecalFromPick: function (e, t) {
                        if (e) {
                            if (t || (t = {}), !t.scale) {
                                var i = .05 * J.Z.getModelBoxWithDisplacement().radius();
                                t.scale = yg.vec3.fromValues(i, i, i)
                            }
                            var n = yg.vec3.create(),
                                r = yg.vec3.create();
                            return Fe.Z.getScenePositionFromHit(e, n, r), t.include = [e._drawable], t.nodePath = e._nodePath, this.createDecal(n, r, t.scale, t)
                        }
                    },
                    createDecalFromData: function (e) {
                        var t = this._viewer.getFeaturesManager().getRootModel(),
                            i = yg.vec3.fromValues(e.position[0], e.position[1], e.position[2]),
                            n = yg.vec3.copy(yg.vec3.create(), i),
                            r = yg.vec3.fromValues(e.normal[0], e.normal[1], e.normal[2]);
                        yg.vec3.scale(r, r, e.scale[2]), yg.vec3.add(i, i, r), yg.vec3.sub(n, n, r);
                        var a = Fe.Z.computeNearestIntersection3D(i, n, Pe.Z.PICK_GEOMETRY_SLOW, t);
                        return this.createDecalFromPick(a, e)
                    },
                    createDecal: function () {
                        var e = yg.vec3.fromValues(0, 0, 1),
                            t = yg.mat4.create(),
                            i = yg.mat4.create(),
                            n = yg.vec3.create(),
                            r = yg.vec3.create(),
                            a = yg.mat4.create(),
                            o = yg.mat4.create();
                        return function (s, u, c, h) {
                            if (Math.abs(yg.vec3.dot(u, e) - 1) < 1e-6 && yg.vec3.set(e, 0, 1, 0), yg.mat4.lookAtDirection(t, n, u, e), yg.mat4.ortho(i, -c[0], c[0], c[1], -c[1], c[2], -c[2]), h.rotation) {
                                var d = h.rotation * Math.PI / 180;
                                i = yg.mat4.multiply(i, i, yg.mat4.fromZRotation(a, d))
                            }
                            yg.mat4.multiply(i, i, t), i = yg.mat4.multiply(i, i, yg.mat4.fromTranslation(a, yg.vec3.negate(r, s))), yg.mat4.identity(o), yg.computeLocalToWorld(h.nodePath, !0, o);
                            var g = h.include[0],
                                f = this.makeDecalPatch(g, i, o),
                                m = this._model.get("decals"),
                                p = Object.keys(m).length;
                            f.setName("testdemo2024_Internal_Decal_" + p), g.getParents()[0].addChild(f);
                            var v, _ = h.materialID,
                                S = this._viewer.getFeatures().material.getModel();
                            _ || (_ = (v = S.makeMaterial({
                                name: f.getName() + "_Material",
                                channels: {
                                    AlbedoPBR: {
                                        color: [0, 1, 0]
                                    }
                                }
                            })).get("id")), v || (v = S.get(_));
                            var x = new _g(!1);
                            if (x.setComputeFragmentTangents(!0), h.useBaseNormalMap) {
                                x.setComputeFragmentTangents(!1);
                                var C = v.getChannels().NormalMap.get("texture");
                                C && C.set("texCoordUnit", 1)
                            }
                            v.getStateSet().setAttribute(x), S.assignMaterial(f, _), (0, l.Z)().zz && f.accept(new mg.Z);
                            var T = {
                                id: p,
                                position: s,
                                normal: u,
                                scale: c,
                                materialID: _
                            };
                            return m[p] = T, this._model.get("decalGeometries")[p] = f, U.Z.draw(), T
                        }
                    }(),
                    destroyDecal: function (e, t) {
                        var i = this._model.get("decals"),
                            n = i[e];
                        if (!n) throw "Couldn't find decal with id " + e;
                        var r = this._model.get("decalGeometries"),
                            a = r[e];
                        (a.getParents()[0].removeChild(a), t && t.deleteMaterial) && this._viewer.getFeatures().material.getModel().destroyMaterial(n.materialID);
                        delete i[e], delete r[e], U.Z.draw()
                    },
                    findUvs: function (e) {
                        for (const t in e)
                            if (t.startsWith("TexCoord")) return e[t]
                    },
                    makeDecalPatch: (Tg = {
                        min: yg.vec3.fromValues(-1, -1, -1),
                        max: yg.vec3.fromValues(1, 1, 1)
                    }, Mg = [yg.vec3.create(), yg.vec3.create(), yg.vec3.create()], bg = yg.mat4.create(), function (e, t, i) {
                        yg.mat4.multiply(bg, t, i);
                        for (var n, r, a = e.getPrimitives()[0].indices, o = e.getAttributes().Vertex, s = e.getAttributes().Normal, l = e.getAttributes().Tangent, u = this.findUvs(e.getAttributes()), c = [], h = [], d = [], g = [], f = [], m = [], p = 0, v = e.getPrimitives(), _ = 0; _ < v.length; _++)
                            for (var S = v[_], x = S.mode === yg.primitiveSet.TRIANGLES ? 3 : 1, C = (a = S.indices, 0); C < a._numItems; C += x) {
                                for (var T = 0; T < 3; T++) n = Mg[T], r = 3 * a.getElements()[C + T], yg.vec3.set(n, o.getElements()[r], o.getElements()[r + 1], o.getElements()[r + 2]), n = yg.vec3.transformMat4(n, n, bg);
                                if (this.intersectsTriangleAABB(Mg[0], Mg[1], Mg[2], Tg))
                                    for (var M = 0; M < 3; M++) {
                                        n = Mg[M], f.push(.5 * (n[0] + 1)), f.push(.5 * (n[1] + 1));
                                        var b = 2 * (r = a.getElements()[C + M]),
                                            y = 3 * r,
                                            A = 4 * r;
                                        h.push(o.getElements()[y]), h.push(o.getElements()[y + 1]), h.push(o.getElements()[y + 2]), d.push(s.getElements()[y]), d.push(s.getElements()[y + 1]), d.push(s.getElements()[y + 2]), u && (m.push(u.getElements()[b]), m.push(u.getElements()[b + 1])), l && (A = 4 * r, g.push(l.getElements()[A]), g.push(l.getElements()[A + 1]), g.push(l.getElements()[A + 2]), g.push(l.getElements()[A + 3])), c.push(p), p++
                                    }
                            }
                        var R = new yg.Geometry;
                        return R.getAttributes().Vertex = new yg.BufferArray(yg.BufferArray.ARRAY_BUFFER, new Float32Array(h), 3), R.getAttributes().Normal = new yg.BufferArray(yg.BufferArray.ARRAY_BUFFER, new Float32Array(d), 3), l && (R.getAttributes().Tangent = new yg.BufferArray(yg.BufferArray.ARRAY_BUFFER, new Float32Array(g), 4)), R.getAttributes().TexCoord0 = new yg.BufferArray(yg.BufferArray.ARRAY_BUFFER, new Float32Array(f), 2), u && (R.getAttributes().TexCoord1 = new yg.BufferArray(yg.BufferArray.ARRAY_BUFFER, new Float32Array(m), 2)), R.getPrimitives().push(new yg.DrawElements(yg.primitiveSet.TRIANGLES, new yg.BufferArray(yg.BufferArray.ELEMENT_ARRAY_BUFFER, new Uint16Array(c), 1))), R
                    }),
                    getWorldHitFromTexCoord: function () {
                        var e = [yg.vec2.create(), yg.vec2.create(), yg.vec2.create()],
                            t = [yg.vec3.create(), yg.vec3.create(), yg.vec3.create()],
                            i = yg.vec3.create(),
                            n = yg.vec3.create(),
                            r = yg.vec3.create(),
                            a = yg.vec3.create(),
                            o = yg.mat4.create(),
                            s = yg.mat3.create();
                        return function (l, u) {
                            for (var c, h, d = l.getAttributes().Vertex, g = l.getAttributes().Normal, f = this.findUvs(l.getAttributes()), m = l.getPrimitives(), p = !1, v = 0, _ = 0, S = 0; S < m.length && !p; S++) {
                                v = S;
                                for (var x = m[S].indices, C = 0; C < x._numItems && !p; C += 3) {
                                    _ = C;
                                    for (var T = 0; T < 3; T++) c = e[T], h = 2 * x.getElements()[C + T], yg.vec3.set(c, f.getElements()[h], f.getElements()[h + 1]);
                                    this.computeBarycentricCoordinates(i, u, e[0], e[1], e[2]), i[0] >= 0 && i[1] >= 0 && i[2] >= 0 && (p = !0)
                                }
                            }
                            yg.vec3.set(n, 0, 0, 0), yg.vec3.set(r, 0, 0, 0);
                            for (T = 0; T < 3; T++) h = 3 * m[v].indices.getElements()[_ + T], yg.vec3.set(a, d.getElements()[h], d.getElements()[h + 1], d.getElements()[h + 2]), yg.vec3.copy(t[T], a), yg.vec3.add(n, n, yg.vec3.scale(a, a, i[T])), yg.vec3.set(a, g.getElements()[h], g.getElements()[h + 1], g.getElements()[h + 2]), yg.vec3.add(r, r, a);
                            l.getWorldMatrix(null, o), yg.vec3.transformMat4(n, n, o), yg.mat3.normalFromMat4(s, o), yg.vec3.transformMat3(r, r, s), yg.vec3.normalize(r, r), yg.vec3.transformMat4(t[0], t[0], o), yg.vec3.transformMat4(t[1], t[1], o), yg.vec3.transformMat4(t[2], t[2], o);
                            var M = yg.vec3.length(yg.vec3.sub(a, t[0], t[1]));
                            return M /= yg.vec2.length(yg.vec2.sub(a, e[0], e[1])), console.log("uvs", e), console.log("barycentric", i), console.log("triangle", t), console.log("position", n), console.log("normal", r), console.log("ratio", M), {
                                normal: r,
                                position3D: n,
                                texCoordTo3DScaleRatio: M
                            }
                        }
                    }(),
                    computeBarycentricCoordinates: (Sg = yg.vec2.create(), xg = yg.vec2.create(), Cg = yg.vec2.create(), function (e, t, i, n, r) {
                        yg.vec2.sub(Sg, n, i), yg.vec2.sub(xg, r, i), yg.vec2.sub(Cg, t, i);
                        var a = 1 / (Sg[0] * xg[1] - xg[0] * Sg[1]),
                            o = (Cg[0] * xg[1] - xg[0] * Cg[1]) * a,
                            s = (Sg[0] * Cg[1] - Cg[0] * Sg[1]) * a,
                            l = 1 - o - s;
                        yg.vec3.set(e, l, o, s)
                    }),
                    findDecalFromWorldPosition: function (e) {
                        if (e) {
                            var t = this._model.get("decals"),
                                i = Object.keys(t).length;
                            for (let a = 0; a < i; a++) {
                                const i = t[a];
                                var n = .5 * yg.vec3.length(i.scale),
                                    r = Math.sqrt(n * n * 2);
                                if (yg.vec3.distance(e, i.position) <= r) return i
                            }
                            return uundefined
                        }
                    },
                    intersectsTriangleAABB: function () {
                        var e = yg.vec3.create(),
                            t = yg.vec3.create(),
                            i = yg.vec3.create(),
                            n = yg.vec3.create(),
                            r = yg.vec3.create(),
                            a = yg.vec3.create(),
                            o = yg.vec3.create(),
                            s = yg.vec3.create(),
                            l = [yg.vec3.create(), yg.vec3.create(), yg.vec3.create()],
                            u = [yg.vec3.create(), yg.vec3.create(), yg.vec3.create()];
                        return function (c, h, d, g) {
                            if (e = yg.vec3.min(e, c, yg.vec3.min(e, h, d)), t = yg.vec3.max(t, c, yg.vec3.max(t, h, d)), e[0] >= g.max[0] || t[0] <= g.min[0] || e[1] >= g.max[1] || t[1] <= g.min[1] || e[2] >= g.max[2] || t[2] <= g.min[2]) return !1;
                            i = yg.vec3.scale(i, yg.vec3.add(i, g.max, g.min), .5), n = yg.vec3.sub(n, g.max, i), yg.vec3.sub(l[0], h, c), yg.vec3.sub(l[1], d, c), yg.vec3.sub(l[2], d, h), r = yg.vec3.sub(r, c, i), a = yg.vec3.cross(a, l[0], l[1]);
                            var f = yg.vec3.dot(a, r),
                                m = Math.abs(yg.vec3.dot(n, Math.abs(a)));
                            if (Math.abs(f) >= m) return !1;
                            yg.vec3.set(u[0], Math.abs(l[0][0]), Math.abs(l[0][1]), Math.abs(l[0][2])), yg.vec3.set(u[1], Math.abs(l[1][0]), Math.abs(l[1][1]), Math.abs(l[1][2])), yg.vec3.set(u[2], Math.abs(l[2][0]), Math.abs(l[2][1]), Math.abs(l[2][2])), o = yg.vec3.sub(o, h, i), s = yg.vec3.sub(s, d, i);
                            var p = l[0][1] * r[2] - l[0][2] * r[1],
                                v = l[0][1] * s[2] - l[0][2] * s[1],
                                _ = .5 * (p + v);
                            return !((m = Math.abs(n[1] * u[0][2] + n[2] * u[0][1])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[1][1] * r[2] - l[1][2] * r[1]) + (v = l[1][1] * o[2] - l[1][2] * o[1])), !((m = Math.abs(n[1] * u[1][2] + n[2] * u[1][1])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[2][1] * r[2] - l[2][2] * r[1]) + (v = l[2][1] * o[2] - l[2][2] * o[1])), !((m = Math.abs(n[1] * u[2][2] + n[2] * u[2][1])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[0][2] * r[0] - l[0][0] * r[2]) + (v = l[0][2] * s[0] - l[0][0] * s[2])), !((m = Math.abs(n[0] * u[0][2] + n[2] * u[0][0])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[1][2] * r[0] - l[1][0] * r[2]) + (v = l[1][2] * o[0] - l[1][0] * o[2])), !((m = Math.abs(n[0] * u[1][2] + n[2] * u[1][0])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[2][2] * r[0] - l[2][0] * r[2]) + (v = l[2][2] * o[0] - l[2][0] * o[2])), !((m = Math.abs(n[0] * u[2][2] + n[2] * u[2][0])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[0][0] * r[1] - l[0][1] * r[0]) + (v = l[0][0] * s[1] - l[0][1] * s[0])), !((m = Math.abs(n[1] * u[0][0] + n[0] * u[0][1])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[1][0] * r[1] - l[1][1] * r[0]) + (v = l[1][0] * o[1] - l[1][1] * o[0])), !((m = Math.abs(n[1] * u[1][0] + n[0] * u[1][1])) + Math.abs(_ - p) < Math.abs(_)) && (_ = .5 * ((p = l[2][0] * r[1] - l[2][1] * r[0]) + (v = l[2][0] * o[1] - l[2][1] * o[0])), !((m = Math.abs(n[1] * u[2][0] + n[0] * u[2][1])) + Math.abs(_ - p) < Math.abs(_))))))))))
                        }
                    }()
                }));
            var Rg = {
                FeatureName: "Decals",
                ModelType: fg,
                ViewListType: [Ag]
            },
                wg = n.Z.create(Rg);
            wg.prototype.getNodeIn = function () { }, wg.prototype.getNodeOut = function () { };
            const Eg = [Y, Tt, Br, Wr, aa, pa, Oa, Bo, zo, el, ml, ql, pu, oh, Lh, gd, Kd, gg, wg]
        },
        "1XKa": (e, t, i) => {
            i.d(t, {
                Z: () => n
            });
            const n = ["4024128cf8904b69946e891caac5f305", "b83e3a8794ae47e0b4039e7fdb031602", "16cdcddf277d423d99094f8db0c731e9", "efd4ef0fc18a4ec0a1313d782fade965", "675ff0f13b474c62947097939fe9aa1e", "df5b82c5ccec42cbb9c5ba9528f0be52", "491ddabd93aa49ecb5ad36538f7d00e3", "02751cd893a14f3986fb17a90245f64f", "78a54c2fd53a4ba4891a4bbdac7f30f7", "956bb00775a044e7afdd1c17f6bdab63", "003c1543cd754a19a0e14bc89726ccf5", "268447ca0a954f44b06d1387863d114e", "80fba9759ab94307a782f38d359b8ea8", "e73867d210de4bc2b5eb261738cf3e79", "2e9c3708feb74137b0436f946b8b66b8", "591b2c2db5744df1803a09d477f5a2c7"]
        },
        ZmEo: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = i("aqzA"),
                r = i("icLH"),
                a = n.Z.osg;
            const o = {
                uDrawOpaque: a.Uniform.createInt(-1, "uDrawOpaque"),
                uEarlyZ: a.Uniform.createInt(0, "uEarlyZ"),
                uQVT: a.Uniform.createFloat3("uQVT"),
                uQVS: a.Uniform.createFloat3("uQVS"),
                uQW: a.Uniform.createFloat2("uQW"),
                uQUV0: a.Uniform.createFloat4("uQUV0"),
                uNearFar: a.Uniform.createFloat2("uNearFar"),
                uPreviousNearFar: a.Uniform.createFloat2("uPreviousNearFar"),
                uBoxRadius: a.Uniform.createFloat("uBoxRadius"),
                uOutputLinear: a.Uniform.createInt(1, "uOutputLinear"),
                uRGBMRange: a.Uniform.createFloat("uRGBMRange"),
                uGlobalTexSize: a.Uniform.createFloat2("uGlobalTexSize"),
                uGlobalTexRatio: a.Uniform.createFloat2("uGlobalTexRatio"),
                uPixelRatio: a.Uniform.createFloat2("uPixelRatio"),
                uPreviousGlobalTexSize: a.Uniform.createFloat2("uPreviousGlobalTexSize"),
                uPreviousGlobalTexRatio: a.Uniform.createFloat2("uPreviousGlobalTexRatio"),
                uPreviousHalton: a.Uniform.createFloat4("uPreviousHalton"),
                uReprojectViewProj: a.Uniform.createMatrix4("uReprojectViewProj"),
                uTaaCornersCSLeft: r.Z.uTaaCornersCSLeft,
                uPreviousProjection: a.Uniform.createMatrix4("uPreviousProjection"),
                uPreviousViewInvView: a.Uniform.createMatrix4("uPreviousViewInvView"),
                uTextureToBeRefractedSize: a.Uniform.createFloat2("uTextureToBeRefractedSize"),
                uHoverUV: a.Uniform.createFloat2(a.vec2.fromValues(1e6, 1e6), "uHoverUV"),
                uDisplay2D: a.Uniform.createFloat(0, "uDisplay2D"),
                uSplitView: a.Uniform.createFloat(0, "uSplitView"),
                uInspectorView: a.Uniform.createInt(0, "uInspectorView"),
                uTimeViewer: a.Uniform.createFloat("uTimeViewer"),
                uHalton: a.Uniform.createFloat4("uHalton"),
                uSSAARestart: a.Uniform.createFloat(0, "uSSAARestart"),
                uScatteringFactorPacker: a.Uniform.createFloat("uScatteringFactorPacker"),
                uNormalizeFactorThickness: a.Uniform.createFloat("uNormalizeFactorThickness"),
                uStaticFrameNumShadow0: a.Uniform.createFloat("uStaticFrameNumShadow0"),
                uStaticFrameNumShadow1: a.Uniform.createFloat("uStaticFrameNumShadow1"),
                uStaticFrameNumShadow2: a.Uniform.createFloat("uStaticFrameNumShadow2"),
                uStaticFrameNumShadow3: a.Uniform.createFloat("uStaticFrameNumShadow3"),
                uShadowMapSize: a.Uniform.createFloat2("uShadowMapSize"),
                uIsVr: a.Uniform.createInt("uIsVr"),
                uFrameMod: a.Uniform.createFloat(0, "uFrameMod"),
                uFrameModTaaSS: a.Uniform.createFloat(0, "uFrameModTaaSS"),
                uSsrFactor: a.Uniform.createFloat(1, "uSsrFactor"),
                uQuality: a.Uniform.createFloat(0, "uQuality")
            }
        },
        Vwae: (e, t, i) => {
            i.d(t, {
                Z: () => g
            });
            var n = i("aqzA"),
                r = i("QKpV"),
                a = i("MQQR"),
                o = n.Z.osg,
                s = {},
                l = function (e) {
                    for (var t = o.vec3.create(), i = 0, n = e.length; i < n; i += 3)
                        if (isFinite(e[i]) && isFinite(e[i + 1]) && isFinite(e[i + 2])) {
                            t[0] = e[i], t[1] = e[i + 1], t[2] = e[i + 2];
                            break
                        }
                    return t
                },
                u = function (e, t, i) {
                    e[i] || t.push(i)
                },
                c = function (e, t, i, n) {
                    e[i] || e[n] || t.push(i, n)
                },
                h = function (e, t, i, n, r) {
                    e[i] || e[n] || e[r] || t.push(i, n, r)
                },
                d = function (e) {
                    if (function (e) {
                        var t = e.getVertexAttributeList().Vertex;
                        if (void 0 !== t.processedNaN) return t.processedNaN;
                        t.processedNaN = !1;
                        for (var i, n = t.getInstanceID(), r = t.getElements(), a = 0, o = r.length; a < o; a += 3) isFinite(r[a]) && isFinite(r[a + 1]) && isFinite(r[a + 2]) || (t.processedNaN = !0, i || (i = l(r)), r[a] = i[0], r[a + 1] = i[1], r[a + 2] = i[2], s[n] || (s[n] = {}), s[n][a / 3] = !0);
                        return t.processedNaN
                    }(e) || (0, a.Z)().forceTriangles) {
                        var t = e.getVertexAttributeList().Vertex,
                            i = s[t.getInstanceID()] || {},
                            n = [],
                            r = [],
                            d = [],
                            g = {
                                operatorPoint: u.bind(this, i, n),
                                operatorLine: c.bind(this, i, r),
                                operatorTriangle: h.bind(this, i, d)
                            };
                        o.primitiveIndexFunctor(e, g);
                        var f, m, p = e.getPrimitiveSetList();
                        p.length = 0, n.length && (m = new Uint16Array(n), f = new o.BufferArray(o.BufferArray.ELEMENT_ARRAY_BUFFER, m, 1), p.push(new o.DrawElements(o.primitiveSet.POINTS, f))), r.length && (m = new Uint16Array(r), f = new o.BufferArray(o.BufferArray.ELEMENT_ARRAY_BUFFER, m, 1), p.push(new o.DrawElements(o.primitiveSet.LINES, f))), d.length && (m = new Uint16Array(d), f = new o.BufferArray(o.BufferArray.ELEMENT_ARRAY_BUFFER, m, 1), p.push(new o.DrawElements(o.primitiveSet.TRIANGLES, f)))
                    }
                };
            const g = function (e) {
                for (var t = !1, i = 0, n = e.length; i < n; ++i) t = d(e[i]) || t;
                t && r.Z.logMessage("NaN values detected in vertices!")
            }
        },
        Rdny: (e, t, i) => {
            i.d(t, {
                Z: () => c
            });
            var n = i("aqzA"),
                r = i("KXnA"),
                a = n.Z.osg,
                o = ["Inspector", "Matcap", "Displacement", "AlphaMask", "Opacity", "SubsurfaceScattering", "SubsurfaceTranslucency", "DiffuseColor", "DiffusePBR", "AlbedoPBR", "ClearCoat", "ClearCoatRoughness", "ClearCoatNormalMap", "SpecularColor", "DiffuseIntensity", "SpecularPBR", "MetalnessPBR", "GlossinessPBR", "RoughnessPBR", "NormalMap", "BumpMap", "AOPBR", "EmitColor", "CavityPBR", "SpecularHardness", "SpecularF0", "Anisotropy", "Sheen", "SheenRoughness"],
                s = function (e) {
                    switch (e) {
                        case "DiffuseColor":
                        case "DiffuseIntensity":
                        case "SpecularColor":
                        case "NormalMap":
                        case "EmitColor":
                        case "DiffusePBR":
                        case "AlbedoPBR":
                        case "SpecularPBR":
                        case "Matcap":
                        case "Inspector":
                        case "ClearCoatNormalMap":
                        case "Anisotropy":
                        case "Sheen":
                            return a.Texture.RGB;
                        case "SpecularHardness":
                        case "BumpMap":
                        case "GlossinessPBR":
                        case "RoughnessPBR":
                        case "MetalnessPBR":
                        case "SheenRoughness":
                        case "SpecularF0":
                        case "AOPBR":
                        case "CavityPBR":
                        case "Displacement":
                        case "SubsurfaceScattering":
                        case "SubsurfaceTranslucency":
                        case "ClearCoat":
                        case "ClearCoatRoughness":
                            return a.Texture.LUMINANCE;
                        case "Opacity":
                        case "AlphaMask":
                            return a.Texture.ALPHA;
                        default:
                            return console.error("unknown channel: " + e), a.Texture.RGB
                    }
                },
                l = function (e) {
                    if ("Anisotropy" === e) return "rg";
                    var t = s(e);
                    return t === a.Texture.RGB ? "rgb" : t === a.Texture.LUMINANCE ? "r" : t === a.Texture.ALPHA ? "a" : "rgba"
                },
                u = function (e) {
                    for (var t = {}, i = 0, n = o.length; i < n; ++i) {
                        var r = o[i];
                        t[r] = e(r)
                    }
                    return function (e) {
                        return t[e]
                    }
                };
            o.getShadingMask = u((function (e) {
                switch (e) {
                    case "Matcap":
                        return r.Z.MATCAP;
                    case "SubsurfaceScattering":
                    case "SubsurfaceTranslucency":
                        return r.Z.LIT;
                    case "Opacity":
                    case "AlphaMask":
                    case "Displacement":
                        return r.Z.LIT | r.Z.SHADELESS | r.Z.MATCAP | r.Z.INSPECTOR;
                    case "EmitColor":
                        return r.Z.LIT | r.Z.SHADELESS;
                    case "NormalMap":
                    case "BumpMap":
                        return r.Z.LIT | r.Z.MATCAP;
                    case "DiffusePBR":
                    case "AlbedoPBR":
                    case "AOPBR":
                    case "CavityPBR":
                        return r.Z.PBR;
                    case "SpecularPBR":
                    case "MetalnessPBR":
                    case "GlossinessPBR":
                    case "RoughnessPBR":
                    case "SpecularF0":
                    case "ClearCoat":
                    case "ClearCoatRoughness":
                    case "ClearCoatNormalMap":
                    case "Anisotropy":
                    case "Sheen":
                    case "SheenRoughness":
                        return r.Z.PBR_LIT;
                    case "DiffuseColor":
                    case "DiffuseIntensity":
                        return r.Z.CLASSIC;
                    case "SpecularColor":
                    case "SpecularHardness":
                        return r.Z.CLASSIC_LIT;
                    case "Inspector":
                        return r.Z.INSPECTOR
                }
            })), o.isSRGB = u((function (e) {
                switch (e) {
                    case "DiffuseColor":
                    case "DiffusePBR":
                    case "AlbedoPBR":
                    case "EmitColor":
                    case "SpecularColor":
                    case "SpecularPBR":
                    case "Matcap":
                    case "Inspector":
                    case "Sheen":
                        return !0;
                    default:
                        return !1
                }
            })), o.getDefaultFormatEnum = u(s), o.getDefaultFormatComponent = u(l), o.getDefaultFormatString = u((function (e) {
                var t = s(e);
                return t === a.Texture.RGB ? "RGB" : t === a.Texture.LUMINANCE ? "LUMINANCE" : t === a.Texture.ALPHA ? "ALPHA" : "RGBA"
            })), o.getDefaultComponentCount = u((function (e) {
                return l(e).length
            })), o.getPossibleFormat = u((function (e) {
                var t = {};
                switch (e) {
                    case "NormalMap":
                    case "SpecularPBR":
                    case "ClearCoatNormalMap":
                    case "Anisotropy":
                    case "Sheen":
                        t.RGB = "RGB";
                        break;
                    case "SpecularHardness":
                    case "BumpMap":
                    case "GlossinessPBR":
                    case "RoughnessPBR":
                    case "MetalnessPBR":
                    case "SpecularF0":
                    case "AOPBR":
                    case "CavityPBR":
                    case "Displacement":
                    case "SubsurfaceScattering":
                    case "SubsurfaceTranslucency":
                    case "ClearCoat":
                    case "ClearCoatRoughness":
                    case "SheenRoughness":
                        t.LUMINANCE = "Luminance";
                        break;
                    case "DiffuseColor":
                    case "DiffuseIntensity":
                    case "SpecularColor":
                    case "EmitColor":
                    case "DiffusePBR":
                    case "AlbedoPBR":
                    case "Matcap":
                    case "Inspector":
                        t.LUMINANCE = "Luminance", t.RGB = "RGB";
                        break;
                    case "AlphaMask":
                    case "Opacity":
                        t.ALPHA = "Alpha", t.LUMINANCE = "Luminance";
                        break;
                    default:
                        return console.error("unknown channel: " + e), a.Texture.RGB
                }
                return t
            })), o.getPossibleFiltering = u((function (e) {
                var t = {};
                return "Displacement" !== e && (t.LINEAR_MIPMAP_LINEAR = "Trilinear (best)", t.NEAREST_MIPMAP_LINEAR = "Nearest (mipmap)"), t.LINEAR = "Bilinear", t.NEAREST = "Nearest", t
            })), o.getColorPacking = u((function (e) {
                switch (e) {
                    case "DiffuseColor":
                    case "DiffusePBR":
                    case "AlbedoPBR":
                    case "Inspector":
                        return 0;
                    case "EmitColor":
                        return 1;
                    case "SpecularColor":
                    case "SpecularPBR":
                        return 2;
                    case "DiffuseIntensity":
                        return 3;
                    default:
                        return -1
                }
            })), o.getBoxFactor = u((function (e) {
                return "SubsurfaceScattering" === e || "SubsurfaceTranslucency" === e ? .2 : "Displacement" === e ? 1 : -1
            }));
            const c = o
        },
        Majl: (e, t, i) => {
            i.d(t, {
                Z: () => J
            });
            var n = i("k46e"),
                r = i("aqzA"),
                a = i("bWy4"),
                o = i("R4My"),
                s = i.n(o),
                l = i("mSEu"),
                u = i("WGQk"),
                c = i("Rdny"),
                h = i("KXnA"),
                d = i("5Mmo"),
                g = i("qk4i"),
                f = i("XkCy"),
                m = i("CUcOv"),
                p = i("WoEt"),
                v = r.Z.osg,
                _ = s().View,
                S = s().Model,
                x = {
                    CavityPBR: !0,
                    AOPBR: !0,
                    NormalMap: !0,
                    Displacement: !0,
                    BumpMap: !0,
                    ClearCoatNormalMap: !0
                },
                C = {
                    DiffuseIntensity: !0,
                    DiffusePBR: !0,
                    AlbedoPBR: !0,
                    SpecularPBR: !0,
                    GlossinessPBR: !0,
                    RoughnessPBR: !0,
                    MetalnessPBR: !0,
                    SpecularF0: !0
                },
                T = {},
                M = T.view = _.extend({
                    initialize: function (e) {
                        _.prototype.initialize.apply(this, arguments), e.stateSetContext && (this.stateSetContext = e.stateSetContext), this.model.on("change:enable", this.updateChannel, this), this.model.on("change:texCoordUnit", this.changeTexCoord, this), this.model.on("setFactor", this.updateChannel, this), this.model.on("setColor", this.updateChannel, this), this.model.on("setTextureModel", this.updateChannel, this), this.model.on("updateChannel", this.updateChannel, this), this.model.on("all", g.Z.draw)
                    },
                    getStateSetContext: function () {
                        return this.stateSetContext
                    },
                    updateChannel: function () {
                        if (this.model.getTextureModel()) {
                            var e = this.model.get("material").get("texCoordUnitList"),
                                t = this.model.getTexCoordUnit();
                            e.length && -1 === e.indexOf(t) && this.model.setTexCoordUnit(e[0])
                        }
                        this.getStateSetContext().updateChannel(this.model)
                    },
                    changeTexCoord: function () {
                        this.getStateSetContext().dirtyMaterial()
                    }
                }),
                b = T.model = a.Z.extend({
                    getModelOptionPath: function () {
                        return "materials:0.channels." + this.get("name")
                    },
                    _initFactorFromBox: function (e, t) {
                        var i = this;
                        i.get(e) >= 0 || f.Z.getBoxReady().then((function () {
                            if (!(i.get(e) >= 0)) {
                                var n = f.Z.getModelBoxWithoutDisplacement().radius();
                                i.set(e, n * t)
                            }
                        }))
                    },
                    setupTextureModel: function (e) {
                        var t = new d.Z(e);
                        return -1 === t.get("internalFormat") && t.set("internalFormat", c.Z.getDefaultFormatEnum(this.get("name"))), t.updateMultiresTexture(), this.setTextureModel(t), t
                    },
                    _createTextureModel: function (e, t) {
                        var i = t.get(e.uid);
                        if (i) return this.setupTextureModel((0, n.Z)({}, e, {
                            image: i
                        }));
                        (this.isEffective() || (0, u.Z)()) && v.error("can't find imageModel " + e.uid)
                    },
                    setChannelJSON: function (e, t, i) {
                        var n = this.setJSON(e, {
                            ignore: ["texture"],
                            context: this.get("name"),
                            imageCollection: t,
                            validate: i && i.validate,
                            warnOnError: i && i.warnOnError
                        });
                        return n.length || (e.texture ? this._createTextureModel(e.texture, t) : null === e.texture && this.setTextureModel(void 0)), n
                    },
                    getJSON: function () {
                        var e = a.Z.prototype.getJSON.call(this, {
                            ignore: ["texture"],
                            context: this.get("name")
                        }),
                            t = this.get("textureModel");
                        return t && (e.texture = t.getJSON()), e
                    },
                    validate: function (e, t) {
                        var i = a.Z.prototype.validate.call(this, e, t);
                        return t && t.imageCollection && e.texture && e.enable && e.factor && !t.warnOnError ? (t.imageCollection.get(e.texture.uid) || i.push(this.get("name") + " texture uid does not exist"), i) : i
                    },
                    getName: function () {
                        return this.get("name")
                    },
                    getEnable: function () {
                        return this.get("enable")
                    },
                    getFactor: function () {
                        return this.get("factor")
                    },
                    getTextureModel: function () {
                        return this.get("textureModel")
                    },
                    getTexCoordUnit: function () {
                        var e = this.get("textureModel");
                        return e && e.get("texCoordUnit")
                    },
                    setEnable: function (e) {
                        return this.set("enable", e)
                    },
                    setFactor: function (e) {
                        return this.set("factor", e), this.trigger("setFactor")
                    },
                    setTextureModel: function (e) {
                        return this.set("textureModel", e), this.trigger("setTextureModel")
                    },
                    setTexCoordUnit: function (e) {
                        var t = this.get("textureModel");
                        void 0 !== t && (t.set("texCoordUnit", e), this.trigger("change:texCoordUnit"))
                    },
                    changeTexCoordTransform: function () {
                        this.trigger("change:texCoordUnit")
                    },
                    getOrCreateUVTransforms: function () {
                        var e = this.get("UVTransforms");
                        return e || (e = {
                            scale: v.vec2.fromValues(1, 1),
                            rotation: 0,
                            offset: v.vec2.fromValues(0, 0)
                        }, this.set("UVTransforms", e), e)
                    },
                    getNonIdentityUvTransform: function () {
                        var e = this.get("UVTransforms");
                        if (e && (1 !== e.scale[0] || 1 !== e.scale[1] || 0 !== e.rotation || 0 !== e.offset[0] || 0 !== e.offset[1])) return e
                    },
                    removeTexture: function () {
                        this.setColor(v.vec3.ONE)
                    },
                    reset: function () {
                        return this.removeTexture(), this.set("factor", 1), this.trigger("updateChannel")
                    },
                    resetTextureFormat: function () {
                        var e = this.get("textureModel");
                        e && (e.set("internalFormat", c.Z.getDefaultFormatEnum(this.get("name"))), e.updateMultiresTexture())
                    },
                    isEffective: function () {
                        if (!this.isActivated()) return !1;
                        var e = this.get("name"),
                            t = this.get("factor");
                        if (0 === t) {
                            if ("RoughnessPBR" !== e && "GlossinessPBR" !== e) return !1;
                            var i = this.get("material").getChannels().Opacity;
                            return i.isEffective() && "refraction" === i.get("type") && i.get("useMicrosurfaceTexture")
                        }
                        if (x[e] && !this.get("textureModel")) return !1;
                        if ("Displacement" === e && !v.WebGLCaps.instance().getWebGLParameter("MAX_VERTEX_TEXTURE_IMAGE_UNITS")) return !1;
                        var n = this.get("color");
                        return !(!C[e] && n && function (e) {
                            return 0 === e[0] && 0 === e[1] && 0 === e[2]
                        }(n) && "SubsurfaceTranslucency" !== e) && ("DiffuseIntensity" !== e || 1 !== t || !n || ! function (e) {
                            return 1 === e[0] && 1 === e[1] && 1 === e[2]
                        }(n))
                    },
                    isEnableEffective: function () {
                        return !!this.isActivated() && (!!C[this.get("name")] || this.isEffective())
                    },
                    isEnableEffectiveHardware: function (e) {
                        if (!this.isEnableEffective()) return !1;
                        if (!x[this.get("name")]) return !0;
                        var t = e.getChannelMapping(this.get("name"));
                        return void 0 !== t && t >= 0
                    },
                    isActivated: function () {
                        return !!(c.Z.getShadingMask(this.get("name")) & this.getCurrentShading()) && this.get("enable")
                    },
                    getCurrentShading: function () {
                        var e = this.get("material").get("stateSet"),
                            t = e && e.getShaderGeneratorName();
                        return t ? h.Z.nameMatch[t] : h.Z.get("mask")
                    },
                    shouldDisplayGUIWarningOnDeletion: function () {
                        if (!this.getEnable()) return !1;
                        var e = h.Z.get("mask") & h.Z.CLASSIC ? h.Z.CLASSIC : h.Z.PBR;
                        return !!(c.Z.getShadingMask(this.getName()) & e)
                    },
                    addUniforms: function (e, t) {
                        var i = "u" + (t || this.get("name")) + "Factor";
                        e[i] = v.Uniform.createFloat(i), e[i = "u" + (t || this.get("name")) + "UVTransforms"] = v.Uniform.createFloat4(i), e[i = "u" + (t || this.get("name")) + "UVOffset"] = v.Uniform.createFloat2(i)
                    },
                    cacheUniforms: function (e) {
                        this._uniformFactor = e["u" + this.get("name") + "Factor"].getInternalArray(), this._valueFactor = this.isEnableEffective() ? this.get("factor") : 0;
                        var t = this.getNonIdentityUvTransform();
                        if (t) {
                            var i = Math.cos(t.rotation),
                                n = Math.sin(t.rotation);
                            this._uniformUVTransform = e["u" + this.get("name") + "UVTransforms"].getInternalArray(), this._valueUVTransform = v.vec4.fromValues(i * t.scale[0], -n * t.scale[1], n * t.scale[0], i * t.scale[1]), this._uniformUVOffset = e["u" + this.get("name") + "UVOffset"].getInternalArray(), this._valueUVOffset = t.offset
                        } else this._uniformUVTransform && (this._valueUVTransform = v.vec4.fromValues(1, 0, 0, 1), this._valueUVOffset = v.vec2.fromValues(0, 0))
                    },
                    updateUniforms: function () {
                        this._uniformFactor[0] = this._valueFactor, this._valueUVTransform && this._uniformUVTransform && (v.vec4.copy(this._uniformUVTransform, this._valueUVTransform), v.vec2.copy(this._uniformUVOffset, this._valueUVOffset))
                    },
                    getSRGB: function () {
                        var e = this.get("textureModel");
                        if (!e) return !1;
                        if (!e.getImageModel()) return c.Z.isSRGB(this.get("name"));
                        var t = e.getImageModel().get("colorSpace");
                        return "srgb" === t || "linear" !== t && c.Z.isSRGB(this.get("name"))
                    },
                    getShaderHash: function () {
                        var e = this.isEffective() && this.get("textureModel"),
                            t = this.getSRGB() ? "1" : "0";
                        return t += e ? e.get("texCoordUnit") : "x", t += this._valueUVTransform ? "x" : "t"
                    }
                }),
                y = {};
            y.view = M, y.model = b.extend({
                _adaptJSON: function (e) {
                    e.texture ? delete e.color : delete e.texture
                },
                getColor: function () {
                    return this.get("color")
                },
                setColor: function (e) {
                    return this.set("textureModel", void 0), this.set("color", v.vec3.copy(this.get("color") || v.vec3.create(), e)), this.trigger("setColor")
                },
                setTextureModel: function (e) {
                    e && this.set("color", void 0), b.prototype.setTextureModel.call(this, e)
                },
                getJSON: function () {
                    var e = b.prototype.getJSON.call(this);
                    return this.get("textureModel") && e.color && delete e.color, e
                },
                setChannelJSON: function (e, t, i) {
                    var n = b.prototype.setChannelJSON.call(this, e, t, i);
                    return n.length || e.color && this.setColor(e.color), n
                }
            });
            var A = b.prototype.addUniforms,
                R = b.prototype.cacheUniforms,
                w = b.prototype.updateUniforms,
                E = {};
            E.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:invert", this.updateChannel, this), this.model.get("material").on("change:vertexAlphaEnable", this.updateChannel, this), this._migrate()
                },
                _migrate: function () {
                    var e = this.model.get("material").getChannels().Opacity;
                    "alphaMask" === e.get("type") && (this.model.set("enable", e.get("enable")), this.model.set("invert", e.get("invert")), this.model.set("factor", e.get("factor")), this.model.setTextureModel(e.getTextureModel()), e.set("enable", !1), e.set("factor", 1), e.set("invert", !1), e.set("type", "alphaBlend"), e.setTextureModel(void 0))
                },
                _checkForceLuminance: function () {
                    var e = this.model.getTextureModel(),
                        t = e && e.getMultiresTexture();
                    if (t) {
                        var i = e.getImageModel();
                        if (!(!1 === i.get("alpha"))) {
                            var n = i.get("name") || t.getImageModel().getURL();
                            if (-1 === (n = n.toLowerCase()).indexOf("jpg") && -1 === n.indexOf("jpeg")) return
                        }
                        e.set("internalFormat", v.Texture.LUMINANCE), e.updateMultiresTexture()
                    }
                },
                updateChannel: function () {
                    this._checkForceLuminance(), M.prototype.updateChannel.call(this), g.Z.redrawShadow()
                },
                _updateMaskingFiltering: function () {
                    var e = this.model.isMasked();
                    if (e !== this._isMasking) {
                        this._isMasking = e;
                        var t = this.model.getTextureModel();
                        if (t && t.get("magFilter") !== v.Texture.NEAREST) {
                            var i = t.get("minFilter"),
                                n = i === v.Texture.LINEAR_MIPMAP_LINEAR,
                                r = i;
                            e && i === n ? r = v.Texture.LINEAR : e || i !== v.Texture.LINEAR || (r = this._blendFilter), r && (t.set("minFilter", i), t.set("magFilter", n ? v.Texture.LINEAR : i), t.updateMultiresTexture())
                        }
                    }
                },
                changeType: function () {
                    this._updateMaskingFiltering(), this.updateChannel()
                }
            }), E.model = b.extend({
                _modelOptionPath: "materials:0.channels.AlphaMask",
                isMasked: function () {
                    var e = this.get("factor");
                    return (this.get("textureModel") || this.get("material").get("vertexAlphaEnable")) && 0 !== e
                },
                isEffective: function () {
                    return !!this.isActivated() && (this.isMasked(), !0)
                },
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uAlphaMaskInvert = v.Uniform.createInt("uAlphaMaskInvert")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformInvert = e.uAlphaMaskInvert.getInternalArray();
                    var t = this.isEnableEffective();
                    this._valueInvert = t && this.get("textureModel") && this.get("invert") ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformInvert[0] = this._valueInvert
                },
                _hasTextureAlpha: function () {
                    var e = this.get("textureModel");
                    if (!e) return !1;
                    var t = e.getMultiresTexture();
                    return !(!t || !t.getOriginalFormat) && t.getOriginalFormat() === v.Texture.ALPHA
                },
                getSRGB: function () {
                    return !this._hasTextureAlpha() && b.prototype.getSRGB.call(this)
                },
                getShaderHash: function () {
                    var e = b.prototype.getShaderHash.call(this);
                    return e += this.get("textureModel") && this.get("textureModel").isLuminance() ? "1" : "0"
                }
            });
            var P = {};
            P.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:type", this.changeType, this), this.model.on("change:invert", this.updateChannel, this), this.model.on("change:ior", this.updateChannel, this), this.model.on("change:roughnessFactor", this.updateChannel, this), this.model.on("change:useMicrosurfaceTexture", this.updateChannel, this), this.model.on("change:useAlbedoTint", this.updateChannel, this), this.model.on("change:useNormalOffset", this.updateChannel, this), this.model.on("change:refractionColor", this.updateChannel, this), this.model.on("change:thinLayer", this.updateChannel, this), this.model.get("material").on("change:vertexAlphaEnable", this.updateChannel, this)
                },
                _checkForceLuminance: function () {
                    var e = this.model.getTextureModel(),
                        t = e && e.getMultiresTexture();
                    if (t) {
                        var i = e.getImageModel();
                        if (!(!1 === i.get("alpha"))) {
                            var n = i.get("name") || t.getImageModel().getURL();
                            if (-1 === (n = n.toLowerCase()).indexOf("jpg") && -1 === n.indexOf("jpeg")) return
                        }
                        e.set("internalFormat", v.Texture.LUMINANCE), e.updateMultiresTexture()
                    }
                },
                updateChannel: function () {
                    var e = this.model.get("material").getChannels();
                    e.RoughnessPBR.isEnableEffective() ? e.RoughnessPBR.trigger("updateChannel") : e.GlossinessPBR.isEnableEffective() && e.GlossinessPBR.trigger("updateChannel"), this._checkForceLuminance(), M.prototype.updateChannel.call(this), g.Z.redrawShadow()
                },
                changeType: function () {
                    this.updateChannel()
                }
            }), P.model = b.extend({
                _modelOptionPath: "materials:0.channels.Opacity",
                getTransparency: function () {
                    return this.get("type")
                },
                setTransparency: function (e) {
                    this.setJSON({
                        type: e
                    })
                },
                isEffective: function () {
                    if (!this.isActivated()) return !1;
                    var e = this.get("type"),
                        t = this.get("factor"),
                        i = this.get("textureModel");
                    if ("dithering" === e) return !0;
                    if (("alphaBlend" === e || "refraction" === e || "additive" === e) && this.get("material").getChannels().SubsurfaceScattering.isEffective()) return !1;
                    return "alphaBlend" !== e && "refraction" !== e && "dithering" !== e || (i || this.get("material").get("vertexAlphaEnable") || 1 !== t)
                },
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uOpacityInvert = v.Uniform.createInt("uOpacityInvert"), e.uOpacityDithering = v.Uniform.createInt("uOpacityDithering"), e.uOpacityAdditive = v.Uniform.createInt("uOpacityAdditive"), e.uOpacityIOR = v.Uniform.createFloat("uOpacityIOR"), e.uOpacityRoughnessFactor = v.Uniform.createFloat("uOpacityRoughnessFactor"), e.uOpacityRefractionColor = v.Uniform.createFloat3("uOpacityRefractionColor"), e.uOpacityThinLayer = v.Uniform.createFloat("uOpacityThinLayer")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformInvert = e.uOpacityInvert.getInternalArray(), this._uniformDithering = e.uOpacityDithering.getInternalArray(), this._uniformAdditive = e.uOpacityAdditive.getInternalArray(), this._uniformIOR = e.uOpacityIOR.getInternalArray(), this._uniformRoughnessFactor = e.uOpacityRoughnessFactor.getInternalArray(), this._uniformRefractionColor = e.uOpacityRefractionColor.getInternalArray();
                    var t = this.isEnableEffective();
                    this._valueInvert = t && this.get("textureModel") && this.get("invert") ? 1 : 0, this._valueDithering = t && "dithering" === this.get("type") ? 1 : 0, this._valueAdditive = t && "additive" === this.get("type") ? 1 : 0;
                    var i = t && "refraction" === this.get("type");
                    this._valueIOR = i ? this.get("ior") : 0, this._valueRoughness = i ? this.get("roughnessFactor") : 0, this._valueRefractionColor = i ? this.get("refractionColor") : v.vec3.ONE, this._uniformThinLayer = e.uOpacityThinLayer.getInternalArray(), this._valueThinLayer = this.get("thinLayer") ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformInvert[0] = this._valueInvert, this._uniformDithering[0] = this._valueDithering, this._uniformAdditive[0] = this._valueAdditive, this._uniformIOR[0] = this._valueIOR, this._uniformRoughnessFactor[0] = this._valueRoughness, v.vec3.copy(this._uniformRefractionColor, this._valueRefractionColor), this._uniformThinLayer[0] = this._valueThinLayer
                },
                _hasTextureAlpha: function () {
                    var e = this.get("textureModel");
                    if (!e) return !1;
                    var t = e.getMultiresTexture();
                    return !(!t || !t.getOriginalFormat) && t.getOriginalFormat() === v.Texture.ALPHA
                },
                getSRGB: function () {
                    return !this._hasTextureAlpha() && b.prototype.getSRGB.call(this)
                },
                _isReadingMicrosurface: function () {
                    if ("refraction" !== this.get("type")) return !1;
                    if (!this.get("useMicrosurfaceTexture")) return !1;
                    if (0 == (h.Z.get("mask") & h.Z.PBR)) return !1;
                    var e = this.get("material").getChannels();
                    return e.RoughnessPBR.isEnableEffective() ? e.RoughnessPBR.getTextureModel() : e.GlossinessPBR.getTextureModel()
                },
                getShaderHash: function () {
                    var e = b.prototype.getShaderHash.call(this),
                        t = this.get("type"),
                        i = "alphaBlend" === t || "additive" === t,
                        n = this.get("textureModel") && this.get("textureModel").isLuminance(),
                        r = "refraction" === t,
                        a = this._isReadingMicrosurface(),
                        o = r && this.get("useAlbedoTint"),
                        s = r && this.get("useNormalOffset");
                    return p.Z.CURRENT_COMPILER === p.Z.SHADOWCAST_COMPILER || p.Z.CURRENT_COMPILER === p.Z.EARLYZ_COMPILER ? (e += i || r ? "1" : "0", e += n ? "1" : "0", e += "0000") : (e += i ? "1" : "0", e += n ? "1" : "0", e += r ? "1" : "0", e += a ? "1" : "0", e += o ? "1" : "0", e += s ? "1" : "0"), e
                }
            });
            var N = {};
            N.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:occludeSpecular", this.updateChannel, this)
                }
            }), N.model = b.extend({
                getModelOptionPath: function () {
                    return "materials:0.channels.AOPBR"
                },
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uAOPBROccludeSpecular = v.Uniform.createInt("uAOPBROccludeSpecular")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformOcclude = e.uAOPBROccludeSpecular.getInternalArray(), this._valueOcclude = this.isEnableEffective() && this.get("occludeSpecular") ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformOcclude[0] = this._valueOcclude
                }
            });
            var O = {};
            O.view = M.extend({}), O.model = b.extend({
                _modelOptionPath: "materials:0.channels.BumpMap",
                addUniforms: function (e, t) {
                    A.call(this, e, t);
                    var i = "u" + t + "Size";
                    e[i] = v.Uniform.createFloat2(v.vec2.create(), i)
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformSize = e["u" + this.get("name") + "Size"].getInternalArray(), this._mrTexture = this.get("textureModel") && this.get("textureModel").getMultiresTexture()
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformSize[0] = this._mrTexture ? this._mrTexture.getWidth() : 0, this._uniformSize[1] = this._mrTexture ? this._mrTexture.getHeight() : 0
                }
            });
            var D = {};
            D.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:colorFactor", this.updateChannel, this)
                }
            }), D.model = b.extend({
                addUniforms: function (e, t) {
                    b.prototype.addUniforms.call(this, e, t);
                    var i = "uSheenColorFactor";
                    e[i] = v.Uniform.createFloat3(v.vec3.create(), i)
                },
                cacheUniforms: function (e) {
                    b.prototype.cacheUniforms.call(this, e), this._uniformColorFactor = e.uSheenColorFactor.getInternalArray(), this._valueColorFactor = this.get("colorFactor") || v.vec3.create()
                },
                updateUniforms: function () {
                    b.prototype.updateUniforms.call(this), v.vec3.copy(this._uniformColorFactor, this._valueColorFactor)
                }
            });
            var I = {};
            I.view = M.extend({}), I.model = b.extend({
                isEnableEffective: function () {
                    return this.get("material").getChannels().Sheen.isEnableEffective()
                }
            });
            var F = {};
            F.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:thickness", this.updateChannel, this), this.model.on("change:tint", this.updateChannel, this), this.model.on("change:reflectivity", this.updateChannel, this), this.model.on("change:useBaseNormalMap", this.updateChannel, this)
                }
            }), F.model = b.extend({
                addUniforms: function (e, t) {
                    b.prototype.addUniforms.call(this, e, t);
                    var i = "uClearCoatThickness";
                    e[i] = v.Uniform.createFloat(0, i), e[i = "uClearCoatIor"] = v.Uniform.createFloat(0, i), e[i = "uClearCoatF0"] = v.Uniform.createFloat(0, i), e[i = "uClearCoatTint"] = v.Uniform.createFloat3(v.vec3.create(), i)
                },
                cacheUniforms: function (e) {
                    b.prototype.cacheUniforms.call(this, e), this._uThickness = e.uClearCoatThickness.getInternalArray(), this._uIor = e.uClearCoatIor.getInternalArray(), this._uF0 = e.uClearCoatF0.getInternalArray(), this._uTint = e.uClearCoatTint.getInternalArray(), this._valueRoughness = this.get("roughness"), this._valueThickness = this.get("thickness");
                    var t = this.get("reflectivity");
                    this._valueIOR = 1.4 * (1 - t) + 1 * t, this._valueF0 = .04 * (1 + t), this.updateTintUniform()
                },
                updateTintUniform: function () {
                    var e = this.get("thickness"),
                        t = Math.max(20 - e, .01);
                    this._valueTint || (this._valueTint = v.vec3.create()), v.vec3.copy(this._valueTint, this.get("tint")), this._valueTint[0] = -Math.log(v.clamp(this._valueTint[0], .01, .99)) / t, this._valueTint[1] = -Math.log(v.clamp(this._valueTint[1], .01, .99)) / t, this._valueTint[2] = -Math.log(v.clamp(this._valueTint[2], .01, .99)) / t
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uThickness[0] = this._valueThickness, v.vec3.copy(this._uTint, this._valueTint), this._uIor[0] = this._valueIOR, this._uF0[0] = this._valueF0
                }
            }), F.model.validateJSON = function (e, t, i) {
                return b.validateJSON(e, t, i)
            };
            var L = {};
            L.view = M.extend({}), L.model = b.extend({
                isEnableEffective: function () {
                    return this.get("material").getChannels().ClearCoat.isEnableEffective()
                }
            });
            var V = {};
            V.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:flipY", this.updateChannel, this)
                }
            }), V.model = b.extend({
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uClearCoatNormalMapFlipY = v.Uniform.createInt("uClearCoatNormalMapFlipY")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformFlip = e.uClearCoatNormalMapFlipY.getInternalArray(), this._valueFlip = this.isEnableEffective() && this.get("flipY") ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformFlip[0] = this._valueFlip
                },
                isEffective: function () {
                    return this.get("material").getChannels().ClearCoat.isEffective() && void 0 !== this.getTextureModel()
                }
            });
            var B, U = {};
            U.view = M.extend({
                updateChannel: function () {
                    M.prototype.updateChannel.call(this), this.model.updateGeometryOffsets(), g.Z.redrawShadow()
                }
            }), U.model = b.extend({
                _modelOptionPath: "materials:0.channels.Displacement",
                updateGeometryOffsets: (B = v.vec3.create(), function () {
                    var e = this.isEffective() ? this.getFactor() : 0;
                    if (f.Z.updateMaxWorldDisplacement(e), 0 !== e)
                        for (var t = this.get("material").get("geometryList"), i = 0, n = t.length; i < n; ++i) {
                            var r = t[i];
                            if (!r._maxScale) {
                                for (var a = r.getWorldMatrices(), o = 0, s = 0, l = a.length; s < l; ++s) v.mat4.getScale(B, a[s]), o = Math.max(o, B[0], B[1], B[2]);
                                r._maxScale = o
                            }
                            var u = e / (r._maxScale || 1);
                            r._displacementFactor = Math.max(r._displacementFactor || 0, u), r.dirtyBound()
                        }
                }),
                setTextureModel: function (e) {
                    return e && e.get("minFilter") === v.Texture.LINEAR_MIPMAP_LINEAR && (e.set("minFilter", v.Texture.LINEAR), e.updateMultiresTexture()), b.prototype.setTextureModel.call(this, e)
                },
                addUniforms: function (e, t) {
                    O.model.prototype.addUniforms.call(this, e, t), e.uDisplacementNormal = v.Uniform.createFloat(1, "uDisplacementNormal")
                },
                cacheUniforms: function (e) {
                    if (O.model.prototype.cacheUniforms.call(this, e), this._uniformNormal = e.uDisplacementNormal.getInternalArray(), this.isEnableEffective()) {
                        var t = f.Z.getModelBoxWithoutDisplacement();
                        t ? this._valueNormal = 250 * this.get("factor") / t.radius() : f.Z.getBoxReady().then(this.cacheUniforms.bind(this, e))
                    } else this._valueNormal = 0
                },
                updateUniforms: function () {
                    O.model.prototype.updateUniforms.call(this), this._uniformNormal[0] = this._valueNormal
                }
            });
            var k = {};
            k.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:flipY", this.updateChannel, this)
                }
            }), k.model = b.extend({
                _modelOptionPath: "materials:0.channels.NormalMap",
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uNormalMapFlipY = v.Uniform.createInt("uNormalMapFlipY")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformFlip = e.uNormalMapFlipY.getInternalArray(), this._valueFlip = this.isEnableEffective() && this.get("flipY") ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformFlip[0] = this._valueFlip
                }
            });
            var Z, H = {};
            H.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:type", this.updateChannel, this)
                }
            }), H.model = y.model.extend({
                _modelOptionPath: "materials:0.channels.EmitColor",
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uEmitMultiplicative = v.Uniform.createInt("uEmitMultiplicative")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformMultiply = e.uEmitMultiplicative.getInternalArray();
                    var t = this.isEnableEffective() && "multiplicative" === this.get("type");
                    this._valueMultiply = t ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformMultiply[0] = this._valueMultiply
                },
                isEffective: function () {
                    return !!this.isActivated() && (0 !== this.get("factor") || "additive" !== this.get("type"))
                }
            });
            var G = function () {
                if (Z) return Z;
                0 === (Z = m.Z.instance.getMatcapCollection()).length && Z.addNewImage({
                    url: l.Z.defaultMatcapUid,
                    name: l.Z.defaultMatcapUid,
                    width: 1,
                    height: 1
                }).set("uid", l.Z.defaultMatcapUid);
                return Z
            },
                z = {};
            z.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:curvature", this.updateChannel, this)
                }
            }), z.model = y.model.extend({
                _modelOptionPath: "materials:0.channels.Matcap",
                _adaptJSON: function () { },
                initialize: function () {
                    if (b.prototype.initialize.apply(this, arguments), !this.get("textureModel")) {
                        var e = G(),
                            t = e.get(l.Z.defaultMatcapUid);
                        t || (t = e.at(0)), this.setChannelJSON({
                            texture: {
                                uid: t.getUID()
                            }
                        })
                    }
                },
                setTextureModel: function (e) {
                    return this.set("textureModel", e), this.trigger("setTextureModel")
                },
                setColor: function (e) {
                    return this.set("color", v.vec3.copy(this.get("color") || v.vec3.create(), e)), this.trigger("setColor")
                },
                isEffective: function () {
                    return !!this.isActivated()
                },
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uMatcapCurvature = v.Uniform.createFloat("uMatcapCurvature"), e.uMatcapColor = v.Uniform.createFloat3("uMatcapColor")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformCurvature = e.uMatcapCurvature.getInternalArray(), this._valueCurvature = this.isEnableEffective() ? this.get("curvature") : 0, this._uniformColor = e.uMatcapColor.getInternalArray(), this._valueColor = this.isEnableEffective() ? this.get("color") : v.vec3.ONE
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformCurvature[0] = this._valueCurvature, v.vec3.copy(this._uniformColor, this._valueColor)
                },
                getJSON: function () {
                    return b.prototype.getJSON.call(this)
                },
                setChannelJSON: function (e, t, i) {
                    return !1 === e.enable && (e.enable = !0), b.prototype.setChannelJSON.call(this, e, G(), i)
                },
                resetToDefaultMatcap: function () {
                    this.setChannelJSON({
                        texture: {
                            uid: l.Z.defaultMatcapUid
                        }
                    })
                }
            });
            var W = {};
            W.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:profile", this.updateChannel, this)
                }
            }), W.model = b.extend({
                _modelOptionPath: "materials:0.channels.SubsurfaceScattering",
                initialize: function () {
                    b.prototype.initialize.apply(this, arguments), this._initFactorFromBox("factor", .05)
                },
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uSubsurfaceScatteringProfile = v.Uniform.createFloat("uSubsurfaceScatteringProfile")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformProfile = e.uSubsurfaceScatteringProfile.getInternalArray(), this._valueProfile = this.isEnableEffective() ? this.get("profile") : 1
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformProfile[0] = this._valueProfile
                }
            });
            var j = {};
            j.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:thicknessFactor", this.updateChannel, this)
                }
            }), j.model = y.model.extend({
                _modelOptionPath: "materials:0.channels.SubsurfaceTranslucency",
                initialize: function () {
                    b.prototype.initialize.apply(this, arguments), this._initFactorFromBox("thicknessFactor", .05)
                },
                setTextureModel: z.model.prototype.setTextureModel,
                setColor: z.model.prototype.setColor,
                getJSON: z.model.prototype.getJSON,
                setJSON: z.model.prototype.setJSON,
                _adaptJSON: z.model.prototype._adaptJSON,
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uSubsurfaceTranslucencyColor = v.Uniform.createFloat3("uSubsurfaceTranslucencyColor"), e.uSubsurfaceTranslucencyThicknessFactor = v.Uniform.createFloat("uSubsurfaceTranslucencyThicknessFactor")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformThicknessFactor = e.uSubsurfaceTranslucencyThicknessFactor.getInternalArray(), this._uniformColor = e.uSubsurfaceTranslucencyColor.getInternalArray(), this._valueColor = this.isEnableEffective() ? this.get("color") : v.vec3.ONE, this._valueThicknessFactor = this.isEnableEffective() ? this.get("thicknessFactor") : 0
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformThicknessFactor[0] = this._valueThicknessFactor, v.vec3.copy(this._uniformColor, this._valueColor)
                }
            });
            var X = {};
            X.view = M.extend({
                initialize: function () {
                    M.prototype.initialize.apply(this, arguments), this.model.on("change:direction", this.updateChannel, this), this.model.on("change:flipXY", this.updateChannel, this)
                }
            }), X.model = b.extend({
                isEnableEffective: function () {
                    return b.prototype.isEnableEffective.call(this) && !this.get("material").get("missingUvs")
                },
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uAnisotropyDirection = v.Uniform.createFloat("uAnisotropyDirection"), e.uAnisotropyFlipXY = v.Uniform.createInt("uAnisotropyFlipXY")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformDirection = e.uAnisotropyDirection.getInternalArray(), this._valueDirection = this.isEnableEffective() ? this.get("direction") : 0, this._uniformFlipXY = e.uAnisotropyFlipXY.getInternalArray(), this._valueXY = this.get("flipXY") ? 1 : 0
                },
                updateUniforms: function () {
                    w.call(this);
                    var e = !!this.getTextureModel() ? -1 : Math.sign(this._valueDirection) || 1;
                    this._uniformFactor[0] = this._valueFactor * e, this._uniformDirection[0] = this._valueDirection < 0 ? 1 + this._valueDirection : this._valueDirection, this._uniformFlipXY[0] = this._valueXY
                }
            });
            var Y = {};
            Y.view = M.extend({}), Y.model = y.model.extend({
                transient: !0,
                initialize: function () {
                    S.prototype.initialize.apply(this, arguments), this.set("selectUV", 0)
                },
                setInspectorSRGB: function (e) {
                    this._srgb = e
                },
                getSRGB: function () {
                    return !!this._srgb
                },
                setTextureModel: z.model.prototype.setTextureModel,
                setColor: z.model.prototype.setColor,
                addUniforms: function (e, t) {
                    A.call(this, e, t), e.uInspectorInvert = v.Uniform.createInt("uInspectorInvert"), e.uInspectorMaskThreshold = v.Uniform.createFloat("uInspectorMaskThreshold"), e.uInspectorColor = v.Uniform.createFloat3("uInspectorColor"), e.uInspectorSelected = v.Uniform.createInt("uInspectorSelected")
                },
                cacheUniforms: function (e) {
                    R.call(this, e), this._uniformInvert = e.uInspectorInvert.getInternalArray(), this._uniformMaskThreshold = e.uInspectorMaskThreshold.getInternalArray(), this._uniformColor = e.uInspectorColor.getInternalArray(), this._uniformSelected = e.uInspectorSelected.getInternalArray()
                },
                updateUniforms: function () {
                    w.call(this), this._uniformFactor[0] = this._valueFactor, this._uniformInvert[0] = this.get("invert") ? 1 : 0, this._uniformMaskThreshold[0] = this.get("maskThreshold"), v.vec3.copy(this._uniformColor, this.getColor()), this._uniformSelected[0] = this.get("isSelected") ? 1 : 0
                },
                setChannelJSON: function (e, t) {
                    (void 0 !== e.enable && this.setEnable(e.enable), void 0 !== e.factor && this.setFactor(e.factor), e.color && this.setColor(e.color), e.texture) && (this._createTextureModel(e.texture, t) || this.setColor(e.color || v.vec3.fromValues(1, 1, 1)));
                    return void 0 !== e.invert && this.set("invert", e.invert), void 0 !== e.maskThreshold && this.set("maskThreshold", e.maskThreshold), []
                },
                setTexCoordUnit: function (e) {
                    b.prototype.setTexCoordUnit.call(this, e), this.set("fallbackUV", e)
                },
                getShaderHash: function () {
                    var e = b.prototype.getShaderHash.call(this);
                    return e += this.isEffective() && !this.get("textureModel") ? this.get("selectUV") : 0
                },
                getJSON: function () {
                    var e = {},
                        t = this.get("textureModel");
                    t && (e.texture = t.getJSON());
                    var i = this.get("color");
                    return i && (e.color = i), e.factor = this.get("factor"), e.enable = this.get("enable"), e.invert = this.get("invert"), e.maskThreshold = this.get("maskThreshold"), e
                }
            });
            const J = {
                DiffusePBR: y,
                AlbedoPBR: y,
                SpecularPBR: y,
                GlossinessPBR: T,
                RoughnessPBR: T,
                MetalnessPBR: T,
                SpecularF0: T,
                CavityPBR: T,
                Matcap: z,
                SubsurfaceTranslucency: j,
                DiffuseColor: y,
                SpecularColor: y,
                DiffuseIntensity: y,
                SpecularHardness: T,
                SubsurfaceScattering: W,
                Displacement: U,
                NormalMap: k,
                AOPBR: N,
                BumpMap: O,
                EmitColor: H,
                Opacity: P,
                AlphaMask: E,
                ClearCoat: F,
                ClearCoatRoughness: L,
                ClearCoatNormalMap: V,
                Anisotropy: X,
                Sheen: D,
                SheenRoughness: I,
                Inspector: Y
            }
        },
        pXO4: (e, t, i) => {
            i.d(t, {
                Z: () => T
            });
            var n = i("pql+"),
                r = i("lZH+"),
                a = i.n(r),
                o = i("aqzA"),
                s = i("avzw"),
                l = i("wAYD"),
                u = i("aMVL"),
                c = i("qk4i"),
                h = i("QKpV"),
                d = i("Rdny"),
                g = i("MQQR");
            i("R2Pi");
            var f = o.Z.osg,
                m = f.StateAttribute.OVERRIDE_ON,
                p = f.createTexturedFullScreenFakeQuadGeometry(),
                v = function (e, t) {
                    f.Camera.call(this), this.addChild(p), this.setNodeMask(0), this._outTexture = e, this._packedTextures = (0, n.Z)(t.getPackedTextures()), this._channels = t.getOrderedChannels().slice(), this._lastHash = "", this.initPacking()
                };
            v.AUTO_RELEASE_GL = !1;
            var _, S = function (e) {
                for (var t in _)
                    for (var i = _[t].get("stateSet"), n = i.getNumTextureAttributeLists(), r = 0; r < n; ++r) {
                        var a = i.getTextureAttribute(r, "Texture");
                        if (a && a.getTexture && a.getTexture() === e) return !1
                    }
                return !0
            };
            f.createPrototypeNode(v, f.objectInherit(f.Camera.prototype, {
                getNbChannels: function () {
                    return this._channels.length
                },
                disablePacking: function () {
                    this.setNodeMask(0);
                    for (var e = this.getStateSet(), t = this.getNbChannels(), i = 0; i < t; ++i) {
                        var n = e.getTextureAttribute(i, "Texture");
                        n && n !== s.Z.dummyTexture && S(n) && n.releaseGLObjects()
                    }
                    if (v.AUTO_RELEASE_GL) {
                        var r = this.frameBufferObject;
                        r && r.releaseGLObjects()
                    }
                },
                initPacking: function () {
                    var e = this.getOrCreateStateSet(),
                        t = this._packedTextures,
                        i = 0,
                        n = this._channels,
                        r = n.length,
                        a = f.Uniform.createInt4("uReadPacking"),
                        o = a.getInternalArray();
                    for (i = 0; i < r; ++i) {
                        var l = n[i],
                            u = t[l].texture.getInternalFormat() === f.Texture.ALPHA,
                            c = d.Z.getDefaultComponentCount(l);
                        o[i] = 2 === c ? 4 : 3 === c ? u ? 3 : 2 : u ? 1 : 0
                    }
                    for (i = 0; i < 4; ++i) e.setTextureAttributeAndModes(i, s.Z.dummyTexture, m);
                    this._outTexture.setTextureSize(1, 1), this.setRenderOrder(f.Camera.PRE_RENDER, 0), this.attachTexture(f.FrameBufferObject.COLOR_ATTACHMENT0, this._outTexture, f.Texture.TEXTURE_2D);
                    var h = new f.Viewport(0, 0, 1, 1);
                    this.setReferenceFrame(f.Transform.ABSOLUTE_RF), this.setViewport(h), e.addUniform(f.Uniform.createInt(0, "uTexture0"), m), e.addUniform(f.Uniform.createInt(1, "uTexture1"), m), e.addUniform(f.Uniform.createInt(2, "uTexture2"), m), e.addUniform(f.Uniform.createInt(3, "uTexture3"), m), e.addUniform(a, m)
                },
                updatePacking: function (e) {
                    var t, i = this._packedTextures,
                        n = this._channels,
                        r = n.length,
                        a = 0,
                        o = "";
                    for (a = 0; a < r; ++a) o += "" + (t = i[n[a]].texture).getWidth() + t.getHeight();
                    if (o === this._lastHash) return 0;
                    var s = 0,
                        l = 0;
                    for (a = 0; a < r; ++a) {
                        if (!(t = i[n[a]].texture).apply(e)) return -1;
                        s = Math.max(s, t.getWidth()), l = Math.max(l, t.getHeight())
                    }
                    if (!c.Z.requestTextureBudget(s * l)) return -1;
                    this._lastHash = o, this.setNodeMask(-1);
                    var u = this.getStateSet();
                    for (a = 0; a < r; ++a) t = i[n[a]].texture, u.setTextureAttributeAndModes(a, t, m);
                    return this._outTexture.setTextureSize(s, l), this._outTexture.dirtyMipmap(), this._outTexture._rttPass = !0, this.setRenderOrder(f.Camera.PRE_RENDER, 0), this.resetAttachments(), this.attachTexture(f.FrameBufferObject.COLOR_ATTACHMENT0, this._outTexture, f.Texture.TEXTURE_2D), this.getViewport().setViewport(0, 0, s, l), (this._packedTextures.Opacity || this._packedTextures.Displacement) && c.Z.redrawShadowNextFrame(), s * l
                }
            }), "osgtestdemo2024", "TexturePacker");
            var x = function () {
                f.Node.call(this), this.setCullCallback(this), this._program = l.Z.getOrCreateShader("attribute vec3 Vertex;\nvarying vec2 vTexCoord0;\n\nvoid main(void) {\n    gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);\n    vTexCoord0 = Vertex.xy;\n}\n", "uniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uTexture2;\nuniform sampler2D uTexture3;\n\n// vec4 (up to 4 textures input)\n// int meaning :\n// 0 -> read R\n// 1 -> read A\n// 2 -> read RGB\n// 3 -> read AAA\n// 4 -> read RG\nuniform ivec4 uReadPacking;\n\nvarying vec2 vTexCoord0;\n\nvoid main(void) {\n    if (uReadPacking.x == 4) {\n        gl_FragColor.rg = texture2D(uTexture0, vTexCoord0).rg;\n        if (uReadPacking.y == 4) {\n            gl_FragColor.ba = texture2D(uTexture1, vTexCoord0).rg;\n        } else {\n            gl_FragColor.b = uReadPacking.y == 0 ? texture2D(uTexture1, vTexCoord0).r : texture2D(uTexture1, vTexCoord0).a;\n            gl_FragColor.a = uReadPacking.z == 0 ? texture2D(uTexture2, vTexCoord0).r : texture2D(uTexture2, vTexCoord0).a;\n        }\n\n    } else if (uReadPacking.x == 3) {\n        // 1 rgb, 1 greyscale\n        gl_FragColor.rgb = texture2D(uTexture0, vTexCoord0).aaa;\n        gl_FragColor.a = uReadPacking.y == 0 ? texture2D(uTexture1, vTexCoord0).r : texture2D(uTexture1, vTexCoord0).a;\n\n    } else if (uReadPacking.x == 2) {\n        // 3 aaa, 1 greyscale\n        gl_FragColor.rgb = texture2D(uTexture0, vTexCoord0).rgb;\n        gl_FragColor.a = uReadPacking.y == 0 ? texture2D(uTexture1, vTexCoord0).r : texture2D(uTexture1, vTexCoord0).a;\n\n    } else {\n        // 4 greyscales\n        gl_FragColor.r = uReadPacking.x == 0 ? texture2D(uTexture0, vTexCoord0).r : texture2D(uTexture0, vTexCoord0).a;\n        gl_FragColor.g = uReadPacking.y == 0 ? texture2D(uTexture1, vTexCoord0).r : texture2D(uTexture1, vTexCoord0).a;\n        gl_FragColor.b = uReadPacking.z == 0 ? texture2D(uTexture2, vTexCoord0).r : texture2D(uTexture2, vTexCoord0).a;\n        gl_FragColor.a = uReadPacking.w == 0 ? texture2D(uTexture3, vTexCoord0).r : texture2D(uTexture3, vTexCoord0).a;\n    }\n}", "material-packer", "MaterialPacker"), this._dirtyPackedTextures = [], this._cacheCameras = {}, this._currentPackingCameras = [], this._frameCount = -1, this._lowResDone = !1, this._highResDone = !1, this._canResolveHighRes = !1, this._allMaterialsPackingCalled = !1
            };
            f.createPrototypeNode(x, f.objectInherit(f.Node.prototype, {
                initReadyForHighResBound: function () {
                    ((0, g.Z)().preload ? u.Z.getHighResLoaded() : a().all([u.Z.getHighResLoaded(), u.Z.getFirstCameraAnimation()])).then(function () {
                        this._canResolveHighRes = !0
                    }.bind(this))
                },
                addPackedTexture: function (e) {
                    this._allMaterialsPackingCalled && this._dirtyPackedTextures.push(e)
                },
                removePackedTexture: function (e) {
                    var t = this._dirtyPackedTextures.indexOf(e);
                    t >= 0 && (this._dirtyPackedTextures[t] = void 0)
                },
                packAllMaterialsTextures: function (e) {
                    for (var t in e)
                        for (var i = e[t].get("stateSet"), n = i.getNumTextureAttributeLists(), r = 0; r < n; ++r) {
                            var a = i.getTextureAttribute(r, "Texture");
                            a && a.getTexture && a.getTexture()
                        }
                    this._allMaterialsPackingCalled = !0
                },
                resetCaches: function () {
                    var e = this.frameBufferObject;
                    e && e.releaseGLObjects(), this._cacheCameras = {}, this._currentPackingCameras = []
                },
                deleteUnusedCameras: function (e) {
                    var t = {};
                    for (var i in e)
                        for (var n = e[i].get("stateSet"), r = n.getNumTextureAttributeLists(), a = 0; a < r; ++a) {
                            var o = n.getTextureAttribute(a, "Texture");
                            if (o && o.getTexture) t[this._getHash(o)] = !0
                        }
                    var s = this._cacheCameras;
                    for (var l in s)
                        if (!t[l]) {
                            var u = s[l];
                            u.disablePacking(), u.getParents()[0].removeChild(u), delete this._cacheTextures[l]
                        }
                },
                packTextures: function (e) {
                    var t = e.getPackedTextures(),
                        i = e.getOrderedChannels();
                    if (0 === i.length) return f.Texture.textureNull;
                    var n = t[i[0]].texture;
                    if (1 === i.length) return n;
                    var r = this._getHash(e);
                    if (this._cacheCameras[r]) return this._cacheCameras[r]._outTexture;
                    var a = new s.Z;
                    a.setForceUpload(!0), a.setImageFormat(f.Texture.RGBA), a.setWrapS(n.getWrapS()), a.setWrapT(n.getWrapT()), a.setMagFilter(n.getMagFilter());
                    var o, l = n.getMinFilter();
                    a.setMinFilter(l), l === f.Texture.LINEAR_MIPMAP_LINEAR && (0, g.Z)().anisotropy && a.setMaxAnisotropy(16), (o = a).generateMipmap = function () {
                        this._dirtyMipmap && (this._rttPass || f.Texture.prototype.generateMipmap.apply(this, arguments), this._rttPass = !1)
                    }.bind(o);
                    var u = new v(a, e);
                    return u.getOrCreateStateSet().setAttributeAndModes(this._program, m), this._cacheCameras[r] = u, this.addChild(u), a
                },
                _getHash: function (e) {
                    var t = "";
                    if (e.getOrderedChannels().length <= 1) return t;
                    for (var i = e.getPackedTextures(), n = e.getOrderedChannels(), r = 0; r < n.length; ++r) {
                        var a = n[r],
                            o = i[a].texture,
                            s = d.Z.getDefaultComponentCount(a);
                        t += o.getInstanceID() + "-" + s + "-"
                    }
                    return t
                },
                _createNewJobs: function () {
                    var e = this._dirtyPackedTextures,
                        t = e.length;
                    if (t) {
                        for (var i = 0; i < t; ++i) e[i] && e[i].getTexture();
                        e.length = 0
                    }
                },
                _disableOldJobs: function () {
                    var e = this._currentPackingCameras,
                        t = e.length;
                    if (!t) return 0;
                    for (var i = 0; i < t; ++i) e[i].disablePacking();
                    return e.length = 0, c.Z.draw(), t
                },
                _updateNewJobs: function (e) {
                    for (var t = this._currentPackingCameras, i = this.getChildren(), n = i.length, r = 0; r < n; ++r) {
                        var a = i[r].updatePacking(e);
                        if (0 !== a) {
                            if (a < 0) return t.length || -1;
                            t.push(i[r])
                        }
                    }
                    return t.length
                },
                _checkResolveHighResBound: function () {
                    if (this._canResolveHighRes && !this._highResDone) {
                        this._highResDone = !0, u.Z.resolveHighResBound(), (0, g.Z)().textureFrameBudget = 1 / 0;
                        var e = this.getChildren(),
                            t = e.length;
                        h.Z.logMessage("Texture packing FBO Count : " + t), v.AUTO_RELEASE_GL = !0;
                        for (var i = 0; i < t; ++i) {
                            var n = e[i].frameBufferObject;
                            n && n.releaseGLObjects()
                        }
                    }
                },
                _checkResolveLowResBound: function () {
                    this._lowResDone || (this._lowResDone = !0, u.Z.resolveLowResBound())
                },
                cull: function (e, t) {
                    if (this._frameCount++, 0 === this._frameCount) return !0;
                    this._createNewJobs();
                    var i = this._disableOldJobs(),
                        n = this._updateNewJobs(t.getRenderer().getState());
                    return this._frameCount > 1 && !i && !n && (this._checkResolveLowResBound(), this._checkResolveHighResBound()), !0
                }
            }));
            var C = new x;
            C.setMaterials = function (e) {
                _ = e
            };
            const T = C
        },
        gvzH: (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = {
                PICK_GEOMETRY_FIXED: 1,
                PICK_GEOMETRY_ANIMATED: 2,
                PICK_GEOMETRY_RIG_BOX: 4,
                PICK_GIZMO_LIGHT: 8,
                SHADOW_CAST: 16,
                SHADOW_BOUNDS: 32
            };
            n.PICK_GEOMETRY_SLOW = n.PICK_GEOMETRY_FIXED | n.PICK_GEOMETRY_ANIMATED, n.PICK_GEOMETRY_FAST = n.PICK_GEOMETRY_FIXED | n.PICK_GEOMETRY_RIG_BOX, n.PICK_GEOMETRY = n.PICK_GEOMETRY_FIXED | n.PICK_GEOMETRY_ANIMATED | n.PICK_GEOMETRY_RIG_BOX, n.PICK = n.PICK_GEOMETRY | n.PICK_GIZMO_LIGHT, n.SHADOW = n.SHADOW_BOUNDS | n.SHADOW_CAST, n.PICK_GEOMETRY_SHADOW = n.PICK_GEOMETRY | n.SHADOW, n.NO_SHADOW = ~n.SHADOW, n.NO_PICK = ~n.PICK, n.NO_PICK_NO_SHADOW_CAST = ~(n.PICK | n.SHADOW_CAST), n.NO_PICK_NO_SHADOW_BOUNDS = ~(n.PICK | n.SHADOW_BOUNDS), n.NO_PICK_NO_SHADOW = ~(n.PICK | n.SHADOW);
            const r = n
        },
        WoEt: (e, t, i) => {
            i.d(t, {
                Z: () => l
            });
            var n = i("aqzA"),
                r = i("Rdny"),
                a = i("KXnA"),
                o = n.Z.osg,
                s = function () {
                    o.StateAttribute.call(this), this._channelMapping = {}, this._materialModel = void 0, this._stateSetContext = void 0, this._additive = !1, this._depthWrite = !0, this._castShadows = !0, this._hashes = ["", ""], this._dirtyUniforms = !0, this._activeChannels = []
                };
            s.SHADING_COMPILER = 0, s.EARLYZ_COMPILER = 1, s.SHADOWCAST_COMPILER = 2, s.WIREFRAME_COMPILER = 3, s.CURRENT_COMPILER = s.SHADING_COMPILER, (s.compilerChannels = [])[s.SHADING_COMPILER] = r.Z, s.compilerChannels[s.EARLYZ_COMPILER] = ["AlphaMask", "Opacity", "Displacement", "SubsurfaceScattering"], s.compilerChannels[s.SHADOWCAST_COMPILER] = ["Displacement", "AlphaMask", "Opacity"], s.compilerChannels[s.WIREFRAME_COMPILER] = ["Displacement"], s.hasVertexColor = !1, s.hasVertexAlpha = !1, o.createPrototypeStateAttribute(s, o.objectInherit(o.StateAttribute.prototype, {
                attributeType: "testdemo2024Material",
                dirtyMaterial: function () {
                    for (var e = this._hashes.length, t = 0; t < e; ++t) this._hashes[t] = "";
                    this._dirtyUniforms = !0
                },
                getHash: function () {
                    if (!this._materialModel) return "";
                    var e = this._hashes[s.CURRENT_COMPILER];
                    if (e) return e;
                    e = this.attributeType, s.CURRENT_COMPILER !== s.WIREFRAME_COMPILER && (e += this.getVertexAlphaEnable() ? "1" : "0"), s.CURRENT_COMPILER === s.SHADING_COMPILER && (e += this.getShadeless() ? "1" : "0", e += this.getVertexColorEnable() ? "1" : "0", e += this.getHasOnlyPoints() ? "1" : "0", e += "srgb" === this.getVertexColorColorSpace() ? "1" : "0", e += a.Z.get("hasSsr") ? "1" : "0");
                    for (var t = s.CURRENT_COMPILER === s.SHADOWCAST_COMPILER, i = this._materialModel.getChannels(), n = s.compilerChannels[s.CURRENT_COMPILER], r = n.length, o = this._channelMapping, l = 0; l < r; ++l) {
                        var u = n[l],
                            c = i[u];
                        if (c.isEnableEffective())
                            if (!t || this._castShadows) {
                                var h = o[u];
                                e += ".", e += h < 0 ? "" : h, e += c.getShaderHash(), e += this.getChannelPacking(u)
                            } else e += ".0";
                        else e += ".0"
                    }
                    return this._hashes[s.CURRENT_COMPILER] = e, e
                },
                setMaterialModel: function (e) {
                    this._materialModel = e
                },
                setStateSetContext: function (e) {
                    this._stateSetContext = e
                },
                setChannelMapping: function (e, t) {
                    this._channelMapping[e] = t
                },
                getChannelPacking: function (e) {
                    return this._stateSetContext ? this._stateSetContext.getChannelPacking(e) : ""
                },
                updateOpacity: function () {
                    this._additive = !1, this._depthWrite = !0, this._castShadows = !0;
                    var e = this._materialModel.getChannels().Opacity;
                    if (e.isEffective()) {
                        var t = e.getTransparency();
                        if ("dithering" !== t) {
                            if ("additive" === t) return this._additive = !0, this._depthWrite = !1, void (this._castShadows = !1);
                            var i = !1;
                            return 1 === e.getFactor() && (i = e.getTextureModel() || this.getVertexAlphaEnable()), i ? void 0 : (this._depthWrite = !1, void (this._castShadows = !1))
                        }
                    }
                },
                cloneType: function () {
                    return new s
                },
                getType: function () {
                    return this.attributeType
                },
                getTypeMember: function () {
                    return this.attributeType
                },
                getMaterialModel: function () {
                    return this._materialModel
                },
                getShadeless: function () {
                    return this._materialModel && this._materialModel.get("shadeless")
                },
                getReflection: function () {
                    return this._materialModel && this._materialModel.get("reflection")
                },
                getVertexColorEnable: function () {
                    return this._materialModel && this._materialModel.get("vertexColorEnable")
                },
                getVertexAlphaEnable: function () {
                    return this._materialModel && this._materialModel.get("vertexAlphaEnable")
                },
                getVertexColorColorSpace: function () {
                    return this._materialModel && this._materialModel.get("vertexColorColorSpace")
                },
                getCullFace: function () {
                    return this._materialModel && this._materialModel.get("cullFace")
                },
                getHasOnlyPoints: function () {
                    return this._materialModel && this._materialModel.hasOnlyPoints()
                },
                getAdditive: function () {
                    return this._additive
                },
                getDepthWrite: function () {
                    return this._depthWrite
                },
                getCastShadows: function () {
                    return this._castShadows
                },
                getChannelMapping: function (e) {
                    return this._channelMapping[e]
                },
                getOrCreateUniforms: function () {
                    if (s.uniforms) return s.uniforms;
                    var e = s.uniforms = {};
                    e.uReflection = o.Uniform.createFloat("uReflection");
                    for (var t = i("Majl").Z, n = r.Z.length, a = 0; a < n; ++a) {
                        var l = r.Z[a],
                            u = t[l].model;
                        u.prototype.addUniforms.call(u, e, l)
                    }
                    return e
                },
                _cacheChannelUniforms: function () {
                    var e = this.getOrCreateUniforms(),
                        t = this._materialModel.getChannels(),
                        i = r.Z.length,
                        n = this._activeChannels;
                    n.length = 0;
                    for (var a = 0; a < i; ++a) {
                        var o = t[r.Z[a]];
                        o.isEnableEffective() && (o.cacheUniforms(e), n.push(o))
                    }
                },
                apply: function () {
                    if (this._materialModel) {
                        this._dirtyUniforms && (this._dirtyUniforms = !1, this._cacheChannelUniforms()), this.getOrCreateUniforms().uReflection.setFloat(this.getReflection());
                        for (var e = this._activeChannels, t = e.length, i = 0; i < t; ++i) e[i].updateUniforms()
                    }
                }
            }), "osgtestdemo2024", "Material");
            const l = s
        },
        avzw: (e, t, i) => {
            i.d(t, {
                Z: () => p
            });
            var n = i("lZH+"),
                r = i.n(n),
                a = i("aqzA"),
                o = i("mv18"),
                s = i("N8nW"),
                l = i("YxXF"),
                u = i("aMVL"),
                c = i("qk4i"),
                h = i("MQQR"),
                d = i("BvLe"),
                g = a.Z.osg,
                f = function () {
                    g.Texture.call(this), this._isVideo = !1, this._requireOriginalCompression = !1, this._imageModel = void 0, this._convertNPOT = !d.Z.instance().isWebGL2(), this._truePackingRead = void 0
                },
                m = g.ImageStream.prototype.play;
            g.ImageStream.prototype.play = function () {
                this._status !== g.ImageStream.PLAYING && (c.Z.draw(), m.call(this))
            }, g.createPrototypeStateAttribute(f, g.objectInherit(g.Texture.prototype, {
                isVideo: function () {
                    return this._isVideo
                },
                getOriginalFormat: function () {
                    return this._truePackingRead || this.getInternalFormat()
                },
                _resizeToNearestPowerOf2: function (e) {
                    var t = document.createElement("canvas"),
                        i = t.width = l.Z.floorPowerOf2(e.getWidth()),
                        n = t.height = l.Z.floorPowerOf2(e.getHeight()),
                        r = t.getContext("2d");
                    r.drawImage(e.getImage(), 0, 0, i, n);
                    var a = this._internalFormat;
                    if (a === g.Texture.RGB || a === g.Texture.RGBA) return t;
                    for (var o = r.getImageData(0, 0, i, n).data, s = a === g.Texture.ALPHA ? 3 : 0, u = i * n, c = new Uint8Array(u), h = 0; h < u; ++h) c[h] = o[4 * h + s];
                    return this.setTextureSize(i, n), c
                },
                setImage: function (e, t) {
                    var i = e instanceof g.Image;
                    if (!i || e.isDirty() || e !== this.getImage() && e !== this._lastSetImage) {
                        this._lastSetImage = e;
                        var n = e instanceof g.ImageStream;
                        this._convertNPOT && i && !n && (l.Z.isPowerOf2(e.getWidth()) && l.Z.isPowerOf2(e.getHeight()) || (e.setDirty && e.setDirty(!1), e = this._resizeToNearestPowerOf2(e))), g.Texture.prototype.setImage.call(this, e, t), c.Z.draw()
                    }
                },
                applyTexImage2D: function () {
                    g.Texture.prototype.applyTexImage2D.apply(this, arguments), c.Z.draw()
                },
                getResourceManager: function () {
                    return this._resourceManager || i("CUcOv").Z.instance
                },
                setImageModel: function (e) {
                    this._imageModel = e, this._isVideo = e.isVideo(), this.updateRequireOriginalCompression();
                    var t = this.getImageJSONMaxSupported();
                    t.options && "A" === t.options.format ? (this._truePackingRead = g.Texture.ALPHA, this.setInternalFormat(g.Texture.LUMINANCE)) : this._truePackingRead = void 0
                },
                getImageModel: function () {
                    return this._imageModel
                },
                getImageCount: function () {
                    var e = this._imageModel;
                    return e && e.getImages ? e.getImages().length : this._image ? 1 : 0
                },
                setImageSmallest: function () {
                    var e = this.getImageSmallest();
                    if (e) return this._smallPreview = !0, !0 === e.promise.isFulfilled() && e.image ? this.setImage(e.image) : this._setEntryImage(e, e.promise), e
                },
                setImageMaxSupported: function () {
                    var e = this.getImageMaxSupported();
                    if (e) {
                        var t = (0, h.Z)().preload ? r().resolve() : u.Z.getFirstCameraAnimation(),
                            i = r().all((0, o.Z)([t, e.promise, u.Z.getLowResBound()], (function (e) {
                                return e.reflect()
                            })));
                        return i.then(function () {
                            this._smallPreview = !1
                        }.bind(this)), this._setEntryImage(e, i), e
                    }
                },
                _setEntryImage: function (e, t) {
                    this._lastEntry = e, e.promise = t.then(function () {
                        return this._lastEntry !== e ? this._lastEntry.promise : (this.setImage(e.image), e.image)
                    }.bind(this))
                },
                getImageSmallest: function () {
                    if (this._imageModel) {
                        var e = this._requireOriginalCompression ? void 0 : this.getOriginalFormat(),
                            t = this._imageModel.findImageNearestToResolution(128, 128, e);
                        return this.getResourceImage(t)
                    }
                },
                updateRequireOriginalCompression: function () {
                    var e = (0, s.Z)(),
                        t = this._imageModel.findImageNearestPowerOfTwoUpToResolution(e, e, this.getOriginalFormat()),
                        i = this._imageModel.findImageNearestPowerOfTwoUpToResolution(e, e),
                        n = Math.min(e, l.Z.floorPowerOf2(i.width)),
                        r = Math.min(e, l.Z.floorPowerOf2(i.height));
                    return this._requireOriginalCompression = t.width < n || t.height < r, this._requireOriginalCompression
                },
                getImageJSONMaxSupported: function (e) {
                    e = (0, s.Z)(e);
                    var t = this._requireOriginalCompression ? void 0 : this.getOriginalFormat();
                    return this._imageModel.findImageNearestPowerOfTwoUpToResolution(e, e, t)
                },
                getImageMaxSupported: function () {
                    if (this._imageModel) return this.getResourceImage(this.getImageJSONMaxSupported())
                },
                getImageWidget: function () {
                    if (this._imageModel) {
                        var e = this._imageModel.findImageWidget();
                        return e.options ? e.options.widget = !0 : e.options = {
                            widget: !0
                        }, this.getResourceImage(e, !0)
                    }
                },
                getResourceImage: function (e, t) {
                    !t && e.url && e.width * e.height > 1048576 && (e.options = e.options || {}, e.options.decodeAsync = !0), e.pk && (e.options.pk = e.pk);
                    var i = this.getResourceManager().getOrCreateImage(e.url, e.options);
                    return i.promise.progressSize = e.size, i
                },
                _shouldBindNull: function () {
                    return !!this._textureNull || (this._image ? !this._image.isReady() : 0 === this._textureHeight || 0 === this._textureWidth)
                },
                _requestUploadBudget: function (e) {
                    var t = this._textureWidth * this._textureHeight,
                        i = this._forceUpload || c.Z.requestTextureBudget(t);
                    return i || c.Z.draw(), i || e || this._gl.texImage2D(this._textureTarget, 0, this._getInternalFormatGL(), 2, 2, 0, this._internalFormat, this._getTypeGL(), null), i
                },
                setForceUpload: function (e) {
                    this._forceUpload = e
                },
                apply: function (e) {
                    var t = e.getGraphicContext();
                    if (this._dirtyTextureObject && (this.releaseGLObjects(), this._dirtyTextureObject = !1, this.setGraphicContext(t)), this._textureObject && !this.isDirty()) return this._textureObject.bind(t), void 0 !== this._image && this._image.isDirty() && this.applyImage(t), this.isDirtyMipmap() && this.generateMipmap(t, this._textureTarget), !0;
                    if (this._shouldBindNull()) return t.bindTexture(this._textureTarget, null), !0;
                    if (this.computeTextureFormat(), this._image) {
                        var i = this._image.getWidth() || this._textureWidth,
                            n = this._image.getHeight() || this._textureHeight;
                        this.setTextureSize(i, n)
                    }
                    this._textureObject;
                    if (this._textureObject || this.init(e), !this._smallPreview && this._wasAsmallPreview) {
                        var r = this._textureObject;
                        this._textureObject = g.Texture.getTextureManager(this._gl).generateTextureObject(this._gl, this, this._textureTarget, this._internalFormat, this._textureWidth, this._textureHeight), this._dirtyTextureObject = !1, this._textureNull = !1, g.Texture.getTextureManager(this._gl).releaseTextureObject(r)
                    } else this._wasAsmallPreview = !0;
                    return this._textureObject.bind(t), this.applyImage(t), this.applyFilterParameter(t, this._textureTarget), this.generateMipmap(t, this._textureTarget), this._unrefImageDataAfterApply && (this._image = void 0), this._dirty = !1, !0
                },
                getHash: function () {
                    return "osgtestdemo2024Texture"
                }
            }), "osgtestdemo2024", "MultiresTexture"), (f.dummyTexture = new f).setName("MultiresDummyTexture"), f.dummyTexture.setTextureSize(1, 1);
            const p = f
        },
        Qf9l: (e, t, i) => {
            i.d(t, {
                Z: () => a
            });
            var n = i("aqzA").Z.osg,
                r = function () {
                    n.TextureCubeMap.call(this), this._imageProxy = void 0
                };
            n.createPrototypeStateAttribute(r, n.objectInherit(n.TextureCubeMap.prototype, {
                getHash: function () {
                    return "osgtestdemo2024Texture"
                }
            }), "osgtestdemo2024", "TextureCubeMap"), (r.dummyTexture = new r).setTextureSize(1, 1);
            const a = r
        },
        icLH: (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = i("aqzA").Z.osg;
            const r = {
                uProjFactor: n.Uniform.createFloat("uProjFactor"),
                uSsaoRadius: n.Uniform.createFloat("uSsaoRadius"),
                uSsaoIntensity: n.Uniform.createFloat("uSsaoIntensity"),
                uSsaoBias: n.Uniform.createFloat("uSsaoBias"),
                uSsaoProjectionInfo: n.Uniform.createFloat4("uSsaoProjectionInfo"),
                uSsaoProjectionScale: n.Uniform.createFloat(1, "uSsaoProjectionScale"),
                uDofBlurNearFarFocal: n.Uniform.createFloat3("uDofBlurNearFarFocal"),
                uDofCross: n.Uniform.createFloat3(n.vec3.create(), "uDofCross"),
                uDofScale: n.Uniform.createFloat(1, "uDofScale"),
                uBloomFactor: n.Uniform.createFloat("uBloomFactor"),
                uBloomThreshold: n.Uniform.createFloat("uBloomThreshold"),
                uBloomRadius: n.Uniform.createFloat("uBloomRadius"),
                uChromaFactor: n.Uniform.createFloat("uChromaFactor"),
                uColorBalanceLow: n.Uniform.createFloat3("uColorBalanceLow"),
                uColorBalanceMid: n.Uniform.createFloat3("uColorBalanceMid"),
                uColorBalanceHigh: n.Uniform.createFloat3("uColorBalanceHigh"),
                uToneExposure: n.Uniform.createFloat("uToneExposure"),
                uToneBrightness: n.Uniform.createFloat("uToneBrightness"),
                uToneContrast: n.Uniform.createFloat("uToneContrast"),
                uToneSaturation: n.Uniform.createFloat("uToneSaturation"),
                uToneMethod: n.Uniform.createInt("uToneMethod"),
                uDistortion: n.Uniform.createFloat2("uDistortion"),
                uProjectionLeft: n.Uniform.createFloat4("uProjectionLeft"),
                uUnprojectionLeft: n.Uniform.createFloat4("uUnprojectionLeft"),
                uSharpFactor: n.Uniform.createFloat("uSharpFactor"),
                uLensRadius: n.Uniform.createFloat2("uLensRadius"),
                uTimeGrain: n.Uniform.createFloat("uTimeGrain"),
                uGrainFactor: n.Uniform.createFloat("uGrainFactor"),
                uTaaMotionMatrixLeft: n.Uniform.createMatrix4("uTaaMotionMatrixLeft"),
                uTaaCornersCSLeft: n.Uniform.createFloat4Array("uTaaCornersCSLeft", 2),
                uTaaEnabled: n.Uniform.createFloat(1, "uTaaEnabled"),
                uTaaInvViewMatrixLeft: n.Uniform.createMatrix4("uTaaInvViewMatrixLeft"),
                uTaaCurrentFramePVLeft: n.Uniform.createMatrix4("uTaaCurrentFramePVLeft"),
                uTaaLastFramePVLeft: n.Uniform.createMatrix4("uTaaLastFramePVLeft"),
                uTaaMotionMatrixRight: n.Uniform.createMatrix4("uTaaMotionMatrixRight"),
                uTaaCornersCSRight: n.Uniform.createFloat4Array("uTaaCornersCSRight", 2),
                uTaaInvViewMatrixRight: n.Uniform.createMatrix4("uTaaInvViewMatrixRight"),
                uTaaCurrentFramePVRight: n.Uniform.createMatrix4("uTaaCurrentFramePVRight"),
                uTaaLastFramePVRight: n.Uniform.createMatrix4("uTaaLastFramePVRight"),
                uVrFadeFactor: n.Uniform.createFloat(0, "uVrFadeFactor"),
                uVrVeilFactor: n.Uniform.createFloat(1, "uVrVeilFactor")
            }
        },
        "4rHk": (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = {
                OPAQUE: 0
            };
            n.OPAQUE_NO_EARLYZ = n.BACKGROUND = 1, n.REFRACTION = 2, n.TRANSPARENT_CUSTOM_EARLYZ = 8, n.TRANSPARENT_NO_EARLYZ_PRE = 9, n.TRANSPARENT = 10, n.TRANSPARENT_NO_EARLYZ_POST = 11, n.EXTRA = 19, n.EDITOR_GIZMO = n.HOTSPOT = 20, n.GRID = n.TOOLTIP = n.VR_MENU = 21, n.WIREFRAME = n.VR_CURSOR = 22, n.OUTLINE = 23, n.DEBUG = 24, n.DEBUG_2 = 25;
            const r = n
        },
        qk4i: (e, t, i) => {
            i.d(t, {
                Z: () => w
            });
            var n, r, a, o, s = i("aqzA"),
                l = i("3XAv"),
                u = i("HXjs"),
                c = i("lZH+"),
                h = i.n(c),
                d = i("aMVL"),
                g = i("MQQR"),
                f = s.Z.osg,
                m = {},
                p = -1,
                v = 0,
                _ = !1,
                S = 40,
                x = f.Timer.instance().tick(),
                C = !1,
                T = !1,
                M = (0, u.X2)(),
                b = function () {
                    (window.setTimeout(b, S), n && r) && (C || m.isDrawAlreadyQueued() || ((0, u.BG)() && !d.Z.getHighResBound().isFulfilled() && o(), f.Timer.instance().tick() - x - S <= S || (r.enable(), p = -1)))
                };
            (0, l.Z)() || window.setTimeout(b, S), o = function () {
                a || (a = new (h())((function (e) {
                    e()
                })).finally((function () {
                    n.requestRedraw(), n.frame(), a = void 0
                })))
            };
            var y = function (e) {
                if (n && !C) {
                    if ((0, u.BG)()) return o(), void (T = !0);
                    T = !1;
                    var t = m.isDrawAlreadyQueued();
                    if (t || n.requestRedraw(), r && !e && (r.reset(), !t)) {
                        var i = f.Timer.instance().tick();
                        v += i - x, 0 === ++p ? (p = 0, v = 0) : 4 === p && (S = Math.min(200, Math.max(16, v / p)), p = 0, v = 0), x = i
                    }
                }
            };
            m.setPoseForScreenshot = function (e) {
                C = e
            }, m.isDrawAlreadyQueued = function () {
                return n._requestRedraw
            }, m.draw = function () {
                y()
            }, m.drawNoJitter = function () {
                this._doJitter = !1, y()
            }, m.drawSameFrame = function () {
                y(!0)
            }, m.redrawShadow = function () {
                _ = !0, y()
            }, m.redrawShadowNextFrame = function () {
                window.setTimeout(m.redrawShadow, 0)
            }, m.getShadowForcedUpdate = function () {
                return _
            }, m.setShadowForcedUpdate = function (e) {
                _ = e
            }, m.setViewer = function (e) {
                n = e
            }, m.setSuperSample = function (e) {
                r = e
            }, m.getSuperSample = function () {
                return r
            }, m.getFrameTimeAverage = function () {
                return S
            }, m.requestDrawHiddenDefered = function () {
                o()
            };
            var A = 0,
                R = 0;
            m.requestTextureBudget = function (e) {
                if (!d.Z.getModelDisplayed().isResolved()) return !0;
                if (!n) return !0;
                var t = n.getFrameStamp().getFrameNumber();
                if (R < t && (R = t, A = 0), (A += e) === e) return !0;
                var i = (0, g.Z)().textureFrameBudget;
                return A <= i * i
            }, M && document.addEventListener(M, (function () {
                T && y()
            }));
            const w = m
        },
        WjOL: (e, t, i) => {
            i.d(t, {
                Z: () => R
            });
            var n = i("tEGF"),
                r = i("lZH+"),
                a = i.n(r),
                o = i("Hjnd"),
                s = i.n(o),
                l = i("HPk7"),
                u = i("mv18"),
                c = i("0aN2"),
                h = i("eKF4"),
                d = i("jQKg"),
                g = i("mSEu"),
                f = i("+zma"),
                m = i("nv4P"),
                p = i("LLYa"),
                v = i("SM3V"),
                _ = i("RyS8"),
                S = i("57Pw"),
                x = i("1nxQ"),
                C = i("aqzA"),
                T = i("g6dK"),
                M = C.Z.osg;

            function b(e, t) {
                var i, n = e.getImageModel(),
                    r = e.getMultiresTexture().getImage().getImage();
                if (!r.toBlob) {
                    if (!r.toDataURL) {
                        var o = r;
                        if (r = document.createElement("canvas"), void 0 !== o.width) r.width = o.width, r.height = o.height, r.getContext("2d").drawImage(o, 0, 0);
                        else {
                            var s = r.getContext("2d"),
                                l = e.getImageModel().getImages()[0];
                            r.width = l.width, r.height = l.height;
                            var u = s.getImageData(0, 0, l.width, l.height);
                            u.data.set(o), s.putImageData(u, 0, 0)
                        }
                    }
                    return (i = (0, v.Z)(r.toDataURL(t.type, .95))).name = t.name, n.set("imageFile", i), n
                }
                r.toBlob((function (e) {
                    return e.name = t.name, n.set("imageFile", e), a().resolve(n)
                }), t.type, .95)
            }

            function y(e, t) {
                return a().resolve(e.save(t).then((function (t) {
                    e.set("uid", t.uid)
                })))
            }
            var A = {
                FeatureName: "saveUI",
                ModelName: "Material",
                ViewListType: [m.Z.extend({
                    savingEnabled: !1,
                    constructor: function () {
                        this.onSave = (0, l.Z)(this.onSave, 1e3), m.Z.apply(this, arguments)
                    },
                    initialize: function () {
                        m.Z.prototype.initialize.apply(this, arguments), s()(".save-model").click(this.onSave.bind(this));
                        var e = this.options.context;
                        this._features = e.getFeatures();
                        var t = e.getModel();
                        t && (this.listenTo(t, "status:loaded", this.enableSaving.bind(this)), this.listenTo(t, "status:pending", this.disableSaving.bind(this)))
                    },
                    onSave: function (e) {
                        e.preventDefault();
                        var t = f.n2.store.getState();
                        f.wl.authUser.canAccessFeature("ff_read_only_mode", t) ? S.Z.showPopup() : this.save()
                    },
                    save: function () {
                        var e = this._features.inspector.getModel(),
                            t = e.get("displayView");
                        e.set("displayView", "Default");
                        var i = this._save();
                        return i.finally((function () {
                            e.set("displayView", t)
                        })), i
                    },
                    _save: function () {
                        if (!this.savingEnabled) return a().reject(new Error("Model is still loading. Please try to save again later."));
                        if (s()(".save-model").hasClass("progress")) return a().reject(new Error("Already saving previous changes. Please try to save again later."));
                        s()(".save-model").addClass("progress");
                        var e = {
                            modelUID: this.options.context.getModel().get("uid"),
                            userUID: this.options.context.getModel().get("user").uid
                        },
                            t = this,
                            i = [];
                        return this.cancelSave = !1, a().resolve(this.checkVersion(i)).then(function () {
                            return a().all([this.saveBackgroundImages(e, i), this.saveMaterialImages(e, i), this.saveTexturesColorspace(e, i), this.saveHotspots(e, i), this.saveAnimations(e, i), this.saveSounds(e, i), this.saveGroundTexture(e, i)].map((function (e) {
                                return e.reflect()
                            })))
                        }.bind(this)).then(function () {
                            return i.length > 0 || this.cancelSave ? a().reject(new Error) : t.saveOptions()
                        }.bind(this)).then((function () {
                            return i.length > 0 ? a().reject(new Error) : a().all([t.deleteTextures(i), t.deleteMatcaps(i), t.deleteBackgroundImages(i), t.deleteAnimations(i), t.deleteEnvironments(i), t.deleteGroundTexture(i)].map((function (e) {
                                return e.reflect()
                            })))
                        })).then(function () {
                            if (i.length > 0) return a().reject(new Error);
                            s()(".save-model").removeClass("progress"), s()(".save-model").addClass("success"), setTimeout((function () {
                                s()(".save-model").removeClass("success")
                            }), 4e3)
                        }.bind(this)).catch(function (e) {
                            if (s()(".save-model").removeClass("progress"), e && 503 === e.status) S.Z.showPopup();
                            else {
                                if (this.cancelSave) return;
                                var t = "";
                                if (i.length) t = i.join("<br/>");
                                else {
                                    t = "An unexpected error happened while saving the following settings : <br/><ul>";
                                    var n = e && e.responseJSON && e.responseJSON.detail || e && e.response && e.response.data.detail || e;
                                    if (n) {
                                        M.error(n);
                                        var r = "string" == typeof n ? {
                                            "": [n]
                                        } : n;
                                        for (var a in r) t += "<li>&bullet; " + (a ? a + ": " : "") + r[a].join(", ") + "</li>"
                                    }
                                    t += "</ul>"
                                }
                                t += '<br/>Contact our support team <a href="' + g.Z.hosts.faq + '/s/?ProductOrigin=testdemo2024" target="_blank">here</a> if you need help.';
                                var o = new T.Z({
                                    title: "Error",
                                    text: t,
                                    buttons: {
                                        ok: !0
                                    },
                                    safe: !0
                                });
                                o.open().then(o.close.bind(o))
                            }
                        }.bind(this))
                    },
                    deleteUnusedResources: function (e, t, i) {
                        if (0 === e.length) return a().resolve();
                        var n = "Errors while deleting the following " + t + " :<br/><ul>",
                            r = !1,
                            o = (0, u.Z)(e, (function (e) {
                                return a().resolve(e.destroy()).catch((function (t) {
                                    var i = t && t.responseJSON && t.responseJSON.detail;
                                    n += "<li>&bullet; " + (0, x.escapeHTML)(e.get("name")) + " : " + i + "</li>", e.trigger("restore", e), r = !0
                                }))
                            }));
                        return e.length = 0, a().all(o).then((function () {
                            if (r) return i.push(n + "</ul>"), a().reject(new Error)
                        }))
                    },
                    deleteTextures: function (e) {
                        var t = this._features.material.getModel()._textureTrashbin,
                            i = (0, u.Z)(t, (function (e) {
                                return new c.Z({
                                    uid: e
                                })
                            }));
                        return t.length = 0, this.deleteUnusedResources(i, "material textures", e)
                    },
                    deleteMatcaps: function (e) {
                        var t = this._features.material.getModel()._matcapTrashbin;
                        return this.deleteUnusedResources(t, "matcap textures", e)
                    },
                    deleteAnimations: function (e) {
                        var t = this._features.animation.getModel().get("animations")._trashbin;
                        return this.deleteUnusedResources(t, "animations", e)
                    },
                    deleteEnvironments: function (e) {
                        var t = this._features.environment.getModel()._trashbin;
                        return this.deleteUnusedResources(t, "environments", e)
                    },
                    deleteBackgroundImages: function (e) {
                        var t = this._features.background.getModel()._trashbin;
                        return this.deleteUnusedResources(t, "backgrounds", e)
                    },
                    deleteGroundTexture: function (e) {
                        var t = this._features.ground.getModel()._trashbin;
                        return this.deleteUnusedResources(t, "ground", e)
                    },
                    saveBackgroundImages: function (e, t) {
                        var i = [];
                        return this._features.background.getModel().backgroundCollection.each((function (n) {
                            if (n.isNew()) {
                                var r = y(n, e);
                                r.catch((function (e) {
                                    var i = 0;
                                    if (e.responseJSON.detail.imageFile)
                                        for (i = 0; i < e.responseJSON.detail.imageFile.length; i++) e.responseJSON.detail.imageFile[i].match("The image should be less than 4mb") && t.push("Background image is too big (max: 4MB)")
                                })), i.push(r)
                            }
                        })), a().all(i)
                    },
                    saveGroundTexture: function (e, t) {
                        var i = this._features.ground.getModel(),
                            n = "BakedAO" === i.get("shadowMode");
                        if (i.get("enable") && i.get("dirty") && n) {
                            var r = i.get("imageCanvas"),
                                o = (0, v.Z)(r.toDataURL("image/jpeg", .95));
                            o.name = "internal_ground_ao_texture";
                            var s = new c.Z({
                                name: o.name,
                                imageFile: o
                            }),
                                l = y(s, e);
                            return l.then((function () {
                                i.set("aoTextureUid", s.get("uid")), i.set("dirty", !1)
                            })), l.catch((function () {
                                t.push("Error while saving the baked AO texture "), i.set("enable", !1)
                            })), a().resolve(l)
                        }
                        if (!i.get("enable") || !n) {
                            var u = i.get("aoTextureUid");
                            u && (i._trashbin.push(new c.Z({
                                uid: u
                            })), i.set("aoTextureUid", void 0))
                        }
                        return a().resolve()
                    },
                    saveMaterialImages: function (e, t) {
                        var i, n = {},
                            r = this._features.material,
                            o = "Errors while saving the following texture materials :<br/><ul>",
                            s = !1;
                        return i = Object.values(r.getModel().attributes).reduce((function (e, t) {
                            var i = t.getChannels();
                            return e.concat(Object.values(i).filter((function (e) {
                                if (e.transient) return !1;
                                var t = e.getTextureModel();
                                if (!t) return !1;
                                var i = t.getImageModel();
                                if (!i || !i.isNew()) return !1;
                                var r = i.getUID();
                                return 1 !== n[r] && (n[r] = 1, !0)
                            })).map((function (e) {
                                var t = e.getTextureModel(),
                                    i = t.getImageModel();
                                return new (a())((function (e) {
                                    var n = i.get("imageFile");
                                    if (void 0 === n) {
                                        var r = i.findImageNearestToResolution(16384, 16384),
                                            a = (0, v.Z)(r.url);
                                        return i.set("imageFile", a), e(i)
                                    }
                                    if (0 === n.size) e(b(t, n));
                                    else if (window.File) {
                                        var o = new FileReader;
                                        o.onload = function () {
                                            this.readyState === FileReader.DONE ? e(i) : e(b(t, n))
                                        }, o.onerror = function () {
                                            e(b(t, n))
                                        }, o.readAsArrayBuffer(n)
                                    }
                                }))
                            })))
                        }), []), a().map(i, (function (t) {
                            return y(t, e).catch((function (e) {
                                var i = e && e.responseJSON && e.responseJSON.detail;
                                i = i && i.imageFile && i.imageFile[0], o += "<li>&bullet; " + (0, x.escapeHTML)(t.get("name")) + " : " + i + "</li>", s = !0
                            }))
                        }), {
                            concurrency: 4
                        }).then((function () {
                            if (s) return t.push(o + "</ul>"), a().reject(new Error)
                        }))
                    },
                    checkVersion: function (e) {
                        var t = this.options.context.getModel();
                        return d.Z.getModelVersion(t.get("uid"), t.get("version").uid).then((function (i) {
                            return t.set("version", i), i.isCurrentVersion ? a().resolve() : new T.Z({
                                title: "Update old version",
                                text: "You are about to update an old version of your model.<br/>These changes will not show up on the model page.<br/>To update the latest version, go to 3D settings from the model page.<br/><br/>Do you wish to update the old version?",
                                buttons: {
                                    ok: !0,
                                    cancel: !0
                                },
                                safe: !0
                            }).open().catch((function () {
                                e.push("You chose not to update this older version of your model.")
                            }))
                        }))
                    },
                    saveOptions: function () {
                        var e = this.options.context,
                            t = e.getModel(),
                            i = e.getViewer(),
                            n = i.getOptionsJSON();
                        if (i.getFeaturesManager().registerOptionsJSON(n), n.animation)
                            for (var r = this._features.animation.getModel().get("animations")._trashbin, a = 0; a < r.length; a++) r[a] && n.animation.order.splice(a, 0, r[a].get("uid"));
                        return t.set({
                            options: n
                        }), d.Z.patchModelOptions(t.get("uid"), t.get("version").uid, n)
                    },
                    saveHotspot: function (e, t, i) {
                        return e.save(t).catch((function (t) {
                            if (i.push("Annotation #" + (+e.get("order") + 1) + " could not be saved."), t.responseJSON && t.responseJSON.detail) {
                                var n = 0;
                                if (t.responseJSON.detail.name)
                                    for (n = 0; n < t.responseJSON.detail.name.length; n++) t.responseJSON.detail.name[n].match("This field is required.") ? i.push("Title is required.") : t.responseJSON.detail.name[n].match("Ensure this value has at most 64 characters") ? i.push("Title is too long (64 characters max).") : i.push(t.responseJSON.detail.name[n]);
                                if (t.responseJSON.detail.content)
                                    for (n = 0; n < t.responseJSON.detail.content.length; n++) t.responseJSON.detail.content[n].match("Ensure this value has at most 1024 characters") ? i.push("Description is too long (1024 characters max).") : i.push(t.responseJSON.detail.content[n])
                            }
                        }))
                    },
                    deleteHotspot: function (e, t, i, n) {
                        return e.remove(t).catch((function () {
                            n.push(e), i.push("An annotation could not be deleted. Please try saving your settings again.")
                        }))
                    },
                    saveHotspots: function (e, t) {
                        var i = this._features.hotspot.getModel(),
                            n = i.get("hotspots"),
                            r = this.options.context.getModel().toJSON(),
                            o = (0, p.A8)(r),
                            s = g.Z.maxHotspotsPerModel[o];
                        if (n.length > s) return i.trigger("hotspot-error", new _.r(void 0, "hotspot", n.length, s, h.Z.me().toJSON().account)), this.cancelSave = !0, a().reject();
                        if (n.models.some((function (e) {
                            return !e.get("name")
                        }))) {
                            var l = new T.Z({
                                title: "Error",
                                text: "All your annotations must have a title.",
                                buttons: {
                                    ok: !0
                                },
                                safe: !0
                            });
                            return l.open().then(l.close.bind(l)), this.cancelSave = !0, a().reject()
                        }
                        var u = [],
                            c = this,
                            d = i.hotspotsToBeDeleted.map((function (i) {
                                return c.deleteHotspot(i, e, t, u)
                            }));
                        return i.hotspotsToBeDeleted = u, a().all(d).then((function () {
                            return a().all(n.map((function (i) {
                                return i.set("order", n.indexOf(i)), c.saveHotspot(i, e, t)
                            })))
                        }))
                    },
                    saveTexturesColorspace: function (e, t) {
                        var i = "Errors while changing the following texture colorspace :<br/><ul>",
                            n = !1,
                            r = [];
                        return this.model.getImageCollection().each((function (e) {
                            !e.isNew() && e.hasChanged("colorSpace") && r.push(e.saveColorspace().catch((function (t) {
                                var r = t && t.responseJSON && t.responseJSON.detail;
                                i += "<li>&bullet; " + (0, x.escapeHTML)(e.get("name")) + " : " + r + "</li>", n = !0
                            })))
                        })), a().all(r).then((function () {
                            if (n) return t.push(i + "</ul>"), a().reject(new Error)
                        }))
                    },
                    saveAnimations: function (e, t) {
                        var i = this._features.animation.getModel(),
                            n = "Errors while saving the following animations :<br/><ul>",
                            r = !1,
                            o = i.get("animations").map((function (t) {
                                return t.save(e).catch((function (e) {
                                    var i = e && e.responseJSON && e.responseJSON.detail;
                                    n += "<li>&bullet; " + (0, x.escapeHTML)(t.get("name")) + " : " + i + "</li>", r = !0
                                }))
                            }));
                        return a().all(o).then((function () {
                            if (r) return t.push(n + "</ul>"), a().reject(new Error)
                        }))
                    },
                    saveSounds: function (e, t) {
                        var i = this._features.sound.getModel(),
                            n = i.get("soundtracks"),
                            r = this.options.context.getModel().toJSON(),
                            o = (0, p.A8)(r),
                            s = g.Z.maxSoundtracksPerModel[o];
                        if (this.maxSoundtracksCount = g.Z.maxSoundtracksPerModel[o], n.length > s) return i.trigger("sound-error", new _.r(void 0, "sound", n.length, s, h.Z.me().toJSON().account)), this.cancelSave = !0, a().reject();
                        var l = !1,
                            u = "Errors while saving the following sounds :<br/><ul>",
                            c = a().resolve();
                        return n.each((function (t) {
                            c = c.then((function () {
                                return t.save(e)
                            })).catch((function (e) {
                                var i = e && e.responseJSON && e.responseJSON.detail;
                                return i && i.__all__ && (i = i.__all__[0]), i && i.soundFile && (i = i.soundFile[0]), u += "<li>&bullet; " + (0, x.escapeHTML)(t.get("name")) + " : " + i + "</li>", l = !0, a().resolve()
                            }))
                        })), c.then((function () {
                            if (l) return t.push(u + "</ul>"), a().reject(new Error)
                        }))
                    },
                    enableSaving: function () {
                        this.savingEnabled = !0, s()(".save-model").removeClass("btn-disabled")
                    },
                    disableSaving: function () {
                        this.savingEnabled = !1, s()(".save-model").addClass("btn-disabled")
                    }
                })]
            };
            const R = n.Z.create(A)
        },
        yzbh: (e, t, i) => {
            i.d(t, {
                Z: () => u
            });
            var n = i("Hjnd"),
                r = i.n(n),
                a = i("aWGP"),
                o = i("nv4P"),
                s = i("QR/4"),
                l = i("zJM7");
            const u = o.Z.extend({
                _isLoaded: !1,
                _context: null,
                isMoving: !1,
                startX: 0,
                sensitivity: 20,
                sprite: {
                    current: 0,
                    steps: 15,
                    ratio: null,
                    width: 0
                },
                size: 1,
                autospinTimer: null,
                events: {
                    mousedown: "onMouseDown",
                    mouseup: "onMouseUp",
                    "mousemove ": "onMouseMove",
                    touchstart: "onTouchStart",
                    touchend: "onTouchEnd",
                    touchmove: "onTouchMove"
                },
                constructor: function () {
                    this._boundResizeEvent = this.onWindowResize.bind(this), o.Z.prototype.constructor.apply(this, arguments)
                },
                initialize: function () {
                    o.Z.prototype.initialize.apply(this, arguments), this.$viewport = r()(), this.$image = r()()
                },
                delegateEvents: function () {
                    o.Z.prototype.delegateEvents.apply(this, arguments), r()(window).on("resize", this._boundResizeEvent)
                },
                undelegateEvents: function () {
                    o.Z.prototype.undelegateEvents.apply(this, arguments), r()(window).off("resize", this._boundResizeEvent), this.autospinTimer && clearInterval(this.autospinTimer)
                },
                isViewerReady: function () {
                    return this._isLoaded
                },
                run: function () {
                    var e = new s.Z;
                    this._context = e, this.$el.show(), this.$el.siblings(".webgl").hide(), this.$el.siblings(".osd").hide();
                    var t = this.model.get("uid"),
                        i = this._fallbackCollection = new l.Z([], {
                            uid: t
                        });
                    return i.fetch().then(function () {
                        i.length > 0 ? this.displayFallback() : this.displayNoFallbackError()
                    }.bind(this)).catch(function () {
                        this.displayNoFallbackError()
                    }.bind(this)), this._isLoaded = !0, !0
                },
                getContext: function () {
                    return this._context
                },
                getFeatures: function () {
                    return {}
                },
                findBestImage: function () {
                    for (var e, t = this._fallbackCollection.toJSON(), i = this.$el.height(), n = 1 / 0, r = 0, a = t.length; r < a; ++r) {
                        var o = t[r],
                            s = Math.abs(i - o.height);
                        s < n && (n = s, e = o)
                    }
                    return e
                },
                displayFallback: function () {
                    this.$viewport = r()(".fallback-viewport"), this.$image = this.$viewport.find("img.fallback-sprite");
                    var e = this.findBestImage(),
                        t = e.url;
                    this._currentHeight = e.height, this.$image.on("load", function (e) {
                        var t = e.target.naturalHeight,
                            i = e.target.naturalWidth / this.sprite.steps;
                        this.sprite.ratio = t ? i / t : 0, r()(e.target).css("display", "block"), this.trigger("secondary-progress", {
                            progress: 1
                        }), this.trigger("success"), this.displayFallbackWarning(), this.onWindowResize()
                    }.bind(this)), this.$image.on("error", function (e) {
                        console.error("Fallback loading failed. URL : " + t + " ERROR : " + e.toString()), this.trigger("fail"), this.displayFallbackLoadingError()
                    }.bind(this)), this.$image.attr("src", t)
                },
                displayFallbackLoadingError: function () {
                    this.$el.find(".fallback-error-loading").show()
                },
                displayNoFallbackError: function () {
                    this.$el.find(".fallback-error-nofallback").show()
                },
                displayFallbackWarning: function () {
                    this._warningDisplayed || (this._warningDisplayed = !0, this.$el.find(".fallback-warning").show(), this.fallbackWarning = setTimeout(function () {
                        this.$el.find(".fallback-warning").fadeOut()
                    }.bind(this), 1e4))
                },
                onWindowResize: function () {
                    if (this._fallbackCollection.length) {
                        var e, t, i = this.$el.width(),
                            n = this.$el.height(),
                            r = i / n;
                        this.findBestImage().height > this._currentHeight && this.displayFallback(), 2 === this.size ? r < this.sprite.ratio ? (e = i, t = Math.floor(e / this.sprite.ratio)) : (t = n, e = Math.floor(t * this.sprite.ratio)) : r < this.sprite.ratio ? (t = n, e = Math.floor(t * this.sprite.ratio)) : (e = i, t = Math.floor(e / this.sprite.ratio)), this.$viewport.width(e).height(t).css({
                            "margin-top": Math.round(-1 * t / 2),
                            "margin-left": Math.round(-1 * e / 2)
                        }), this.sprite.width = Math.round(this.$image.prop("scrollHeight") * this.sprite.ratio), this.$viewport.scrollLeft(this.sprite.width * this.sprite.current)
                    }
                },
                onMouseDown: function (e) {
                    e.preventDefault(), this.isMoving = !0, this.startX = e.clientX
                },
                onMouseMove: function (e) {
                    e.preventDefault(), this.move(e.clientX)
                },
                onMouseUp: function (e) {
                    e.preventDefault(), this.isMoving = !1
                },
                onTouchStart: function (e) {
                    e.preventDefault(), this.isMoving = !0;
                    var t = e.originalEvent.touches[0];
                    this.startX = t.clientX
                },
                onTouchMove: function (e) {
                    e.preventDefault(), this.move(e.originalEvent.touches[0].clientX)
                },
                onTouchEnd: function (e) {
                    e.preventDefault(), this.isMoving = !1
                },
                move: function (e) {
                    this.isMoving && (this.autospinTimer && this.stopAutospin(), e > this.startX + this.sensitivity && (this.startX = e, this.moveRight()), e < this.startX - this.sensitivity && (this.startX = e, this.moveLeft()))
                },
                moveRight: function () {
                    0 === this.sprite.current ? this.sprite.current = this.sprite.steps - 1 : this.sprite.current = this.sprite.current - 1, this.$viewport.scrollLeft(this.sprite.width * this.sprite.current)
                },
                moveLeft: function () {
                    this.sprite.current = (this.sprite.current + 1) % this.sprite.steps, this.$viewport.scrollLeft(this.sprite.width * this.sprite.current)
                },
                startAutospin: function () {
                    this.autospinTimer = setInterval((0, a.Z)((function () {
                        this.moveLeft()
                    }), this), 500)
                },
                stopAutospin: function () {
                    clearInterval(this.autospinTimer), this.autospinTimer = null
                },
                toggleAutospin: function () {
                    this.autospinTimer ? this.stopAutospin() : this.startAutospin()
                }
            })
        },
        "078t": (e, t, i) => {
            i.d(t, {
                Z: () => h
            });
            var n = i("aqzA"),
                r = i("kTKr"),
                a = i("4rHk"),
                o = i("Ygw6"),
                s = n.Z.osg,
                l = s.Uniform.createFloat4("uColor"),
                u = new r.Z(l.getInternalArray(), 1),
                c = function () {
                    s.StateSet.call(this), this.init()
                };
            c.updateCallback = u, s.createPrototypeObject(c, s.objectInherit(s.StateSet.prototype, {
                setRenderBinVR: function (e) {
                    var t = e ? a.Z.TRANSPARENT_NO_EARLYZ_POST : a.Z.WIREFRAME;
                    this.setRenderBinDetails(t, "RenderBin")
                },
                init: function () {
                    this.setRenderBinDetails(a.Z.WIREFRAME, "RenderBin"), this.setAttributeAndModes(o.Z.DEPTH_LEQUAL_WRITE), this.setAttributeAndModes(o.Z.BLEND_SUBSTRACTIVE), this.setShaderGeneratorName("wireframe"), this.addUniform(l), this.addUpdateCallback(u)
                },
                setWireframeColorSmooth: function (e) {
                    u.setColorTarget(e)
                },
                setWireframeColor: function (e) {
                    l.setFloat4(e)
                },
                setWireframeEnable: function (e, t) {
                    e ? (!0 === u._finished && (l.setFloat3(t), l.getInternalArray()[3] = 0), u.show(t[3])) : u.hide()
                }
            }));
            const h = c
        },
        kTKr: (e, t, i) => {
            i.d(t, {
                Z: () => l
            });
            var n = i("aqzA"),
                r = i("PpZu"),
                a = i("qk4i"),
                o = n.Z.osg,
                s = function (e, t) {
                    this._color = e, this._colorDelta = o.vec4.create(), this._lastRatio = 0, r.Z.call(this, t), this._finished = !0, this._disableAfterFinished = !1, this._finishCallback = void 0, this._lastFrame = 0
                };
            o.createPrototypeObject(s, o.objectInherit(r.Z.prototype, {
                hide: function () {
                    o.vec3.init(this._colorDelta), this._colorDelta[3] = -this._color[3], this._disableAfterFinished = !0, this._lastRatio = 0, this.reset()
                },
                show: function (e) {
                    o.vec3.init(this._colorDelta), this._colorDelta[3] = void 0 !== e ? e : 1 - this._color[3], this._disableAfterFinished = !1, this._lastRatio = 0, this.reset()
                },
                setColorTarget: function (e) {
                    o.vec4.sub(this._colorDelta, e, this._color), this._disableAfterFinished = !1, this._lastRatio = 0, this.reset()
                },
                setFinishCallback: function (e) {
                    this._finishCallback = e
                },
                finished: function () {
                    !0 === this._disableAfterFinished && this._finishCallback && this._finishCallback()
                },
                update: function (e, t) {
                    if (!0 === this._finished) return !0;
                    a.Z.draw();
                    var i = t.getFrameStamp(),
                        n = i.getFrameNumber();
                    if (this._lastFrame === n) return !0;
                    this._lastFrame = n;
                    var r = i.getSimulationTime(),
                        s = this.interpolate(r, e, t),
                        l = (s = o.smoothStep(0, 1, s)) - this._lastRatio;
                    return this._lastRatio = s, o.vec4.scaleAndAdd(this._color, this._color, this._colorDelta, l), !0
                }
            }));
            const l = s
        },
        vcih: (e, t, i) => {
            i.d(t, {
                Z: () => y
            });
            var n = i("XkCy"),
                r = i("3O9e"),
                a = i("Bpah"),
                o = i("aqzA"),
                s = i("lZH+"),
                l = i.n(s),
                u = i("R2Pi"),
                c = i("QG/p"),
                h = i("+VSF"),
                d = o.Z.osg,
                g = .2;
            h.Z && (g = .35);
            var f = function (e, t, i) {
                var n = i.isNew() ? i.get("url") : i.get("files")[0].url;
                this._src = n, t && this.setMediaElement(t), this._manager = e, this._model = i, this._mediaElementSource = void 0, this._gain = void 0, this._panner = void 0, this._canPlayDefered = void 0, this._isPlaying = !1, this._seeking = !1, this._duration = void 0, this._isPlayerPendingToPlay = !1, this._doPausePlayerWhenPendingToPlayFinished = void 0, this.pendingToPlayResolvedBound = this.pendingToPlayResolved.bind(this), this.releasePlayerBound = this.releasePlayer.bind(this)
            };
            f.prototype = {
                setMediaElement: function (e) {
                    this._player = e, this._player.setAttribute("src", this._src), u.default.apple.device || this._player.load(), this._player.addEventListener("ended", this.onEnded.bind(this)), this._player.addEventListener("loadedmetadata", function (e) {
                        this._duration = e.currentTarget.duration
                    }.bind(this))
                },
                isPlayerPlaying: function () {
                    return !!this._player && !(!(this._player.currentTime > 0) || this._player.paused || this._player.ended)
                },
                playerPlay: function () {
                    if (this._player && !this.isPlayerPlaying()) {
                        if (this._isPlayerPendingToPlay) return this._pendingToPlayPromise;
                        var e;
                        this._managerContextVersion = this._manager._releaseSafeCounter;
                        try {
                            e = this._player.play()
                        } catch (e) {
                            return this.checkAndHandleDOMError(e), l().resolve()
                        }
                        return this._isPlayerPendingToPlay = !0, this._pendingToPlayPromise = e, e || (e = new (l())(function (e) {
                            this._player.addEventListener("play", e)
                        }.bind(this))), e.then(this.pendingToPlayResolvedBound).catch(function (e) {
                            return e instanceof DOMException && "The element has no supported sources." === e.message ? (this._isPlayerPendingToPlay = !1, void (this._pendingToPlayPromise = void 0)) : this.checkAndHandleDOMError(e) ? void 0 : this._doPausePlayerWhenPendingToPlayFinished || this._managerContextVersion !== this._manager._releaseSafeCounter || this._manager.releasePending ? void this.pendingToPlayResolved() : (this._isPlayerPendingToPlay = !1, this._pendingToPlayPromise = void 0, void window.setTimeout(this.playerPlay.bind(this), 1e3))
                        }.bind(this)), e
                    }
                },
                playerPause: function () {
                    return this._gain && 0 !== this._gain.gain.value && this.setGainValue(0), this._doPausePlayerWhenPendingToPlayFinished ? this._doPausePlayerWhenPendingToPlayFinished.promise : this._isPlayerPendingToPlay ? (this._doPausePlayerWhenPendingToPlayFinished = new c.Z, this._doPausePlayerWhenPendingToPlayFinished.promise) : (this.isPlayerPlaying() && this._player && this._player.pause(), l().resolve())
                },
                pendingToPlayResolved: function () {
                    this._isPlayerPendingToPlay = !1, this._pendingToPlayPromise = void 0, this._doPausePlayerWhenPendingToPlayFinished && (this._player && this._player.pause(), this._doPausePlayerWhenPendingToPlayFinished.resolve(), this._doPausePlayerWhenPendingToPlayFinished = void 0), this.updateVolume()
                },
                releasePlayer: function () {
                    this._player = void 0, this._mediaElementSource = void 0
                },
                onEnded: function () {
                    this._model.get("loop") || this.pause()
                },
                play: function () {
                    this._isPlaying = !0, this.updateVolume()
                },
                pause: function () {
                    this._isPlaying = !1, this.updateVolume()
                },
                getModel: function () {
                    return this._model
                },
                updateVolume: function () {
                    if (this._player)
                        if (this._manager.getIsMute()) this.setGainValue(0);
                        else if (this._gain && this._manager.isTabVisible()) {
                            if (void 0 === this._model.get("volume") || !this._isPlaying || this._seeking || !this._manager.isPlaying()) {
                                if (this._player.muted) return;
                                return d.debug("[SOUND] Volume Change: " + this._model.get("name") + " = 0"), void this.setGainValue(0)
                            }
                            this._volumeReal = this._model.get("volume") * this._manager.getVolume(), this.setGainValue(this._volumeReal)
                        } else this.setGainValue(0)
                },
                _seekToSync: function (e) {
                    return !!this._player && (void 0 !== this._duration && this._duration < 1.5 || (Math.abs(this._player.currentTime - e) > g ? this._player.seeking ? (this._seeking = !0, !1) : (this._player.currentTime = e + .05, this._seeking = !0, !1) : !(this._seeking && !this._player.seeking) || (this._seeking = !1, !0)))
                },
                setTime: function (e, t) {
                    if (this._manager.canPlay()) {
                        if (!this._player || !this._gain) {
                            if (!t) return;
                            this.updateFromModel()
                        }
                        if (void 0 !== this._duration) {
                            var i = this._model.get("loop");
                            if (this._player.loop !== i && (this._player.loop = i), this.isSoundAsync()) i || this._player.currentTime < this._duration ? this.play() : this.pause();
                            else {
                                var n = e - this._model.get("startTime"),
                                    r = n >= 0;
                                if (r && (i ? n %= this._duration : r = r && this._duration >= n), !r) return this.isPlayerPlaying() && (this._player.currentTime = 0, this.playerPause()), void this.pause();
                                this._seekToSync(n) && this._manager.isPlaying() ? (!this.isPlayerPlaying() && this._manager.isPlaying() && this.playerPlay(), this.play()) : this.pause()
                            }
                        }
                    }
                },
                isSoundAsync: function () {
                    return !1 === this._manager._hasAnim || !this._model.get("sync")
                },
                setRefDistanceNormalized: function (e) {
                    this._panner && (this._panner.refDistance = e / this._manager.getRadius())
                },
                setMaxDistanceNormalized: function (e) {
                    this._panner && (this._panner.maxDistance = e / this._manager.getRadius())
                },
                setPositionNormalized: function (e) {
                    if (this._panner) {
                        var t = this._manager.getRadius();
                        this._manager._setPannerPosition(this._panner, e[0] / t, e[1] / t, e[2] / t)
                    }
                },
                setLoop: function () {
                    this._player && (this._player.loop = this._model.get("loop"))
                },
                updateFromModel: function () {
                    if (!this._player) {
                        var e = this._manager._createAudio();
                        e && this.setMediaElement(e)
                    }
                    var t;
                    this.setLoop(), t = this._model.get("ambient") ? this._manager.connectAmbientSound(this) : this._manager.connect3DSound(this), this.isSoundAsync() && this.play(), t ? t.catch(function (e) {
                        this.checkAndHandleDOMError(e)
                    }.bind(this)) : (this.isSoundAsync() && this.playerPlay(), this.updateVolume())
                },
                checkAndHandleDOMError: function (e) {
                    d.debug(e.message);
                    return e instanceof DOMException && -1 !== ["Failed to execute 'play' on 'HTMLMediaElement': API can only be initiated by a user gesture.", "play() can only be initiated by a user gesture."].indexOf(e.message) && (this._authErrors = !0, this.pendingToPlayResolved(), this._manager._lock(), !0)
                },
                whenReady: function () {
                    if (!this._canPlayDefered) {
                        var e = new (l())(function (e) {
                            this._player.addEventListener("canplaythrough", e)
                        }.bind(this));
                        this._canPlayDefered = e
                    }
                    return this._canPlayDefered
                },
                setGainValue: function (e) {
                    if (this._player && (this._player.muted = e <= 0), this._gain) {
                        var t = this._gain.gain;
                        if (t.setValueAtTime) {
                            var i = this._manager.getOrCreateAudioContext();
                            if (!i) return;
                            t.setValueAtTime(e, i.currentTime)
                        } else t.value = e
                    }
                }
            };
            const m = f;
            var p, v, _, S = i("MQQR"),
                x = i("WGQk"),
                C = i("3XAv"),
                T = o.Z.osg,
                M = .016,
                b = function () {
                    if (this._volume = Number(r.default.get("sf_volume", 1)), this._sounds = [], this._context = void 0, this._enabled = !1, this._tabVisible = !0, this._isPlaying = !1, this._waiting = !(0, x.Z)(), this._muted = !1, this._unlockBound = this._unlock.bind(this), this._lockBound = this._lock.bind(this), this._forcePlayBound = function () {
                        this.forcePlay(this._isPlaying)
                    }.bind(this), this._hasSounds = !1, this._willHaveSounds = void 0, window.AudioContext || window.webkitAudioContext) {
                        if ((0, x.Z)() && (this._willHaveSounds = !0), !this._willHaveSounds) {
                            var e = (0, S.Z)() && (0, S.Z)().model;
                            if (!e) {
                                var t = window.location.href.match(/\/models\/((.+)(?:\/)+|(.+))/);
                                t && t.length > 3 && (e = t[2] ? t[2] : t[3])
                            }
                            e && a.Z.get(e).then(this.checkWillHaveSounds.bind(this))
                        }
                        this._authErrors = this.featureDetectSoundAuthGestureNeeded(), this._resetPlayedOnceFromAuthGesture(), this._enablingAuthAudio = !1, this._firstEnter = !0, this._readyForErrorMessage = new c.Z, this._audioContextTriesCount = 0, window.addEventListener("beforeunload", this.exit.bind(this)), this._contextClosePending = !1, this._radius = 1, n.Z.getBoxReady().then(function () {
                            this._radius = n.Z.getModelBoxWithoutDisplacement().radius()
                        }.bind(this))
                    } else this._willHaveSounds = !1
                };
            b.prototype = {
                release: function () {
                    if (this._context && !this._releasePending) {
                        var e;
                        this._releasePendingPromises = [];
                        for (var t = 0; t < this._sounds.length; t++)(e = this.releaseSound(this._sounds[t])) && this._releasePendingPromises.push(e);
                        var i = this._context.close;
                        i && ((e = this._context.close()) ? (this._contextClosePending = !0, e.then(function () {
                            this._contextClosePending = !1, this._context = void 0
                        }.bind(this)), this._releasePendingPromises.push(e)) : i = !1), this._releasePending = l().all(this._releasePendingPromises), this._releasePending.finally(function () {
                            i || (this._context = void 0), this._releasePendingPromises = void 0, this._releasePending = void 0
                        }.bind(this))
                    }
                },
                releaseSound: function (e) {
                    if (e && (this.disconnectSound(e), e._mediaElementSource && (e._mediaElementSource.disconnect(), e._mediaElementSource = void 0), e._player)) {
                        e._player.volume = 0, e.pause();
                        var t = e.playerPause();
                        return t.then(e.releasePlayerBound), e.isSoundAsync() && (e._exitTime = e._player.currentTime), e._player = void 0, e.isPlayerPlaying() || e.releasePlayer(), t
                    }
                },
                removeSound: function (e) {
                    e && (this.releaseSound(e), this._sounds.splice(this._sounds.indexOf(e), 1))
                },
                reset: function () {
                    this._releasePending ? this._releasePending.then(this.reset.bind(this)) : (this._audioContextTriesCount = 0, this._hasSounds && !this._firstEnter && this.forcePlay(this._isPlaying))
                },
                enableTapRequestPopup: function () {
                    this._osdProxyModel && this._willHaveSounds && !(0, x.Z)() && this._osdProxyModel.trigger("sound-show", "Tap/Click to play sounds", {
                        position: "top",
                        duration: 1 / 0
                    })
                },
                exit: function () {
                    this._context && (this.release(), this._firstEnter = !1, this._lock())
                },
                enter: function () {
                    this.reset()
                },
                checkWillHaveSounds: function (e) {
                    if (void 0 !== this._willHaveSounds) return this._willHaveSounds;
                    var t, i = e.get("options").sound;
                    if (!i || !i.soundtracks || !i.soundtracks.length) return this._willHaveSounds = !1, !1;
                    if (!u.default.apple.device) return this._willHaveSounds = !0, !0;
                    for (var n = 0, r = i.soundtracks.length; n < r; n++)
                        if (i.soundtracks[n].ambient) {
                            t = n;
                            break
                        }
                    return void 0 !== t ? (i.soundtracks.length > 1 && (i.soundtracks.splice(t + 1, i.soundtracks.length - t), i.soundtracks.splice(0, t)), this._willHaveSounds = !0, !0) : (i.soundtracks.length = 0, this._willHaveSounds = !1, !1)
                },
                setProxyModel: function (e) {
                    this._osdProxyModel = e, this._readyForErrorMessage && this._readyForErrorMessage.resolve()
                },
                getProxyModel: function () {
                    return this._osdProxyModel
                },
                getOrCreateAudioContext: function (e) {
                    if (this._willHaveSounds && this._enabled && (!this._waiting || (0, x.Z)()) && this._tabVisible) {
                        if (this._context && !this._contextClosePending) return this._context;
                        var t = window.AudioContext || window.webkitAudioContext;
                        try {
                            return this._context = e ? new t : new t({
                                latencyHint: "interactive"
                            }), "suspended" === this._context.state ? void this._context.resume().then(function () {
                                this._unlock()
                            }.bind(this)).catch(function () {
                                this._authErrors = !0, this._lock()
                            }.bind(this)) : (this._audioContextTriesCount && this.forcePlay(this._isPlaying), this._context)
                        } catch (e) {
                            if (e instanceof TypeError) {
                                if (T.debug(e.message), this.getOrCreateAudioContext(!0), this._context) return this._context
                            } else if ("An AudioContext in a cross origin iframe must be created or resumed from a user gesture to enable audio output." === e.message) return this._authErrors = !0, this.pendingToPlayResolved(), void this._lock();
                            this._readyForErrorMessage.promise.then(function () {
                                this._audioContextTriesCount++, this._audioContextTriesCount < 5 ? setTimeout(function () {
                                    this.getOrCreateAudioContext()
                                }.bind(this), 200) : this._osdProxyModel.trigger("sound-error", new Error('Your browser can not play additional sounds and this page must be reloaded. If the problem persists, try to restart your browser. <a style="color: -webkit-link; cursor: auto; text-decoration: underline;" href="javascript:window.location.reload()">reload</a>'), {
                                    position: "top",
                                    duration: 1 / 0
                                })
                            }.bind(this))
                        }
                        return this._context
                    }
                },
                _createAudio: function () {
                    var e = document.createElement("audio");
                    return e.loop = !0, e.volume = 1, e.muted = !0, e.preload = "auto", e.crossOrigin = "anonymous", e
                },
                addSound: function (e, t) {
                    return this._hasSounds = !0, this._playedOnceFromAuthGesture || this._enableAuthAudioListener(this._forcePlayBound), this.canPlay() && (t || !1 === this._hasAnim) && e.play(), this._sounds.push(e), e
                },
                createSound: function (e, t) {
                    this._isPlaying = t;
                    var i, n = this._createAudio(e),
                        r = new m(this, n, e);
                    return n && this.canPlay() && (i = e.get("ambient") ? this.connectAmbientSound(r) : this.connect3DSound(r)) && i.then(this._unlockBound).catch(this._lockBound), this.addSound(r, t)
                },
                createPreview: function (e) {
                    var t = this._createAudio(e),
                        i = new m(this, t, e);
                    return this.connectAmbientSound(i), i
                },
                _errorCatchAndTryAgain: function (e) {
                    T.debug(e.message), this.exit(), window.setTimeout(function () {
                        this.reset()
                    }.bind(this), 500)
                },
                _tryCreateMediaElementSource: function (e) {
                    if (e._mediaElementSource) return !0;
                    try {
                        return e._mediaElementSource = this._context.createMediaElementSource(e._player), !0
                    } catch (e) {
                        return e instanceof DOMException && "Failed to execute 'createMediaElementSource' on 'BaseAudioContext': AudioContext has been closed." === e.message && this._errorCatchAndTryAgain(e), !1
                    }
                },
                _tryConnectMediaElementSource: function (e, t) {
                    try {
                        return e._mediaElementSource.connect(t), !0
                    } catch (e) {
                        return this._errorCatchAndTryAgain(e), !1
                    }
                },
                _setPannerPosition: function (e, t, i, n) {
                    if (e.positionX) {
                        var r = this.getOrCreateAudioContext(),
                            a = r ? r.currentTime : 0;
                        e.positionX.setTargetAtTime(t, a, M), e.positionY.setTargetAtTime(i, a, M), e.positionZ.setTargetAtTime(n, a, M)
                    } else e.setPosition(t, i, n)
                },
                _setPannerOrientation: function (e, t, i, n, r, a, o) {
                    if (e.forwardX) {
                        var s = this.getOrCreateAudioContext(),
                            l = s ? s.currentTime : 0;
                        e.forwardX.setTargetAtTime(t, l, M), e.forwardY.setTargetAtTime(i, l, M), e.forwardZ.setTargetAtTime(n, l, M), e.upX.setTargetAtTime(r, l, M), e.upY.setTargetAtTime(a, l, M), e.upZ.setTargetAtTime(o, l, M)
                    } else e.setOrientation(t, i, n, r, a, o)
                },
                connect3DSound: function (e) {
                    var t = this.getOrCreateAudioContext();
                    if (t) {
                        this.disconnectSound(e);
                        var i = t.createPanner();
                        if (e._panner = i, i.panningModel = "HRTF", i.rolloffFactor = 1, i.coneInnerAngle = 360, i.coneOuterAngle = 0, i.coneOuterGain = 0, i.distanceModel = e.getModel().get("distanceModel"), e.setRefDistanceNormalized(e.getModel().get("distance")), e.setMaxDistanceNormalized(e.getModel().get("distanceMax")), e._player || (e._player = this._createAudio(e.getModel())), this._tryCreateMediaElementSource(e)) {
                            var n = e._gain ? e._gain : t.createGain();
                            if (e._gain = n, e.setGainValue(0), n.connect(i), i.connect(t.destination), this._tryConnectMediaElementSource(e, n)) return e.playerPlay()
                        }
                    }
                },
                connectAmbientSound: function (e) {
                    var t = this.getOrCreateAudioContext();
                    if (t && (this.disconnectSound(e), e._player || (e._player = this._createAudio(e.getModel())), this._tryCreateMediaElementSource(e))) {
                        var i = t.createGain();
                        if (e._gain = i, e.setGainValue(0), i.connect(t.destination), this._tryConnectMediaElementSource(e, i)) return e.playerPlay()
                    }
                },
                disconnectSound: function (e) {
                    e && (e._panner && (e._panner.disconnect(), e._panner = void 0), e._gain && (e._gain.disconnect(), e._gain = void 0))
                },
                update: (p = T.vec3.create(), v = T.vec3.create(), _ = T.vec3.create(), function () {
                    if (!this._enabled) return !0;
                    var e = this._context,
                        t = this._camera;
                    if (!t || !e) return !0;
                    T.mat4.getLookAt(p, v, _, t.getViewMatrix()), T.vec3.sub(v, v, p), T.vec3.normalize(v, v);
                    var i = this._radius,
                        n = e.listener;
                    return this._setPannerPosition(n, p[0] / i, p[1] / i, p[2] / i), this._setPannerOrientation(n, v[0], v[1], v[2], _[0], _[1], _[2]), !0
                }),
                getVolume: function () {
                    return this._volume
                },
                setCamera: function (e) {
                    this._camera = e
                },
                setVolume: function (e) {
                    var t = 0 === this._volume;
                    if (this._volume = e, !this._muted && (r.default.set("sf_volume", e), this.canPlay())) {
                        !t && e > 0 && this._lock();
                        for (var i = 0, n = this._sounds.length; i < n; i++) this._sounds[i].updateVolume()
                    }
                },
                isTabVisible: function () {
                    return this._tabVisible
                },
                hide: function () {
                    this._tabVisible = !1, this.exit()
                },
                show: function () {
                    this._tabVisible = !0, this.enter()
                },
                setEnabled: function (e) {
                    e ? (this._enabled = !0, this.reset()) : (this.exit(), this._enabled = !1)
                },
                isEnabled: function () {
                    return this._enabled
                },
                setHasAnim: function (e) {
                    this._hasAnim = e
                },
                _unlockAcknowledge: function () {
                    document.removeEventListener("touchend", this._forcePlayBound, !0), document.removeEventListener("mouseup", this._forcePlayBound, !0), this._playedOnceFromAuthGesture = !0, this._authErrors = this.featureDetectSoundAuthGestureNeeded(), this._osdProxyModel && this._osdProxyModel.trigger("sound-hide")
                },
                _unlock: function () {
                    if (this._enablingAuthAudio = !1, this._context) return this._context.resume(), void this._unlockAcknowledge();
                    var e = this.getOrCreateAudioContext();
                    e && (e.resume(), this._unlockAcknowledge())
                },
                _lock: function () {
                    this._resetPlayedOnceFromAuthGesture(), this._playedOnceFromAuthGesture || this._waiting || this._muted || 0 === this._volume || (this._enableAuthAudioListener(this._forcePlayBound), this.enableTapRequestPopup())
                },
                _enableAuthAudioListener: function () {
                    this._enablingAuthAudio || (this._enablingAuthAudio = !0, document.addEventListener("touchend", this._forcePlayBound, !0), document.addEventListener("mouseup", this._forcePlayBound, !0))
                },
                setPlaying: function (e) {
                    this._isPlaying = e
                },
                isPlaying: function () {
                    return this._isPlaying
                },
                forcePlay: function (e) {
                    var t = this._sounds.length;
                    if (!t) return this._unlock();
                    for (var i = [], n = 0; n < t; n++) {
                        var r = this._sounds[n];
                        r.updateFromModel();
                        var a = r.playerPlay();
                        a && i.push(a), r.isSoundAsync() && (r.play(), r._exitTime && (r._player.currentTime = r._exitTime, r._exitTime = void 0))
                    }
                    this._isPlaying = e, this._context && this._context.resume && i.push(this._context.resume()), i.length && l().all(i).then(this._unlockBound).catch(function () {
                        T.debug("error on sound play"), this._authErrors = !0, this._lock()
                    }.bind(this))
                },
                pause: function () {
                    for (var e = 0; e < this._sounds.length; e++) {
                        var t = this._sounds[e];
                        t.isSoundAsync() || t.pause()
                    }
                    this._isPlaying = !1
                },
                getPlayedOnceFromAuthGesture: function () {
                    return this._playedOnceFromAuthGesture
                },
                _resetPlayedOnceFromAuthGesture: function () {
                    this._playedOnceFromAuthGesture = !this._authErrors || (0, S.Z)().isApp || (0, C.Z)(), this._playedOnceFromAuthGesture || (this._playedOnceFromAuthGesture = !1, this._enabled && this._hasSounds && (this._playedOnceFromAuthGesture = !this._authErrors))
                },
                canPlay: function () {
                    return this._enabled && !this._releasePending && !this._waiting && this._tabVisible
                },
                setWaiting: function (e) {
                    this._waiting = e, this._enabled && this._hasSounds && this._lock()
                },
                getRadius: function () {
                    return this._radius
                },
                featureDetectSoundAuthGestureNeeded: function () {
                    if (window.navigator.userActivation) {
                        var e = window.navigator.userActivation.hasBeenActive || window.navigator.userActivation.isActive;
                        return e || (this._authErrors = !0, this._lock()), e
                    }
                    var t = document.createElement("audio");
                    try {
                        return t.pause(), t.play().catch(function (e) {
                            e instanceof DOMException && "NotAllowedError" === e.name && (this._authErrors = !0, this._lock())
                        }.bind(this)), t.paused
                    } catch (e) {
                        return T.debug(e), !0
                    }
                },
                setMute: function (e) {
                    if (this.canPlay()) {
                        this._muted = e;
                        for (var t = 0, i = this._sounds.length; t < i; t++) this._sounds[t].updateVolume();
                        this._muted || this._lock()
                    }
                },
                getIsMute: function () {
                    return this._muted
                }
            };
            const y = new b
        },
        kRpH: (e, t, i) => {
            i.d(t, {
                Z: () => l
            });
            var n = i("aqzA"),
                r = i("MQQR"),
                a = n.Z.osg,
                o = ["magFilter", "minFilter", "wrapS", "wrapT", "textureWidth", "textureHeight", "textureTarget", "internalFormat"],
                s = {
                    getValidOptions: function () {
                        return o
                    },
                    getOptions: function (e) {
                        var t = {};
                        return t.minFilter = e.getMinFilter(), t.magFilter = e.getMagFilter(), t.wrapT = e.getWrapT(), t.wrapS = e.getWrapS(), t.textureWidth = e.getWidth(), t.textureHeight = e.getHeight(), t.textureTarget = e.getTextureTarget(), t.internalFormat = e._internalFormat, t.imageFormat = e._imageFormat, t
                    },
                    setOptions: function (e, t) {
                        t.setMinFilter(e.minFilter), t.setMagFilter(e.magFilter), t.setWrapT(e.wrapT), t.setWrapS(e.wrapS), e.minFilter === a.Texture.LINEAR_MIPMAP_LINEAR && (0, r.Z)().anisotropy && t.setMaxAnisotropy(16), t.setInternalFormat(e.internalFormat)
                    },
                    createValidOptionsForMaterial: function (e) {
                        var t = s.createValidOptions(e),
                            i = t.minFilter,
                            n = t.magFilter;
                        return i === a.Texture.LINEAR_MIPMAP_LINEAR || i === a.Texture.LINEAR ? (t.magFilter = a.Texture.LINEAR, t) : n === a.Texture.LINEAR ? (t.minFilter = a.Texture.LINEAR_MIPMAP_LINEAR, t) : i === a.Texture.NEAREST_MIPMAP_LINEAR || i === a.Texture.NEAREST ? (t.magFilter = a.Texture.NEAREST, t) : (t.magFilter = a.Texture.LINEAR, t.minFilter = a.Texture.LINEAR_MIPMAP_LINEAR, t)
                    },
                    createValidOptions: function (e) {
                        e || (e = {});
                        for (var t = o.length, i = 0; i < t; ++i) {
                            var n = o[i];
                            "string" == typeof e[n] && (e[n] = a.Texture[e[n]])
                        }
                        return e.magFilter || (e.magFilter = a.Texture.LINEAR), e.minFilter || (e.minFilter = a.Texture.LINEAR_MIPMAP_LINEAR), e.wrapS || (e.wrapS = a.Texture.REPEAT), e.wrapT || (e.wrapT = a.Texture.REPEAT), e.textureWidth || (e.textureWidth = 0), e.textureHeight || (e.textureHeight = 0), e.textureTarget || (e.textureTarget = a.Texture.TEXTURE_2D), e.internalFormat || (e.internalFormat = -1), e
                    }
                };
            const l = s
        },
        IuDx: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = 3.14159265359,
                r = 1801779,
                a = {};
            const o = function (e, t, i, o, s, l) {
                o = o || .25, s = s || 720;
                var u = Math.cos(.01745329251 * o),
                    c = 0,
                    h = a.table;
                if (void 0 === h)
                    for (h = a.table = new Float32Array(r), a.nphi = s, a.epsilon = o, c = 0; c < r; ++c) h[c] = 1 / 0;
                var d = n / (s - 1),
                    g = 1.57079632679 / (s - 1),
                    f = l ? 3 : 2,
                    m = s !== a.nphi || o !== a.epsilon,
                    p = e.length / f;
                for (c = 0; c < p; ++c) {
                    var v = c * i,
                        _ = c * f,
                        S = e[_],
                        x = e[_ + 1];
                    4 !== i || l || (t[v + 3] = 1024 & S ? -1 : 1, S &= -1025);
                    var C, T, M, b = 3 * (S + s * x),
                        y = b >= r;
                    if (m || y || h[b] === 1 / 0) {
                        var A = S * d,
                            R = Math.cos(A),
                            w = Math.sin(A);
                        A += g;
                        var E = (u - R * Math.cos(A)) / Math.max(1e-5, w * Math.sin(A));
                        E > 1 ? E = 1 : E < -1 && (E = -1);
                        var P = 6.28318530718 * x / Math.ceil(n / Math.max(1e-5, Math.acos(E)));
                        C = w * Math.cos(P), T = w * Math.sin(P), M = R, y || m || (h[b] = C, h[b + 1] = T, h[b + 2] = M)
                    } else C = h[b], T = h[b + 1], M = h[b + 2];
                    if (l) {
                        var N = 47938362584151635e-21 * e[_ + 2],
                            O = Math.sin(N);
                        t[v] = O * C, t[v + 1] = O * T, t[v + 2] = O * M, t[v + 3] = Math.cos(N)
                    } else t[v] = C, t[v + 1] = T, t[v + 2] = M
                }
                return t
            }
        },
        vNR5: (e, t, i) => {
            i.d(t, {
                Z: () => n
            });
            const n = function (e, t, i, n, r) {
                for (var a = e.length / r, o = 0; o < a; ++o)
                    for (var s = o * r, l = 0; l < r; ++l) t[s + l] = i[l] + e[s + l] * n[l];
                return t
            }
        },
        "H+3W": (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = i("aqzA").Z.osg;
            const r = function (e, t, i) {
                for (var r = new n[i](t), a = 0, o = 0; a !== t;) {
                    var s = 0,
                        l = 0;
                    do {
                        s |= (127 & e[o]) << l, l += 7
                    } while (0 != (128 & e[o++]));
                    r[a++] = s
                }
                if ("U" !== i[0])
                    for (var u = 0; u < t; ++u) {
                        var c = r[u];
                        r[u] = c >> 1 ^ -(1 & c)
                    }
                return r
            }
        },
        Mq9W: (e, t, i) => {
            i.d(t, {
                Z: () => w
            });
            var n = i("aqzA"),
                r = i("IuDx");
            const a = function (e, t) {
                for (var i = t || 0, n = e.length, r = e[i], a = i + 1; a < n; ++a) {
                    var o = e[a];
                    r = e[a] = r + (o >> 1 ^ -(1 & o))
                }
                return e
            };
            var o = function (e, t, i, n) {
                for (var r = e[o.IMPLICIT_HEADER_EXPECTED_INDEX], a = e[o.IMPLICIT_HEADER_MASK_LENGTH], s = new Uint32Array(e.subarray(o.IMPLICIT_HEADER_LENGTH, a + o.IMPLICIT_HEADER_LENGTH)), l = 32 * a - t.length, u = 0; u < a; ++u)
                    for (var c = s[u], h = 32 * u, d = u === a - 1 ? l : 0; d < 32; ++d, ++h) t[h] = c & -2147483648 >>> d ? e[i++] : n ? r : r++;
                return t
            };
            o.IMPLICIT_HEADER_PRIMITIVE_LENGTH = 0, o.IMPLICIT_HEADER_MASK_LENGTH = 1, o.IMPLICIT_HEADER_EXPECTED_INDEX = 2, o.IMPLICIT_HEADER_LENGTH = 3;
            const s = o;
            const l = function (e, t, i) {
                var n = e.length / t,
                    r = new Uint8Array(n),
                    a = i.length - 1;
                r[i[0]] = 1, r[i[1]] = 1, r[i[2]] = 1;
                for (var o = 2; o < a; ++o) {
                    var s = o - 2,
                        l = i[s],
                        u = i[s + 1],
                        c = i[s + 2],
                        h = i[s + 3];
                    if (1 !== r[h]) {
                        r[h] = 1, l *= t, u *= t, c *= t, h *= t;
                        for (var d = 0; d < t; ++d) e[h + d] = e[h + d] + e[u + d] + e[c + d] - e[l + d]
                    }
                }
                return e
            };
            var u = i("vNR5"),
                c = i("H+3W");
            const h = function (e, t, i) {
                for (var n = i[0], r = e.length, a = 0; a < r; ++a) {
                    var o = n - e[a];
                    t[a] = o, n <= o && (n = o + 1)
                }
                return i[0] = n, t
            };
            var d = i("MQQR"),
                g = n.Z.osg,
                f = n.Z.osgWrappers.osg.functionSortAttributes,
                m = "attributes",
                p = "vertex_mode",
                v = {
                    Vertex: 1,
                    Normal: 2,
                    TexCoord: 4,
                    Color: 8,
                    Triangle: 16,
                    Tangent: 32
                },
                _ = 1,
                S = 2,
                x = 1,
                C = 2,
                T = 4,
                M = function (e) {
                    return -1 !== e.indexOf("TexCoord") ? v.TexCoord : v[e]
                },
                b = function (e, t, i, n, r) {
                    var o, l = t.vb,
                        u = l.Offset ? l.Offset : 0,
                        d = e.getIndices();
                    1 === (o = l.Encoding && "varint" === l.Encoding ? (0, c.Z)(new Uint8Array(r, u), d.getItemSize() * l.Size, t.type) : new g[t.type](r, u, d.getItemSize() * l.Size)).BYTES_PER_ELEMENT && (o = new Uint16Array(o));
                    var f = i[m],
                        p = M("Triangle"),
                        v = o,
                        _ = e.getMode() === g.primitiveSet.TRIANGLE_STRIP;
                    if (0 == (f & p) || !_ && e.getMode() !== g.primitiveSet.TRIANGLES) return o instanceof Uint16Array == !1 && (v = new Uint16Array(o.buffer, o.byteOffset, o.length)).set(o), d.setElements(v), void e.setIndices(d);
                    var S = i.triangle_mode,
                        b = 0;
                    if (S & T && _ && (b = s.IMPLICIT_HEADER_LENGTH + o[s.IMPLICIT_HEADER_MASK_LENGTH], v = new Uint16Array(o[s.IMPLICIT_HEADER_PRIMITIVE_LENGTH])), S & x && a(o, b), S & T && _ && s(o, v, b, S & C), S & C && h(v, v, n), v instanceof Uint16Array == !1) {
                        var y = v;
                        (v = new Uint16Array(y.buffer, y.byteOffset, y.length)).set(y)
                    }
                    d.setElements(v), e.setIndices(d)
                },
                y = g.vec3.create(),
                A = g.vec3.create(),
                R = function (e, t, i, n, a, o) {
                    var s, h = t.vb,
                        f = e.getItemSize(),
                        v = h.Size,
                        x = h.Offset ? h.Offset : 0;
                    if (s = h.Encoding && "varint" === h.Encoding ? (0, c.Z)(new Uint8Array(o, x), f * v, t.type) : new g[t.type](o, x, f * v), 0 == (n[m] & M(i))) return "Color" === i ? s = function (e, t) {
                        if (4 === t.BYTES_PER_ELEMENT && (0, d.Z)().convertVertexColor8Bit) {
                            for (var i = t.length, n = new Uint8Array(t.buffer, t.byteOffset, i), r = 0; r < i; ++r) n[r] = Math.round(255 * Math.max(0, Math.min(1, t[r])));
                            t = n
                        }
                        return 1 === t.BYTES_PER_ELEMENT && e.setNormalize(!0), t
                    }(e, s) : "Bones" === i && (s = function (e, t) {
                        if (1 === t.BYTES_PER_ELEMENT) return t;
                        for (var i = 0, n = t.length; i < n; ++i)
                            if (t[i] > 255) return t;
                        var r = new Uint8Array(t.buffer, t.byteOffset, n);
                        return r.set(t), r
                    }(0, s)), void e.setElements(s);
                    if ("Normal" === i) return e.setElements((0, r.Z)(s, new Float32Array(3 * v), 3, n.epsilon, n.nphi)), void e.setItemSize(3);
                    if ("Tangent" === i) return e.setElements((0, r.Z)(s, new Float32Array(4 * v), 4, n.epsilon, n.nphi)), void e.setItemSize(4);
                    var C = null;
                    if ("Vertex" === i) C = n[p];
                    else if (-1 !== i.indexOf("TexCoord")) {
                        var T = "uv_" + i.substr(8) + "_mode";
                        C = void 0 !== n[T] ? n[T] : n[p]
                    }
                    C & S && void 0 !== a && l(s, f, a.getElements()), e.setElements(function (e, t, i, n, r) {
                        var a = "Vertex" === n ? "vtx_" : "uv_" + n.substr(8) + "_",
                            o = e & _ && void 0 !== r[a + "bbl_x"],
                            s = t instanceof Float32Array == 1;
                        if (!o && s) return t;
                        var l = 4 === t.BYTES_PER_ELEMENT ? new Float32Array(t.buffer, t.byteOffset, t.length) : new Float32Array(t.length);
                        return o ? (y[0] = r[a + "bbl_x"], y[1] = r[a + "bbl_y"], A[0] = r[a + "h_x"], A[1] = r[a + "h_y"], 3 === i && (y[2] = r[a + "bbl_z"], A[2] = r[a + "h_z"]), (0, u.Z)(t, l, y, A, i)) : (l.set(t), l)
                    }(C, s, f, i, n))
                };
            const w = function (e, t, i) {
                var n = function (e, t, i) {
                    for (var n, r = e.userDataMap, a = e.getPrimitiveSetList(), o = [0], s = 0, l = a.length; s < l; ++s) {
                        var u = a[s];
                        if (!(u instanceof g.DrawArrays || u instanceof g.DrawArrayLengths)) {
                            var c = u.getIndices();
                            c.getInitialBufferArray && (c = c.getInitialBufferArray());
                            var h = t[c.getInstanceID()];
                            !0 !== h.visited && (h.visited = !0, h.inlined ? (c.setElements(new Uint16Array(h.inlined)), u.setIndices(c)) : (b(u, h, r, o, i), u.getMode() === g.primitiveSet.TRIANGLE_STRIP && (n = c)))
                        }
                    }
                    for (s = l - 1; s >= 0; s--)(u = a[s]).getCount() || a.splice(s, 1);
                    return n
                }(e, t, i);
                ! function (e, t, i, n) {
                    var r = e.userDataMap,
                        a = e.getVertexAttributeList(),
                        o = Object.keys(a);
                    o.sort(f);
                    for (var s = o.length, l = 0; l < s; ++l) {
                        var u = o[l],
                            c = a[u];
                        c.getInitialBufferArray && (c = c.getInitialBufferArray());
                        var h = t[c.getInstanceID()];
                        if (!0 !== h.visited)
                            if (h.visited = !0, h.inlined) c.setElements(new Float32Array(h.inlined));
                            else {
                                var d = r,
                                    g = u.indexOf("_"); - 1 !== g && (d = r["morph_" + u.slice(g + 1)], u = u.slice(0, g)), R(c, h, u, d, n, i)
                            }
                    }
                }(e, t, i, n)
            }
        },
        FGWR: (e, t, i) => {
            i.d(t, {
                Z: () => a
            });
            var n = i("aqzA").Z.osg,
                r = [0, 0];
            const a = {
                init: function (e, t, i) {
                    this._qualityModel = t, this._canvasPixelRatio = i, this._canvas = e, this._pixelRatio = [1, 1]
                },
                getCanvasCoord: function (e, t) {
                    if (t = t || r, e.center || e.touches) {
                        if (e.center) t[0] = e.center.x, t[1] = e.center.y;
                        else {
                            t[0] = t[1] = 0;
                            for (var i = e.touches.length, n = 0; n < i; ++n) t[0] += e.touches[n].clientX / i, t[1] += e.touches[n].clientY / i
                        }
                        var a = e.target.getBoundingClientRect();
                        t[0] += -a.left, t[1] += -a.top
                    } else t[0] = void 0 === e.offsetX ? e.layerX : e.offsetX, t[1] = void 0 === e.offsetY ? e.layerY : e.offsetY;
                    return t
                },
                getPixelRatio: function () {
                    var e = this._qualityModel.get("dynamicResolutionScaling");
                    return this._pixelRatio[0] = this._canvasPixelRatio * e[0], this._pixelRatio[1] = this._canvasPixelRatio * e[1], this._pixelRatio
                },
                canvasCoordToGL: function (e, t, i) {
                    var r = this._canvas,
                        a = i || n.vec2.create(),
                        o = this.getPixelRatio();
                    return a[0] = e * o[0], a[1] = (r.clientHeight - t) * o[1], a
                },
                glCoordToCanvas: function (e, t, i) {
                    var r = this._canvas,
                        a = i || n.vec2.create(),
                        o = this.getPixelRatio();
                    return a[0] = e / o[0], a[1] = r.clientHeight - t / o[1], a
                }
            }
        },
        wvpl: (e, t, i) => {
            i.d(t, {
                Z: () => a
            });
            var n = i("Hjnd"),
                r = i.n(n);
            const a = {
                onFullScreenChange: function (e) {
                    var t = r()(document);
                    t.on("fullscreenchange", e), t.on("webkitfullscreenchange", e), t.on("MSFullscreenchange", e), t.on("mozfullscreenchange", e)
                },
                offFullScreenChange: function (e) {
                    var t = r()(document);
                    t.off("fullscreenchange", e), t.off("webkitfullscreenchange", e), t.off("MSFullscreenchange", e), t.off("mozfullscreenchange", e)
                },
                hasFullscreen: function () {
                    return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled || document.mozFullScreenEnabled
                },
                isFullscreen: function () {
                    return document.fullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement && null !== document.msFullscreenElement || document.webkitIsFullScreen
                },
                requestFullscreen: function (e) {
                    e.requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : e.msRequestFullscreen ? e.msRequestFullscreen() : e.mozRequestFullScreen && e.mozRequestFullScreen()
                },
                exitFullscreen: function () {
                    document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen && document.mozCancelFullScreen()
                }
            }
        },
        JBIs: (e, t, i) => {
            i.d(t, {
                Z: () => s
            });
            var n = i("aqzA"),
                r = i("MQQR"),
                a = n.Z.osg,
                o = function (e) {
                    a.StateAttribute.call(this), this._enable = !e && (0, r.Z)().zz
                };
            a.createPrototypeStateAttribute(o, a.objectInherit(a.StateAttribute.prototype, {
                attributeType: "VertexCompression",
                cloneType: function () {
                    return new o(!0)
                },
                isEnabled: function () {
                    return this._enable
                },
                getHash: function () {
                    return "VCMP" + (this._enable ? 1 : 0)
                }
            }), "osg", "VertexCompression");
            const s = o
        },
        o2b8: (e, t, i) => {
            i.d(t, {
                Z: () => h
            });
            var n = i("aqzA"),
                r = i("ZmEo"),
                a = n.Z.osg,
                o = n.Z.osgAnimation,
                s = a.BufferArray.randa,
                l = {},
                u = function (e, t, i) {
                    e._listQuantUV || (e._listQuantUV = []);
                    var n = "uQUV" + i.substr(8),
                        o = t._objQUV;
                    if (o) return -1 === e._listQuantUV.indexOf(o) && e._listQuantUV.push(o), void (o.uniformName !== n && (e._listQuantUV.push({
                        uniformName: n,
                        _QUV: o._QUV
                    }), r.Z[n] || (r.Z[n] = a.Uniform.createFloat4(n))));
                    var s = t.computeMinMaxUV(l),
                        u = a.vec4.fromValues(s.xmin, s.ymin, s.xmax - s.xmin, s.ymax - s.ymin);
                    t._QUV = u, o = {
                        uniformName: n,
                        _QUV: u
                    }, t._objQUV = o, e._listQuantUV.push(o), r.Z[n] || (r.Z[n] = a.Uniform.createFloat4(n))
                },
                c = function () {
                    a.ComputeBoundsVisitor.call(this), this.nodeMaskOverride = -1
                };
            a.createPrototypeObject(c, a.objectInherit(a.NodeVisitor.prototype, {
                apply: function (e) {
                    if (e instanceof a.Geometry != !1) {
                        var t = (e.getSourceGeometry ? e.getSourceGeometry() : e) instanceof o.MorphGeometry;
                        if (!e._qcomp) {
                            e._qcomp = !0;
                            var i = e.getVertexAttributeList();
                            if (!t) {
                                var n = i.Vertex;
                                n && function (e, t) {
                                    if (t._QVT) return e._QVT = t._QVT, void (e._QVS = t._QVS);
                                    var i = t._minMax || t.computeMinMaxVertex(l),
                                        n = a.vec3.fromValues(i.xmax - i.xmin, i.ymax - i.ymin, i.zmax - i.zmin);
                                    a.vec3.div(n, n, s);
                                    var r = a.vec3.fromValues(i.xmin, i.ymin, i.zmin);
                                    t._QVT = r, t._QVS = n, e._QVT = r, e._QVS = n
                                }(e, n);
                                var r = i.Normal;
                                r && (r._QNOR = !0);
                                var c = i.Tangent;
                                c && (c._QTAN = !0)
                            }
                            for (var h in i) h.startsWith("TexCoord") && u(e, i[h], h)
                        }
                    } else this.traverse(e)
                }
            }));
            const h = c
        },
        N8nW: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = i("aqzA"),
                r = i("MQQR"),
                a = n.Z.osg;
            const o = function (e) {
                var t = a.WebGLCaps.instance(),
                    i = t.getWebGLParameter("MAX_TEXTURE_SIZE"),
                    n = t.getWebGLParameter("MAX_RENDERBUFFER_SIZE"),
                    o = (0, r.Z)().maxTextureSize,
                    s = void 0 === e ? 1 / 0 : e;
                return Math.min(i, n, o, s)
            }
        },
        WvFz: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = i("aqzA"),
                r = i("MQQR"),
                a = n.Z.osg;
            const o = function () {
                var e = a.WebGLCaps.instance().getWebGLParameter("MAX_TEXTURE_IMAGE_UNITS");
                return Math.min(e, (0, r.Z)().maxTextureUnits)
            }
        },
        QKpV: (e, t, i) => {
            i.d(t, {
                Z: () => g
            });
            var n = i("aqzA").Z.osg,
                r = !0,
                a = n.Timer.prototype.tick,
                o = function () {
                    this.children = [], this.message = "", this.parent = this
                },
                s = {},
                l = {},
                u = new o,
                c = u,
                h = function (e) {
                    console.log("%c" + e, "color:purple")
                };
            n.time = function (e) {
                var t = new o;
                s[e] = t, t.start = a(), r && (c.children.push(t), t.parent = c, c = t, t.timerMessage = e)
            }, n.timeEnd = function (e) {
                var t = s[e],
                    i = e + " : " + (a() - t.start).toFixed(2) + "ms";
                r ? (c = t.parent || u, t.message = i) : l.logMessage(i)
            };
            var d = function (e, t) {
                var i = !e.message,
                    n = e.children,
                    r = "";
                e !== u && n.length > 0 && (r = t + e.timerMessage + (i ? "(pending)\n\n" : "\n"));
                for (var a = e === u || i ? "" : "  |  ", o = 0; o < n.length; ++o) r += d(n[o], t + a) + "\n";
                var s = (e.parent === u || !e.parent.message) && e.timerMessage ? "\n" : "";
                return r + (t + e.message) + s
            };
            l.showMessage = function () {
                var e = d(u, "");
                e = e.replace(/(\n*$)/, "");
                var t = window.performance && window.performance.now ? (window.performance.now() / 1e3).toString() : "";
                h(e += "\n\n<<<<< Model Displayed! " + t + ">>>>>"), r = !1
            }, l.logBound = function (e) {
                var t = e.center(n.vec3.create()),
                    i = "Bound center : [ " + t[0] + ", " + t[1] + ", " + t[2] + " ]\n";
                i += "Bound radius : " + e.radius() + "\n";
                var r = e.getMin(),
                    a = e.getMax();
                i += "Bbox min : [ " + r[0] + ", " + r[1] + ", " + r[2] + " ]\n", i += "Bbox max : [ " + a[0] + ", " + a[1] + ", " + a[2] + " ]\n", l.logMessage(i)
            }, l.logMessage = function (e) {
                if (!r) return h(e);
                var t = new o;
                t.message = e, c.children.push(t), t.parent = c
            };
            const g = l
        },
        "3XAv": (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = "undefined" != typeof global;
            const r = function () {
                return n
            }
        },
        YxXF: (e, t, i) => {
            i.d(t, {
                Z: () => o
            });
            var n = {
                isPowerOf2: function (e) {
                    return 0 == (e & e - 1)
                },
                floorPowerOf2: function (e) {
                    return 1 << Math.floor(Math.log2(e))
                },
                ceilPowerOf2: function (e) {
                    return 1 << Math.ceil(Math.log2(e))
                },
                snapToPowerOf2: function (e, t) {
                    if (n.isPowerOf2(e)) return e;
                    var i = n.floorPowerOf2(e);
                    return e / i - 1 > (void 0 === t ? .5 : t) ? n.ceilPowerOf2(e) : i
                }
            },
                r = new Uint32Array(1);

            function a(e) {
                return r[0] = e, r[0] = (r[0] << 16 | r[0] >> 16) >>> 0, r[0] = (1431655765 & r[0]) << 1 | (2863311530 & r[0]) >>> 1 >>> 0, r[0] = (858993459 & r[0]) << 2 | (3435973836 & r[0]) >>> 2 >>> 0, r[0] = (252645135 & r[0]) << 4 | (4042322160 & r[0]) >>> 4 >>> 0, r[0] = (16711935 & r[0]) << 8 | (4278255360 & r[0]) >>> 8 >>> 0, 2.3283064365386963e-10 * r[0]
            }
            n.hammersley = function (e, t) {
                return [e / t, a(e)]
            }, n.hemisphereSampleUniform = function (e, t) {
                var i = n.hammersley(e, t),
                    r = 2 * i[1] * Math.PI,
                    a = 1 - i[0],
                    o = Math.sqrt(1 - a * a);
                return [Math.cos(r) * o, Math.sin(r) * o, a]
            }, n.hemisphereSampleCos = function (e, t) {
                var i = n.hammersley(e, t),
                    r = 2 * i[1] * Math.PI,
                    a = Math.sqrt(1 - i[0]),
                    o = Math.sqrt(1 - a * a);
                return [Math.cos(r) * o, Math.sin(r) * o, a]
            };
            const o = n
        },
        Ygw6: (e, t, i) => {
            i.d(t, {
                Z: () => r
            });
            var n = i("aqzA").Z.osg;
            const r = {
                DEPTH_LESS_WRITE: new n.Depth(n.Depth.LESS, 0, 1, !0),
                DEPTH_LESS_NO_WRITE: new n.Depth(n.Depth.LESS, 0, 1, !1),
                DEPTH_DISABLE: new n.Depth(n.Depth.DISABLE, 0, 1, !0),
                DEPTH_ALWAYS: new n.Depth(n.Depth.ALWAYS, 0, 1, !0),
                DEPTH_NEVER: new n.Depth(n.Depth.NEVER, 0, 1, !1),
                DEPTH_LEQUAL_BACKGROUND_NO_WRITE: new n.Depth(n.Depth.LEQUAL, 1, 1, !1),
                DEPTH_LEQUAL_WRITE: new n.Depth(n.Depth.LEQUAL, 0, 1, !0),
                DEPTH_LEQUAL_NO_WRITE: new n.Depth(n.Depth.LEQUAL, 0, 1, !1),
                DEPTH_EQUAL_NO_WRITE: new n.Depth(n.Depth.EQUAL, 0, 1, !1),
                COLOR_MASK_NONE: new n.ColorMask(!1, !1, !1, !1),
                COLOR_MASK_ALPHA: new n.ColorMask(!1, !1, !1, !0),
                COLOR_MASK_RGBA: new n.ColorMask(!0, !0, !0, !0),
                BLEND_DISABLE: new n.BlendFunc,
                BLEND_SUBSTRACTIVE: new n.BlendFunc(n.BlendFunc.ONE, n.BlendFunc.ONE_MINUS_SRC_ALPHA),
                BLEND_ADDITIVE: new n.BlendFunc(n.BlendFunc.ONE, n.BlendFunc.ONE),
                CULL_BACK: new n.CullFace(n.CullFace.BACK),
                CULL_FRONT: new n.CullFace(n.CullFace.FRONT),
                CULL_DISABLE: new n.CullFace(n.CullFace.DISABLE)
            }
        },
        hySD: (e, t, i) => {
            i.d(t, {
                Z: () => d,
                i: () => c
            });
            var n, r, a, o = i("MQQR"),
                s = i("qk4i"),
                l = document.createElement("canvas"),
                u = document.createElement("canvas"),
                c = function (e, t, i, a) {
                    return a || (a = u),
                        function (e, t, i, n) {
                            l.width === t && l.height === i || (n.width = t, n.height = i, l.width = t, l.height = i, r = new Uint8Array(4 * t * i));
                            var a = e.getGraphicContext(),
                                o = a.checkFramebufferStatus(a.FRAMEBUFFER);
                            if (o !== a.FRAMEBUFFER_COMPLETE) return console.error("FRAMEBUFFER status invalid.", o);
                            a.flush(), a.finish(), a.readPixels(0, 0, t, i, a.RGBA, a.UNSIGNED_BYTE, r);
                            var s = l.getContext("2d"),
                                u = s.getImageData(0, 0, t, i);
                            u.data.set(r), s.putImageData(u, 0, 0);
                            var c = n.getContext("2d");
                            c.clearRect(0, 0, t, i), c.fillStyle = "transparent", c.fillRect(0, 0, t, i), c.save(), c.globalCompositeOperation = "copy", c.scale(1, -1), c.drawImage(l, 0, 0, t, i, 0, -i, t, i), c.restore()
                        }(e, t, i, a), (0, o.Z)().downloadPicture && (n || (n = document.createElement("a"), document.body.appendChild(n), n.style.display = "none"), n.href = a.toDataURL("image/jpeg"), n.download = "image.jpg", n.click()), a
                },
                h = function (e) {
                    e.getScene().updateSceneGraph(e.getUpdateVisitor());
                    var t = e.getCamera().getRenderer();
                    t.cull(), t.draw()
                };
            const d = function (e, t, i, n) {
                var r = i.getSuperSample(),
                    o = i.getViewerOSGJS();
                if (e && t || (e = o.getCanvasWidth(), t = o.getCanvasHeight()), function (e, t, i) {
                    var n = e.getFeatures(),
                        r = e.getSuperSample(),
                        o = e.getViewerOSGJS(),
                        l = e.getFeaturesManager().getNodeGizmo(),
                        u = o.getCamera();
                    for (var d in n) n[d].prepareForScreenShot();
                    a = void 0, l && l.getNodeMask() && (a = l.getNodeMask(), l.setNodeMask(0)), e.trigger("resizeViewer", t, i), o.updateViewport(), s.Z.setPoseForScreenshot(!0), o.checkNeedToDoFrame(), h(o), u.setFinalDrawCallback((function (e) {
                        r.isEnabled() || c(e, t, i)
                    }))
                }(i, e, t), r.canBeEnabled())
                    for (r.forceEnable(); r.isEnabled();) r.updateFrame(), h(o);
                else h(o);
                return function (e) {
                    var t = e.getFeatures(),
                        i = e.getViewerOSGJS(),
                        n = e.getFeaturesManager().getNodeGizmo(),
                        r = i.getCamera();
                    for (var o in s.Z.setPoseForScreenshot(!1), r.setFinalDrawCallback(void 0), t) t[o].resetAfterScreenShot();
                    a && n.setNodeMask(a), e.trigger("resizeViewerOnNextFrame", -1, -1)
                }(i), n || (o.updateViewport(), i.getFeatures().inspector.getModel().trigger("change:viewerToCanvasRatio")), u
            }
        },
        uyWM: (e, t, i) => {
            i.d(t, {
                D1: () => x,
                cW: () => S,
                gN: () => g,
                hP: () => v,
                kR: () => p
            });
            var n, r, a, o = i("aqzA"),
                s = i("+cmV"),
                l = i("JbUU"),
                u = i("jXe1"),
                c = i("MQQR"),
                h = o.Z.osg,
                d = o.Z.osgAnimation,
                g = function (e) {
                    n = e.getViewerWebGL().getRootModel()
                },
                f = null !== (0, c.Z)().apiVersion,
                m = (r = h.vec3.create(), a = h.mat4.create(), function (e) {
                    var t = e.get("lastComputedScenePosition"),
                        i = function (e) {
                            var t = e.get("sticky");
                            if (void 0 !== t) return t;
                            var i = e.get("geometryUid");
                            if (i < 0) return e.set("sticky", null), null;
                            var n = s.Z.uidGeometryMap[i];
                            return n && (f || n instanceof d.RigGeometry || n instanceof d.MorphGeometry || (0, u.Z)(n)) ? (e.set("sticky", n), n) : (e.set("sticky", null), null)
                        }(e);
                    if (!i) return h.vec3.copy(t, e.get("position"));
                    var o = e.get("indices"),
                        l = o[0],
                        c = o[1],
                        g = o[2];
                    if (i.getWorldMatrix(n, a), l < 0 || !i.computeTransformedVertex) return h.vec3.transformMat4(t, e.get("localPosition"), a);
                    var m = i.getVertexAttributeList().Vertex.getElements().length / 3;
                    if (l >= m || c >= m || g >= m) return h.vec3.copy(t, e.get("position"));
                    var p = e.get("barycentricWeights"),
                        v = p[0],
                        _ = p[1],
                        S = p[2];
                    return h.vec3.init(t), i.computeTransformedVertex(l, r), h.vec3.scaleAndAdd(t, t, r, v), c >= 0 && (i.computeTransformedVertex(c, r), h.vec3.scaleAndAdd(t, t, r, _)), g >= 0 && (i.computeTransformedVertex(g, r), h.vec3.scaleAndAdd(t, t, r, S)), h.vec3.transformMat4(t, t, a), t
                }),
                p = function (e) {
                    m(e);
                    var t = e.get("lastComputedScenePosition"),
                        i = e.get("lastComputedWorldPosition");
                    return l.Z.getWorldPositionFromScenePoint(t, i)
                },
                v = function (e, t) {
                    l.Z.getScenePositionFromHit(t, e.get("position"));
                    var i = t._nodePath[t._nodePath.length - 1],
                        n = void 0 !== i._uniqueID ? i._uniqueID : -1;
                    e.set("geometryUid", n);
                    var r = e.get("localPosition");
                    r[0] = t._localIntersectionPoint[0], r[1] = t._localIntersectionPoint[1], r[2] = t._localIntersectionPoint[2];
                    var a = e.get("indices");
                    a[0] = t._i1, a[1] = t._i2, a[2] = t._i3;
                    var o = e.get("barycentricWeights");
                    o[0] = t._r1, o[1] = t._r2, o[2] = t._r3
                },
                _ = function (e) {
                    e.set("geometryUid", -1), h.vec3.set(e.get("indices"), -1, -1, -1), h.vec3.init(e.get("barycentricWeights")), h.vec3.init(e.get("localPosition"))
                },
                S = function (e, t) {
                    h.vec3.copy(e.get("position"), t), h.vec3.copy(e.get("lastComputedScenePosition"), t);
                    var i = e.get("lastComputedWorldPosition");
                    l.Z.getWorldPositionFromScenePoint(i, t), _(e)
                },
                x = function (e, t) {
                    var i = e.get("position");
                    l.Z.getScenePositionFromWorldPoint(t, i), h.vec3.copy(e.get("lastComputedScenePosition"), i), h.vec3.copy(e.get("lastComputedWorldPosition"), t), _(e)
                }
        },
        HXjs: (e, t, i) => {
            i.d(t, {
                BG: () => h,
                X2: () => d
            });
            var n, r, a = i("3XAv"),
                o = !1;
            if (document)
                for (var s = ["hidden", "mozHidden", "msHidden", "webkitHidden"], l = 0, u = s.length; l < u; l++) {
                    var c = s[l];
                    if (void 0 !== document[c]) {
                        n = c, r = c.toLowerCase().split("hidden").shift() + "visibilitychange";
                        break
                    }
                }
            var h, d = function () {
                return r
            };
            h = (0, a.Z)() ? function () {
                return !1
            } : function () {
                return !(o || !n) && document[n]
            }
        },
        s4wW: e => {
            e.exports = '\n#pragma include "shadowing/shadowReceive.glsl"\n\nvarying vec3 vModelNormal;\nvarying vec3 vModelVertex;\n\nvoid main() {\n    vec3 modelNormal = normalize(gl_FrontFacing ? vModelNormal : -vModelNormal);\n    #ifdef _ATLAS_SHADOW\n        float shadow = shadowReceive(true, modelNormal, vModelVertex, Texture7, uShadow_Texture0_renderSize, uShadow_Texture0_projection, uShadow_Texture0_viewRight, uShadow_Texture0_viewUp, uShadow_Texture0_viewLook, uShadow_Texture0_depthRange, uShadowReceive0_bias, uShadow_Texture0_mapSize, uStaticFrameNumShadow0);\n    #else\n        float shadow = shadowReceive(true, modelNormal, vModelVertex, Texture12, uShadow_Texture0_renderSize, uShadow_Texture0_projection, uShadow_Texture0_viewRight, uShadow_Texture0_viewUp, uShadow_Texture0_viewLook, uShadow_Texture0_depthRange, uShadowReceive0_bias, uStaticFrameNumShadow0);\n    #endif\n\n    // not much blending, so no need to convert to srgb\n    // gl_FragColor = vec4(0.0, 0.0, 0.0, linearTosRGB(0.5 - shadow));\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.5 - shadow);\n}\n'
        },
        aV2Y: e => {
            e.exports = '#pragma include "base.vert"\n'
        },
        WkX6: e => {
            e.exports = 'uniform float uDisplay2D;\nuniform float uPointSize;\n\nuniform vec2 uGlobalTexRatio;\nuniform vec2 uGlobalTexSize;\nuniform vec4 uHalton;\n\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uModelViewNormalMatrix;\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelViewMatrix;\n\n// in case of srgbToLinear texfetch\n#ifdef HAS_DISPLACEMENT\n#pragma include "utils/functions.glsl"\n#endif\n\n#ifdef NEED_INVARIANT\ninvariant gl_Position;\n#endif\n\n\n#if defined(HAS_COMPRESSION) && !defined(HAS_MORPHING)\n    #define HAS_POSITION_COMPRESSION\n#endif\n\n/////////////////////////////////////\n// ATTRIBUTES (NORMAL/VERTEX/TANGENT)\n/////////////////////////////////////\n\n#ifdef HAS_ZW_COMPRESSION\n    attribute vec4 Vertex;\n#else\n    attribute vec3 Vertex;\n#endif\n\n// need normal to displace vertex\n#if defined(HAS_VIEW_NORMAL) || defined(HAS_MODEL_NORMAL) || defined(HAS_testdemo2024_DISPLACEMENT)\n\n    #ifdef HAS_POSITION_COMPRESSION\n        attribute vec2 Normal;\n    #else\n        attribute vec3 Normal;\n    #endif\n\n    #define NEED_LOCAL_NORMAL\n#endif\n\n// if no normalmap, correct the normal with displacement (as bump)\n#if defined(HAS_DISPLACEMENT) && !defined(HAS_NORMALMAP) && (defined(HAS_MODEL_NORMAL) || defined(HAS_VIEW_NORMAL))\n    #define CORRECT_BUMP_NORMAL\n#endif\n\n// need tangent to correct normal\n#if defined(HAS_VIEW_TANGENT) || defined(HAS_MODEL_TANGENT) || defined(CORRECT_BUMP_NORMAL)\n\n    #ifdef HAS_POSITION_COMPRESSION\n        attribute vec3 Tangent;\n    #else\n        attribute vec4 Tangent;\n    #endif\n\n    #define NEED_LOCAL_TANGENT\n#endif\n\n#ifdef HAS_VERTEX_COLOR\n    attribute vec4 Color;\n#endif\n\n////////////////////\n// VARYING/VARIABLES\n////////////////////\n\n// view\n#ifdef HAS_VIEW_VERTEX\n    varying vec4 vViewVertex;\n#else\n    vec4 vViewVertex;\n#endif\n\n#ifdef HAS_VIEW_NORMAL\n    varying vec3 vViewNormal;\n#endif\n\n#ifdef HAS_VIEW_TANGENT\n    varying vec4 vViewTangent;\n#endif\n\n// model\n#if defined(HAS_MODEL_VERTEX)\n    varying vec3 vModelVertex;\n#elif defined(HAS_DISPLACEMENT)\n    vec3 vModelVertex;\n#endif\n\n#if defined(HAS_MODEL_NORMAL)\n    varying vec3 vModelNormal;\n#elif defined(HAS_testdemo2024_DISPLACEMENT)\n    vec3 vModelNormal;\n#endif\n\n#if defined(HAS_MODEL_TANGENT)\n    varying vec3 vModelTangent;\n#endif\n\n#ifdef HAS_VERTEX_COLOR\n    varying vec4 vColor;\n    uniform float uArrayColorEnabled;\n#endif\n\n////////////\n// ANIMATION\n////////////\n\n#ifdef HAS_MORPHING\n    uniform vec4 uTargetWeights;\n\n%UNROLL 4%\n    #if NUM_TARGETS > %ID%\n        attribute vec3 Vertex_%ID%;\n        #define ARG_MORPH_VERTEX_%ID% , Vertex_%ID%\n\n        #ifdef HAS_MORPHING_NORMAL\n            attribute vec3 Normal_%ID%;\n            #define ARG_MORPH_NORMAL_%ID% , Normal_%ID%\n        #endif\n\n        #ifdef HAS_MORPHING_TANGENT\n            attribute vec3 Tangent_%ID%;\n            #define ARG_MORPH_TANGENT_%ID% , Tangent_%ID%.xyz\n        #endif\n    #else\n        #define ARG_MORPH_VERTEX_%ID%\n        #define ARG_MORPH_NORMAL_%ID%\n        #define ARG_MORPH_TANGENT_%ID%\n    #endif\n%%\n\n    #pragma include "utils/morphing.glsl"\n#endif\n\n#ifdef HAS_SKINNING\n    #ifndef NUM_BONES\n        #define NUM_BONES 1\n    #endif\n\n    attribute vec4 Bones;\n    attribute vec4 Weights;\n    uniform vec4 uBones[NUM_BONES];\n\n    #pragma include "utils/skinning.glsl"\n#endif\n\n#ifdef HAS_DISPLACEMENT\n    uniform float uDisplacementFactor;\n#endif\n\n#ifdef CORRECT_BUMP_NORMAL\n    uniform float uDisplacementNormal;\n    uniform vec2 uDisplacementSize;\n    #pragma include "utils/normalBump.glsl"\n#endif\n\n#ifdef HAS_POSITION_COMPRESSION\n    uniform vec3 uQVT;\n    uniform vec3 uQVS;\n\n    #ifdef HAS_OCT_COMPRESSION\n        #define UNCOMPRESS_DIR(n) n.z = 1.0 - abs(n.x) - abs(n.y); n.xy = n.z >= 0.0 ? n.xy : (1.0 - abs(n.yx)) * sign(n.xy);\n    #else\n        #define UNCOMPRESS_DIR(n) n.z = dot(n.xy, n.xy); n.xyz = vec3(2.0 * n.xy * sqrt(1.0 - n.z), 1.0 - 2.0 * n.z);\n    #endif\n#endif\n\n// attribute -> morph -> skin -> model -> displace -> view -> screen\n// localVertex = skin(morph(Vertex))\n// modelVertex = displacement(modelMatrix * localVertex)\n// viewVertex = viewMatrix * modelVertex\n\nvoid main() {\n#ifdef ASSIGN_UV\n    ASSIGN_UV\n#endif\n\n#ifdef HAS_VERTEX_COLOR\n    vColor = uArrayColorEnabled == 1.0 ? Color : vec4(1.0);\n#endif\n\n#ifdef HAS_SKINNING\n    mat4 boneMatrix = skinning(Weights, Bones);\n#endif\n\n    /////////////////////\n    // LOCAL/MODEL VERTEX\n    /////////////////////\n    vec3 localVertex = Vertex.xyz;\n#ifdef HAS_POSITION_COMPRESSION\n    #ifdef HAS_ZW_COMPRESSION\n        localVertex += Vertex.w;\n    #endif\n    localVertex = localVertex * uQVS RAND_SCALE + uQVT;\n#endif\n\n#ifdef HAS_MORPHING\n    localVertex = morphing(uTargetWeights, localVertex ARG_MORPH_VERTEX_0 ARG_MORPH_VERTEX_1 ARG_MORPH_VERTEX_2 ARG_MORPH_VERTEX_3);\n#endif\n\n#ifdef HAS_SKINNING\n    localVertex = (vec4(localVertex, 1.0) * boneMatrix).xyz;\n#endif\n\n#if defined(HAS_MODEL_VERTEX) || defined(HAS_DISPLACEMENT)\n    vModelVertex = (uModelMatrix * vec4(localVertex, 1.0)).xyz;\n#endif\n\n#if (defined(NEED_LOCAL_NORMAL) && defined(HAS_MORPHING_NORMAL)) || (defined(NEED_LOCAL_TANGENT) && defined(HAS_MORPHING_TANGENT))\n    // normalize weights for direction morphing\n    vec4 nTargetWeights = abs(uTargetWeights);\n    nTargetWeights = uTargetWeights / max(1.0, nTargetWeights.x + nTargetWeights.y + nTargetWeights.z + nTargetWeights.w);\n#endif\n\n    /////////\n    // NORMAL\n    /////////\n#ifdef NEED_LOCAL_NORMAL\n    #ifdef HAS_POSITION_COMPRESSION\n        vec3 localNormal = Normal.xyy;\n        UNCOMPRESS_DIR(localNormal);\n    #else\n        vec3 localNormal = Normal;\n    #endif\n\n    #ifdef HAS_MORPHING_NORMAL\n        localNormal = morphing(nTargetWeights, localNormal ARG_MORPH_NORMAL_0 ARG_MORPH_NORMAL_1 ARG_MORPH_NORMAL_2 ARG_MORPH_NORMAL_3);\n    #endif\n\n    #ifdef HAS_SKINNING\n        localNormal = (vec4(localNormal, 0.0) * boneMatrix).xyz;\n    #endif\n\n    #if defined(HAS_MORPHING) || defined(HAS_SKINNING)\n        localNormal.xyz = normalize(localNormal);\n    #endif\n\n    #if defined(HAS_MODEL_NORMAL) || defined(HAS_testdemo2024_DISPLACEMENT)\n        vModelNormal = uModelNormalMatrix * localNormal;\n    #endif\n\n    // view normal computed later if we need to correct it (displacement)\n    #if defined(HAS_VIEW_NORMAL) && !defined(CORRECT_BUMP_NORMAL)\n        vViewNormal = uModelViewNormalMatrix * localNormal;\n    #endif\n#endif\n\n    //////////\n    // TANGENT\n    //////////\n#ifdef NEED_LOCAL_TANGENT\n    #ifdef HAS_POSITION_COMPRESSION\n        vec4 localTangent = Tangent.xyzz;\n        UNCOMPRESS_DIR(localTangent);\n    #else\n        vec4 localTangent = Tangent;\n    #endif\n\n    #ifdef HAS_MORPHING_TANGENT\n        localTangent.xyz = morphing(nTargetWeights, localTangent.xyz ARG_MORPH_TANGENT_0 ARG_MORPH_TANGENT_1 ARG_MORPH_TANGENT_2 ARG_MORPH_TANGENT_3);\n    #endif\n\n    #ifdef HAS_SKINNING\n        localTangent.xyz = (vec4(localTangent.xyz, 0.0) * boneMatrix).xyz;\n    #endif\n\n    #if defined(HAS_MORPHING) || defined(HAS_SKINNING)\n        localTangent.xyz = normalize(localTangent.xyz);\n    #endif\n\n    #ifdef HAS_MODEL_TANGENT\n        vModelTangent = vec4(uModelNormalMatrix * localTangent.xyz, localTangent.w).xyz;\n    #endif\n\n    #ifdef HAS_VIEW_TANGENT\n        vViewTangent = vec4(uModelViewNormalMatrix * localTangent.xyz, localTangent.w);\n    #endif\n#endif\n\n    //////////////////\n    // DISPLACE VERTEX\n    //////////////////\n#ifdef HAS_DISPLACEMENT\n    // we multiply by 1 - uDisplay2D here as we don\'t want the displacement to appear in the 2D view of the inspector\n    float displacement = (COLOR_CONVERT_DISPLACEMENT(texture2D(SAMPLER_DISPLACEMENT, UV_DISPLACEMENT).PACK_DISPLACEMENT) - 0.5) * uDisplacementFactor * (1.0 - uDisplay2D);\n    #ifdef HAS_testdemo2024_DISPLACEMENT\n        vModelVertex += normalize(vModelNormal) * displacement;\n    #else\n        vModelVertex += vec3(0.0, 0.0, 1.0) * (vModelVertex.z > 0.01 ? displacement : 0.0);\n    #endif\n    vViewVertex = uViewMatrix * vec4(vModelVertex, 1.0);\n#else\n    vViewVertex = uModelViewMatrix * vec4(localVertex, 1.0);\n#endif\n\n    //////////////////\n    // DISPLACE NORMAL\n    //////////////////\n#ifdef CORRECT_BUMP_NORMAL\n    // if there is no normal map, use displacement to correct normal\n    vec3 invSize = vec3(1.0 / uDisplacementSize, 0.0);\n    vec2 gradient = vec2(COLOR_CONVERT_DISPLACEMENT(texture2D(SAMPLER_DISPLACEMENT, UV_DISPLACEMENT - invSize.xz).PACK_DISPLACEMENT)\n                        - COLOR_CONVERT_DISPLACEMENT(texture2D(SAMPLER_DISPLACEMENT, UV_DISPLACEMENT + invSize.xz).PACK_DISPLACEMENT),\n                        COLOR_CONVERT_DISPLACEMENT(texture2D(SAMPLER_DISPLACEMENT, UV_DISPLACEMENT - invSize.zy).PACK_DISPLACEMENT)\n                        -COLOR_CONVERT_DISPLACEMENT(texture2D(SAMPLER_DISPLACEMENT, UV_DISPLACEMENT + invSize.zy).PACK_DISPLACEMENT));\n\n    localNormal = bumpMap(localTangent, localNormal, uDisplacementNormal * gradient);\n\n    #if defined(HAS_VIEW_NORMAL)\n        vModelNormal = uModelNormalMatrix * localNormal;\n    #endif\n\n    #ifdef HAS_VIEW_NORMAL\n        vViewNormal = uModelViewNormalMatrix * localNormal;\n    #endif\n#endif\n\n    ///////////////////////\n    // PROJECTION JITTERING (could be done on the CPU)\n    ///////////////////////\n    mat4 jitteredProjection = uProjectionMatrix;\n#if defined(WIREFRAME)\n    vViewVertex.w += 0.005 / uProjectionMatrix[1][1];\n#elif defined(SHADOW_CAST)\n    float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;\n    vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);\n    jitteredProjection[2].xy += doPersp * jitter;\n    jitteredProjection[3].xy += (1.0 - doPersp) * jitter;\n#elif !defined(NO_JITTER)\n    jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);\n#endif\n\n    #ifdef HAS_POLYGON_OFFSET\n        vViewVertex.z -= vViewVertex.z *  0.001;\n    #endif\n\n    gl_Position = jitteredProjection * vViewVertex;\n\n#ifdef HAS_POINT_SIZE\n    gl_PointSize = min(64.0, max(1.0, -uPointSize / vViewVertex.z));\n#else\n    gl_PointSize = 1.0;\n#endif\n\n// probably not the best solution (in case you need custom things while including base.vert)\n#ifdef INJECT_VERT\n    INJECT_VERT\n#endif\n}\n'
        },
        Aakz: e => {
            e.exports = 'uniform float uRGBMRange;\n\nvarying vec3 vViewNormal;\n\n#pragma include "utils/functions.glsl"\n\nvoid main(void) {\n   gl_FragColor = encodeRGBM(0.5 * vec3(abs(dot(vViewNormal.xyz, vec3(0.3, 0.6, 0.9)))), uRGBMRange);\n}\n'
        },
        "0Vir": e => {
            e.exports = '#define HAS_VIEW_NORMAL\n#pragma include "base.vert"\n'
        },
        mROa: e => {
            e.exports = "uniform vec3 uColorDebug;\n\nvoid main(void) {\n   gl_FragColor = vec4(uColorDebug, 1.0);\n}\n"
        },
        t7Q4: e => {
            e.exports = '#define NO_JITTER\n#pragma include "base.vert"\n'
        },
        AYWJ: e => {
            e.exports = "uniform vec3 uColorDebug;\n\nvoid main(void) {\n   gl_FragColor = vec4(uColorDebug, 1.0);\n}\n"
        },
        M9k7: e => {
            e.exports = 'attribute float Offset;\nuniform float uScale;\n\n#define HAS_MODEL_VERTEX\n#define HAS_MODEL_NORMAL\n\n#define INJECT_VERT gl_Position = uProjectionMatrix * uViewMatrix * vec4(Offset == 1.0 ? vModelVertex + normalize(vModelNormal) * uScale : vModelVertex, 1.0);\n\n#pragma include "base.vert"\n'
        },
        YpwI: e => {
            e.exports = "varying vec3 vBonesColor;\n\nvoid main(void) {\n   gl_FragColor = vec4(vBonesColor, 1.0);\n}\n"
        },
        PQ9b: e => {
            e.exports = 'attribute vec3 BonesColor;\nvarying vec3 vBonesColor;\n\n#define NO_JITTER\n#define INJECT_VERT vBonesColor = BonesColor;\n\n#pragma include "base.vert"\n'
        },
        "Lzt+": e => {
            e.exports = "uniform vec3 uColorDebug;\n\nvoid main(void) {\n   gl_FragColor = vec4(uColorDebug, 1.0);\n}\n"
        },
        "5oZM": e => {
            e.exports = 'attribute float Offset;\nuniform float uScale;\n\n#define HAS_MODEL_VERTEX\n#define HAS_MODEL_TANGENT\n\n#define INJECT_VERT gl_Position = uProjectionMatrix * uViewMatrix * vec4(Offset == 1.0 ? vModelVertex + normalize(vModelTangent) * uScale : vModelVertex, 1.0);\n\n#pragma include "base.vert"\n'
        },
        "1BmB": e => {
            e.exports = '// opacity\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform int uDrawOpaque;\n\nvarying vec4 vViewVertex;\n\n#pragma include "utils/encodeDepth.glsl"\n\n#pragma include "utils/material.glsl"\n\n#ifdef HAS_OPACITY\n#pragma include "utils/rand.glsl"\n#endif\n\nvoid main() {\n#ifdef HAS_DISCARD_OOTB_PIXELS\n    if(vTexCoord0.x > 1.0 || vTexCoord0.x < 0.0 || vTexCoord0.y > 1.0 ||vTexCoord0.y < 0.0) discard;\n#endif\n\n#ifdef HAS_POINT_CIRCLE\n    if (length(2.0 * gl_PointCoord - 1.0) > 1.0) discard;\n#endif\n\n\n#ifdef HAS_ALPHAMASK\n    if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n#endif\n#ifdef HAS_OPACITY_DITHER\n    ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n#endif\n\n    float alpha = 1.0;\n#if defined(HAS_OPACITY_BLEND_OR_ADDITIVE) || defined(HAS_OPACITY_REFRACTION)\n    alpha = getMaterialOpacity();\n    if (uDrawOpaque == 1 && alpha < EPSILON_ALPHA) discard;\n    alpha = uDrawOpaque == 1 ? 1.0 : alpha;\n#endif\n\n    float depth = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);\n    float scatter = 0.0;\n    float profile = 0.0;\n\n#ifdef HAS_SUBSURFACESCATTERING\n    scatter = getMaterialScattering();\n    profile = uSubsurfaceScatteringProfile;\n#endif\n\n    gl_FragColor = encodeDepthAlphaProfileScatter(depth, alpha, profile, scatter);\n}\n'
        },
        urqr: e => {
            e.exports = '#define HAS_VIEW_VERTEX\n#pragma include "base.vert"\n'
        },
        xERb: e => {
            e.exports = '#pragma include "utils/encodeDecode.glsl"\n\n// opacity\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform int uDrawOpaque;\n\n#pragma include "utils/material.glsl"\n#ifdef HAS_OPACITY\n#pragma include "utils/rand.glsl"\n#endif\n\nvoid main(void) {\n\n    #ifdef HAS_ALPHAMASK\n        if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n    #endif\n    #ifdef HAS_OPACITY_DITHER\n        ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n    #endif\n\n    #if defined(HAS_OPACITY_BLEND_OR_ADDITIVE) || defined(HAS_OPACITY_REFRACTION)\n        if (getMaterialOpacity() < EPSILON_ALPHA) discard;\n    #endif\n\n    // Depth in clip space\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    gl_FragColor.rgb = encode24(depth);\n    gl_FragColor.a = 1.0;\n\n}\n'
        },
        WHiR: e => {
            e.exports = '#pragma include "base.vert"\n'
        },
        "zG+0": e => {
            e.exports = '#pragma include "utils/encodeDepth.glsl"\nuniform vec2 uNearFar;\nvarying vec4 vViewVertex;\n\nuniform float uGroundFade;\nuniform float uGroundOpacity;\nuniform float uChanging;\n\nvarying vec2 vTexCoord0;\n\n#ifdef PASS_THROUGH\n    float getShadow(){\n       return 1.0;\n    }\n#endif\n\n#ifdef SHADOW_CATCHER\n\n    varying vec3 vModelNormal;\n    varying vec3 vModelVertex;\n\n    #define OPT_DISTANCE\n    #pragma include "shadowing/shadowReceive.glsl"\n\n    #pragma include "utils/getLuminance.glsl"\n\n    %UNROLL 4%\n    #ifdef LIGHT_TYPE_%ID%\n        uniform vec4 utestdemo2024Light%ID%_diffuse;\n    #endif\n    %%\n\n\n    float getShadow(){\n        float shadow = 0.0;\n        vec3 modelNormal = normalize(gl_FrontFacing ? vModelNormal : -vModelNormal);\n        bool lighted = true;\n\n        float weight;\n        float sumWeights = 0.0;\n\n        %UNROLL 4%\n        #ifdef LIGHT_TYPE_%ID%\n            #ifdef HAS_SHADOW_%ID%\n                weight = getLuminance(utestdemo2024Light%ID%_diffuse.rgb);\n                #ifdef _ATLAS_SHADOW\n                    shadow += weight * shadowReceive(lighted, modelNormal, vModelVertex, Texture7, uShadow_Texture0_renderSize, uShadow_Texture%ID%_projection, uShadow_Texture%ID%_viewRight, uShadow_Texture%ID%_viewUp, uShadow_Texture%ID%_viewLook, uShadow_Texture%ID%_depthRange, uShadowReceive%ID%_bias, uShadow_Texture%ID%_mapSize, OPT_DISTANCE uStaticFrameNumShadow%ID%);\n                #else\n                    shadow += weight * shadowReceive(lighted, modelNormal, vModelVertex, TEX_SHADOW_%ID%, uShadow_Texture%ID%_renderSize, uShadow_Texture%ID%_projection, uShadow_Texture%ID%_viewRight, uShadow_Texture%ID%_viewUp, uShadow_Texture%ID%_viewLook, uShadow_Texture%ID%_depthRange, uShadowReceive%ID%_bias, OPT_DISTANCE uStaticFrameNumShadow%ID%);\n                #endif // _ATLAS_SHADOW\n                sumWeights += weight;\n            #endif // HAS_SHADOW\n        #endif // LIGHT_TYPE\n        %%\n\n        #ifdef HAS_SHADOW\n            shadow /= sumWeights;\n        #else\n            shadow = 1.0;\n        #endif\n\n        return shadow;\n    }\n#endif\n\n#ifdef BAKED_AO\n    #pragma include "utils/encodeDecode.glsl"\n    uniform sampler2D uTexture;\n\n    float getShadow(){\n        return decode24(texture2D(uTexture, vTexCoord0).rgb);\n    }\n#endif\n\n#ifdef DISPLAY_PLANE\n    const float gridSize = 10.0;\n    const vec4 overlayColor = vec4(0.109,0.664,0.848,1.0);\n#endif\n\nuniform float uWidgetFade;\n\nvoid main() {\n    float shadow = getShadow();\n    #ifndef DISPLAY_PLANE\n\t    if (shadow >= 0.99) discard;\n    #endif\n    vec2 centerUV = vTexCoord0 * 2.0 - 1.0;\n    float fade = clamp(1.0 - dot(centerUV, centerUV) * (pow(10.0, uGroundFade) - 1.0) , 0.0, 1.0);\n\n    float alpha = (1.0 - shadow) * uGroundOpacity * fade;\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * uGroundOpacity * fade * alpha;\n\n\n    #ifdef DISPLAY_PLANE\n        float gridValue = clamp(step(0.03,fract(vTexCoord0.x * gridSize))\n            * step(0.03,fract(vTexCoord0.y * gridSize)),0.0,1.0)\n            * step(vTexCoord0.x,0.997)\n            * step(vTexCoord0.y,0.997);\n\n        gl_FragColor = mix(overlayColor * fade, gl_FragColor, uWidgetFade) * vec4(gridValue,gridValue,gridValue,1.0);\n    #endif\n\n}\n'
        },
        Rh6r: e => {
            e.exports = '#pragma include "base.vert"\n'
        },
        "G+Dx": e => {
            e.exports = 'uniform float uRGBMRange;\nuniform int uOutputLinear;\n\n// stuffs (ssr, opacity, scattering)\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform float uTimeViewer;\nuniform int uDrawOpaque;\n\nuniform float uDisplay2D;\nuniform int uInspectorView; // see globalUniforms\n\nuniform float uInspectorFactor;\nuniform int uInspectorInvert;\nuniform float uInspectorMaskThreshold;\nuniform vec3 uInspectorColor;\n\nuniform vec2 uHoverUV;\nuniform int uInspectorSelected;\nuniform int uInspectorWireframe;\n\nfloat pattern(vec2 uv){\n    uv -= 0.5 + uTimeViewer * 3.0;\n    uv *= 15.0;\n    uv.x *= sign(cos(length(ceil(uv)) * 0.1));\n    return cos(min(length(uv = fract(uv)),length(--uv)) * 44.0);\n}\n\n#ifdef FEEDBACK_UV\n    vec3 colorHoverUV(const in vec3 frag) {\n        if (uInspectorSelected == 0) return frag;\n        return mix(vec3(1.0, 0.0, 0.0), frag, smoothstep(0.01, 0.02, distance(FEEDBACK_UV, uHoverUV) / gl_FragCoord.z));\n    }\n#endif\n\n#pragma include "utils/functions.glsl"\n#pragma include "utils/material.glsl"\n#pragma include "utils/rand.glsl"\n\nvoid main() {\n    //////////////////\n    // OPACITY DISCARD\n    //////////////////\n#ifdef HAS_POINT_CIRCLE\n    if (length(2.0 * gl_PointCoord - 1.0) > 1.0) discard;\n#endif\n\n#ifdef HAS_ALPHAMASK\n    if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n#endif\n#ifdef HAS_OPACITY_DITHER\n    if (uDisplay2D == 0.0) ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n#endif\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    float alpha = 1.0;\n    float alphaFinal = 1.0;\n\n    if (uDisplay2D == 0.0) {\n        alpha = getMaterialOpacity();\n        alphaFinal = alpha * float(1 - uOpacityAdditive);\n    }\n\n    if (alpha == 0.0 || (uDrawOpaque == 1 && alphaFinal < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaFinal >= EPSILON_ALPHA)) discard;\n#endif\n\n    ///////////\n    // MATERIAL\n    ///////////\n    vec3 frag = vec3(0.0);\n#ifdef HAS_INSPECTOR\n    frag = uInspectorFactor * COLOR_CONVERT_INSPECTOR(texture2D(SAMPLER_INSPECTOR, UV_INSPECTOR).PACK_INSPECTOR);\n    if (uInspectorInvert == 1) frag = 1.0 - frag;\n\n    if (uInspectorMaskThreshold > 0.0 && uDisplay2D == 0.0) frag = frag.x < uInspectorMaskThreshold ? vec3(0.0) : vec3(1.0);\n\n    #ifdef HAS_VERTEX_COLOR\n        #ifdef HAS_VERTEX_ALPHA\n            frag *= getVertexColor();\n        #else\n            frag *= uInspectorView == 1 ? sRGBToLinear(vColor.aaa) : getVertexColor();\n        #endif\n    #endif\n\n    // we want to display the linear textures as srgb textures, see comment in channelFactoryViewModel\n    #ifdef CONVERT_INSPECTOR_TO_LINEAR\n        frag = sRGBToLinear(frag);\n    #endif\n\n    #ifdef HAS_INSPECTOR_TEXTURE\n        frag *= uInspectorColor;\n    #endif\n\n    frag = colorHoverUV(frag);\n#endif\n\n    // premult\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    frag *= alpha;\n#endif\n\n    if (uOutputLinear != 1) frag = linearTosRGB(frag);\n\n    if (uDisplay2D == 1.0) {\n        #if defined(HAS_INSPECTOR) && defined(DISPLAY_WATERMARK)\n            float w = 0.08 - float(pattern(UV_INSPECTOR)) * 0.08;            \n            vec3 fragColor2 =  COLOR_CONVERT_INSPECTOR(texture2D(SAMPLER_INSPECTOR, UV_INSPECTOR, 2.5).PACK_INSPECTOR);\n            float d = smoothstep(length(UV_INSPECTOR - uHoverUV), 0.0, 0.15);\n            frag = frag * (1.0 - d) + fragColor2.ggg * d *0.75 + w * d + w * 0.1;\n        #endif \n        gl_FragColor = vec4(frag, 1.0);\n        return;\n    }\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    gl_FragColor = uDrawOpaque == 1 ? encodeRGBM(frag, uRGBMRange) : vec4(frag, alphaFinal);\n#else\n    gl_FragColor = encodeRGBM(frag, uRGBMRange);\n#endif\n}\n'
        },
        "rz9/": e => {
            e.exports = '#pragma include "base.vert"\n'
        },
        "8Ftk": e => {
            e.exports = 'uniform float uRGBMRange;\nuniform int uOutputLinear;\n\n// stuffs (ssr, opacity, scattering)\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform int uDrawOpaque;\n\nuniform vec3 uMatcapColor;\n\nuniform int uInspectorView; // see globalUniforms\n\n//////////\n// VARYING\n//////////\nvarying vec4 vViewVertex;\nvarying vec3 vViewNormal;\n\n#ifdef HAS_VIEW_TANGENT\nvarying vec4 vViewTangent;\n#endif\n\n#pragma include "utils/common.glsl"\n\n#pragma include "utils/functions.glsl"\n\n#pragma include "utils/material.glsl"\n\n#pragma include "utils/curvature.glsl"\n\n// TODO ifdef around pragma include can result in error (files being included multiple times can be ignored)\n#pragma include "utils/decodeDepth.glsl"\n\n#pragma include "utils/rand.glsl"\n\n#ifdef HAS_VIEW_TANGENT\n#pragma include "utils/normalBump.glsl"\n#endif\n\n#ifdef HAS_OPACITY_REFRACTION\n#pragma include "utils/refraction.glsl"\n#endif\n\nvoid main() {\n    //////////////////\n    // OPACITY DISCARD\n    //////////////////\n#ifdef HAS_POINT_CIRCLE\n    if (length(2.0 * gl_PointCoord - 1.0) > 1.0) discard;\n#endif\n\n#ifdef HAS_ALPHAMASK\n    if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n#endif\n#ifdef HAS_OPACITY_DITHER\n    ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n#endif\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    float alpha = getMaterialOpacity();\n    float alphaFinal = alpha * float(1 - uOpacityAdditive);\n    if (alpha == 0.0 || (uDrawOpaque == 1 && alphaFinal < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaFinal >= EPSILON_ALPHA)) discard;\n#endif\n\n// /!\\ because of refraction roughness, this part should be done before the call to getMetalness/getSpecular\n#ifdef HAS_OPACITY_REFRACTION\n    gRefractionRoughness = uOpacityRoughnessFactor;\n    float alphaRefraction = getMaterialOpacity();\n    if ((uDrawOpaque == 1 && alphaRefraction < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaRefraction >= EPSILON_ALPHA)) discard;\n#endif\n\n    ///////////\n    // GEOMETRY\n    ///////////\n    vec3 eyeVector = -normalize(vViewVertex.xyz);\n    vec3 frontNormal = normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);\n\n#ifdef HAS_VIEW_TANGENT\n    vec4 tangent = gl_FrontFacing ? vViewTangent : -vViewTangent;\n    tangent.xyz = normalize(tangent.xyz);\n    vec3 binormal = normalize(cross(frontNormal, tangent.xyz)) * tangent.w;\n#endif\n\n    ///////////\n    // MATERIAL\n    ///////////\n    vec3 materialNormal = frontNormal;\n#ifdef HAS_NORMALMAP\n    materialNormal = getMaterialNormalMap();\n    materialNormal = transformNormal(uNormalMapFactor, materialNormal, tangent.xyz, binormal, frontNormal);\n#endif\n\n#ifdef HAS_BUMPMAP\n    materialNormal = transformBump(getMaterialBumpMap(), tangent.xyz, binormal, frontNormal);\n#endif\n\n    vec3 materialDiffuse = uMatcapColor;\n#ifdef HAS_VERTEX_COLOR\n    materialDiffuse *= getVertexColor();\n#endif\n\n    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);\n    vec3 nm_y = cross(nm_x, eyeVector);\n    vec2 uvMatcap = vec2(dot(materialNormal.xz, -nm_x.xz), dot(materialNormal, nm_y)) * 0.5 + 0.5;\n    vec3 diffuse = materialDiffuse * sRGBToLinear(texture2D(SAMPLER_MATCAP, uvMatcap).rgb) * getCurvature(materialNormal);\n\n    /////////////\n    // REFRACTION\n    /////////////\n#ifdef HAS_OPACITY_REFRACTION\n\n#ifdef HAS_REFRACTION_NORMAL_OFFSET\n    vec3 refractLight = refraction(uOpacityRoughnessFactor, materialNormal, frontNormal, eyeVector.xyz);\n#else\n    vec3 refractLight = refraction(uOpacityRoughnessFactor, materialNormal, eyeVector);\n#endif\n\n#ifdef HAS_REFRACTION_ALBEDO_TINT\n    refractLight *= materialDiffuse;\n#endif\n\n    diffuse = mix(refractLight, diffuse, alphaRefraction);\n#endif // HAS_OPACITY_REFRACTION\n\n    vec3 frag = diffuse;\n\n    if (uInspectorView == 2) {\n        frag = vec3(0.9, 0.75, 0.5) * max(0.25, dot(materialNormal.xyz, vec3(0.15, 0.3, 0.9)));\n    }\n\n// premult\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    frag *= alpha;\n#endif\n\n    if (uOutputLinear != 1) frag = linearTosRGB(frag);\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    gl_FragColor = uDrawOpaque == 1 ? encodeRGBM(frag, uRGBMRange) : vec4(frag, alphaFinal);\n#else\n    gl_FragColor = encodeRGBM(frag, uRGBMRange);\n#endif\n}\n'
        },
        "FAG/": e => {
            e.exports = '#define HAS_VIEW_NORMAL\n#define HAS_VIEW_VERTEX\n#pragma include "base.vert"\n'
        },
        "3rnw": e => {
            e.exports = "uniform vec3 uOutlineColor;\n\nvoid main() {\n#ifdef HAS_POINT_CIRCLE\n    if (length(2.0 * gl_PointCoord - 1.0) > 1.0) discard;\n#endif\n\n    gl_FragColor = vec4(uOutlineColor, 1.0);\n}\n"
        },
        sIqN: e => {
            e.exports = '#define NO_JITTER 1\n#pragma include "base.vert"\n'
        },
        "8M0R": e => {
            e.exports = 'uniform float uRGBMRange;\nuniform int uOutputLinear;\n\n// stuffs (ssr, opacity, scattering)\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform int uDrawOpaque;\n\n// shadow signature...\n#ifdef HAS_SUBSURFACETRANSLUCENCY\n    #define _OUT_DISTANCE\n    #define OPT_DISTANCE shadowDistance,\n#else\n    #define OPT_DISTANCE\n#endif\n\n//////////\n// VARYING\n//////////\nvarying vec4 vViewVertex;\nvarying vec3 vViewNormal;\n\n#ifdef HAS_SHADOW\n    varying vec3 vModelNormal;\n    varying vec3 vModelVertex;\n#endif\n\n#ifdef HAS_VIEW_TANGENT\n    varying vec4 vViewTangent;\n#endif\n\n#pragma include "utils/common.glsl"\n\n#pragma include "utils/functions.glsl"\n\n#pragma include "utils/material.glsl"\n\n// TODO ifdef around pragma include can result in error (files being included multiple times can be ignored)\n#pragma include "utils/decodeDepth.glsl"\n\n#pragma include "utils/rand.glsl"\n\n#if defined(HAS_NORMALMAP) || defined(HAS_BUMPMAP) || defined(HAS_CLEARCOATNORMALMAP) || defined(SAMPLER_ANISOTROPY)\n#pragma include "utils/normalBump.glsl"\n#endif\n\n#ifdef HAS_SHADOW\n#pragma include "shadowing/shadowReceive.glsl"\n#endif\n\n// /!\\ (lightsPBR is also included in clearcoat file, and ifdef around pragma include is not reliable)\n#if defined(HAS_LIGHT) || defined(HAS_CLEARCOAT) || defined(HAS_SHEEN)\n#pragma include "utils/lightsPBR.glsl"\n#endif\n\n#ifdef HAS_ENVIRONMENT\n#pragma include "utils/environment.glsl"\n#endif\n\n#ifdef HAS_SUBSURFACETRANSLUCENCY\n#pragma include "utils/lightsSSS.glsl"\n#endif\n\n#ifdef HAS_SUBSURFACESCATTERING\n#pragma include "utils/checkerboard.glsl"\n#endif\n\n#ifdef HAS_CLEARCOAT\n#pragma include "utils/clearCoat.glsl"\n#endif\n\n// #ifdef HAS_OPACITY_DITHER\n// #pragma include "utils/rand.glsl"\n// #endif\n\n#ifdef HAS_OPACITY_REFRACTION\n#pragma include "utils/refraction.glsl"\n#endif\n\n#ifdef HAS_SSR\n#pragma include "utils/ssr.glsl"\n#endif\n\nfloat specularOcclusion(const in int occlude, const in float ao, const in vec3 normal, const in vec3 eyeVector) {\n    if (occlude == 0) return 1.0;\n    // Yoshiharu Gotanda\'s specular occlusion approximation:\n    // cf http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx pg59\n    float d = dot(normal, eyeVector) + ao;\n    return clamp((d * d) - 1.0 + ao, 0.0, 1.0);\n}\n\nfloat adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {\n    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)\n    float nlen2 = dot(normal, normal);\n    if (nlen2 < 1.0) {\n        float nlen = sqrt(nlen2);\n        float kappa = (3.0 * nlen -  nlen2 * nlen) / (1.0 - nlen2);\n        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/\n        // page 91 : they use 0.5/kappa instead\n        return min(1.0, sqrt(roughness * roughness + 1.0 / kappa));\n    }\n    return roughness;\n}\n\nvec3 computeAnisotropicBentNormal(const in vec3 normal, const in vec3 eyeVector, const in float roughness, const in vec3 anisotropicT, const in vec3 anisotropicB, const in float anisotropy) {\n    vec3 anisotropyDirection = anisotropy >= 0.0 ? anisotropicB : anisotropicT;\n    vec3 anisotropicTangent = cross(anisotropyDirection, eyeVector);\n    vec3 anisotropicNormal = cross(anisotropicTangent, anisotropyDirection);\n    float bendFactor = abs(anisotropy) * clamp(5.0 * roughness, 0.0, 1.0);\n    return normalize(mix(normal, anisotropicNormal, bendFactor));\n}\n\nvoid main() {\n\n#ifdef HAS_DISCARD_OOTB_PIXELS\n      if(vTexCoord0.x > 1.0 || vTexCoord0.x < 0.0 || vTexCoord0.y > 1.0 ||vTexCoord0.y < 0.0) discard;\n#endif\n\n    //////////////////\n    // OPACITY DISCARD\n    //////////////////\n#ifdef HAS_POINT_CIRCLE\n    if (length(2.0 * gl_PointCoord - 1.0) > 1.0) discard;\n#endif\n\n#ifdef HAS_ALPHAMASK\n    if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n#endif\n#ifdef HAS_OPACITY_DITHER\n    ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n#endif\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    float alpha = getMaterialOpacity();\n    float alphaFinal = alpha * float(1 - uOpacityAdditive);\n    if (alpha == 0.0 || (uDrawOpaque == 1 && alphaFinal < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaFinal >= EPSILON_ALPHA)) discard;\n#endif\n\n    // /!\\ because of refraction roughness, this part should be done before the call to getMetalness/getSpecular\n#ifdef HAS_OPACITY_REFRACTION\n    gRefractionRoughness = uOpacityRoughnessFactor;\n    float alphaRefraction = getMaterialOpacity();\n    if ((uDrawOpaque == 1 && alphaRefraction < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaRefraction >= EPSILON_ALPHA)) discard;\n#endif\n\n    ///////////\n    // GEOMETRY\n    ///////////\n    // https://twitter.com/pyalot/status/711956736639418369\n    vec3 eyeVector = -normalize(vViewVertex.xyz);\n    vec3 frontNormal = normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);\n\n#ifdef HAS_VIEW_TANGENT\n    vec4 tangent;\n    tangent = vViewTangent;\n\n    tangent = gl_FrontFacing ? tangent : -tangent;\n    tangent.xyz = normalize(tangent.xyz);\n    vec3 binormal = normalize(cross(frontNormal, tangent.xyz)) * tangent.w;\n#elif  HAS_NORMALMAP && COMPUTE_FRAGMENT_TANGENTS\n    vec4 tangent; \n    vec3 binormal;\n    makeTBN(tangent, binormal, vViewNormal, vViewVertex.xyz, vTexCoord0);\n#endif\n\n    ///////////\n    // MATERIAL\n    ///////////\n#if defined(HAS_LEGACY_CLASSIC)\n    vec3 materialDiffuse = getMaterialLegacyDiffuse();\n    vec3 materialSpecular = getMaterialLegacySpecular();\n#elif defined(HAS_METALNESSPBR)\n    float f0 = 0.08 * getMaterialF0();\n    float metal = getMaterialMetalness();\n\n    #ifdef HAS_OPACITY_REFRACTION\n        metal *= alphaRefraction;\n    #endif\n\n    vec3 materialDiffuse = getMaterialAlbedo();\n    vec3 materialSpecular = mix(vec3(f0), materialDiffuse, metal);\n    materialDiffuse *= 1.0 - metal;\n#else\n    vec3 materialSpecular = getMaterialSpecular();\n    vec3 materialDiffuse = getMaterialDiffuse();\n\n    #ifdef HAS_OPACITY_REFRACTION\n        materialSpecular *= mix(0.08, 1.0, alphaRefraction);\n    #endif\n#endif // HAS_METALNESSPBR\n\n#if defined(HAS_ENVIRONMENT) || defined(HAS_LIGHT)\n    float materialF90 = clamp(50.0 * materialSpecular.g, 0.0, 1.0);\n#endif\n\n#if defined(HAS_LEGACY_CLASSIC)\n    float materialShininess = getMaterialLegacyShininess();\n    float materialRoughness = 0.0;\n#elif defined(HAS_ROUGHNESSPBR)\n    float materialRoughness = getMaterialRoughness();\n#else\n    float materialRoughness = 1.0 - getMaterialGlossiness();\n#endif // HAS_ROUGHNESSPBR\n\n#ifdef HAS_AOPBR\n    float materialAO = getMaterialAO();\n#endif\n\n#ifdef HAS_EMITCOLOR\n    vec3 materialEmit = getMaterialEmitColor();\n#endif\n\n#ifdef HAS_CAVITYPBR\n    float materialCavity = getMaterialCavity();\n#endif\n\n#ifdef HAS_SUBSURFACETRANSLUCENCY\n    float materialTranslucency = getMaterialTranslucency();\n#endif\n\n    vec3 materialNormal = frontNormal;\n#ifdef HAS_NORMALMAP\n    materialNormal = getMaterialNormalMap();\n    materialRoughness = adjustRoughnessNormalMap(materialRoughness, materialNormal);\n    materialNormal = transformNormal(uNormalMapFactor, materialNormal, tangent.xyz, binormal, frontNormal);\n#endif\n\n#ifdef HAS_BUMPMAP\n    materialNormal = transformBump(getMaterialBumpMap(), tangent.xyz, binormal, frontNormal);\n#endif\n\n#ifdef HAS_CLEARCOAT\n    float materialClearCoat = getMaterialClearCoat();\n    float materialClearCoatRoughness = getMaterialClearCoatRoughness();\n    #ifdef HAS_CLEARCOATNORMALMAP\n        vec3 materialClearCoatNormal = transformNormal(uClearCoatNormalMapFactor, getMaterialClearCoatNormal(), tangent.xyz, binormal, frontNormal);\n    #else\n        vec3 materialClearCoatNormal = frontNormal;\n    #endif\n#endif\n\n#if defined(HAS_ANISOTROPY) && (defined(HAS_LIGHT) || defined(HAS_ENVIRONMENT))\n    float anisotropy = uAnisotropyFactor;\n\n    #ifdef SAMPLER_ANISOTROPY\n        vec2 aniso = getMaterialDirectionAnisotropy();\n        vec3 anisotropicT = transformTangent(aniso, tangent.xyz, binormal);\n        // reproject tangent/binormal on the material normal plane\n        anisotropicT = normalize(anisotropicT - materialNormal * dot(anisotropicT, materialNormal));\n        vec3 anisotropicB = normalize(cross(materialNormal, anisotropicT.xyz));\n\n        anisotropy *= length(aniso);\n    #else\n        #if defined(HAS_NORMALMAP) || defined(HAS_BUMPMAP)\n            // reproject tangent/binormal on the material normal plane\n            tangent.xyz = normalize(tangent.xyz - materialNormal * dot(tangent.xyz, materialNormal));\n            binormal = normalize(cross(materialNormal, tangent.xyz)) * tangent.w;\n        #endif\n\n        vec3 anisotropicT = normalize(mix(tangent.xyz, binormal, uAnisotropyDirection));\n        vec3 anisotropicB = normalize(mix(binormal, -tangent.xyz, uAnisotropyDirection));\n    #endif\n#endif\n\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n\n#if  (defined(HAS_ENVIRONMENT) || defined(HAS_LIGHT))\n    #if defined(HAS_CLEARCOAT)\n        float ccNoV = saturate(dot(materialClearCoatNormal, -refract(eyeVector, materialClearCoatNormal, 1.0 / uClearCoatIor)));\n    #endif\n    #if defined(HAS_SHEEN)\n        float sheenRoughness = getMaterialSheenRoughness();\n    #endif\n#endif\n    //////////////\n    // ENVIRONMENT\n    //////////////\n#ifdef HAS_ENVIRONMENT\n\n    #ifdef HAS_ANISOTROPY\n        vec3 bentAnisotropicNormal = computeAnisotropicBentNormal(materialNormal, eyeVector, materialRoughness, anisotropicT, anisotropicB, anisotropy);\n    #else\n        vec3 bentAnisotropicNormal = materialNormal;\n    #endif\n\n\n    diffuse = materialDiffuse * computeDiffuseSPH(materialNormal);\n\n    #ifdef HAS_SHEEN\n    diffuse += computeSheen(materialNormal, getSpecularDominantDir(materialNormal, reflect(-eyeVector, materialNormal), sheenRoughness), eyeVector, sheenRoughness);\n    #endif\n\n    #ifdef HAS_LEGACY_CLASSIC\n        specular = materialSpecular * textureCubeFixed(sEnvironmentSpecular, uEnvironmentTransform * normalize((2.0 * clamp(dot(materialNormal, eyeVector), 0.0, 1.0)) * materialNormal - eyeVector), uTextureEnvironmentSpecularTextureSize.x);\n    #else\n        specular = computeIBLSpecularUE4(bentAnisotropicNormal, eyeVector, materialRoughness, materialSpecular, frontNormal, materialF90);\n    #endif\n\n    #ifdef HAS_CLEARCOAT\n        float ccF0 = materialClearCoat * F_Schlick(uClearCoatF0, 1.0, ccNoV);\n        vec3 ccAbsorbtion = getClearCoatAbsorbtion(ccNoV, ccNoV, materialClearCoat);\n        specular = mix(specular * ccAbsorbtion, getPrefilteredEnvMapColor(materialClearCoatNormal, eyeVector, materialClearCoatRoughness, frontNormal), ccF0);\n        diffuse *= ccAbsorbtion * (1.0 - ccF0);\n    #endif\n\n    float aoSpec = 1.0;\n    #ifdef HAS_LEGACY_CLASSIC\n        aoSpec = uReflection;\n        specular *= aoSpec;\n    #endif\n\n    #ifdef HAS_AOPBR\n        diffuse *= uEnvironmentExposure * materialAO;\n        aoSpec = specularOcclusion(uAOPBROccludeSpecular, materialAO, materialNormal, eyeVector);\n        specular *= uEnvironmentExposure * aoSpec;\n    #else\n        diffuse *= uEnvironmentExposure;\n        specular *= uEnvironmentExposure;\n    #endif // HAS_AOPBR\n\n    #ifdef HAS_SSR\n        #ifdef HAS_CLEARCOAT\n            vec3 normalSsr = normalize(mix(bentAnisotropicNormal, materialClearCoatNormal, materialClearCoat * 0.5));\n            float roughnessSsr = mix(materialRoughness, materialClearCoatRoughness, materialClearCoat);\n            vec3 specularSsr = aoSpec * materialSpecular * mix(vec3(1.0), ccAbsorbtion, materialClearCoat);\n            specular = ssr(specular, specularSsr, roughnessSsr, normalSsr, eyeVector);\n        #else\n            specular = ssr(specular, materialSpecular * aoSpec, materialRoughness, bentAnisotropicNormal, eyeVector);\n        #endif\n    #endif // HAS_SSR\n#endif // HAS_ENVIRONMENT\n\n    /////////////////////////\n    // LIGHTING AND SHADOWING\n    /////////////////////////\n#ifdef HAS_LIGHT\n    float attenuation, dotNL;\n    vec3 eyeLightDir;\n    bool lighted;\n    vec3 lightSpecular;\n    vec3 lightDiffuse;\n    vec4 prepGGX = precomputeGGX(materialNormal, eyeVector, max(MIN_ROUGHNESS, materialRoughness));\n\n    #ifdef HAS_CLEARCOAT\n        vec4 prepGGXClearCoat = precomputeGGX(materialClearCoatNormal, eyeVector, materialClearCoatRoughness);\n        vec3 ccSpecular;\n        vec3 ccAttenuation;\n    #endif\n#endif\n\n#ifdef HAS_SHADOW\n    float shadow;\n    vec3 modelNormal = normalize(gl_FrontFacing ? vModelNormal : -vModelNormal);\n\n    #ifdef HAS_SUBSURFACETRANSLUCENCY\n        float shadowDistance;\n    #endif\n#endif // HAS_SHADOW\n\n\n%UNROLL 4%\n#ifdef LIGHT_TYPE_%ID%\n\n    #if LIGHT_TYPE_%ID% == LIGHT_SPOT\n        precomputeSpot(materialNormal, vViewVertex.xyz, utestdemo2024Light%ID%_viewDirection, utestdemo2024Light%ID%_attenuation, utestdemo2024Light%ID%_viewPosition.xyz, utestdemo2024Light%ID%_spotCutOff, utestdemo2024Light%ID%_spotBlend, attenuation, eyeLightDir, dotNL);\n    #elif LIGHT_TYPE_%ID% == LIGHT_POINT\n        precomputePoint(materialNormal, vViewVertex.xyz, utestdemo2024Light%ID%_attenuation, utestdemo2024Light%ID%_viewPosition.xyz, attenuation, eyeLightDir, dotNL);\n    #elif LIGHT_TYPE_%ID% == LIGHT_DIRECTION\n        precomputeSun(materialNormal, utestdemo2024Light%ID%_viewDirection, attenuation, eyeLightDir, dotNL);\n    #elif LIGHT_TYPE_%ID% == LIGHT_HEMI\n        precomputeSun(materialNormal, utestdemo2024Light%ID%_viewDirection, attenuation, eyeLightDir, dotNL);\n    #endif\n\n    #ifdef HAS_LEGACY_CLASSIC\n        #if LIGHT_TYPE_%ID% == LIGHT_HEMI\n            hemiLight(materialNormal, eyeVector, dotNL, eyeLightDir, materialDiffuse, materialSpecular, materialShininess, utestdemo2024Light%ID%_diffuse.rgb, utestdemo2024Light%ID%_ground.rgb, lightDiffuse, lightSpecular, lighted);\n        #else\n            computeLightLambertCookTorrance(materialNormal, eyeVector, dotNL, attenuation, materialDiffuse, materialSpecular, materialShininess, utestdemo2024Light%ID%_diffuse.rgb, utestdemo2024Light%ID%_diffuse.rgb, eyeLightDir, lightDiffuse, lightSpecular, lighted);\n        #endif\n    #else\n        #ifdef HAS_ANISOTROPY\n            computeLightLambertGGXAnisotropy(materialNormal, eyeVector, dotNL, prepGGX, materialDiffuse, materialSpecular, attenuation, utestdemo2024Light%ID%_diffuse.rgb, eyeLightDir, materialF90, anisotropicT, anisotropicB, anisotropy, lightDiffuse, lightSpecular, lighted);\n        #else\n            computeLightLambertGGX(materialNormal, eyeVector, dotNL, prepGGX, materialDiffuse, materialSpecular, attenuation, utestdemo2024Light%ID%_diffuse.rgb, eyeLightDir, materialF90, lightDiffuse, lightSpecular, lighted);\n        #endif\n    #endif\n\n    #ifdef HAS_CLEARCOAT\n        computeLightLambertGGXClearCoat(ccNoV, materialClearCoatNormal, eyeVector, dot(materialClearCoatNormal, eyeLightDir), prepGGXClearCoat, attenuation, utestdemo2024Light%ID%_diffuse.rgb, eyeLightDir, materialClearCoat, ccSpecular, ccAttenuation);\n        lightDiffuse *= ccAttenuation;\n        lightSpecular = ccSpecular + lightSpecular * ccAttenuation;\n    #endif\n\n    #ifdef HAS_SHEEN\n        lightDiffuse += computeSheen(materialNormal, eyeLightDir, eyeVector, sheenRoughness);\n    #endif\n\n\n\n    #ifdef HAS_SHADOW_%ID%\n        #ifdef _ATLAS_SHADOW\n            shadow = shadowReceive(lighted, modelNormal, vModelVertex, Texture7, uShadow_Texture0_renderSize, uShadow_Texture%ID%_projection, uShadow_Texture%ID%_viewRight, uShadow_Texture%ID%_viewUp, uShadow_Texture%ID%_viewLook, uShadow_Texture%ID%_depthRange, uShadowReceive%ID%_bias, uShadow_Texture%ID%_mapSize, OPT_DISTANCE uStaticFrameNumShadow%ID%);\n        #else\n            shadow = shadowReceive(lighted, modelNormal, vModelVertex, TEX_SHADOW_%ID%, uShadow_Texture%ID%_renderSize, uShadow_Texture%ID%_projection, uShadow_Texture%ID%_viewRight, uShadow_Texture%ID%_viewUp, uShadow_Texture%ID%_viewLook, uShadow_Texture%ID%_depthRange, uShadowReceive%ID%_bias, OPT_DISTANCE uStaticFrameNumShadow%ID%);\n        #endif // _ATLAS_SHADOW\n\n        lightDiffuse *= shadow;\n        lightSpecular *= shadow;\n\n        #ifdef HAS_SUBSURFACETRANSLUCENCY\n            lightDiffuse += computeLightSSS(dotNL, attenuation, uSubsurfaceTranslucencyThicknessFactor, uSubsurfaceTranslucencyColor, materialTranslucency, shadowDistance, materialDiffuse, utestdemo2024Light%ID%_diffuse.rgb);\n        #endif\n    #endif // HAS_SHADOW\n\n    diffuse += lightDiffuse;\n    specular += lightSpecular;\n#endif // LIGHT_TYPE\n%%\n\n    /////////////\n    // REFRACTION\n    /////////////\n#ifdef HAS_OPACITY_REFRACTION\n    #ifdef HAS_REFRACTION_NORMAL_OFFSET\n        vec3 refractLight = refraction(gRefractionRoughness, materialNormal, frontNormal, eyeVector);\n    #else\n        vec3 refractLight = refraction(gRefractionRoughness, materialNormal, eyeVector);\n    #endif\n\n    #ifdef HAS_REFRACTION_ALBEDO_TINT\n        refractLight *= materialDiffuse;\n    #endif\n\n    diffuse = mix(refractLight, diffuse, alphaRefraction);\n#endif // HAS_OPACITY_REFRACTION\n\n    //////////////////////\n    // SCATTERING AND EMIT\n    //////////////////////\n#ifdef HAS_SUBSURFACESCATTERING\n    #ifdef HAS_EMITCOLOR\n        diffuse = uEmitMultiplicative == 1 ? diffuse * materialEmit : diffuse + materialEmit;\n        if (uEmitMultiplicative == 1) specular *= materialEmit;\n    #endif\n    vec3 frag = mix(specular, diffuse, checkerboard(gl_FragCoord.xy, uHalton));\n#else\n    vec3 frag = diffuse + specular;\n    #ifdef HAS_EMITCOLOR\n        frag = uEmitMultiplicative == 1 ? frag * materialEmit : frag + materialEmit;\n    #endif\n#endif // HAS_SUBSURFACESCATTERING\n\n#ifdef HAS_CAVITYPBR\n    frag *= materialCavity;\n#endif\n\n    // premult\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    frag *= alpha;\n#endif\n\n    if (uOutputLinear != 1) frag = linearTosRGB(frag);\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    gl_FragColor = uDrawOpaque == 1 ? encodeRGBM(frag, uRGBMRange) : vec4(frag, alphaFinal);\n#else\n    gl_FragColor = encodeRGBM(frag, uRGBMRange);\n#endif\n}\n'
        },
        "m6+n": e => {
            e.exports = '#define HAS_VIEW_NORMAL\n#define HAS_VIEW_VERTEX\n#pragma include "base.vert"\n'
        },
        HCcy: e => {
            e.exports = 'uniform float uRGBMRange;\nuniform int uOutputLinear;\n\n// stuffs (ssr, opacity, scattering)\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform int uDrawOpaque;\n\n//////////\n// VARYING\n//////////\n\n#ifdef HAS_OPACITY_REFRACTION\n    varying vec3 vViewNormal;\n    varying vec4 vViewVertex;\n#endif\n\n#pragma include "utils/common.glsl"\n#pragma include "utils/functions.glsl"\n#pragma include "utils/material.glsl"\n#pragma include "utils/decodeDepth.glsl"\n#pragma include "utils/rand.glsl"\n\n#ifdef HAS_OPACITY_REFRACTION\n#pragma include "utils/refraction.glsl"\n#endif\n\nvoid main() {\n    //////////////////\n    // OPACITY DISCARD\n    //////////////////\n#ifdef HAS_POINT_CIRCLE\n    if (length(2.0 * gl_PointCoord - 1.0) > 1.0) discard;\n#endif\n\n#ifdef HAS_ALPHAMASK\n    if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n#endif\n\n#ifdef HAS_OPACITY_DITHER\n    ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n#endif\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    float alpha = getMaterialOpacity();\n    float alphaFinal = alpha * float(1 - uOpacityAdditive);\n    if (alpha == 0.0 || (uDrawOpaque == 1 && alphaFinal < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaFinal >= EPSILON_ALPHA)) discard;\n#endif\n\n    // /!\\ because of refraction roughness, this part should be done before the call to getMetalness/getSpecular\n#ifdef HAS_OPACITY_REFRACTION\n    gRefractionRoughness = uOpacityRoughnessFactor;\n    float alphaRefraction = getMaterialOpacity();\n    if ((uDrawOpaque == 1 && alphaRefraction < EPSILON_ALPHA) || (uDrawOpaque == 0 && alphaRefraction >= EPSILON_ALPHA)) discard;\n#endif\n\n    ///////////\n    // GEOMETRY\n    ///////////\n#ifdef HAS_OPACITY_REFRACTION\n    vec3 eyeVector = -normalize(vViewVertex.xyz);\n    vec3 frontNormal = normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);\n#endif\n\n    ///////////\n    // MATERIAL\n    ///////////\n#if defined(HAS_LEGACY_CLASSIC)\n    vec3 materialDiffuse = getMaterialLegacyDiffuse();\n#elif defined(HAS_ALBEDOPBR)\n    vec3 materialDiffuse = getMaterialAlbedo();\n#else\n    vec3 materialDiffuse = getMaterialDiffuse();\n#endif\n\n#ifdef HAS_AOPBR\n    float materialAO = getMaterialAO();\n#endif\n\n#ifdef HAS_EMITCOLOR\n    vec3 materialEmit = getMaterialEmitColor();\n#endif\n\n#ifdef HAS_CAVITYPBR\n    float materialCavity = getMaterialCavity();\n#endif\n\n    vec3 diffuse = materialDiffuse;\n\n#ifdef HAS_AOPBR\n    diffuse *= materialAO;\n#endif\n\n    /////////////\n    // REFRACTION\n    /////////////\n#ifdef HAS_OPACITY_REFRACTION\n\n    #ifdef HAS_REFRACTION_NORMAL_OFFSET\n        vec3 refractLight = refraction(gRefractionRoughness, frontNormal.xyz, frontNormal.xyz, eyeVector.xyz);\n    #else\n        vec3 refractLight = refraction(gRefractionRoughness, frontNormal.xyz, eyeVector.xyz);\n    #endif\n\n    #ifdef HAS_REFRACTION_ALBEDO_TINT\n        refractLight *= materialDiffuse;\n    #endif\n\n    diffuse = mix(refractLight, diffuse, alphaRefraction);\n#endif // HAS_OPACITY_REFRACTION\n\n    vec3 frag = diffuse;\n\n#ifdef HAS_EMITCOLOR\n    frag = uEmitMultiplicative == 1 ? frag * materialEmit : frag + materialEmit;\n#endif\n\n#ifdef HAS_CAVITYPBR\n    frag *= materialCavity;\n#endif\n\n    // premult\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    frag *= alpha;\n#endif\n\n    if (uOutputLinear != 1) frag = linearTosRGB(frag);\n\n#ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n    gl_FragColor = uDrawOpaque == 1 ? encodeRGBM(frag, uRGBMRange) : vec4(frag, alphaFinal);\n#else\n    gl_FragColor = encodeRGBM(frag, uRGBMRange);\n#endif\n}\n'
        },
        mU6Y: e => {
            e.exports = '#pragma include "pbr.vert"\n'
        },
        s4hY: e => {
            e.exports = '// opacity\nuniform vec4 uHalton;\nuniform vec2 uNearFar;\nuniform float uFrameMod;\nuniform int uDrawOpaque;\n\nuniform vec4 uShadowDepthRange;\n\nvarying vec4 vViewVertex;\n\n#pragma include "utils/material.glsl"\n\n#ifdef HAS_OPACITY\n#pragma include "utils/material.glsl"\n#pragma include "utils/rand.glsl"\n#endif\n\nvec4 encodeFloatRGBA( float v ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n\nvoid main() {\n#ifdef HAS_ALPHAMASK\n  if (getMaterialAlphaMask() < uAlphaMaskFactor) discard;\n#endif\n#ifdef HAS_OPACITY_DITHER\n    ditheringMaskingDiscard(gl_FragCoord, uOpacityDithering, getMaterialOpacity(), uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton);\n#endif\n\n#if defined(HAS_OPACITY_BLEND_OR_ADDITIVE) || defined(HAS_OPACITY_REFRACTION)\n    if (getMaterialOpacity() < EPSILON_ALPHA) discard;\n#endif\n\n    gl_FragColor = encodeFloatRGBA((-vViewVertex.z - uShadowDepthRange.x) / (uShadowDepthRange.y - uShadowDepthRange.x));\n}\n'
        },
        k2zI: e => {
            e.exports = 'uniform vec2 uShadowMapSize;\n#define SHADOW_CAST\n#define HAS_VIEW_VERTEX\n#pragma include "base.vert"\n'
        },
        U0i3: e => {
            e.exports = "float decodeFloatRGBA(const in vec4 rgba) {\n    return dot(rgba, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n\nfloat getSingleFloatFromTex(const in sampler2D depths, const in vec2 uv){\n#ifndef _FLOATTEX\n    return  decodeFloatRGBA(texture2D(depths, uv));\n#else\n    return texture2D(depths, uv).x;\n#endif\n}\n\n// simulation of texture2Dshadow glsl call on HW\n// http://codeflow.org/entries/2013/feb/15/soft-shadow-mapping/\nfloat texture2DCompare(const in sampler2D depths,\n                       const in vec2 uv,\n                       const in float compare,\n                       const in vec4 clampDimension){\n    float depth = getSingleFloatFromTex(depths, clamp(uv, clampDimension.xy, clampDimension.zw));\n    return compare - depth;\n}\n\n#ifdef _JITTER_OFFSET\n// TODO could be in a random.glsl file\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27\nfloat shadowInterleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));\n}\n#endif\n\n// simulates linear fetch like texture2d shadow\nfloat texture2DShadowLerp(\n    const in sampler2D depths,\n    const in vec2 size,\n    const in vec2 uv,\n    const in float compare,\n    const in vec4 clampDimension\n    OPT_ARG_outDistance\n    OPT_ARG_jitter){\n\n    vec2 centroidCoord = uv / size.xy;\n\n#ifdef _JITTER_OFFSET\n    if (jitter > 0.0){\n        centroidCoord += shadowInterleavedGradientNoise(gl_FragCoord.xy, jitter);\n    }\n#endif\n\n    centroidCoord = centroidCoord + 0.5;\n    vec2 f = fract(centroidCoord);\n    vec2 centroidUV = floor(centroidCoord) * size.xy;\n\n    vec4 fetches;\n    const vec2 shift  = vec2(1.0, 0.0);\n    fetches.x = texture2DCompare(depths, centroidUV + size.xy * shift.yy, compare, clampDimension);\n    fetches.y = texture2DCompare(depths, centroidUV + size.xy * shift.yx, compare, clampDimension);\n    fetches.z = texture2DCompare(depths, centroidUV + size.xy * shift.xy, compare, clampDimension);\n    fetches.w = texture2DCompare(depths, centroidUV + size.xy * shift.xx, compare, clampDimension);\n\n#ifdef _OUT_DISTANCE\n    float _a = mix(fetches.x, fetches.y, f.y);\n    float _b = mix(fetches.z, fetches.w, f.y);\n    outDistance = mix(_a, _b, f.x);\n#endif\n\n    vec4 st = step(fetches, vec4(0.0));\n\n    float a = mix(st.x, st.y, f.y);\n    float b = mix(st.z, st.w, f.y);\n    return mix(a, b, f.x);\n}\n"
        },
        OLDE: e => {
            e.exports = "#extension GL_OES_standard_derivatives : enable\n\n%UNROLL 4%\n#ifdef HAS_SHADOW_%ID%\n    uniform float uShadowReceive%ID%_bias;\n    uniform float uStaticFrameNumShadow%ID%;\n    uniform vec2 uShadow_Texture%ID%_depthRange;\n    uniform vec3 uShadow_Texture%ID%_projection;\n    uniform vec4 uShadow_Texture%ID%_viewLook;\n    uniform vec4 uShadow_Texture%ID%_viewRight;\n    uniform vec4 uShadow_Texture%ID%_viewUp;\n\n    #ifdef _ATLAS_SHADOW\n        uniform vec4 uShadow_Texture%ID%_mapSize;\n    #else\n        uniform vec2 uShadow_Texture%ID%_renderSize;\n    #endif\n#endif // HAS_SHADOW\n%%\n\n// TODO rename sampler uniform to be better and sync with light number (e.g: sShadow0, sShadow1, etc)\n#ifdef _ATLAS_SHADOW\n    uniform vec2 uShadow_Texture0_renderSize;\n    uniform sampler2D Texture7;\n#else\n    #ifdef HAS_SHADOW_0\n        uniform sampler2D Texture12;\n        #define TEX_SHADOW_0 Texture12\n    #endif\n    #ifdef HAS_SHADOW_1\n        uniform sampler2D Texture13;\n        #define TEX_SHADOW_1 Texture13\n    #endif\n    #ifdef HAS_SHADOW_2\n        uniform sampler2D Texture14;\n        #define TEX_SHADOW_2 Texture14\n    #endif\n    #ifdef HAS_SHADOW_3\n        uniform sampler2D Texture15;\n        #define TEX_SHADOW_3 Texture15\n    #endif\n#endif // _ATLAS_SHADOW\n\n#ifdef _OUT_DISTANCE\n#define OPT_ARG_outDistance ,out float outDistance\n#define OPT_INSTANCE_ARG_outDistance ,outDistance\n#else\n#define OPT_ARG_outDistance\n#define OPT_INSTANCE_ARG_outDistance\n#endif\n\n#ifdef _ATLAS_SHADOW\n#define OPT_ARG_atlasSize ,const in vec4 atlasSize\n#else\n#define OPT_ARG_atlasSize\n#endif\n\n#ifdef _NORMAL_OFFSET\n#define OPT_ARG_normalBias ,const in float normalBias\n#else\n#define OPT_ARG_normalBias\n#endif\n\n#ifdef _JITTER_OFFSET\n#define OPT_ARG_jitter ,const in float jitter\n#define OPT_INSTANCE_ARG_jitter ,jitter\n#else\n#define OPT_ARG_jitter\n#define OPT_INSTANCE_ARG_jitter\n#endif\n\n#pragma include \"shadowing/tapPCF.glsl\"\n\nfloat shadowReceive(const in bool lighted,\n                    const in vec3 normalWorld,\n                    const in vec3 vertexWorld,\n\n                    const in sampler2D shadowTexture,\n\n                    const in vec2 shadowSize,\n                    const in vec3 shadowProjection,\n\n                    const in vec4 shadowViewRight,\n                    const in vec4 shadowViewUp,\n                    const in vec4 shadowViewLook,\n\n\n                    const in vec2 shadowDepthRange,\n                    const in float shadowBias\n                    OPT_ARG_atlasSize\n                    OPT_ARG_normalBias\n                    OPT_ARG_outDistance\n                    OPT_ARG_jitter) {\n\n    // 0 for early out\n    bool earlyOut = false;\n\n    // Calculate shadow amount\n    float shadow = 1.0;\n\n    if (!lighted) {\n        shadow = 0.0;\n#ifndef _OUT_DISTANCE\n        earlyOut = true;\n#endif // _OUT_DISTANCE\n    }\n\n    if (shadowDepthRange.x == shadowDepthRange.y) {\n        earlyOut = true;\n    }\n\n    vec4 shadowVertexEye;\n    vec4 shadowNormalEye;\n    float shadowReceiverZ = 0.0;\n    vec4 shadowVertexProjected;\n    vec2 shadowUV;\n    float N_Dot_L;\n    float invDepthRange;\n\n    if (!earlyOut) {\n\n        shadowVertexEye.x = dot(shadowViewRight.xyz, vertexWorld.xyz) + shadowViewRight.w;\n        shadowVertexEye.y = dot(shadowViewUp.xyz, vertexWorld.xyz) + shadowViewUp.w;\n        shadowVertexEye.z = dot(shadowViewLook.xyz, vertexWorld.xyz) + shadowViewLook.w;\n        shadowVertexEye.w = 1.0;\n\n\n        // derivated, only need z.\n        //vec3 shadowLightDir = vec3(0.0, 0.0, 1.0); // in shadow view light is camera\n        //shadowNormalEye =  shadowViewMatrix * normalFront;\n        //shadowNormalEye.x = dot(shadowViewRight.xyz, normalWorld.xyz);\n        //shadowNormalEye.y = dot(shadowViewUp.xyz, normalWorld.xyz);\n        shadowNormalEye.z = dot(shadowViewLook.xyz, normalWorld.xyz);\n        //shadowNormalEye.w = 0.0;\n\n        //N_Dot_L = dot(shadowNormalEye.xyz, shadowLightDir);\n        N_Dot_L = shadowNormalEye.z;\n\n        if (!earlyOut) {\n\n            invDepthRange = 1.0 / (shadowDepthRange.y - shadowDepthRange.x);\n\n#ifdef _NORMAL_OFFSET\n\n            // http://www.dissidentlogic.com/old/images/NormalOffsetShadows/GDC_Poster_NormalOffset.png\n            float normalOffsetScale = clamp(1.0  - N_Dot_L, 0.0 , 1.0);\n            normalOffsetScale *= abs((shadowVertexEye.z - shadowDepthRange.x) * invDepthRange);\n            normalOffsetScale *= max(shadowProjection.x, shadowProjection.y);\n            normalOffsetScale *= normalBias * invDepthRange;\n\n\n            vec4 shadowNormalShift =  vec4(normalWorld, 0.0) * normalOffsetScale;\n            shadowNormalEye.x = dot(shadowViewRight.xyz, shadowNormalShift.xyz);\n            shadowNormalEye.y = dot(shadowViewUp.xyz, shadowNormalShift.xyz);\n            shadowNormalEye.z = dot(shadowViewLook.xyz, shadowNormalShift.xyz);\n            shadowNormalEye.w = 0.0;\n\n            vec4 viewShadow = shadowVertexEye + shadowNormalEye;\n#else\n            vec4 viewShadow = shadowVertexEye;\n#endif\n\n\n            if (shadowProjection.z == 0.0){\n\n               // X, 0, 0, 0,\n               // 0, Y, 0, 0,\n               // 0, 0, -1, -1,\n               // 0, 0, -2.0*znear, 0\n               // mat4 shadowProjectionMatrix;\n               // shadowProjectionMatrix[0] = vec4(shadowProjection.x, 0.0, 0.0, 0.0 );\n               // shadowProjectionMatrix[1] = vec4(0.0, shadowProjection.y, 0.0, 0.0 );\n               // shadowProjectionMatrix[2] = vec4(0.0, 0.0, -1.0, -1.0 );\n               // shadowProjectionMatrix[3] = vec4(0.0, 0.0, -2.0*shadowDepthRange.x, 0.0 );\n               // shadowVertexProjected = shadowProjectionMatrix * shadowVertexEye;\n\n               // derivated optimisation\n               shadowVertexProjected.x = shadowProjection.x * viewShadow.x;\n               shadowVertexProjected.y = shadowProjection.y * viewShadow.y;\n\n               shadowVertexProjected.z = - viewShadow.z - (2.0 * shadowDepthRange.x * viewShadow.w);\n               shadowVertexProjected.w = - viewShadow.z;\n\n            }\n            else{\n                // lr = 1/(left-right);\n                // bt = 1/(bottom-top);\n                // nf = 1/(near-far);\n                // -2*lr,           0,               0,              0,\n                // 0,               -2*bt,           0,              0,\n                // 0,               0,               2*nf,           0.0,\n                // (left+right)*lr, (top+bottom)*bt, (far+near)*nf), 1\n                // here left = -right && top = -bottom\n                // float lr = 1.0 / (-2.0 * shadowProjection.x);\n                // float bt = 1.0 / (-2.0 * shadowProjection.y);\n                // float nf = 1.0 / (shadowDepthRange.x - shadowDepthRange.y);\n                float nfNeg = 1.0 / (shadowDepthRange.x - shadowDepthRange.y);\n                float nfPos = (shadowDepthRange.x + shadowDepthRange.y)*nfNeg;\n\n                //mat4 shadowProjectionMatrix;\n                //shadowProjectionMatrix[0] = vec4(1.0 / shadowProjection.x, 0.0,     0.0,  0.0 );\n                //shadowProjectionMatrix[1] = vec4(0.0,     1.0 / shadowProjection.y, 0.0,  0.0 );\n                //shadowProjectionMatrix[2] = vec4(0.0,     0.0, 2.0*nfNeg, 0.0 );\n                //shadowProjectionMatrix[3] = vec4(0.0,     0.0, nfPos, 1.0 );\n                //shadowdertexProjected = shadowProjectionMatrix * shadowVertexEye;\n\n                // derivated optimisation\n                shadowVertexProjected.x = viewShadow.x / shadowProjection.x;\n                shadowVertexProjected.y = viewShadow.y / shadowProjection.y;\n\n                shadowVertexProjected.z = 2.0 * nfNeg* viewShadow.z + nfPos * viewShadow.w;\n                shadowVertexProjected.w = viewShadow.w;\n\n            }\n\n\n            if (shadowVertexProjected.w < 0.0) {\n                earlyOut = true; // notably behind camera\n            }\n\n        }\n\n        if (!earlyOut) {\n\n            shadowUV.xy = shadowVertexProjected.xy / shadowVertexProjected.w;\n            shadowUV.xy = shadowUV.xy * 0.5 + 0.5;// mad like\n\n            if (any(bvec4 ( shadowUV.x > 1., shadowUV.x < 0., shadowUV.y > 1., shadowUV.y < 0.))) {\n                earlyOut = true;// limits of light frustum\n            }\n\n            // most precision near 0, make sure we are near 0 and in [0,1]\n            shadowReceiverZ = - shadowVertexEye.z;\n            shadowReceiverZ =  (shadowReceiverZ - shadowDepthRange.x) * invDepthRange;\n\n            if(shadowReceiverZ < 0.0) {\n                earlyOut = true; // notably behind camera\n            }\n\n        }\n    }\n\n    // pcf pbias to add on offset\n    vec2 shadowBiasPCF = vec2 (0.);\n\n#ifdef GL_OES_standard_derivatives\n#ifdef _RECEIVERPLANEDEPTHBIAS\n    vec2 biasUV;\n\n    vec3 texCoordDY = dFdx(shadowVertexEye.xyz);\n    vec3 texCoordDX = dFdy(shadowVertexEye.xyz);\n\n    biasUV.x = texCoordDY.y * texCoordDX.z - texCoordDX.y * texCoordDY.z;\n    biasUV.y = texCoordDX.x * texCoordDY.z - texCoordDY.x * texCoordDX.z;\n    biasUV *= 1.0 / ((texCoordDX.x * texCoordDY.y) - (texCoordDX.y * texCoordDY.x));\n\n    // Static depth biasing to make up for incorrect fractional sampling on the shadow map grid\n    float fractionalSamplingError = dot(vec2(1.0, 1.0) * shadowSize.xy, abs(biasUV));\n    float receiverDepthBias = min(fractionalSamplingError, 0.01);\n\n    shadowBiasPCF.x = biasUV.x;\n    shadowBiasPCF.y = biasUV.y;\n\n    shadowReceiverZ += receiverDepthBias;\n\n#else // _RECEIVERPLANEDEPTHBIAS\n    shadowBiasPCF.x = clamp(dFdx(shadowReceiverZ) * shadowSize.x, -1.0, 1.0 );\n    shadowBiasPCF.y = clamp(dFdy(shadowReceiverZ) * shadowSize.y, -1.0, 1.0 );\n#endif\n\n#endif // GL_OES_standard_derivatives\n\n\n    vec4 clampDimension;\n\n#ifdef _ATLAS_SHADOW\n    shadowUV.xy  = ((shadowUV.xy * atlasSize.zw ) + atlasSize.xy) * shadowSize.xy;\n\n    // clamp uv bias/filters by half pixel to avoid point filter on border\n    clampDimension.xy = atlasSize.xy + vec2(0.5);\n    clampDimension.zw = (atlasSize.xy + atlasSize.zw) - vec2(0.5);\n\n    clampDimension = clampDimension * shadowSize.xyxy;\n#else\n    clampDimension = vec4(0.0, 0.0, 1.0, 1.0);\n#endif // _RECEIVERPLANEDEPTHBIAS\n\n\n    // now that derivatives is done and we don't access any mipmapped/texgrad texture we can early out\n    // see http://teknicool.tumblr.com/post/77263472964/glsl-dynamic-branching-and-texture-samplers\n    if (earlyOut) {\n        // empty statement because of weird gpu intel bug\n    } else {\n\n        // depth bias: fighting shadow acne (depth imprecsion z-fighting)\n        // cosTheta is dot( n, l ), clamped between 0 and 1\n        // float shadowBias = 0.005*tan(acos(N_Dot_L));\n        // same but 4 cycles instead of 15\n        float depthBias = 0.05 * sqrt( 1.0 - N_Dot_L * N_Dot_L) / clamp(N_Dot_L, 0.0005, 1.0);\n\n        // That makes sure that plane perpendicular to light doesn't flicker due to\n        // selfshadowing and 1 = dot(Normal, Light) using a min bias\n        depthBias = clamp(depthBias, 0.00005, 2.0 * shadowBias);\n\n        // shadowZ must be clamped to [0,1]\n        // otherwise it's not comparable to shadow caster depth map\n        // which is clamped to [0,1]\n        // Not doing that makes ALL shadowReceiver > 1.0 black\n        // because they ALL becomes behind any point in Caster depth map\n        shadowReceiverZ = clamp(shadowReceiverZ, 0.0, 1.0 -depthBias) - depthBias;\n\n        // Now computes Shadow\n        float res = getShadowPCF(shadowTexture,\n                                 shadowSize,\n                                 shadowUV,\n                                 shadowReceiverZ,\n                                 shadowBiasPCF,\n                                 clampDimension\n                                 OPT_INSTANCE_ARG_outDistance\n                                 OPT_INSTANCE_ARG_jitter);\n#ifdef _OUT_DISTANCE\n        if (lighted) shadow = res;\n        outDistance *= shadowDepthRange.y - shadowDepthRange.x; // world space distance\n#else\n        shadow = res;\n#endif  // _OUT_DISTANCE\n    }\n\n    return shadow;\n\n}\n"
        },
        ZNov: e => {
            e.exports = '#pragma include "shadowing/shadowLinearSoft.glsl"\n\nfloat getShadowPCF(\n    const in sampler2D depths,\n    const in vec2 size,\n    const in vec2 uv,\n    const in float compare,\n    const in vec2 biasPCF,\n    const in vec4 clampDimension\n    OPT_ARG_outDistance\n    OPT_ARG_jitter) {\n\n     float res = 0.0;\n\n     res += texture2DShadowLerp(depths, size, uv + biasPCF, compare, clampDimension OPT_INSTANCE_ARG_outDistance OPT_INSTANCE_ARG_jitter);\n\n\n#if defined(_PCFx1)\n\n#else\n\n    float dx0 = -size.x;\n    float dy0 = -size.y;\n    float dx1 = size.x;\n    float dy1 = size.y;\n\n#define TSF(o1,o2) texture2DShadowLerp(depths, size, uv + vec2(o1, o2) + biasPCF, compare, clampDimension OPT_INSTANCE_ARG_outDistance OPT_INSTANCE_ARG_jitter)\n\n    res += TSF(dx0, dx0);\n    res += TSF(dx0, .0);\n    res += TSF(dx0, dx1);\n\n#if defined(_PCFx4)\n\n    res /=4.0;\n\n#elif defined(_PCFx9)\n    res += TSF(.0, dx0);\n    res += TSF(.0, dx1);\n\n    res += TSF(dx1, dx0);\n    res += TSF(dx1, .0);\n    res += TSF(dx1, dx1);\n\n\n    res /=9.0;\n\n#elif defined(_PCFx25)\n\n    float dx02 = 2.0*dx0;\n    float dy02 = 2.0*dy0;\n    float dx2 = 2.0*dx1;\n    float dy2 = 2.0*dy1;\n\n    // complete row above\n    res += TSF(dx0, dx02);\n    res += TSF(dx0, dx2);\n\n    res += TSF(.0, dx02);\n    res += TSF(.0, dx2);\n\n    res += TSF(dx1, dx02);\n    res += TSF(dx1, dx2);\n\n    // two new col\n    res += TSF(dx02, dx02);\n    res += TSF(dx02, dx0);\n    res += TSF(dx02, .0);\n    res += TSF(dx02, dx1);\n    res += TSF(dx02, dx2);\n\n    res += TSF(dx2, dx02);\n    res += TSF(dx2, dx0);\n    res += TSF(dx2, .0);\n    res += TSF(dx2, dx1);\n    res += TSF(dx2, dx2);\n\n\n    res/=25.0;\n\n#endif\n\n#undef TSF\n\n#endif\n    return res;\n}\n/////// end Tap\n'
        },
        "8g60": e => {
            e.exports = "float checkerboard(const in vec2 uv, const in vec4 halton) {\n  vec2 flooredUV = floor(uv);\n  return mod((halton.z < 0.0 ? 0.0 : 1.0) + flooredUV.x + flooredUV.y, 2.0);\n}\n"
        },
        lLHi: e => {
            e.exports = '#pragma include "utils/lightsPBR.glsl"\n\n//https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law for translucent material absorbtion\nvec3 beerLambert(const float NoV, const float NoL, const vec3 tint, const float d) {\n    // exp(tint * -distance * density)\n    return exp(tint * -(d * ((NoL + NoV) / max(NoL * NoV, 1e-3))));\n}\n\nvec3 getClearCoatAbsorbtion(const in float NoV, const in float NoL, const in float clearCoatFactor) {\n    return mix(vec3(1.0), beerLambert(NoV, NoL, uClearCoatTint, uClearCoatThickness), clearCoatFactor);\n}\n\n// compute Light PBR for clearCoat layer\nvoid computeLightLambertGGXClearCoat(\n    const in float ccNoV,\n    const in vec3 normal,\n    const in vec3 eyeVector,\n    const in float dotNL,\n    const in vec4 precomputeGGX,\n\n    const in float attenuation,\n    const in vec3 lightColor,\n    const in vec3 eyeLightDir,\n\n    const in float clearCoatFactor,\n\n    out vec3 clearCoatSpecular,\n    out vec3 clearCoatAttenuation) {\n\n    if (dotNL <= 0.0) {\n        clearCoatSpecular = vec3(0.0);\n        clearCoatAttenuation = vec3(0.0);\n        return;\n    }\n\n    float ccNoL = saturate(dot(normal, -refract(eyeLightDir, normal, 1.0 / uClearCoatIor)));\n    vec3 clearCoatAbsorption = getClearCoatAbsorbtion(ccNoV, ccNoL, clearCoatFactor);\n\n    vec3 H = normalize(eyeVector + eyeLightDir);\n    float NoH = saturate(dot(normal, H));\n    float VoH = saturate(dot(eyeLightDir, H));\n\n    // distribution / visibility / fresnel\n    float D = D_GGX(precomputeGGX, NoH);\n    float V = V_SmithCorrelated(precomputeGGX, ccNoL);\n    float F = F_Schlick(uClearCoatF0, 1.0, VoH);\n\n    clearCoatSpecular = (attenuation * dotNL * clearCoatFactor * D * V * PI * F) * lightColor;\n    clearCoatAttenuation = (1.0 - F * clearCoatFactor) * clearCoatAbsorption;\n}\n'
        },
        eq5r: e => {
            e.exports = "#define PI 3.141593\n#define saturate(_x) clamp(_x, 0., 1.)\n"
        },
        D4k4: e => {
            e.exports = '#pragma include "utils/functions.glsl"\n\n// used by background.frag\nvec3 textureCubeFixed(const in samplerCube tex, const in vec3 R, const in float size) {\n    vec3 dir = R;\n    float scale = 1.0 - 1.0 / size;\n    // http://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/\n    vec3 absDir = abs(dir);\n    float M = max(max(absDir.x, absDir.y), absDir.z);\n\n    if (absDir.x != M) dir.x *= scale;\n    if (absDir.y != M) dir.y *= scale;\n    if (absDir.z != M) dir.z *= scale;\n\n    return LUVToRGB(textureCube(tex, dir));\n}\n'
        },
        RSGS: e => {
            e.exports = '#pragma include "utils/functions.glsl"\r\n\r\n#extension GL_EXT_shader_texture_lod : enable\r\nvec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R) {\r\n    vec3 dir = R;\r\n    float lod = min(uTextureEnvironmentSpecularPBRLodRange.x, linRoughnessToMipmap(rLinear) * uTextureEnvironmentSpecularPBRLodRange.y);\r\n\r\n    // http://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/\r\n    float scale = 1.0 - exp2(lod) / uTextureEnvironmentSpecularPBRTextureSize.x;\r\n    vec3 absDir = abs(dir);\r\n    float M = max(max(absDir.x, absDir.y), absDir.z);\r\n\r\n    if (absDir.x != M) dir.x *= scale;\r\n    if (absDir.y != M) dir.y *= scale;\r\n    if (absDir.z != M) dir.z *= scale;\r\n\r\n    return LUVToRGB(textureCubeLodEXT(sSpecularPBR, dir, lod));\r\n}\r\n'
        },
        dd27: e => {
            e.exports = "#extension GL_OES_standard_derivatives : enable\n\nuniform float uMatcapCurvature;\nuniform mat4 uProjectionMatrix;\n\n// http://madebyevan.com/shaders/curvature/\nfloat getCurvature(const in vec3 normal) {\n#ifndef GL_OES_standard_derivatives\n    return 1.0;\n#else\n  if (uMatcapCurvature == 0.0) return 1.0;\n\n  // Compute curvature\n  vec3 dx = dFdx(normal);\n  vec3 dy = dFdy(normal);\n  vec3 xneg = normal - dx;\n  vec3 xpos = normal + dx;\n  vec3 yneg = normal - dy;\n  vec3 ypos = normal + dy;\n\n  float factor =  uMatcapCurvature / (length(vViewVertex.xyz) * atan(-1.0 / uProjectionMatrix[2][3]));\n  float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * factor;\n\n  float curvDirt = clamp(-curvature * 1.5, 0.0, 1.0);\n  float curvEdge = clamp(curvature * 2.5, 0.0, 1.0);\n\n  float factorDirt = mix(1.0, 0.3, curvDirt);\n  float factorEdge = 2.0;\n\n  return mix(factorDirt, factorEdge, curvEdge);\n#endif\n}\n"
        },
        RC5z: e => {
            e.exports = "int decodeProfile(const in vec4 pack) {\n    float packValue = floor(pack.b * 255.0 + 0.5);\n    // we extract the 2 lowest bits\n    float profile = mod(packValue, 2.0);\n    profile += mod(packValue - profile, 4.0);\n    return int(profile);\n}\n\nfloat decodeDepth(const in vec4 pack) {\n    if(decodeProfile(pack) == 0){\n        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);\n        return dot(pack.rgb, decode);\n    }\n\n    return pack.r + pack.g / 255.0;\n}\n\nfloat decodeScatter(const in vec4 pack) {\n  // avoid huge number, summation, division and associated loss of precision\n  // by deriving the whole computation to the end\n  // As floor is with mod(x,y) = x - y * floor(x/y)\n\n  // float scatter = pack.b - mod(pack.b, 4.0 / 255.0);\n  // float scatter = pack.b - pack.b  +  (4.0 /255.0) * floor(pack.b / (4.0 /255.0));\n  // float scatter = (4.0 /255.0) * floor(pack.b / (4.0 / 255.0));\n  float scatter = (4.0 / 255.0) * floor(pack.b * 255.0 * 0.25);\n\n  //return scatter * 255.0 / 4.0 / 63.0;\n  return scatter * 1.0119047619;\n}\n\nfloat decodeAlpha(const in vec4 pack) {\n    return pack.a;\n}\n\nfloat distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {\n    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);\n    return fragDepth - decodeDepth(texture2D(depth, uv));\n}\n"
        },
        NfER: e => {
            e.exports = "vec3 encode24(const in float x){\n    const vec3 code = vec3(1.0, 255.0, 65025.0);\n    vec3 pack = vec3(code * x);\n    pack.gb = fract(pack.gb);\n    pack.rg -= pack.gb * (1.0 / 256.0);\n    return pack;\n}\n\nfloat decode24(const in vec3 x) {\n    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);\n    return dot(x, decode);\n}\n"
        },
        Z5UG: e => {
            e.exports = "// random links on packing :\n// cesium attributes packing\n// https://cesiumjs.org/2015/05/18/Vertex-Compression/\n\n// float packing in 24 bits or 32 bits\n// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/\n\nvec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {\n    vec4 pack = vec4(0.0);\n\n    // opacity in alpha\n    pack.a = alpha;\n\n    if(profile == 0.0) {\n        const vec3 code = vec3(1.0, 255.0, 65025.0);\n        pack.rgb = vec3(code * depth);\n        pack.gb = fract(pack.gb);\n        pack.rg -= pack.gb * (1.0 / 256.0);\n    } else {\n        // depth in rg\n        pack.g = fract(depth * 255.0);\n        pack.r = depth - pack.g / 255.0;\n\n        // scatter 6 bits\n        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;\n    \n    }\n\n    // profile on 2 lower bits\n    pack.b -= mod(pack.b, 4.0 / 255.0);\n    pack.b += profile / 255.0; // 3 profile possible for sss\n\n    return pack;\n}\n"
        },
        Lebq: e => {
            e.exports = 'uniform float uEnvironmentExposure;\r\nuniform mat3 uEnvironmentTransform;\r\nuniform vec2 uTextureEnvironmentSpecularPBRLodRange;\r\nuniform vec2 uTextureEnvironmentSpecularPBRTextureSize;\r\nuniform vec3 uDiffuseSPH[9];\r\n\r\n#ifdef HAS_ENVIRONMENT_BRDF\r\nuniform sampler2D sIntegrateBRDF;\r\n#endif\r\n\r\nvec3 computeDiffuseSPH(const in vec3 normal) {\r\n    vec3 n = uEnvironmentTransform * normal;\r\n    // https://github.com/cedricpinson/envtools/blob/master/Cubemap.cpp#L523\r\n    vec3 result =\r\n        uDiffuseSPH[0] +\r\n        uDiffuseSPH[1] * n.y +\r\n        uDiffuseSPH[2] * n.z +\r\n        uDiffuseSPH[3] * n.x +\r\n        uDiffuseSPH[4] * n.y * n.x +\r\n        uDiffuseSPH[5] * n.y * n.z +\r\n        uDiffuseSPH[6] * (3.0 * n.z * n.z - 1.0) +\r\n        uDiffuseSPH[7] * (n.z * n.x) +\r\n        uDiffuseSPH[8] * (n.x * n.x - n.y * n.y);\r\n     return max(result, vec3(0.0));\r\n}\r\n\r\n#ifndef HAS_LEGACY_CLASSIC\r\n\r\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/BRDF.ush#L202\r\nvec3 integrateBRDF(const in vec3 specular, const in float roughness, const in float NoV, const in float f90) {\r\n#ifdef HAS_ENVIRONMENT_BRDF\r\n    vec4 rgba = texture2D(sIntegrateBRDF, vec2(NoV, roughness));\r\n    float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);\r\n    float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);\r\n    const float div = 1.0 / 65535.0;\r\n    return (specular * a + b * f90) * div;\r\n#else\r\n    // https://www.unrealengine.com/blog/physically-based-shading-on-mobile\r\n    // TODO should we use somehow specular f0 ?\r\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\r\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\r\n    vec4 r = roughness * c0 + c1;\r\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\r\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n    return specular * AB.x + AB.y * f90;\r\n#endif\r\n}\r\n\r\n// Frostbite, Lagarde paper p67\r\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\nfloat linRoughnessToMipmap(const in float roughnessLinear) {\r\n    return sqrt(roughnessLinear);\r\n}\r\n\r\n#ifdef ENV_CUBEMAP\r\nuniform samplerCube sSpecularPBR;\r\n#pragma include "utils/cubemapLod.glsl"\r\n#endif\r\n\r\n#ifdef ENV_PANORAMA\r\nuniform sampler2D sSpecularPBR;\r\n#pragma include "utils/panoramaLod.glsl"\r\n#endif\r\n\r\nvec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {\r\n    float smoothness = 1.0 - realRoughness;\r\n    float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\r\n    // The result is not normalized as we fetch in a cubemap\r\n    return mix(N, R, lerpFactor);\r\n}\r\n\r\nvec3 getPrefilteredEnvMapColor(const in vec3 normal, const in vec3 eyeVector, const in float roughness, const in vec3 frontNormal) {\r\n    vec3 R = reflect(-eyeVector, normal);\r\n\r\n    // specular dominant dir is using the bentNormal in the anisotropy scenario\r\n    // if we want to get rid of the dominant dir but still have a matching result with anisotropy=0 we could try:\r\n    // R = mix(getSpecularDominantDir(normal, R, roughness), R, anisotropy);\r\n    R = getSpecularDominantDir(normal, R, roughness);\r\n\r\n#ifdef ENV_CUBEMAP\r\n    vec3 prefilteredColor = prefilterEnvMapCube(roughness, uEnvironmentTransform * R);\r\n#else\r\n    vec3 prefilteredColor = prefilterEnvMapPanorama(roughness, uEnvironmentTransform * R);\r\n#endif\r\n\r\n    // http://marmosetco.tumblr.com/post/81245981087\r\n    // marmoset uses 1.3, we force it to 1.0\r\n    float factor = clamp(1.0 + dot(R, frontNormal), 0.0, 1.0);\r\n    prefilteredColor *= factor * factor;\r\n    return prefilteredColor;\r\n}\r\n\r\nvec3 computeIBLSpecularUE4(const in vec3 normal, const in vec3 eyeVector, const in float roughness, const in vec3 specular, const in vec3 frontNormal, const in float f90) {\r\n    float NoV = dot(normal, eyeVector);\r\n    return getPrefilteredEnvMapColor(normal, eyeVector, roughness, frontNormal) * integrateBRDF(specular, roughness, NoV, f90);\r\n}\r\n\r\n#endif\r\n'
        },
        GDcI: e => {
            e.exports = "// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html\n// introduced slightly darker colors and more slight banding in the darks.\n\n// so we stick with the reference implementation (except we don't check if color >= 0.0):\n// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt\n#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055\n#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)\n\nfloat linearTosRGB(const in float color) { return LIN_SRGB(color); }\nvec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }\nvec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }\n\nfloat sRGBToLinear(const in float color) { return SRGB_LIN(color); }\nvec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }\nvec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }\n\n//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\nvec3 RGBMToRGB( const in vec4 rgba ) {\n    const float maxRange = 8.0;\n    return rgba.rgb * maxRange * rgba.a;\n}\n\nconst mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );\n\nvec3 LUVToRGB( const in vec4 vLogLuv ) {\n    float Le = vLogLuv.z * 255.0 + vLogLuv.w;\n    vec3 Xp_Y_XYZp;\n    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;\n    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;\n    vec3 vRGB = LUVInverse * Xp_Y_XYZp;\n    return max(vRGB, 0.0);\n}\n\n// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\nvec4 encodeRGBM(const in vec3 color, const in float range) {\n    if(range <= 0.0) return vec4(color, 1.0);\n    vec4 rgbm;\n    vec3 col = color / range;\n    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );\n    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;\n    rgbm.rgb = col / rgbm.a;\n    return rgbm;\n}\n\nvec3 decodeRGBM(const in vec4 color, const in float range) {\n    if(range <= 0.0) return color.rgb;\n    return range * color.rgb * color.a;\n}\n"
        },
        hWsA: e => {
            e.exports = "float getLuminance(const in vec3 color) {\n    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\n    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);\n    return dot(color, colorBright);\n}\n"
        },
        fvmo: e => {
            e.exports = "#define LIGHT_SPOT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTION 2\n#define LIGHT_HEMI 3\n\n%UNROLL 4%\n#ifdef LIGHT_TYPE_%ID%\n    uniform vec4 utestdemo2024Light%ID%_diffuse;\n\n    #if LIGHT_TYPE_%ID% == LIGHT_DIRECTION\n        uniform vec3 utestdemo2024Light%ID%_viewDirection;\n    #elif LIGHT_TYPE_%ID% == LIGHT_SPOT\n        uniform vec3 utestdemo2024Light%ID%_viewDirection;\n        uniform vec4 utestdemo2024Light%ID%_viewPosition;\n        uniform float utestdemo2024Light%ID%_spotBlend;\n        uniform float utestdemo2024Light%ID%_spotCutOff;\n        uniform vec4 utestdemo2024Light%ID%_attenuation;\n    #elif LIGHT_TYPE_%ID% == LIGHT_POINT\n        uniform vec4 utestdemo2024Light%ID%_viewPosition;\n        uniform vec4 utestdemo2024Light%ID%_attenuation;\n    #elif LIGHT_TYPE_%ID% == LIGHT_HEMI\n        uniform vec4 utestdemo2024Light%ID%_ground;\n        uniform vec3 utestdemo2024Light%ID%_viewDirection;\n    #endif\n#endif // LIGHT_TYPE\n%%\n\nfloat getLightAttenuation(const in float dist, const in vec4 lightAttenuation) {\n    // lightAttenuation(constantEnabled, linearEnabled, quadraticEnabled)\n    // TODO find a vector alu instead of 4 scalar\n    float constant = lightAttenuation.x;\n    float linear = lightAttenuation.y * dist;\n    float quadratic = lightAttenuation.z * dist * dist;\n    return 1.0 / (constant + linear + quadratic);\n}\n\nvoid precomputeSpot(\n        const in vec3 normal,\n        const in vec3 viewVertex,\n                          \n        const in vec3 lightViewDirection,\n        const in vec4 lightAttenuation,\n        const in vec3 lightViewPosition,\n        const in float lightSpotCutOff,\n        const in float lightSpotBlend,\n                          \n        out float attenuation,\n        out vec3 eyeLightDir,\n        out float dotNL) {\n\n    eyeLightDir = lightViewPosition - viewVertex;\n    float dist = length(eyeLightDir);\n    eyeLightDir = dist > 0.0 ? eyeLightDir / dist : vec3( 0.0, 1.0, 0.0 );\n\n    float cosCurAngle = dot(-eyeLightDir, lightViewDirection);\n    float spot = cosCurAngle * smoothstep(0.0, 1.0, (cosCurAngle - lightSpotCutOff) / lightSpotBlend);\n\n    dotNL = dot(eyeLightDir, normal);\n    attenuation = spot * getLightAttenuation(dist, lightAttenuation);\n}\n\nvoid precomputePoint(\n        const in vec3 normal,\n        const in vec3 viewVertex,\n\n        const in vec4 lightAttenuation,\n        const in vec3 lightViewPosition,\n\n        out float attenuation,\n        out vec3 eyeLightDir,\n        out float dotNL) {\n\n    eyeLightDir = lightViewPosition - viewVertex;\n    float dist = length(eyeLightDir);\n\n    attenuation = getLightAttenuation(dist, lightAttenuation);\n    eyeLightDir = dist > 0.0 ? eyeLightDir / dist :  vec3( 0.0, 1.0, 0.0 );\n    dotNL = dot(eyeLightDir, normal);\n}\n\nvoid precomputeSun(\n        const in vec3 normal,\n        const in vec3 lightViewDirection,\n  \n        out float attenuation,\n        out vec3 eyeLightDir,\n        out float dotNL) {\n\n    attenuation = 1.0;\n    eyeLightDir = -lightViewDirection;\n    dotNL = dot(eyeLightDir, normal);\n}"
        },
        "U/h/": e => {
            e.exports = '#pragma include "utils/lightCommon.glsl"\n\n////////////////\n// COOK TORRANCE\n////////////////\nvec3 specularCookTorrance(\n        const in vec3 normal,\n        const in vec3 lightDir,\n        const in vec3 eyeVector,\n        const in float materialShininess,\n        const in vec3 materialSpecular,\n        const in vec3 lightSpecular) {\n  \n    vec3 h = normalize(eyeVector + lightDir);\n    float nh = dot(normal, h);\n    float specfac = 0.0;\n\n    if(nh > 0.0) {\n        float nv = max( dot(normal, eyeVector), 0.0 );\n        float i = pow(nh, materialShininess);\n        i = i / (0.1 + nv);\n        specfac = i;\n    }\n    // ugly way to fake an energy conservation (mainly to avoid super bright stuffs with low glossiness)\n    float att = materialShininess > 100.0 ? 1.0 : smoothstep(0.0, 1.0, materialShininess * 0.01);\n    return specfac * materialSpecular * lightSpecular * att;\n}\n\nvec3 lambert(const in float dotNL,  const in vec3 materialDiffuse, const in vec3 lightDiffuse) {\n    return dotNL * materialDiffuse * lightDiffuse;\n}\n\nvoid computeLightLambertCookTorrance(\n        const in vec3 normal,\n        const in vec3 eyeVector,\n        const in float dotNL,\n        const in float attenuation,\n\n        const in vec3 materialDiffuse,\n        const in vec3 materialSpecular,\n        const in float materialShininess,\n\n        const in vec3 lightDiffuse,\n        const in vec3 lightSpecular,\n        const in vec3 eyeLightDir,\n\n        out vec3 diffuseOut,\n        out vec3 specularOut,\n        out bool lighted) {\n\n    lighted = dotNL > 0.0;\n    if (lighted == false) {\n        specularOut = diffuseOut = vec3(0.0);\n        return;\n    }\n\n    specularOut = attenuation * specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular);\n    diffuseOut = attenuation * lambert(dotNL, materialDiffuse, lightDiffuse);\n}\n\n///////\n// HEMI\n///////\nvoid hemiLight(\n        const in vec3 normal,\n        const in vec3 eyeVector,\n        const in float dotNL,\n        const in vec3 eyeLightDir,\n\n        const in vec3 materialDiffuse,\n        const in vec3 materialSpecular,\n        const in float materialShininess,\n\n        const in vec3 lightDiffuse,\n        const in vec3 lightGround,\n\n        out vec3 diffuseOut,\n        out vec3 specularOut,\n        out bool lighted) {\n\n    lighted = false;\n    float weight = 0.5 * dotNL + 0.5;\n    diffuseOut = materialDiffuse * mix(lightGround, lightDiffuse, weight);\n\n    // same cook-torrance as above for sky/ground\n    float skyWeight = 0.5 * dot(normal, normalize(eyeVector + eyeLightDir)) + 0.5;\n    float gndWeight = 0.5 * dot(normal, normalize(eyeVector - eyeLightDir)) + 0.5;\n    float skySpec = pow(skyWeight, materialShininess);\n    float skyGround = pow(gndWeight, materialShininess);\n    float divisor = (0.1 + max( dot(normal, eyeVector), 0.0 ));\n    float att = materialShininess > 100.0 ? 1.0 : smoothstep(0.0, 1.0, materialShininess * 0.01);\n    \n    specularOut = lightDiffuse * materialSpecular * weight * att * (skySpec + skyGround) / divisor;\n}\n'
        },
        uMel: e => {
            e.exports = '#pragma include "utils/common.glsl"\n#pragma include "utils/lightCommon.glsl"\n\nvec4 precomputeGGX(const in vec3 normal, const in vec3 eyeVector, const in float roughness) {\n    float NoV = saturate(dot(normal, eyeVector));\n    float r2 = roughness * roughness;\n    return vec4(r2, r2 * r2, NoV, NoV * (1.0 - r2));\n}\n\n// Walter et al. 2007, "Microfacet models for refraction through rough surfaces"\nfloat D_GGX(const vec4 precomputeGGX, const float NoH) {\n    float a2 = precomputeGGX.y;\n    float d = (NoH * a2 - NoH) * NoH + 1.0;\n    return a2 / (PI * d * d);\n}\n\n// Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"\nvec3 F_Schlick(const vec3 f0, const float f90, const in float VoH) {\n    float VoH5 = pow(1.0 - VoH, 5.0);\n    return f90 * VoH5 + (1.0 - VoH5) * f0;\n}\n\n// greyscale f0 version (clearcoat)\nfloat F_Schlick(const float f0, const float f90, const in float VoH) {\n    return f0 + (f90 - f0) * pow(1.0 - VoH, 5.0);\n}\n\n\n// Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"\nfloat V_SmithCorrelated(const vec4 precomputeGGX, const float NoL) {\n    float a = precomputeGGX.x;\n    float smithV = NoL * (precomputeGGX.w + a);\n    float smithL = precomputeGGX.z * (NoL * (1.0 - a) + a);\n    return 0.5 / (smithV + smithL);\n    // same as\n    // Hammon 2017, "PBR Diffuse Lighting for GGX+Smith Microsurfaces"\n    // return 0.5 / mix(2.0 * NoL * NoV, NoL + NoV, precomputeGGX.y)\n}\n\nvec3 specularLobe(const vec4 precomputeGGX, const vec3 normal, const vec3 eyeVector, const vec3 eyeLightDir, const vec3 specular, const float NoL, const float f90) {\n    vec3 H = normalize(eyeVector + eyeLightDir);\n    float NoH = saturate(dot(normal, H));\n    float VoH = saturate(dot(eyeLightDir, H));\n\n    // distribution / visibility / fresnel\n    float D = D_GGX(precomputeGGX, NoH);\n    float V = V_SmithCorrelated(precomputeGGX, NoL);\n    vec3 F = F_Schlick(specular, f90, VoH);\n\n    return (D * V * PI) * F; // we multipy by PI because our diffuse is not divided by PI\n}\n\n// pure compute Light PBR\nvoid computeLightLambertGGX(\n    const in vec3 normal,\n    const in vec3 eyeVector,\n    const in float NoL,\n    const in vec4 precomputeGGX,\n\n    const in vec3 diffuse,\n    const in vec3 specular,\n\n    const in float attenuation,\n    const in vec3 lightColor,\n    const in vec3 eyeLightDir,\n    const in float f90,\n\n    out vec3 diffuseOut,\n    out vec3 specularOut,\n    out bool lighted) {\n\n    lighted = NoL > 0.0;\n    if (lighted == false) {\n        specularOut = diffuseOut = vec3(0.0);\n        return;\n    }\n\n    vec3 colorAttenuate = attenuation * NoL * lightColor;\n    specularOut = colorAttenuate * specularLobe(precomputeGGX, normal, eyeVector, eyeLightDir, specular, NoL, f90);\n    diffuseOut = colorAttenuate * diffuse;\n}\n\n/////////////\n// ANISOTROPY\n/////////////\n\nfloat V_SmithGGXCorrelated_Anisotropic(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL) {\n    // Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"\n    // UE4 version : https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/BRDF.ush#L270-L286\n    float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n    float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n    return 0.5 / (lambdaV + lambdaL);\n}\n\nfloat D_GGX_Anisotropic(const float at, const float ab, const float ToH, const float BoH, const float NoH) {\n    // Burley 2012, "Physically-Based Shading at Disney"\n    // https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L81\n    // similar to UE4 version https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/BRDF.ush#L232-L238\n    float a2 = at * ab;\n    vec3 d = vec3(ab * ToH, at * BoH, a2 * NoH);\n    float x = a2 / dot(d, d);\n    return a2 * (x * x) / PI;\n}\n\nvec3 anisotropicLobe(\n    const vec4 precomputeGGX,\n    const vec3 normal,\n    const vec3 eyeVector,\n\n    const vec3 eyeLightDir,\n    const vec3 specular,\n    const float NoL,\n    const float f90,\n\n    const in vec3 anisotropicT,\n    const in vec3 anisotropicB,\n    const in float anisotropy) {\n\n    vec3 H = normalize(eyeVector + eyeLightDir);\n    float NoH = saturate(dot(normal, H));\n    float NoV = saturate(dot(normal, eyeVector));\n    float VoH = saturate(dot(eyeLightDir, H));\n\n    float ToV = dot(anisotropicT, eyeVector);\n    float BoV = dot(anisotropicB, eyeVector);\n    float ToL = dot(anisotropicT, eyeLightDir);\n    float BoL = dot(anisotropicB, eyeLightDir);\n    float ToH = dot(anisotropicT, H);\n    float BoH = dot(anisotropicB, H);\n\n    // slide 26, Disney 2012, "Physically Based Shading at Disney"\n    // https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n    float aspect = sqrt(1.0 - abs(anisotropy) * 0.9);\n    if (anisotropy > 0.0) aspect = 1.0 / aspect;\n    float at = precomputeGGX.x * aspect;\n    float ab = precomputeGGX.x / aspect;\n\n    // slide 24, Kulla 2017, "Revisiting Physically Based Shading at Imageworks"\n    // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n    // float at = max(0.002025, precomputeGGX.x * (1.0 + anisotropy));\n    // float ab = max(0.002025, precomputeGGX.x * (1.0 - anisotropy));\n\n    // specular anisotropic BRDF\n    float D = D_GGX_Anisotropic(at, ab, ToH, BoH, NoH);\n    float V = V_SmithGGXCorrelated_Anisotropic(at, ab, ToV, BoV, ToL, BoL, NoV, NoL);\n    vec3 F = F_Schlick(specular, f90, VoH);\n\n    return (D * V * PI) * F;\n}\n\nvoid computeLightLambertGGXAnisotropy(\n    const in vec3 normal,\n    const in vec3 eyeVector,\n    const in float NoL,\n    const in vec4 precomputeGGX,\n\n    const in vec3 diffuse,\n    const in vec3 specular,\n\n    const in float attenuation,\n    const in vec3 lightColor,\n    const in vec3 eyeLightDir,\n    const in float f90,\n\n    const in vec3 anisotropicT,\n    const in vec3 anisotropicB,\n    const in float anisotropy,\n\n    out vec3 diffuseOut,\n    out vec3 specularOut,\n    out bool lighted) {\n\n    lighted = NoL > 0.0;\n    if (lighted == false) {\n        specularOut = diffuseOut = vec3(0.0);\n        return;\n    }\n\n    vec3 colorAttenuate = attenuation * NoL * lightColor;\n    specularOut = colorAttenuate * anisotropicLobe(precomputeGGX, normal, eyeVector, eyeLightDir, specular, NoL, f90, anisotropicT, anisotropicB, anisotropy);\n    diffuseOut = colorAttenuate * diffuse;\n}\n'
        },
        rSdO: e => {
            e.exports = '#pragma include "utils/common.glsl"\n#pragma include "utils/lightCommon.glsl"\n\n///////////////////////////\n/// SUBSURFACE TRANSLUCENCY\n///////////////////////////\nvec3 computeLightSSS(\n        const in float dotNL,\n        const in float attenuation,\n        const in float thicknessFactor,\n        const in vec3 translucencyColor,\n        const in float translucencyFactor,\n        const in float shadowDistance,\n        const in vec3 diffuse,\n        const in vec3 lightColor) {\n\n    // http://blog.stevemcauley.com/2011/12/03/energy-conserving-wrapped-diffuse/\n    // float scatter = 0.5;\n    // float wrap = saturate((dotNL + scatter) / ((1.0 + scatter) * (1.0 + scatter)));\n\n    // https://github.com/iryoku/separable-sss/blob/master/SeparableSSS.h#L362\n    float wrap = saturate(0.3 - dotNL);\n    float thickness = max(0.0, shadowDistance / max(0.001, thicknessFactor));\n\n    // http://www.crytek.com/download/2014_03_25_CRYENGINE_GDC_Schultz.pdf\n    // skin approximation vec3(0.98, 0.3, 0.2)\n    float finalAttenuation = translucencyFactor * attenuation * wrap;\n    return finalAttenuation * lightColor * diffuse * exp(-thickness / max(translucencyColor, vec3(0.001))); \n}\n'
        },
        "HUu/": e => {
            e.exports = '#define MIN_ROUGHNESS 0.045\n\n#pragma include "utils/functions.glsl"\n\n#ifdef HAS_OPACITY_REFRACTION\n    float gRefractionRoughness; // global variable (simpler to handle in order to re-use rough/gloss fetch)\n#endif\n\n#ifdef HAS_VERTEX_COLOR\n    varying vec4 vColor;\n\n    vec3 getVertexColor() {\n        return COLOR_CONVERT_VERTEX_COLOR(vColor.rgb);\n    }\n#endif\n\n// METALNESS WORKFLOW\n#ifdef HAS_ALBEDOPBR\n    uniform float uAlbedoPBRFactor;\n\n    vec3 getMaterialAlbedo() {\n        vec3 albedo;\n        #ifdef SAMPLER_ALBEDOPBR\n            albedo = uAlbedoPBRFactor * COLOR_CONVERT_ALBEDOPBR(texture2D(SAMPLER_ALBEDOPBR, UV_ALBEDOPBR).PACK_ALBEDOPBR);\n        #else\n            albedo = vec3(uAlbedoPBRFactor);\n        #endif\n\n        #ifdef HAS_VERTEX_COLOR\n            albedo *= getVertexColor();\n        #endif\n\n        return albedo;\n    }\n#endif\n\n#ifdef HAS_METALNESSPBR\n    uniform float uMetalnessPBRFactor;\n\n    float getMaterialMetalness() {\n        #ifdef SAMPLER_METALNESSPBR\n            return uMetalnessPBRFactor * COLOR_CONVERT_METALNESSPBR(texture2D(SAMPLER_METALNESSPBR, UV_METALNESSPBR).PACK_METALNESSPBR);\n        #else\n            return uMetalnessPBRFactor;\n        #endif\n    }\n#endif\n\n#ifdef HAS_SPECULARF0\n    uniform float uSpecularF0Factor;\n\n    float getMaterialF0() {\n        #ifdef SAMPLER_SPECULARF0\n            return uSpecularF0Factor * COLOR_CONVERT_SPECULARF0(texture2D(SAMPLER_SPECULARF0, UV_SPECULARF0).PACK_SPECULARF0);\n        #else\n            return uSpecularF0Factor;\n        #endif\n    }\n#endif\n\n// SPECULAR WORKFLOW\n#ifdef HAS_DIFFUSEPBR\n    uniform float uDiffusePBRFactor;\n\n    vec3 getMaterialDiffuse() {\n        vec3 diffuse;\n        #ifdef SAMPLER_DIFFUSEPBR\n            diffuse = uDiffusePBRFactor * COLOR_CONVERT_DIFFUSEPBR(texture2D(SAMPLER_DIFFUSEPBR, UV_DIFFUSEPBR).PACK_DIFFUSEPBR);\n        #else\n            diffuse = vec3(uDiffusePBRFactor);\n        #endif\n\n        #ifdef HAS_VERTEX_COLOR\n            diffuse *= getVertexColor();\n        #endif\n\n        return diffuse;\n    }\n#endif\n\n#ifdef HAS_SPECULARPBR\n    uniform float uSpecularPBRFactor;\n\n    vec3 getMaterialSpecular() {\n        #ifdef SAMPLER_SPECULARPBR\n            return uSpecularPBRFactor * COLOR_CONVERT_SPECULARPBR(texture2D(SAMPLER_SPECULARPBR, UV_SPECULARPBR).PACK_SPECULARPBR);\n        #else\n            return vec3(uSpecularPBRFactor);\n        #endif\n    }\n#endif\n\n// MICROSURFACE\n#ifdef HAS_ROUGHNESSPBR\n    uniform float uRoughnessPBRFactor;\n\n    float getMaterialRoughness() {\n        #ifdef SAMPLER_ROUGHNESSPBR\n            float fetch = COLOR_CONVERT_ROUGHNESSPBR(texture2D(SAMPLER_ROUGHNESSPBR, UV_ROUGHNESSPBR).PACK_ROUGHNESSPBR);\n\n            #ifdef HAS_REFRACTION_MICROSURFACE\n                gRefractionRoughness *= fetch;\n            #endif\n\n            return uRoughnessPBRFactor * fetch;\n        #else\n            return uRoughnessPBRFactor;\n        #endif\n    }\n#endif\n\n#ifdef HAS_GLOSSINESSPBR\n    uniform float uGlossinessPBRFactor;\n\n    float getMaterialGlossiness() {\n        #ifdef SAMPLER_GLOSSINESSPBR\n            float fetch = COLOR_CONVERT_GLOSSINESSPBR(texture2D(SAMPLER_GLOSSINESSPBR, UV_GLOSSINESSPBR).PACK_GLOSSINESSPBR);\n\n            #ifdef HAS_REFRACTION_MICROSURFACE\n                gRefractionRoughness = mix(1.0 - fetch, 1.0, gRefractionRoughness);\n            #endif\n\n            return uGlossinessPBRFactor * fetch;\n        #else\n            return uGlossinessPBRFactor;\n        #endif\n    }\n#endif\n\n\n#ifdef HAS_EMITCOLOR\n    uniform float uEmitColorFactor;\n    uniform int uEmitMultiplicative;\n\n    vec3 getMaterialEmitColor() {\n        #ifdef SAMPLER_EMITCOLOR\n            return uEmitColorFactor * COLOR_CONVERT_EMITCOLOR(texture2D(SAMPLER_EMITCOLOR, UV_EMITCOLOR).PACK_EMITCOLOR);\n        #else\n            return vec3(0.0);\n        #endif\n    }\n#endif\n\n#ifdef HAS_AOPBR\n    uniform float uAOPBRFactor;\n    uniform int uAOPBROccludeSpecular;\n\n    float getMaterialAO() {\n        return mix(1.0, COLOR_CONVERT_AOPBR(texture2D(SAMPLER_AOPBR, UV_AOPBR).PACK_AOPBR), uAOPBRFactor);\n    }\n#endif\n\n#ifdef HAS_CAVITYPBR\n    uniform float uCavityPBRFactor;\n\n    float getMaterialCavity() {\n        return mix(1.0, COLOR_CONVERT_CAVITYPBR(texture2D(SAMPLER_CAVITYPBR, UV_CAVITYPBR).PACK_CAVITYPBR), uCavityPBRFactor);\n    }\n#endif\n\n#ifdef HAS_SUBSURFACETRANSLUCENCY\n    uniform float uSubsurfaceTranslucencyFactor;\n    uniform float uSubsurfaceTranslucencyThicknessFactor;\n    uniform vec3 uSubsurfaceTranslucencyColor;\n\n    float getMaterialTranslucency() {\n        #ifdef SAMPLER_SUBSURFACETRANSLUCENCY\n            return uSubsurfaceTranslucencyFactor * COLOR_CONVERT_SUBSURFACETRANSLUCENCY(texture2D(SAMPLER_SUBSURFACETRANSLUCENCY, UV_SUBSURFACETRANSLUCENCY).PACK_SUBSURFACETRANSLUCENCY);\n        #else\n            return uSubsurfaceTranslucencyFactor;\n        #endif\n    }\n#endif\n\n#ifdef HAS_NORMALMAP\n    uniform float uNormalMapFactor;\n    uniform int uNormalMapFlipY;\n\n    vec3 getMaterialNormalMap() {\n        vec3 nmap = COLOR_CONVERT_NORMALMAP(texture2D(SAMPLER_NORMALMAP, UV_NORMALMAP).PACK_NORMALMAP) * 2.0 - 1.0;\n        nmap.y = uNormalMapFlipY == 1 ? -nmap.y : nmap.y;\n        return nmap;\n    }\n#endif\n\n#ifdef HAS_BUMPMAP\n    uniform float uBumpMapFactor;\n    uniform vec2 uBumpMapSize;\n\n    vec2 getMaterialBumpMap() {\n        vec2 bump;\n        vec3 invSize = vec3(1.0 / uBumpMapSize, 0.0);\n        return uBumpMapFactor * vec2(COLOR_CONVERT_BUMPMAP(texture2D(SAMPLER_BUMPMAP, UV_BUMPMAP - invSize.xz).PACK_BUMPMAP)\n                                    - COLOR_CONVERT_BUMPMAP(texture2D(SAMPLER_BUMPMAP, UV_BUMPMAP + invSize.xz).PACK_BUMPMAP),\n                                    COLOR_CONVERT_BUMPMAP(texture2D(SAMPLER_BUMPMAP, UV_BUMPMAP - invSize.zy).PACK_BUMPMAP)\n                                    -COLOR_CONVERT_BUMPMAP(texture2D(SAMPLER_BUMPMAP, UV_BUMPMAP + invSize.zy).PACK_BUMPMAP));\n    }\n#endif\n\n#ifdef HAS_SUBSURFACESCATTERING\n    uniform float uSubsurfaceScatteringProfile;\n    uniform float uSubsurfaceScatteringFactor;\n    uniform float uScatteringFactorPacker;\n\n    float getMaterialScattering() {\n        #ifdef SAMPLER_SUBSURFACESCATTERING\n            return uScatteringFactorPacker * uSubsurfaceScatteringFactor * COLOR_CONVERT_SUBSURFACESCATTERING(texture2D(SAMPLER_SUBSURFACESCATTERING, UV_SUBSURFACESCATTERING).PACK_SUBSURFACESCATTERING);\n        #else\n            return uScatteringFactorPacker * uSubsurfaceScatteringFactor;\n        #endif\n    }\n#endif\n\n#ifdef HAS_ALPHAMASK\n    uniform float uAlphaMaskFactor;\n    uniform int uAlphaMaskInvert;\n\n    float getMaterialAlphaMask() {\n      float alpha = 1.0;\n\n     #ifdef SAMPLER_ALPHAMASK\n      alpha = COLOR_CONVERT_ALPHAMASK(texture2D(SAMPLER_ALPHAMASK, UV_ALPHAMASK).PACK_ALPHAMASK);\n      if (uAlphaMaskInvert == 1) alpha = 1.0 - alpha;\n    #endif\n\n    #ifdef HAS_VERTEX_ALPHA\n      alpha *= vColor.a;\n    #endif\n\n      return alpha;\n  }\n#endif\n\n#ifdef HAS_OPACITY\n    uniform float uOpacityFactor;\n    uniform int uOpacityInvert;\n\n    #ifdef HAS_OPACITY_DITHER\n        uniform float uOpacityThinLayer;\n        uniform int uOpacityDithering;\n    #endif\n\n    #ifdef HAS_OPACITY_BLEND_OR_ADDITIVE\n        uniform int uOpacityAdditive;\n    #endif\n\n    #ifdef HAS_OPACITY_REFRACTION\n        uniform float uOpacityRoughnessFactor;\n    #endif\n\n    float getMaterialOpacity() {\n        float alpha = 1.0;\n\n        #ifdef SAMPLER_OPACITY\n            alpha = COLOR_CONVERT_OPACITY(texture2D(SAMPLER_OPACITY, UV_OPACITY).PACK_OPACITY);\n            if (uOpacityInvert == 1) alpha = 1.0 - alpha;\n        #endif\n\n        #ifndef HAS_OPACITY_DITHER\n            alpha *= uOpacityFactor;\n        #endif\n\n        #ifdef HAS_VERTEX_ALPHA\n            alpha *= vColor.a;\n        #endif\n\n        return alpha;\n    }\n#endif // HAS_OPACITY\n\n\n#ifdef HAS_CLEARCOAT\n    uniform vec3 uClearCoatTint;\n    uniform float uClearCoatThickness;\n    uniform float uClearCoatIor;\n    uniform float uClearCoatFactor;\n    uniform float uClearCoatF0;\n\n    float getMaterialClearCoat() {\n        #ifdef SAMPLER_CLEARCOAT\n            return uClearCoatFactor * COLOR_CONVERT_CLEARCOAT(texture2D(SAMPLER_CLEARCOAT, UV_CLEARCOAT).PACK_CLEARCOAT);\n        #else\n            return uClearCoatFactor;\n        #endif\n    }\n#endif\n\n#ifdef HAS_CLEARCOATROUGHNESS\n    uniform float uClearCoatRoughnessFactor;\n\n    float getMaterialClearCoatRoughness() {\n        #ifdef SAMPLER_CLEARCOATROUGHNESS\n            return uClearCoatRoughnessFactor * COLOR_CONVERT_CLEARCOATROUGHNESS(texture2D(SAMPLER_CLEARCOATROUGHNESS, UV_CLEARCOATROUGHNESS).PACK_CLEARCOATROUGHNESS);\n        #else\n            return uClearCoatRoughnessFactor;\n        #endif\n    }\n#endif\n\n#ifdef HAS_CLEARCOATNORMALMAP\n    uniform float uClearCoatNormalMapFactor;\n    uniform int uClearCoatNormalMapFlipY;\n\n    vec3 getMaterialClearCoatNormal() {\n        vec3 nmap = COLOR_CONVERT_CLEARCOATNORMALMAP(texture2D(SAMPLER_CLEARCOATNORMALMAP, UV_CLEARCOATNORMALMAP).PACK_CLEARCOATNORMALMAP) * 2.0 - 1.0;\n        nmap.y = uClearCoatNormalMapFlipY == 1 ? -nmap.y : nmap.y;\n        return nmap;\n    }\n#endif\n\n#ifdef HAS_ANISOTROPY\n    uniform float uAnisotropyFactor;\n    uniform float uAnisotropyDirection;\n    uniform int uAnisotropyFlipXY;\n\n    #ifdef SAMPLER_ANISOTROPY\n        vec2 getMaterialDirectionAnisotropy() {\n            vec2 dir = COLOR_CONVERT_ANISOTROPY(texture2D(SAMPLER_ANISOTROPY, UV_ANISOTROPY).PACK_ANISOTROPY) * 2.0 - 1.0;\n            if (uAnisotropyFlipXY == 1) dir.xy = dir.yx;\n            return dir;\n        }\n    #endif\n\n#endif\n\n\n#ifdef HAS_SHEEN\n\nuniform float uSheenFactor;\nuniform vec3 uSheenColorFactor;\nuniform float uSheenRoughnessFactor;\n\n\nfloat sheenLobe(const float sheenRoughness, const float NdotV, const float NdotL, const float NdotH) {\n  // Charlie Sheen distribution, Conty Estevez and Kulla Production Friendly Microfacet Sheen BRDF\n  float r =  sheenRoughness *  sheenRoughness;\n  float invAlpha  = 1.0 / r;\n  float cos2h = NdotH * NdotH;\n  // 0.0078125 => 2^(-14/2), so sin2h^2 > 0 in fp16\n  float sin2h = max(1.0 - cos2h, 0.0078125);\n  float D = (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n\n  // Sheen visibility (much faster than charlie sheen distribution)\n  // Ashikhmin and Premoze Distribution-based Brdfs\n  // also Neubelt and Pettineo Crafting a Next-gen Material Pipeline for The Order\n  float V = clamp(1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\n  return (D * V);\n}\n\nfloat getMaterialSheenRoughness(){\n#if defined(SAMPLER_SHEENROUGHNESS)\n  return uSheenRoughnessFactor * texture2D(SAMPLER_SHEENROUGHNESS, UV_SHEENROUGHNESS).PACK_SHEENROUGHNESS;\n#else\n  return uSheenRoughnessFactor;\n#endif\n}\n\nvec3 computeSheen(const vec3 normal, const vec3 lightDir, const vec3 eyeVector, const float sheenRoughness){\n\n  float NdotL = dot(normal, lightDir);\n  float NdotV = dot(normal, eyeVector);\n  vec3 H = normalize(lightDir + eyeVector);\n  float NdotH = dot(normal, H);\n\n  float sheenContribution = sheenLobe(max(0.04, sheenRoughness), NdotV, NdotL, NdotH);\n\n#if defined(SAMPLER_SHEEN)\n  vec3 sheenColor = uSheenFactor * uSheenColorFactor * COLOR_CONVERT_SHEEN(texture2D(SAMPLER_SHEEN, UV_SHEEN).PACK_SHEEN);\n#else\n  vec3 sheenColor = uSheenFactor * uSheenColorFactor;\n#endif\n\n  return max(vec3(0.0), sheenContribution * sheenColor);\n}\n\n#endif\n\n\n\n\n\n/////////////////\n// LEGACY CLASSIC\n/////////////////\n#ifdef HAS_LEGACY_CLASSIC\n    uniform vec2 uTextureEnvironmentSpecularTextureSize;\n    uniform samplerCube sEnvironmentSpecular;\n    uniform mat3 uEnvironmentTransform;\n\n    uniform float uReflection;\n\n    uniform float uDiffuseColorFactor;\n    uniform float uDiffuseIntensityFactor;\n        vec3 getMaterialLegacyDiffuse() {\n        vec3 diffuse = vec3(0.0);\n        #if defined(SAMPLER_DIFFUSECOLOR)\n            diffuse = uDiffuseColorFactor * COLOR_CONVERT_DIFFUSECOLOR(texture2D(SAMPLER_DIFFUSECOLOR, UV_DIFFUSECOLOR).PACK_DIFFUSECOLOR);\n        #elif defined(HAS_DIFFUSECOLOR)\n            diffuse = vec3(uDiffuseColorFactor);\n        #endif\n\n        #ifdef HAS_VERTEX_COLOR\n            diffuse *= getVertexColor();\n        #endif\n\n        #ifdef HAS_DIFFUSEINTENSITY\n            #ifdef SAMPLER_DIFFUSEINTENSITY\n                diffuse *= uDiffuseIntensityFactor * COLOR_CONVERT_DIFFUSEINTENSITY(texture2D(SAMPLER_DIFFUSEINTENSITY, UV_DIFFUSEINTENSITY).PACK_DIFFUSEINTENSITY);\n            #else\n                diffuse *= uDiffuseIntensityFactor;\n            #endif\n        #endif\n\n        return diffuse;\n    }\n\n    uniform float uSpecularColorFactor;\n        vec3 getMaterialLegacySpecular() {\n        #if defined(SAMPLER_SPECULARCOLOR)\n            return uSpecularColorFactor * COLOR_CONVERT_SPECULARCOLOR(texture2D(SAMPLER_SPECULARCOLOR, UV_SPECULARCOLOR).PACK_SPECULARCOLOR);\n        #elif defined(HAS_SPECULARCOLOR)\n            return vec3(uSpecularColorFactor);\n        #else\n            return vec3(0.0);\n        #endif\n    }\n\n    uniform float uSpecularHardnessFactor;\n    float getMaterialLegacyShininess() {\n        #if defined(SAMPLER_SPECULARHARDNESS)\n            return uSpecularHardnessFactor * COLOR_CONVERT_SPECULARHARDNESS(texture2D(SAMPLER_SPECULARHARDNESS, UV_SPECULARHARDNESS).PACK_SPECULARHARDNESS);\n        #elif defined(HAS_SPECULARHARDNESS)\n            return uSpecularHardnessFactor;\n        #else\n            return 0.0;\n        #endif\n    }\n\n#endif\n'
        },
        lyG1: e => {
            e.exports = "vec3 morphing(const in vec4 weights, const in vec3 vertex, const in vec3 target0) {\n    return mix(vertex, target0, weights[0]);\n}\n\nvec3 morphing(const in vec4 weights, const in vec3 vertex, const in vec3 target0, const in vec3 target1) {\n    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));\n    vecOut += target0 * weights[0];\n    vecOut += target1 * weights[1];\n    return vecOut;\n}\n\nvec3 morphing(const in vec4 weights, const in vec3 vertex, const in vec3 target0, const in vec3 target1, const in vec3 target2) {\n    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));\n    vecOut += target0 * weights[0];\n    vecOut += target1 * weights[1];\n    vecOut += target2 * weights[2];\n    return vecOut;\n}\n\nvec3 morphing(const in vec4 weights,const in vec3 vertex,const in vec3 target0,const in vec3 target1,const in vec3 target2,const in vec3 target3) {\n    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));\n    vecOut += target0 * weights[0];\n    vecOut += target1 * weights[1];\n    vecOut += target2 * weights[2];\n    vecOut += target3 * weights[3];\n    return vecOut;\n}\n"
        },
        "IK/+": e => {
            e.exports = "// version for vertex shader\nvec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {\n    vec3 tang =  normalize(tangent.xyz);\n    vec3 binormal = tangent.w * normalize(cross(normal, tang));\n    return normalize(normal + gradient.x * tang + gradient.y * binormal);\n}\n\n// #define transformNormal(f, tn, tex, b, n) n = f * n.xy; n = normalize(tex.x * t.xyz + tex.y * b + tex.z * n)\nvec3 transformNormal(const in float factor, in vec3 normal, const in vec3 t, const in vec3 b, in vec3 n) {\n    normal.xy = factor * normal.xy;\n    return normalize(normal.x * t + normal.y * b + normal.z * n);\n}\n\n// anisotropy transform\nvec3 transformTangent(in vec2 tangent, const in vec3 t, const in vec3 b) {\n    return normalize(tangent.x * t + tangent.y * b);\n}\n\n// #define transformBump(tex, t, b, n) n = normalize(tex.x * t.xyz + tex.y * b + n)\nvec3 transformBump(in vec2 bump, const in vec3 t, const in vec3 b, in vec3 n) {\n    return normalize(bump.x * t + bump.y * b + n);\n}\n#if HAS_NORMALMAP && COMPUTE_FRAGMENT_TANGENTS\n    float rsqrt(float a)\n    {\n        return pow(a, -0.5);\n    }\n\n    // #ifdef GL_OES_standard_derivatives\n\n    //     void tangentFrame(vec3 denormNormal, vec3 pos, vec2 texCoord, out vec3 T, out vec3 B, out vec3 N){\n    //         vec3 denormTangent =  dFdx(pos) * dFdy(texCoord.y) -dFdx(texCoord.y) * dFdy(pos);\n    //         T = normalize(denormTangent - denormNormal * dot(denormNormal, denormTangent));\n    //         N = normalize(denormNormal);\n    //         B = cross(N, T);\n    //         float invmax = rsqrt(max(dot(T, T), dot(B, B)));\n    //         T *= invmax;\n    //         B *= invmax;\n    //     }\n\n    //     void makeTBN(out vec4 tangent, out vec3 binormal, in vec3 viewNormal, in vec3 viewPos, in vec2 uv){   \n    //         float renormFactor = 1.0 / length(viewNormal);\n    //         vec3 nrmBaseNormal = ((gl_FrontFacing ? 1.0 : -1.0 ) * renormFactor) * viewNormal;\n\n    //         vec3 dPdx = dFdx(viewPos);\n    //         vec3 dPdy = -dFdy(viewPos);            \n    //         float flipSign = dot (dPdy, cross(nrmBaseNormal, dPdx)) < 0.0 ? -1.0 : 1.0;\n    //         vec3 T;\n    //         tangentFrame(nrmBaseNormal, viewPos, uv, T, binormal, nrmBaseNormal);            \n    //         tangent = vec4(T, flipSign);\n    //     }\n     \n    // #else\n        void makeTBN(out vec4 tangent, out vec3 binormal, in vec3 viewNormal, in vec3 viewPos, in vec2 uv){                   \n            vec3 normal = normalize((gl_FrontFacing ? 1.0 : -1.0 ) * viewNormal);\n            tangent = vec4(normalize(cross(normal, vec3(0.0,1.0,0.0))), 1.0);\n            binormal = -normalize(cross(normal,tangent.xyz));              \n        }\n    // #endif\n\n#endif\n"
        },
        JBxq: e => {
            e.exports = '#pragma include "utils/functions.glsl"\r\n\r\nvec2 computeUVForMipmap(const in float level, const in vec2 uv) {\r\n    // width for level\r\n    float widthForLevel = exp2(uTextureEnvironmentSpecularPBRLodRange.x - level);\r\n\r\n    // the height locally for the level in pixel\r\n    // to opimitize a bit we scale down the v by two in the inputs uv\r\n    float heightForLevel = widthForLevel * 0.5;\r\n\r\n    // compact version\r\n    float texelSize = 1.0 / uTextureEnvironmentSpecularPBRTextureSize.x;\r\n    vec2 uvSpaceLocal =  vec2(1.0) + uv * vec2(widthForLevel - 2.0, heightForLevel - 2.0);\r\n    uvSpaceLocal.y += uTextureEnvironmentSpecularPBRTextureSize.x - widthForLevel;\r\n    return uvSpaceLocal * texelSize;\r\n}\r\n\r\n//for y up\r\nvec2 normalToPanoramaUVY(const in vec3 dir) {\r\n    float n = length(dir.xz);\r\n\r\n    // to avoid bleeding the max(-1.0,dir.x / n) is needed\r\n    vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);\r\n\r\n    // fix edge bleeding\r\n    if (pos.x > 0.0) pos.x = min(0.999999, pos.x);\r\n\r\n    pos = acos(pos) * 0.3183098861837907; // inv_pi\r\n\r\n    pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);\r\n\r\n    // shift u to center the panorama to -z\r\n    pos.x = mod(pos.x - 0.25 + 1.0, 1.0);\r\n    pos.y = 1.0 - pos.y;\r\n    return pos;\r\n}\r\n\r\nvec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R) {\r\n    float lod = min(uTextureEnvironmentSpecularPBRLodRange.x, linRoughnessToMipmap(rLinear) * uTextureEnvironmentSpecularPBRLodRange.y);\r\n    vec2 uvBase = normalToPanoramaUVY(R);\r\n\r\n    // // we scale down v here because it avoid to do twice in sub functions\r\n    // uvBase.y *= 0.5;\r\n\r\n    vec3 texel0 = LUVToRGB(texture2D(sSpecularPBR, computeUVForMipmap(floor(lod), uvBase)));\r\n    vec3 texel1 = LUVToRGB(texture2D(sSpecularPBR, computeUVForMipmap(ceil(lod), uvBase)));\r\n\r\n    return mix(texel0, texel1, fract(lod));\r\n}\r\n'
        },
        "58et": e => {
            e.exports = "\n// white vs interleaved vs blue noise\n// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n\n// to test in a shadertoy\n// https://www.shadertoy.com/view/lsdfD4\n\n// https://www.shadertoy.com/view/4djSRW\n// most combinations are possible : in[1,2,3] -> out[1,2,3]\n#define INT_SCALE1 .1031\nfloat pseudoRandom(const in vec2 fragCoord) {\n    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27\nfloat interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));\n}\n\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863\n// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]\nfloat ditheringNoise(const in vec2 fragCoord, const in float frameMod) {\n    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;\n    float fm = frameMod;\n    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);\n    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));\n    return (dither5 * 5.0 + noise) * (1.2 / 6.0);\n}\n\nvoid ditheringMaskingDiscard(\n    const in vec4 fragCoord,\n    const in int dithering,\n    const in float alpha,\n    const in float factor,\n\n    const in float thinLayer,\n\n    const in float frameMod,\n    const in vec2 nearFar,\n\n    const in vec4 halton) {\n\n    float rnd;\n\n    if (thinLayer == 0.0) {\n        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);\n        float sliceZ = floor(linZ * 500.0) / 500.0;\n        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);\n    } else {\n        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));\n    }\n\n    if ((alpha * factor) < rnd) discard;\n}\n"
        },
        "49g6": e => {
            e.exports = '#pragma include "utils/encodeDecode.glsl"\n#pragma include "utils/decodeDepth.glsl"\n\n// manual refract mostly to re-use dot(I, N)\nvec3 batchRefract(const in vec3 I, const in vec3 N , const in float eta, const in float dotNI) {\n    float k = 1.0 - eta * eta * (1.0 - dotNI * dotNI);\n    return (k < 0.0) ? vec3(0.0) :  eta * I - (eta * dotNI + sqrt(k)) * N;\n}\n\nuniform float uOpacityIOR;\nuniform vec3 uOpacityRefractionColor;\n\nuniform float uBoxRadius;\nuniform int uIsVr;\nuniform sampler2D uTextureToBeRefracted;\nuniform vec2 uTextureToBeRefractedSize;\nuniform mat4 uProjectionMatrix;\nuniform vec4 uPreviousHalton;\nuniform vec2 uPreviousGlobalTexRatio;\nuniform vec2 uPreviousGlobalTexSize;\nuniform vec2 uGlobalTexSize;\n\n    uniform sampler2D uTextureMipmapDepth;\n    uniform vec2 uNearFar;\n    uniform vec2 uPreviousNearFar;\n    uniform vec2 uGlobalTexRatio;\n\n    uniform mat4 uProjectionMatrix;\n    uniform mat4 uReprojectViewProj;\n    uniform vec4 uTaaCornersCSLeft[2];\n\nvec3 refraction(\n    const in float roughness,\n    const in vec3 normalSurface,\n\n#ifdef HAS_REFRACTION_NORMAL_OFFSET\n    const in vec3 normalVertex,\n#endif\n    const in vec3 eyeVector\n)\n\n{\n    \n    float dotNI = dot(-eyeVector, normalSurface);\n\n    // same as using glsl refract but doesnt compute  dotNI twice\n    // vec3 normalRefract = refract(-eyeVector, normalSurface, 1.0 / uOpacityIOR);\n    vec3 normalRefract = batchRefract(-eyeVector, normalSurface, 1.0 / uOpacityIOR, dotNI);    \n    // \n    // uboxradius is "world space constant" but view space should not scale scene\n    vec3 viewPosRefractedCurrentFrame = vViewVertex.xyz + uBoxRadius * normalRefract;\n    \n    // get uv in current frame to get depth\n    vec3 clipPosRefractedCurrentFrame = (uProjectionMatrix * vec4(viewPosRefractedCurrentFrame, 1.0)).xyw;\n    vec2 uvRefractedCurrentPos = 0.5 + 0.5 * clipPosRefractedCurrentFrame.xy / clipPosRefractedCurrentFrame.z;\n\n     #ifdef DEPTH_MIPMAP\n           vec3 pack = texture2D(uTextureMipmapDepth, uGlobalTexRatio * vec2(uvRefractedCurrentPos.x, (1.0 - uvRefractedCurrentPos.y) * 0.5)).xyz;\n           //float depthRefracted = pack.x == 1.0 ? (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x) : decode24(pack);\n           float depthRefracted = pack.x == 1.0 ? 0.0 : decode24(pack);\n     #else\n           vec4 pack = texture2D(uTextureMipmapDepth, uGlobalTexRatio * uvRefractedCurrentPos);\n           //float depthRefracted = pack.x == 1.0 ? (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x) : decodeDepth(pack);\n           float depthRefracted = pack.x == 1.0 ? 0.0 : decodeDepth(pack);\n     #endif\n\n    vec2 uv;    \n\n\n\n    // check if Refracted Depth is BEHIND the surface in Current Frame\n    // Before trying to reproject so that we get something BEHIND in Previous Frame\n    // so we compare vector direction fomr depth->pos with normal if incidence is negative, it comes from behind\n    vec3 color;\n\n    // compute clipsace depth\n    float clipCurrentRasterZ = (- vViewVertex.z - uPreviousNearFar.x) / (uPreviousNearFar.y - uPreviousNearFar.x);\n    // if background or if refracted is behind the refracting surface we can refract\n    if ( pack.x == 1.0 || clipCurrentRasterZ - depthRefracted < 0.001 ) {\n\n        // compute view space refracted position from depth CURRENT FRAME\n        vec4 AB = mix(uTaaCornersCSLeft[0], uTaaCornersCSLeft[1], uvRefractedCurrentPos.x);\n        \n        // if translate it\'s ok\n        // if rotation, very small depth change makes for same object to appear twice as we don\'t have prev Depth but current Depth\n        //float constantDepthRefracted = depthRefracted;\n        // A constant shiftvalue per scene in order to ensure we get no double and yet give consistent results\n        // previous depth would allow to scale using abs(prevDepth - curDepth))\n        float scaleVector =  clipCurrentRasterZ - 0.01 * (depthRefracted - clipCurrentRasterZ);\n        scaleVector = - ((scaleVector *  (uPreviousNearFar.y - uPreviousNearFar.x)) + uPreviousNearFar.x);\n        //float scaleVector =  vViewVertex.z - uBoxRadius/(uPreviousNearFar.y - uPreviousNearFar.x);\n        vec3 viewPosRefractedCurrentFrameFromDepth = vec3(mix(AB.xy, AB.zw, uvRefractedCurrentPos.y), 1.0) * scaleVector;\n        vec4 posReproj = uReprojectViewProj * vec4(viewPosRefractedCurrentFrameFromDepth.xyz, 1.0);\n        \n        uv  = 0.5 + 0.5 * (posReproj.xy / posReproj.w);        \n    }      \n    else{\n        \n        // prevent same or things just in front of refract surface\n        // being "mirrored" on the refracting surface\n        uv =  gl_FragCoord.xy / uPreviousGlobalTexSize.xy;\n    }\n\n    if (uIsVr == 1) {\n        // no reprojection in vr (would require another uTaaCornersCSRight uniform)\n        uv.x *= 0.5;\n        if (gl_FragCoord.x > uGlobalTexSize.x * 0.5) uv.x += 0.5;\n    }\n\n    \n       \n    // position of refracted point in last frame clipspace\n\n#ifdef HAS_REFRACTION_NORMAL_OFFSET\n    // no reprojection and no depth compare for the normal offset version (not worth it as for the moment)\n    uv = uv.xy + (normalVertex.xy - normalSurface.xy) * (uOpacityIOR - 1.0);\n    \n#endif\n\n    // unjitter (so that the refraction is stable when doing supersampling)\n    uv -= 0.5 * uPreviousHalton.xy / uPreviousGlobalTexSize.xy;\n\n    // repeat mirror for out of screen fetches (it\'s better than a sudden cut)\n    // we can\'t simply use MIRRORED_REPEAT because of manual mipmap\n    uv = abs(uv); \n    if (uv.x > 1.0) uv.x -= 2.0 * (uv.x - 1.0);\n    if (uv.y > 1.0) uv.y -= 2.0 * (uv.y - 1.0);\n\n    \n    // adjusts roughness-to-mipmap depending of distance from surface (aka: consistent blurring even when we unzoom)\n    float adjustRoughness = clamp(uProjectionMatrix[1][1] / 12.0 * uBoxRadius / -vViewVertex.z, 0.0, 1.0);\n    float adjustFactor = 0.05; // the higher it is, the sharper it will be when we are far away\n    adjustRoughness = (1.0 + adjustFactor) * adjustRoughness / (adjustFactor + adjustRoughness);\n\n    // roughness support\n    float maxLod = 7.0;\n    float lodLevel = maxLod * min(0.99, roughness * adjustRoughness); // same as in pbr\n\n    float lowerLevel = floor(lodLevel);\n    float higherLevel = min(maxLod, lowerLevel + 1.0);\n    float lerpFactor = lodLevel - lowerLevel; // [0,1]\n\n    // see packMipmapRefraction.glsl\n    // mipmap packing of refracted texture (the packing is not optimal and is a bit naive):\n    // level0: (1-uv)/2\n    // level1: (3-uv)/4\n    // level2: (7-uv)/8\n    // level3: (15-uv)/16\n    // level4: (31-uv)/32\n    // etc...\n\n    float powLevel = pow(2.0, higherLevel);\n\n    // border pixel issue with bilinear...\n    vec2 pixelSize = 2.0 * powLevel / uTextureToBeRefractedSize;\n    uv = max(pixelSize, min(1.0 - pixelSize, uv));\n\n    // lower uv\n    vec2 uvLower = vec2(2.0 * uv.x, powLevel - 1.0 - uv.y) * uPreviousGlobalTexRatio.xy / powLevel;\n\n    // higher uv\n    powLevel *= 2.0;\n    vec2 uvHigher = vec2(2.0 * uv.x, powLevel - 1.0 - uv.y) * uPreviousGlobalTexRatio.xy / powLevel;\n\n    // manual lerp, mixing rgbm colors exhibits visible seams\n    vec3 fetch = mix(decodeRGBM(texture2D(uTextureToBeRefracted, uvLower), 7.0), decodeRGBM(texture2D(uTextureToBeRefracted, uvHigher), 7.0), lerpFactor);\n\n#ifndef HAS_REFRACTION_NORMAL_OFFSET\n    // reduce bright fresnel effect, it darkens/accentuates the edges in some cases (very rough surface)\n    fetch.rgb -= fetch.rgb * pow(clamp(1.0 + dotNI, 0.0, 1.0), 4.0);\n#endif\n\n    return uOpacityRefractionColor * fetch.rgb ;\n}\n'
        },
        LG61: e => {
            e.exports = "//////////////////////////////\n// UN-OPTIMIZED VERSION (WITH IF)\n//////////////////////////////\n\n// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html\n// mat4 getMat4FromVec4(const int index, inout mat4 myMat) {\n//     // We have to use a global variable because we can't access dynamically\n//     // matrix is transpose so we should do vec * matrix\n//     myMat[0] = uBones[index];\n//     myMat[1] = uBones[index + 1];\n//     myMat[2] = uBones[index + 2];\n//     return myMat;\n// }\n\n// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {\n//     ivec4 idx =  3 * ivec4(bonesIndex);\n//     mat4 tmpMat = mat4(1.0);\n//     mat4 outMat = mat4(0.0);\n\n//     // we handle negative weights\n//     if(all(equal(weights, vec4(0.0)))) return tmpMat;\n\n//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4(idx.x, tmpMat);\n//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4(idx.y, tmpMat);\n//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4(idx.z, tmpMat);\n//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4(idx.w, tmpMat);\n//     return outMat;\n// }\n\n//////////////////////////////\n// UN-OPTIMIZED VERSION (NO IF)\n//////////////////////////////\n\nmat4 skinning(const in vec4 weights, const in vec4 bonesIndex) {\n    ivec4 idx =  3 * ivec4(bonesIndex);\n    mat4 tmpMat = mat4(1.0);\n\n    // if sum is 0, return identity\n    vec4 absWeights = -abs(weights);\n    mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;\n\n    // we handle negative weights\n    // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;\n\n    tmpMat[0] = uBones[idx.x];\n    tmpMat[1] = uBones[idx.x + 1];\n    tmpMat[2] = uBones[idx.x + 2];\n    outMat += weights.x * tmpMat;\n\n    tmpMat[0] = uBones[idx.y];\n    tmpMat[1] = uBones[idx.y + 1];\n    tmpMat[2] = uBones[idx.y + 2];\n    outMat += weights.y * tmpMat;\n\n    tmpMat[0] = uBones[idx.z];\n    tmpMat[1] = uBones[idx.z + 1];\n    tmpMat[2] = uBones[idx.z + 2];\n    outMat += weights.z * tmpMat;\n\n    tmpMat[0] = uBones[idx.w];\n    tmpMat[1] = uBones[idx.w + 1];\n    tmpMat[2] = uBones[idx.w + 2];\n    outMat += weights.w * tmpMat;\n\n    return outMat;\n}\n"
        },
        I19b: e => {
            e.exports = '#pragma include "utils/decodeDepth.glsl"\n#pragma include "utils/rand.glsl"\n\n#define SSR_STEPS 8\n\n#define LOD_COLOR 7.0\n#define LOD_DEPTH 5.0\n\nuniform int uDrawOpaque;\nuniform float uFrameModTaaSS;\nuniform float uQuality;\nuniform float uSsrFactor;\n\nuniform sampler2D uTextureToBeRefracted;\nuniform sampler2D uTextureMipmapDepth;\n\nuniform vec2 uTextureToBeRefractedSize;\nuniform vec2 uPreviousGlobalTexRatio;\nuniform vec2 uPreviousGlobalTexSize;\nuniform vec2 uNearFar;\nuniform vec2 uGlobalTexRatio;\nuniform vec4 uTaaCornersCSLeft[2];\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uReprojectViewProj;\nuniform mat4 uPreviousViewInvView;\nuniform mat4 uPreviousProjection; // DEPTH_MIPMAP\n\nvec3 computeLodNearestPixelSizePowLevel(const in float lodLevelIn, const in float maxLod, const in vec2 size) {\n    float lodLevel = min(maxLod - 0.01, lodLevelIn);\n    float lowerLevel = floor(lodLevel);\n    float higherLevel = min(maxLod, lowerLevel + 1.0);\n\n    float powLevel = pow(2.0, higherLevel);\n    vec2 pixelSize = 2.0 * powLevel / size;\n\n    if (lodLevel - lowerLevel > 0.5) powLevel *= 2.0;\n    return vec3(pixelSize, powLevel);\n}\n\n// lerping between 2 mipmap is too costly (with no notable quality gain in the end)\nvec2 computeLodUVNearest(const in vec2 uvIn, const in vec3 pixelSizePowLevel) {\n    // border pixel issue with bilinear...\n    vec2 uv = max(pixelSizePowLevel.xy, min(1.0 - pixelSizePowLevel.xy, uvIn));\n    return vec2(2.0 * uv.x, pixelSizePowLevel.z - 1.0 - uv.y) / pixelSizePowLevel.z;\n}\n\nfloat fetchDepthLod(const in vec2 uv, const in vec3 pixelSizePowLevel) {\n#ifdef DEPTH_MIPMAP\n    vec2 uvNearest = computeLodUVNearest(uv, pixelSizePowLevel);\n    float depth =  decodeDepth(texture2D(uTextureMipmapDepth, uvNearest * uPreviousGlobalTexRatio));\n#else\n    float depth = decodeDepth(texture2D(uTextureMipmapDepth, uv * uGlobalTexRatio));\n#endif\n\n    if (depth >= 1.0) return -uNearFar.y * 100.0; // very far so it won\'t reflect background\n    return -uNearFar.x - depth * (uNearFar.y - uNearFar.x);\n}\n\nvec4 fetchDepthLod(const in vec4 uv0, const in vec4 uv1, const in vec3 pixelSizePowLevel) {\n    vec4 result = vec4(0.0);\n    result.x = fetchDepthLod(uv0.xy, pixelSizePowLevel);\n    result.y = fetchDepthLod(uv0.zw, pixelSizePowLevel);\n    result.z = fetchDepthLod(uv1.xy, pixelSizePowLevel);\n    result.w = fetchDepthLod(uv1.zw, pixelSizePowLevel);\n    return result;\n}\n\nvec3 ssrViewToScreen(const in mat4 projection, const in vec3 viewVertex) {\n    vec4 projected = projection * vec4(viewVertex, 1.0);\n    return vec3(0.5 + 0.5 * projected.xy / projected.w, projected.w);\n}\n\nvec3 fetchColorLod(const in float level, const in vec2 uv) {\n    vec3 pixelSizePowLevel = computeLodNearestPixelSizePowLevel(LOD_COLOR * level, LOD_COLOR, uPreviousGlobalTexSize); \n    vec2 uvNearest = computeLodUVNearest(uv, pixelSizePowLevel);\n    return decodeRGBM(texture2D(uTextureToBeRefracted, uvNearest * uPreviousGlobalTexRatio), 7.0);\n}\n\n// #define HASHSCALE1 .1031\n// #define HASHSCALE3 vec3(.1031, .1030, .0973)\n// #define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// vec2 hash23(vec3 p3)\n// {\n//     p3 = fract(p3 * HASHSCALE3);\n//     p3 += dot(p3, p3.yzx + 19.19);\n//     return fract((p3.xx + p3.yz) * p3.zy);\n// }\n\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/ScreenSpaceReflections.usf#L143\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MonteCarlo.ush#L169\nvec3 unrealImportanceSampling(const in float frameMod, const in vec3 tangentX, const in vec3 tangentY, const in vec3 tangentZ, const in vec3 eyeVector, const in float rough4) {\n    vec2 E;\n\n    // could be improved (visible patterns)\n    E.x = interleavedGradientNoise(gl_FragCoord.yx, frameMod);\n    E.y = fract(E.x * 52.9829189);\n    // E = hash23(vec3(gl_FragCoord.xy + frameMod * 150.2420, frameMod * 100.0));\n\n    // Reduces BRDF tail is noisy, we clamp it\n    // https://www.slideshare.net/DICEStudio/stochastic-screenspace-reflections#p=67\n    E.y = mix(E.y, 1.0, 0.7);\n\n    float phi = 2.0 * 3.14159 * E.x;\n    // float cosTheta = sqrt((1.0 - E.y) / (1.0 + (rough4 - 1.0) * E.y)); // ggx (long tail, more noisy)\n    float cosTheta = pow(max(E.y, 0.000001), rough4 / (2.0 - rough4)); // blinn\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    vec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    h = h.x * tangentX + h.y * tangentY + h.z * tangentZ;\n    return normalize((2.0 * dot(eyeVector, h)) * h - eyeVector);\n}\n\nfloat getStepOffset(const in float frameMod) {\n    return (interleavedGradientNoise(gl_FragCoord.xy, frameMod) - 0.5);\n}\n\nvec3 computeRayDirUV(const in vec3 rayOriginUV, const in float rayLen, const in vec3 rayDirView) {\n#ifdef DEPTH_MIPMAP\n    vec3 rayDirUV = ssrViewToScreen(uPreviousProjection, vViewVertex.xyz + rayDirView * rayLen);\n#else\n    vec3 rayDirUV = ssrViewToScreen(uProjectionMatrix, vViewVertex.xyz + rayDirView * rayLen);\n#endif\n\n    rayDirUV.z = 1.0 / rayDirUV.z;\n    rayDirUV -= rayOriginUV;\n\n    // clip the line to the viewport edges\n    // https://github.com/godotengine/godot/blob/master/drivers/gles3/shaders/screen_space_reflection.glsl#L124\n    float scaleMaxX = min(1.0, 0.99 * (1.0 - rayOriginUV.x) / max(1e-5, rayDirUV.x));\n    float scaleMaxY = min(1.0, 0.99 * (1.0 - rayOriginUV.y) / max(1e-5, rayDirUV.y));\n    float scaleMinX = min(1.0, 0.99 * rayOriginUV.x / max(1e-5, -rayDirUV.x));\n    float scaleMinY = min(1.0, 0.99 * rayOriginUV.y / max(1e-5, -rayDirUV.y));\n    return rayDirUV * min(scaleMaxX, scaleMaxY) * min(scaleMinX, scaleMinY);\n}\n\n#define SSR_RAY_FETCH(void) \\\nsampleUV = rayOriginUV + rayDirUV * diffSampleW.y; \\\ndepth = fetchDepthLod(sampleUV.xy, pixelSizePowLevel); \\\ndepthDiff = -1.0 / sampleUV.z - depth; \\\nhit = abs(depthDiff + depthTolerance) < depthTolerance; \\\ntimeLerp = clamp(diffSampleW.x / (diffSampleW.x - depthDiff), 0.0, 1.0); \\\nhitTime = hit ? (diffSampleW.y + timeLerp * invNumSteps - invNumSteps) : 1.0; \\\ndiffSampleW.z = min(diffSampleW.z, hitTime); \\\ndiffSampleW.x = depthDiff; \\\ndiffSampleW.y += invNumSteps; \\\n\n#define SSR_RAY_UNROLLED(void) \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\nSSR_RAY_FETCH() \\\n\nvec4 rayTraceUnrealSimple(\n    const in vec3 rayOriginUV,\n    const in float rayLen,\n    in float depthTolerance,\n    const in vec3 rayDirView,\n\n    const in float roughness,\n    const in float frameMod) {\n\n    vec3 pixelSizePowLevel = computeLodNearestPixelSizePowLevel(LOD_DEPTH * roughness, LOD_DEPTH, uTextureToBeRefractedSize); \n\n    float invNumSteps = 1.0 / float(SSR_STEPS);\n    if (uQuality > 1.0) invNumSteps /= 2.0;\n\n    depthTolerance *= invNumSteps;\n\n    vec3 rayDirUV = computeRayDirUV(rayOriginUV, rayLen, rayDirView);\n\n    float sampleTime = getStepOffset(frameMod) * invNumSteps + invNumSteps;\n    vec3 diffSampleW = vec3(0.0, sampleTime, 1.0);\n\n    vec3 sampleUV;\n    float depth, depthDiff, timeLerp, hitTime;\n    bool hit;\n\n    SSR_RAY_UNROLLED()\n    if (uQuality > 1.0) { SSR_RAY_UNROLLED() }\n\n    // alternative : ray refinement around the intersected cell\n    // if (uQuality > 1.0) {\n    //     rayOriginUV = rayOriginUV + rayDirUV * diffSampleW.z - rayDirUV * invNumSteps * 0.5;\n    //     diffSampleW = vec3(0.0, sampleTime, 1.0);\n    //     rayDirUV *= invNumSteps;\n    //     depthTolerance *= invNumSteps;\n    //     SSR_RAY_UNROLLED()\n    // }\n\n    return vec4(rayOriginUV + rayDirUV * diffSampleW.z, 1.0 - diffSampleW.z);\n}\n\nvec4 fetchColorContribution(\n    in vec4 resRay,\n    const in float maskSsr,\n    const in vec3 specularEnvironment,\n    const in vec3 specularColor,\n    const in float roughness) {\n\n    // reprojection\n    vec4 AB = mix(uTaaCornersCSLeft[0], uTaaCornersCSLeft[1], resRay.x);\n    resRay.xyz = vec3(mix(AB.xy, AB.zw, resRay.y), 1.0) * -1.0 / resRay.z;\n    resRay.xyz = (uReprojectViewProj * vec4(resRay.xyz, 1.0)).xyw;\n    resRay.xy /= resRay.z;\n\n    // fade edge of screen\n    float maskEdge = clamp(6.0 - 6.0 * max(abs(resRay.x), abs(resRay.y)), 0.0, 1.0);\n\n    resRay.xy = 0.5 + 0.5 * resRay.xy;\n\n    vec3 fetchColor = specularColor * fetchColorLod(roughness * (1.0 - resRay.w), resRay.xy);\n\n    // fade ray count\n    // maskEdge *= resRay.w;\n\n    return vec4(mix(specularEnvironment, fetchColor, maskSsr * maskEdge), 1.0);\n}\n\nvec3 ssr(const in vec3 specularEnvironment, const in vec3 specularColor, const in float roughness, const in vec3 normal, const in vec3 eyeVector) {\n\n#if (defined(HAS_OPACITY_BLEND_OR_ADDITIVE) || defined(HAS_OPACITY_REFRACTION)) && !defined(HAS_SSR_TRANSPARENT)\n    // no ssr for transparent pxiels for now (mainly performance reason)\n    if (uDrawOpaque == 0) return specularEnvironment;\n#endif\n\n    vec4 result = vec4(0.0);\n\n    // precompute importance sampling roughness^4\n    float rough4 = roughness * roughness;\n    rough4 = rough4 * rough4;\n\n    // precompute importance sampling basis tangent\n    vec3 upVector = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangentX = normalize(cross(upVector, normal));\n    vec3 tangentY = cross(normal, tangentX);\n\n    // fade ray that points toward camera\n    float maskSsr = uSsrFactor * clamp(-4.0 * dot(eyeVector, normal) + 3.8, 0.0, 1.0);\n    maskSsr *= clamp(4.7 - roughness * 5.0, 0.0, 1.0); // fade out ssr for high roughness values\n\n    // compute ray uv origin\n    vec3 rayOriginUV = ssrViewToScreen(uProjectionMatrix, vViewVertex.xyz);\n    rayOriginUV.z = 1.0 / rayOriginUV.z;\n\n    // direction of reflection\n    vec3 rayDirView = unrealImportanceSampling(uFrameModTaaSS, tangentX, tangentY, normal, eyeVector, rough4);\n\n    // if reflection is toward us, we cast [near, vertex], otherwise [vertex, far]\n    float rayLen = mix(uNearFar.y + vViewVertex.z, -vViewVertex.z - uNearFar.x, rayDirView.z * 0.5 + 0.5);\n    float depthTolerance = 0.5 * rayLen;\n\n    // ray under the surface (normalmap or inverted normal)\n    if (dot(rayDirView, normal) > 0.001 && maskSsr > 0.0) {\n        vec4 resRay = rayTraceUnrealSimple(rayOriginUV, rayLen, depthTolerance, rayDirView, roughness, uFrameModTaaSS);\n        if (resRay.w > 0.0) result += fetchColorContribution(resRay, maskSsr, specularEnvironment, specularColor, roughness);\n    }\n\n    // if (uQuality > 0.4) {\n    //     for (int i = 1; i < 4; ++i) {\n    //         float frameRay = frameMod + float(i) * 50.0;\n    //         rayDirView = unrealImportanceSampling(frameRay, tangentX, tangentY, normal, eyeVector, rough4);\n    //         rayLen = mix(uNearFar.y + vViewVertex.z, -vViewVertex.z - uNearFar.x, rayDirView.z * 0.5 + 0.5);\n    //         depthTolerance = 0.5 * rayLen;\n\n    //         if (dot(rayDirView, normal) > 0.001) {\n    //             vec4 resRay = rayTraceUnrealSimple(rayOriginUV, rayLen, depthTolerance, rayDirView, roughness, frameRay);\n    //             if (resRay.w > 0.0) result += fetchColorContribution(resRay, maskSsr, specularEnvironment, specularColor, roughness);\n    //         }\n    //     }\n    // }\n\n    return result.w > 0.0 ? result.rgb / result.w : specularEnvironment;\n}\n'
        },
        "26Cb": e => {
            e.exports = '#define MIN_ROUGHNESS 0.045\n\nuniform float uRGBMRange;\nuniform int uOutputLinear;\n\nvarying vec4 vViewVertex;\nvarying vec3 vViewNormal;\nvarying vec4 vColor;\n\nuniform float uNormalSign;\nuniform vec3 uAlbedo;\nuniform float uRoughness;\nuniform float uMetalness;\n\nvec3 lightDir = normalize(vec3(0.0, 0.3, 0.9));\nvec3 lightColor = vec3(0.7, 0.7, 0.9);\n\n#pragma include "utils/functions.glsl"\n\n#pragma include "utils/lightsPBR.glsl"\n\nvoid main() {\n    vec3 eyeVector = -normalize(vViewVertex.xyz);\n    vec3 materialNormal = uNormalSign * normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);\n\n    // material\n    float f0 = 0.04;\n    vec3 materialDiffuse = uAlbedo * vColor.r;\n    vec3 materialSpecular = mix(vec3(f0), materialDiffuse, uMetalness);\n    materialDiffuse *= 1.0 - uMetalness;\n    float materialRoughness = max(MIN_ROUGHNESS, uRoughness);\n    float materialF90 = clamp(50.0 * materialSpecular.g, 0.0, 1.0);\n\n    // precompute light\n    float attenuation, dotNL;\n    vec3 eyeLightDir;\n    bool lighted;\n    vec3 lightSpecular;\n    vec3 lightDiffuse;\n    vec4 prepGGX = precomputeGGX(materialNormal, eyeVector, materialRoughness);\n\n    // shading\n    attenuation = 1.0;\n    dotNL = dot(lightDir, materialNormal);\n    computeLightLambertGGX(materialNormal, eyeVector, dotNL, prepGGX, materialDiffuse, materialSpecular, attenuation, lightColor, lightDir, materialF90, lightDiffuse, lightSpecular, lighted);\n\n    vec3 frag = lightDiffuse + lightSpecular;\n    if (uOutputLinear != 1) frag = linearTosRGB(frag);\n    gl_FragColor = encodeRGBM(frag, uRGBMRange);\n}\n'
        },
        cMLc: e => {
            e.exports = '#define HAS_VERTEX_COLOR\n#define HAS_VIEW_VERTEX\n#define HAS_VIEW_NORMAL\n#pragma include "base.vert"\n'
        },
        z26O: e => {
            e.exports = "uniform vec4 uColor;\n\nvoid main() {\n    gl_FragColor = vec4(uColor.rgb * uColor.a, uColor.a);\n}\n"
        },
        qgTy: e => {
            e.exports = '#define WIREFRAME\n#pragma include "base.vert"\n'
        }
    }
]);